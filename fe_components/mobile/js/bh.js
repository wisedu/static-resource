/*! onsenui v2.0.0-rc.13 - 2016-06-22 */
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.3
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) global.MutationObserver = JsMutationObserver;
})(this);

window.CustomElements = window.CustomElements || {
  flags: {}
};

(function(scope) {
  var flags = scope.flags;
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
  scope.hasNative = Boolean(document.registerElement);
  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || HTMLImports.useNative);
})(window.CustomElements);

window.CustomElements.addModule(function(scope) {
  var IMPORT_LINK_TYPE = window.HTMLImports ? HTMLImports.IMPORT_LINK_TYPE : "none";
  function forSubtree(node, cb) {
    findAllElements(node, function(e) {
      if (cb(e)) {
        return true;
      }
      forRoots(e, cb);
    });
    forRoots(node, cb);
  }
  function findAllElements(node, find, data) {
    var e = node.firstElementChild;
    if (!e) {
      e = node.firstChild;
      while (e && e.nodeType !== Node.ELEMENT_NODE) {
        e = e.nextSibling;
      }
    }
    while (e) {
      if (find(e, data) !== true) {
        findAllElements(e, find, data);
      }
      e = e.nextElementSibling;
    }
    return null;
  }
  function forRoots(node, cb) {
    var root = node.shadowRoot;
    while (root) {
      forSubtree(root, cb);
      root = root.olderShadowRoot;
    }
  }
  function forDocumentTree(doc, cb) {
    _forDocumentTree(doc, cb, []);
  }
  function _forDocumentTree(doc, cb, processingDocuments) {
    doc = wrap(doc);
    if (processingDocuments.indexOf(doc) >= 0) {
      return;
    }
    processingDocuments.push(doc);
    var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");
    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {
      if (n.import) {
        _forDocumentTree(n.import, cb, processingDocuments);
      }
    }
    cb(doc);
  }
  scope.forDocumentTree = forDocumentTree;
  scope.forSubtree = forSubtree;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  var forSubtree = scope.forSubtree;
  var forDocumentTree = scope.forDocumentTree;
  function addedNode(node) {
    return added(node) || addedSubtree(node);
  }
  function added(node) {
    if (scope.upgrade(node)) {
      return true;
    }
    attached(node);
  }
  function addedSubtree(node) {
    forSubtree(node, function(e) {
      if (added(e)) {
        return true;
      }
    });
  }
  function attachedNode(node) {
    attached(node);
    if (inDocument(node)) {
      forSubtree(node, function(e) {
        attached(e);
      });
    }
  }
  var hasPolyfillMutations = !window.MutationObserver || window.MutationObserver === window.JsMutationObserver;
  scope.hasPolyfillMutations = hasPolyfillMutations;
  var isPendingMutations = false;
  var pendingMutations = [];
  function deferMutation(fn) {
    pendingMutations.push(fn);
    if (!isPendingMutations) {
      isPendingMutations = true;
      setTimeout(takeMutations);
    }
  }
  function takeMutations() {
    isPendingMutations = false;
    var $p = pendingMutations;
    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
      p();
    }
    pendingMutations = [];
  }
  function attached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _attached(element);
      });
    } else {
      _attached(element);
    }
  }
  function _attached(element) {
    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {
      if (!element.__attached && inDocument(element)) {
        element.__attached = true;
        if (element.attachedCallback) {
          element.attachedCallback();
        }
      }
    }
  }
  function detachedNode(node) {
    detached(node);
    forSubtree(node, function(e) {
      detached(e);
    });
  }
  function detached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _detached(element);
      });
    } else {
      _detached(element);
    }
  }
  function _detached(element) {
    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {
      if (element.__attached && !inDocument(element)) {
        element.__attached = false;
        if (element.detachedCallback) {
          element.detachedCallback();
        }
      }
    }
  }
  function inDocument(element) {
    var p = element;
    var doc = wrap(document);
    while (p) {
      if (p == doc) {
        return true;
      }
      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;
    }
  }
  function watchShadow(node) {
    if (node.shadowRoot && !node.shadowRoot.__watched) {
      flags.dom && console.log("watching shadow-root for: ", node.localName);
      var root = node.shadowRoot;
      while (root) {
        observe(root);
        root = root.olderShadowRoot;
      }
    }
  }
  function handler(mutations) {
    if (flags.dom) {
      var mx = mutations[0];
      if (mx && mx.type === "childList" && mx.addedNodes) {
        if (mx.addedNodes) {
          var d = mx.addedNodes[0];
          while (d && d !== document && !d.host) {
            d = d.parentNode;
          }
          var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";
          u = u.split("/?").shift().split("/").pop();
        }
      }
      console.group("mutations (%d) [%s]", mutations.length, u || "");
    }
    mutations.forEach(function(mx) {
      if (mx.type === "childList") {
        forEach(mx.addedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          addedNode(n);
        });
        forEach(mx.removedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          detachedNode(n);
        });
      }
    });
    flags.dom && console.groupEnd();
  }
  function takeRecords(node) {
    node = wrap(node);
    if (!node) {
      node = wrap(document);
    }
    while (node.parentNode) {
      node = node.parentNode;
    }
    var observer = node.__observer;
    if (observer) {
      handler(observer.takeRecords());
      takeMutations();
    }
  }
  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  function observe(inRoot) {
    if (inRoot.__observer) {
      return;
    }
    var observer = new MutationObserver(handler);
    observer.observe(inRoot, {
      childList: true,
      subtree: true
    });
    inRoot.__observer = observer;
  }
  function upgradeDocument(doc) {
    doc = wrap(doc);
    flags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());
    addedNode(doc);
    observe(doc);
    flags.dom && console.groupEnd();
  }
  function upgradeDocumentTree(doc) {
    forDocumentTree(doc, upgradeDocument);
  }
  var originalCreateShadowRoot = Element.prototype.createShadowRoot;
  if (originalCreateShadowRoot) {
    Element.prototype.createShadowRoot = function() {
      var root = originalCreateShadowRoot.call(this);
      CustomElements.watchShadow(this);
      return root;
    };
  }
  scope.watchShadow = watchShadow;
  scope.upgradeDocumentTree = upgradeDocumentTree;
  scope.upgradeSubtree = addedSubtree;
  scope.upgradeAll = addedNode;
  scope.attachedNode = attachedNode;
  scope.takeRecords = takeRecords;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  function upgrade(node) {
    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
      var is = node.getAttribute("is");
      var definition = scope.getRegisteredDefinition(is || node.localName);
      if (definition) {
        if (is && definition.tag == node.localName) {
          return upgradeWithDefinition(node, definition);
        } else if (!is && !definition.extends) {
          return upgradeWithDefinition(node, definition);
        }
      }
    }
  }
  function upgradeWithDefinition(element, definition) {
    flags.upgrade && console.group("upgrade:", element.localName);
    if (definition.is) {
      element.setAttribute("is", definition.is);
    }
    implementPrototype(element, definition);
    element.__upgraded__ = true;
    created(element);
    scope.attachedNode(element);
    scope.upgradeSubtree(element);
    flags.upgrade && console.groupEnd();
    return element;
  }
  function implementPrototype(element, definition) {
    if (Object.__proto__) {
      element.__proto__ = definition.prototype;
    } else {
      customMixin(element, definition.prototype, definition.native);
      element.__proto__ = definition.prototype;
    }
  }
  function customMixin(inTarget, inSrc, inNative) {
    var used = {};
    var p = inSrc;
    while (p !== inNative && p !== HTMLElement.prototype) {
      var keys = Object.getOwnPropertyNames(p);
      for (var i = 0, k; k = keys[i]; i++) {
        if (!used[k]) {
          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
          used[k] = 1;
        }
      }
      p = Object.getPrototypeOf(p);
    }
  }
  function created(element) {
    if (element.createdCallback) {
      element.createdCallback();
    }
  }
  scope.upgrade = upgrade;
  scope.upgradeWithDefinition = upgradeWithDefinition;
  scope.implementPrototype = implementPrototype;
});

window.CustomElements.addModule(function(scope) {
  var isIE11OrOlder = scope.isIE11OrOlder;
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  var upgradeAll = scope.upgradeAll;
  var upgradeWithDefinition = scope.upgradeWithDefinition;
  var implementPrototype = scope.implementPrototype;
  var useNative = scope.useNative;
  function register(name, options) {
    var definition = options || {};
    if (!name) {
      throw new Error("document.registerElement: first argument `name` must not be empty");
    }
    if (name.indexOf("-") < 0) {
      throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(name) + "'.");
    }
    if (isReservedTag(name)) {
      throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(name) + "'. The type name is invalid.");
    }
    if (getRegisteredDefinition(name)) {
      throw new Error("DuplicateDefinitionError: a type with name '" + String(name) + "' is already registered");
    }
    if (!definition.prototype) {
      definition.prototype = Object.create(HTMLElement.prototype);
    }
    definition.__name = name.toLowerCase();
    definition.lifecycle = definition.lifecycle || {};
    definition.ancestry = ancestry(definition.extends);
    resolveTagName(definition);
    resolvePrototypeChain(definition);
    overrideAttributeApi(definition.prototype);
    registerDefinition(definition.__name, definition);
    definition.ctor = generateConstructor(definition);
    definition.ctor.prototype = definition.prototype;
    definition.prototype.constructor = definition.ctor;
    if (scope.ready) {
      upgradeDocumentTree(document);
    }
    return definition.ctor;
  }
  function overrideAttributeApi(prototype) {
    if (prototype.setAttribute._polyfilled) {
      return;
    }
    var setAttribute = prototype.setAttribute;
    prototype.setAttribute = function(name, value) {
      changeAttribute.call(this, name, value, setAttribute);
    };
    var removeAttribute = prototype.removeAttribute;
    prototype.removeAttribute = function(name) {
      changeAttribute.call(this, name, null, removeAttribute);
    };
    prototype.setAttribute._polyfilled = true;
  }
  function changeAttribute(name, value, operation) {
    name = name.toLowerCase();
    var oldValue = this.getAttribute(name);
    operation.apply(this, arguments);
    var newValue = this.getAttribute(name);
    if (this.attributeChangedCallback && newValue !== oldValue) {
      this.attributeChangedCallback(name, oldValue, newValue);
    }
  }
  function isReservedTag(name) {
    for (var i = 0; i < reservedTagList.length; i++) {
      if (name === reservedTagList[i]) {
        return true;
      }
    }
  }
  var reservedTagList = [ "annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph" ];
  function ancestry(extnds) {
    var extendee = getRegisteredDefinition(extnds);
    if (extendee) {
      return ancestry(extendee.extends).concat([ extendee ]);
    }
    return [];
  }
  function resolveTagName(definition) {
    var baseTag = definition.extends;
    for (var i = 0, a; a = definition.ancestry[i]; i++) {
      baseTag = a.is && a.tag;
    }
    definition.tag = baseTag || definition.__name;
    if (baseTag) {
      definition.is = definition.__name;
    }
  }
  function resolvePrototypeChain(definition) {
    if (!Object.__proto__) {
      var nativePrototype = HTMLElement.prototype;
      if (definition.is) {
        var inst = document.createElement(definition.tag);
        var expectedPrototype = Object.getPrototypeOf(inst);
        if (expectedPrototype === definition.prototype) {
          nativePrototype = expectedPrototype;
        }
      }
      var proto = definition.prototype, ancestor;
      while (proto && proto !== nativePrototype) {
        ancestor = Object.getPrototypeOf(proto);
        proto.__proto__ = ancestor;
        proto = ancestor;
      }
      definition.native = nativePrototype;
    }
  }
  function instantiate(definition) {
    return upgradeWithDefinition(domCreateElement(definition.tag), definition);
  }
  var registry = {};
  function getRegisteredDefinition(name) {
    if (name) {
      return registry[name.toLowerCase()];
    }
  }
  function registerDefinition(name, definition) {
    registry[name] = definition;
  }
  function generateConstructor(definition) {
    return function() {
      return instantiate(definition);
    };
  }
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  function createElementNS(namespace, tag, typeExtension) {
    if (namespace === HTML_NAMESPACE) {
      return createElement(tag, typeExtension);
    } else {
      return domCreateElementNS(namespace, tag);
    }
  }
  function createElement(tag, typeExtension) {
    if (tag) {
      tag = tag.toLowerCase();
    }
    if (typeExtension) {
      typeExtension = typeExtension.toLowerCase();
    }
    var definition = getRegisteredDefinition(typeExtension || tag);
    if (definition) {
      if (tag == definition.tag && typeExtension == definition.is) {
        return new definition.ctor();
      }
      if (!typeExtension && !definition.is) {
        return new definition.ctor();
      }
    }
    var element;
    if (typeExtension) {
      element = createElement(tag);
      element.setAttribute("is", typeExtension);
      return element;
    }
    element = domCreateElement(tag);
    if (tag.indexOf("-") >= 0) {
      implementPrototype(element, HTMLElement);
    }
    return element;
  }
  var domCreateElement = document.createElement.bind(document);
  var domCreateElementNS = document.createElementNS.bind(document);
  var isInstance;
  if (!Object.__proto__ && !useNative) {
    isInstance = function(obj, ctor) {
      var p = obj;
      while (p) {
        if (p === ctor.prototype) {
          return true;
        }
        p = p.__proto__;
      }
      return false;
    };
  } else {
    isInstance = function(obj, base) {
      return obj instanceof base;
    };
  }
  function wrapDomMethodToForceUpgrade(obj, methodName) {
    var orig = obj[methodName];
    obj[methodName] = function() {
      var n = orig.apply(this, arguments);
      upgradeAll(n);
      return n;
    };
  }
  wrapDomMethodToForceUpgrade(Node.prototype, "cloneNode");
  wrapDomMethodToForceUpgrade(document, "importNode");
  if (isIE11OrOlder) {
    (function() {
      var importNode = document.importNode;
      document.importNode = function() {
        var n = importNode.apply(document, arguments);
        if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {
          var f = document.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }
  document.registerElement = register;
  document.createElement = createElement;
  document.createElementNS = createElementNS;
  scope.registry = registry;
  scope.instanceof = isInstance;
  scope.reservedTagList = reservedTagList;
  scope.getRegisteredDefinition = getRegisteredDefinition;
  document.register = document.registerElement;
});

(function(scope) {
  var useNative = scope.useNative;
  var initializeModules = scope.initializeModules;
  var isIE11OrOlder = /Trident/.test(navigator.userAgent);
  if (useNative) {
    var nop = function() {};
    scope.watchShadow = nop;
    scope.upgrade = nop;
    scope.upgradeAll = nop;
    scope.upgradeDocumentTree = nop;
    scope.upgradeSubtree = nop;
    scope.takeRecords = nop;
    scope.instanceof = function(obj, base) {
      return obj instanceof base;
    };
  } else {
    initializeModules();
  }
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  if (!window.wrap) {
    if (window.ShadowDOMPolyfill) {
      window.wrap = ShadowDOMPolyfill.wrapIfNeeded;
      window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;
    } else {
      window.wrap = window.unwrap = function(node) {
        return node;
      };
    }
  }
  function bootstrap() {
    upgradeDocumentTree(wrap(document));
    if (window.HTMLImports) {
      HTMLImports.__importsParsingHook = function(elt) {
        upgradeDocumentTree(wrap(elt.import));
      };
    }
    CustomElements.ready = true;
    setTimeout(function() {
      CustomElements.readyTime = Date.now();
      if (window.HTMLImports) {
        CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;
      }
      document.dispatchEvent(new CustomEvent("WebComponentsReady", {
        bubbles: true
      }));
    });
  }
  if (isIE11OrOlder && typeof window.CustomEvent !== "function") {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent("CustomEvent");
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }
  if (document.readyState === "complete" || scope.flags.eager) {
    bootstrap();
  } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
    bootstrap();
  } else {
    var loadEvent = window.HTMLImports && !HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
    window.addEventListener(loadEvent, bootstrap);
  }
  scope.isIE11OrOlder = isIE11OrOlder;
})(window.CustomElements);

if (!window.CustomEvent) {
  (function() {
    var CustomEvent;

    CustomEvent = function(event, params) {
      var evt;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
  })();
}

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.22
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);
/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/


/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
window.animit = (function(){
  'use strict';

  var TIMEOUT_RATIO = 1.4;

  var util = {
  };

  // capitalize string
  util.capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  /**
  * @param {Object} params
  * @param {String} params.property
  * @param {Float} params.duration
  * @param {String} params.timing
  */
  util.buildTransitionValue = function(params) {
    params.property = params.property || 'all';
    params.duration = params.duration || 0.4;
    params.timing = params.timing || 'linear';

    var props = params.property.split(/ +/);

    return props.map(function(prop) {
      return prop + ' ' + params.duration + 's ' + params.timing;
    }).join(', ');
  };

  /**
  * Add an event handler on "transitionend" event.
  */
  util.onceOnTransitionEnd = function(element, callback) {
    if (!element) {
      return function() {};
    }

    var fn = function(event) {
      if (element == event.target) {
        event.stopPropagation();
        removeListeners();

        callback();
      }
    };

    var removeListeners = function() {
      util._transitionEndEvents.forEach(function(eventName) {
        element.removeEventListener(eventName, fn, false);
      });
    };

    util._transitionEndEvents.forEach(function(eventName) {
      element.addEventListener(eventName, fn, false);
    });

    return removeListeners;
  };

  util._transitionEndEvents = (function() {

    if ('ontransitionend' in window) {
      return ['transitionend'];
    }

    if ('onwebkittransitionend' in window) {
      return ['webkitTransitionEnd'];
    }

    if (util.vendorPrefix === 'webkit' || util.vendorPrefix === 'o' || util.vendorPrefix === 'moz' || util.vendorPrefix === 'ms') {
      return [util.vendorPrefix + 'TransitionEnd', 'transitionend'];
    }

    return [];
  })();

  util._cssPropertyDict = (function() {
    var styles = window.getComputedStyle(document.documentElement, '');
    var dict = {};
    var a = 'A'.charCodeAt(0);
    var z = 'z'.charCodeAt(0);

    var upper = function(s) {
      return s.substr(1).toUpperCase();
    };

    for (var i = 0; i < styles.length; i++) {

      var key = styles[i]
        .replace(/^[\-]+/, '')
        .replace(/[\-][a-z]/g, upper)
        .replace(/^moz/, 'Moz');

      if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
        if (key !== 'cssText' && key !== 'parentText') {
          dict[key] = true;
        }
      }
    }

    return dict;
  })();

  util.hasCssProperty = function(name) {
    return name in util._cssPropertyDict;
  };

  /**
   * Vendor prefix for css property.
   */
  util.vendorPrefix = (function() {
    var styles = window.getComputedStyle(document.documentElement, ''),
    pre = (Array.prototype.slice
      .call(styles)
      .join('')
      .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
    )[1];
    return pre;
  })();

  util.forceLayoutAtOnce = function(elements, callback) {
    this.batchImmediate(function() {
      elements.forEach(function(element) {
        // force layout
        element.offsetHeight;
      });
      callback();
    });
  };

  util.batchImmediate = (function() {
    var callbacks = [];

    return function(callback) {
      if (callbacks.length === 0) {
        setImmediate(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.batchAnimationFrame = (function() {
    var callbacks = [];

    var raf = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
      setTimeout(callback, 1000 / 60);
    };

    return function(callback) {
      if (callbacks.length === 0) {
        raf(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.transitionPropertyName = (function() {
    if (util.hasCssProperty('transitionDuration')) {
      return 'transition';
    }

    if (util.hasCssProperty(util.vendorPrefix + 'TransitionDuration')) {
      return util.vendorPrefix + 'Transition';
    }

    throw new Error('Invalid state');
  })();


  /**
   * @param {HTMLElement} element
   */
  var Animit = function(element) {
    if (!(this instanceof Animit)) {
      return new Animit(element);
    }

    if (element instanceof HTMLElement) {
      this.elements = [element];
    } else if (Object.prototype.toString.call(element) === '[object Array]') {
      this.elements = element;

    } else {
      throw new Error('First argument must be an array or an instance of HTMLElement.');
    }

    this.transitionQueue = [];
    this.lastStyleAttributeDict = [];
  };

  Animit.prototype = {

    /**
     * @property {Array}
     */
    transitionQueue: undefined,

    /**
     * @property {Array}
     */
    elements: undefined,

    /**
     * Start animation sequence with passed animations.
     *
     * @param {Function} callback
     */
    play: function(callback) {
      if (typeof callback === 'function') {
        this.transitionQueue.push(function(done) {
          callback();
          done();
        });
      }

      this.startAnimation();

      return this;
    },

    /**
     * Queue transition animations or other function.
     *
     * e.g. animit(elt).queue({color: 'red'})
     * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
     * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
     *
     * @param {Object|Animit.Transition|Function} transition
     * @param {Object} [options]
     */
    queue: function(transition, options) {
      var queue = this.transitionQueue;

      if (transition && options) {
        options.css = transition;
        transition = new Animit.Transition(options);
      }

      if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
        if (transition.css) {
          transition = new Animit.Transition(transition);
        } else {
          transition = new Animit.Transition({
            css: transition
          });
        }
      }

      if (transition instanceof Function) {
        queue.push(transition);
      } else if (transition instanceof Animit.Transition) {
        queue.push(transition.build());
      } else {
        throw new Error('Invalid arguments');
      }

      return this;
    },

    /**
     * Queue transition animations.
     *
     * @param {Float} seconds
     */
    wait: function(seconds) {
      if (seconds > 0) {
        this.transitionQueue.push(function(done) {
          setTimeout(done, 1000 * seconds);
        });
      }

      return this;
    },

    saveStyle: function() {

      this.transitionQueue.push(function(done) {
        this.elements.forEach(function(element, index) {
          var css = this.lastStyleAttributeDict[index] = {};

          for (var i = 0; i < element.style.length; i++) {
            css[element.style[i]] = element.style[element.style[i]];
          }
        }.bind(this));
        done();
      }.bind(this));

      return this;
    },

    /**
     * Restore element's style.
     *
     * @param {Object} [options]
     * @param {Float} [options.duration]
     * @param {String} [options.timing]
     * @param {String} [options.transition]
     */
    restoreStyle: function(options) {
      options = options || {};
      var self = this;

      if (options.transition && !options.duration) {
        throw new Error('"options.duration" is required when "options.transition" is enabled.');
      }

      var transitionName = util.transitionPropertyName;

      if (options.transition || (options.duration && options.duration > 0)) {
        var transitionValue = options.transition || ('all ' + options.duration + 's ' + (options.timing || 'linear'));

        this.transitionQueue.push(function(done) {
          var elements = this.elements;
          var timeoutId;

          var clearTransition = function() {
            elements.forEach(function(element) {
              element.style[transitionName] = '';
            });
          };

          // add "transitionend" event handler
          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            clearTransition();
            done();
          });

          // for fail safe.
          timeoutId = setTimeout(function() {
            removeListeners();
            clearTransition();
            done();
          }, options.duration * 1000 * TIMEOUT_RATIO);

          // transition and style settings
          elements.forEach(function(element, index) {

            var css = self.lastStyleAttributeDict[index];

            if (!css) {
              throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
            }

            self.lastStyleAttributeDict[index] = undefined;

            var name;
            for (var i = 0, len = element.style.length; i < len; i++) {
              name = element.style[i];
              if (css[name] === undefined) {
                css[name] = '';
              }
            }

            element.style[transitionName] = transitionValue;

            Object.keys(css).forEach(function(key) {
              if (key !== transitionName) {
                element.style[key] = css[key];
              }
            });

            element.style[transitionName] = transitionValue;
          });
        });
      } else {
        this.transitionQueue.push(function(done) {
          reset();
          done();
        });
      }

      return this;

      function reset() {
        // Clear transition animation settings.
        self.elements.forEach(function(element, index) {
          element.style[transitionName] = 'none';

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          for (var i = 0, name = ''; i < element.style.length; i++) {
            name = element.style[i];
            if (typeof css[element.style[i]] === 'undefined') {
              css[element.style[i]] = '';
            }
          }

          Object.keys(css).forEach(function(key) {
            element.style[key] = css[key];
          });

        });
      }
    },

    /**
     * Start animation sequence.
     */
    startAnimation: function() {
      this._dequeueTransition();

      return this;
    },

    _dequeueTransition: function() {
      var transition = this.transitionQueue.shift();
      if (this._currentTransition) {
        throw new Error('Current transition exists.');
      }
      this._currentTransition = transition;
      var self = this;
      var called = false;

      var done = function() {
        if (!called) {
          called = true;
          self._currentTransition = undefined;
          self._dequeueTransition();
        } else {
          throw new Error('Invalid state: This callback is called twice.');
        }
      };

      if (transition) {
        transition.call(this, done);
      }
    }

  };

  /**
   * @param {Animit} arguments
   */
  Animit.runAll = function(/* arguments... */) {
    for (var i = 0; i < arguments.length; i++) {
      arguments[i].play();
    }
  };


  /**
   * @param {Object} options
   * @param {Float} [options.duration]
   * @param {String} [options.property]
   * @param {String} [options.timing]
   */
  Animit.Transition = function(options) {
    this.options = options || {};
    this.options.duration = this.options.duration || 0;
    this.options.timing = this.options.timing || 'linear';
    this.options.css = this.options.css || {};
    this.options.property = this.options.property || 'all';
  };

  Animit.Transition.prototype = {

    /**
     * @param {HTMLElement} element
     * @return {Function}
     */
    build: function() {

      if (Object.keys(this.options.css).length === 0) {
        throw new Error('options.css is required.');
      }

      var css = createActualCssProps(this.options.css);

      if (this.options.duration > 0) {
        var transitionValue = util.buildTransitionValue(this.options);
        var self = this;

        return function(callback) {
          var elements = this.elements;
          var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
          var timeoutId;

          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            callback();
          });

          timeoutId = setTimeout(function() {
            removeListeners();
            callback();
          }, timeout);

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = transitionValue;

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

        };
      }

      if (this.options.duration <= 0) {
        return function(callback) {
          var elements = this.elements;

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = '';

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

          if (elements.length > 0) {
            util.forceLayoutAtOnce(elements, function() {
              util.batchAnimationFrame(callback);
            });
          } else {
            util.batchAnimationFrame(callback);
          }
        };
      }

      function createActualCssProps(css) {
        var result = {};

        Object.keys(css).forEach(function(name) {
          var value = css[name];

          if (util.hasCssProperty(name)) {
            result[name] = value;
            return;
          }

          var prefixed = util.vendorPrefix + util.capitalize(name);
          if (util.hasCssProperty(prefixed)) {
            result[prefixed] = value;
          } else {
            result[prefixed] = value;
            result[name] = value;
          }
        });

        return result;
      }

    }
  };


  return Animit;
})();

/*
 * childNode.remove method polyfill for IE.
 * https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
 */

(function() {
	if (!('remove' in Element.prototype)) {
	  Element.prototype.remove = function() {
	    if (this.parentNode) {
	    	this.parentNode.removeChild(this);
	    }
	  };
	}
})();

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_"))
  || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
    classListProp = "classList"
  , protoProp = "prototype"
  , elemCtrProto = view.Element[protoProp]
  , objCtr = Object
  , strTrim = String[protoProp].trim || function () {
    return this.replace(/^\s+|\s+$/g, "");
  }
  , arrIndexOf = Array[protoProp].indexOf || function (item) {
    var
        i = 0
      , len = this.length
    ;
    for (; i < len; i++) {
      if (i in this && this[i] === item) {
        return i;
      }
    }
    return -1;
  }
  // Vendors: please allow content code to instantiate DOMExceptions
  , DOMEx = function (type, message) {
    this.name = type;
    this.code = DOMException[type];
    this.message = message;
  }
  , checkTokenAndGetIndex = function (classList, token) {
    if (token === "") {
      throw new DOMEx(
          "SYNTAX_ERR"
        , "An invalid or illegal string was specified"
      );
    }
    if (/\s/.test(token)) {
      throw new DOMEx(
          "INVALID_CHARACTER_ERR"
        , "String contains an invalid character"
      );
    }
    return arrIndexOf.call(classList, token);
  }
  , ClassList = function (elem) {
    var
        trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
      , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
      , i = 0
      , len = classes.length
    ;
    for (; i < len; i++) {
      this.push(classes[i]);
    }
    this._updateClassName = function () {
      elem.setAttribute("class", this.toString());
    };
  }
  , classListProto = ClassList[protoProp] = []
  , classListGetter = function () {
    return new ClassList(this);
  }
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
  return this[i] || null;
};
classListProto.contains = function (token) {
  token += "";
  return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
  ;
  do {
    token = tokens[i] + "";
    if (checkTokenAndGetIndex(this, token) === -1) {
      this.push(token);
      updated = true;
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.remove = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
    , index
  ;
  do {
    token = tokens[i] + "";
    index = checkTokenAndGetIndex(this, token);
    while (index !== -1) {
      this.splice(index, 1);
      updated = true;
      index = checkTokenAndGetIndex(this, token);
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.toggle = function (token, force) {
  token += "";

  var
      result = this.contains(token)
    , method = result ?
      force !== true && "remove"
    :
      force !== false && "add"
  ;

  if (method) {
    this[method](token);
  }

  if (force === true || force === false) {
    return force;
  } else {
    return !result;
  }
};
classListProto.toString = function () {
  return this.join(" ");
};

if (objCtr.defineProperty) {
  var classListPropDesc = {
      get: classListGetter
    , enumerable: true
    , configurable: true
  };
  try {
    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
  } catch (ex) { // IE 8 doesn't support enumerable:true
    if (ex.number === -0x7FF5EC54) {
      classListPropDesc.enumerable = false;
      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
    }
  }
} else if (objCtr[protoProp].__defineGetter__) {
  elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
  "use strict";

  var testElement = document.createElement("_");

  testElement.classList.add("c1", "c2");

  // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  // classList.remove exist but support only one argument at a time.
  if (!testElement.classList.contains("c2")) {
    var createMethod = function(method) {
      var original = DOMTokenList.prototype[method];

      DOMTokenList.prototype[method] = function(token) {
        var i, len = arguments.length;

        for (i = 0; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };
    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle("c3", false);

  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  // support the second argument.
  if (testElement.classList.contains("c3")) {
    var _toggle = DOMTokenList.prototype.toggle;

    DOMTokenList.prototype.toggle = function(token, force) {
      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };

  }

  testElement = null;
}());

}

}


;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesize a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behavior on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recommended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};

  window.FastClick = FastClick;
}());

/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 * 
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent  = function(){};
MicroEvent.prototype  = {
  on  : function(event, fct){
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once : function(event, fct){
    var self = this;
    var wrapper = function() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off  : function(event, fct){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    this._events[event].splice(this._events[event].indexOf(fct), 1);
  },
  emit : function(event /* , args... */){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    for(var i = 0; i < this._events[event].length; i++){
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin  = function(destObject){
  var props = ['on', 'once', 'off', 'emit'];
  for(var i = 0; i < props.length; i ++){
    if( typeof destObject === 'function' ){
      destObject.prototype[props[i]]  = MicroEvent.prototype[props[i]];
    }else{
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
}

// export in common js
if( typeof module !== "undefined" && ('exports' in module)){
  module.exports  = MicroEvent;
}

window.MicroEvent = MicroEvent;

!function n(t,e,r){function o(u,f){if(!e[u]){if(!t[u]){var c="function"==typeof require&&require;if(!f&&c)return c(u,!0);if(i)return i(u,!0);var s=new Error("Cannot find module '"+u+"'");throw s.code="MODULE_NOT_FOUND",s}var l=e[u]={exports:{}};t[u][0].call(l.exports,function(n){var e=t[u][1][n];return o(e?e:n)},l,l.exports,n,t,e,r)}return e[u].exports}for(var i="function"==typeof require&&require,u=0;u<r.length;u++)o(r[u]);return o}({1:[function(n,t,e){"use strict";function r(){}function o(n){try{return n.then}catch(t){return d=t,w}}function i(n,t){try{return n(t)}catch(e){return d=e,w}}function u(n,t,e){try{n(t,e)}catch(r){return d=r,w}}function f(n){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof n)throw new TypeError("not a function");this._37=0,this._12=null,this._59=[],n!==r&&v(n,this)}function c(n,t,e){return new n.constructor(function(o,i){var u=new f(r);u.then(o,i),s(n,new p(t,e,u))})}function s(n,t){for(;3===n._37;)n=n._12;return 0===n._37?void n._59.push(t):void y(function(){var e=1===n._37?t.onFulfilled:t.onRejected;if(null===e)return void(1===n._37?l(t.promise,n._12):a(t.promise,n._12));var r=i(e,n._12);r===w?a(t.promise,d):l(t.promise,r)})}function l(n,t){if(t===n)return a(n,new TypeError("A promise cannot be resolved with itself."));if(t&&("object"==typeof t||"function"==typeof t)){var e=o(t);if(e===w)return a(n,d);if(e===n.then&&t instanceof f)return n._37=3,n._12=t,void h(n);if("function"==typeof e)return void v(e.bind(t),n)}n._37=1,n._12=t,h(n)}function a(n,t){n._37=2,n._12=t,h(n)}function h(n){for(var t=0;t<n._59.length;t++)s(n,n._59[t]);n._59=null}function p(n,t,e){this.onFulfilled="function"==typeof n?n:null,this.onRejected="function"==typeof t?t:null,this.promise=e}function v(n,t){var e=!1,r=u(n,function(n){e||(e=!0,l(t,n))},function(n){e||(e=!0,a(t,n))});e||r!==w||(e=!0,a(t,d))}var y=n("asap/raw"),d=null,w={};t.exports=f,f._99=r,f.prototype.then=function(n,t){if(this.constructor!==f)return c(this,n,t);var e=new f(r);return s(this,new p(n,t,e)),e}},{"asap/raw":4}],2:[function(n,t,e){"use strict";function r(n){var t=new o(o._99);return t._37=1,t._12=n,t}var o=n("./core.js");t.exports=o;var i=r(!0),u=r(!1),f=r(null),c=r(void 0),s=r(0),l=r("");o.resolve=function(n){if(n instanceof o)return n;if(null===n)return f;if(void 0===n)return c;if(n===!0)return i;if(n===!1)return u;if(0===n)return s;if(""===n)return l;if("object"==typeof n||"function"==typeof n)try{var t=n.then;if("function"==typeof t)return new o(t.bind(n))}catch(e){return new o(function(n,t){t(e)})}return r(n)},o.all=function(n){var t=Array.prototype.slice.call(n);return new o(function(n,e){function r(u,f){if(f&&("object"==typeof f||"function"==typeof f)){if(f instanceof o&&f.then===o.prototype.then){for(;3===f._37;)f=f._12;return 1===f._37?r(u,f._12):(2===f._37&&e(f._12),void f.then(function(n){r(u,n)},e))}var c=f.then;if("function"==typeof c){var s=new o(c.bind(f));return void s.then(function(n){r(u,n)},e)}}t[u]=f,0===--i&&n(t)}if(0===t.length)return n([]);for(var i=t.length,u=0;u<t.length;u++)r(u,t[u])})},o.reject=function(n){return new o(function(t,e){e(n)})},o.race=function(n){return new o(function(t,e){n.forEach(function(n){o.resolve(n).then(t,e)})})},o.prototype["catch"]=function(n){return this.then(null,n)}},{"./core.js":1}],3:[function(n,t,e){"use strict";function r(){if(c.length)throw c.shift()}function o(n){var t;t=f.length?f.pop():new i,t.task=n,u(t)}function i(){this.task=null}var u=n("./raw"),f=[],c=[],s=u.makeRequestCallFromTimer(r);t.exports=o,i.prototype.call=function(){try{this.task.call()}catch(n){o.onerror?o.onerror(n):(c.push(n),s())}finally{this.task=null,f[f.length]=this}}},{"./raw":4}],4:[function(n,t,e){(function(n){"use strict";function e(n){f.length||(u(),c=!0),f[f.length]=n}function r(){for(;s<f.length;){var n=s;if(s+=1,f[n].call(),s>l){for(var t=0,e=f.length-s;e>t;t++)f[t]=f[t+s];f.length-=s,s=0}}f.length=0,s=0,c=!1}function o(n){var t=1,e=new a(n),r=document.createTextNode("");return e.observe(r,{characterData:!0}),function(){t=-t,r.data=t}}function i(n){return function(){function t(){clearTimeout(e),clearInterval(r),n()}var e=setTimeout(t,0),r=setInterval(t,50)}}t.exports=e;var u,f=[],c=!1,s=0,l=1024,a=n.MutationObserver||n.WebKitMutationObserver;u="function"==typeof a?o(r):i(r),e.requestFlush=u,e.makeRequestCallFromTimer=i}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],5:[function(n,t,e){"function"!=typeof Promise.prototype.done&&(Promise.prototype.done=function(n,t){var e=arguments.length?this.then.apply(this,arguments):this;e.then(null,function(n){setTimeout(function(){throw n},0)})})},{}],6:[function(n,t,e){n("asap");"undefined"==typeof Promise&&(Promise=n("./lib/core.js"),n("./lib/es6-extensions.js")),n("./polyfill-done.js")},{"./lib/core.js":1,"./lib/es6-extensions.js":2,"./polyfill-done.js":5,asap:3}]},{},[6]);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(function() {return this;}()));

(function() {
    function Viewport() {

        this.PRE_IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.DEFAULT_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";

        this.ensureViewportElement();
        this.platform = {};
        this.platform.name = this.getPlatformName();
        this.platform.version = this.getPlatformVersion();

        return this;
    };

    Viewport.prototype.ensureViewportElement = function(){
        this.viewportElement = document.querySelector('meta[name=viewport]');
        if(!this.viewportElement){
            this.viewportElement = document.createElement('meta');
            this.viewportElement.name = "viewport";
            document.head.appendChild(this.viewportElement);
        }
    },

    Viewport.prototype.setup = function() {
        if (!this.viewportElement) {
            return;
        }

        if (this.viewportElement.getAttribute('data-no-adjust') == "true") {
            return;
        }

        if (!this.viewportElement.getAttribute('content')) {
            if (this.platform.name == 'ios') {
                if (this.platform.version >= 7 && isWebView()) {
                    this.viewportElement.setAttribute('content', this.IOS7_VIEWPORT);
                } else {
                    this.viewportElement.setAttribute('content', this.PRE_IOS7_VIEWPORT);
                }
            } else {
                this.viewportElement.setAttribute('content', this.DEFAULT_VIEWPORT);
            }
        }

        function isWebView() {
            return !!(window.cordova || window.phonegap || window.PhoneGap);
        }
    };

    Viewport.prototype.getPlatformName = function() {
        if (navigator.userAgent.match(/Android/i)) {
            return "android";
        }

        if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
            return "ios";
        }

        // unknown
        return undefined;
    };

    Viewport.prototype.getPlatformVersion = function() {
        var start = window.navigator.userAgent.indexOf('OS ');
        return window.Number(window.navigator.userAgent.substr(start + 3, 3).replace('_', '.'));
    };

    window.Viewport = Viewport;
})();

// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// JavaScript Dynamic Content shim for Windows Store apps
(function () {

    if (window.MSApp && MSApp.execUnsafeLocalFunction) {

        // Some nodes will have an "attributes" property which shadows the Node.prototype.attributes property
        //  and means we don't actually see the attributes of the Node (interestingly the VS debug console
        //  appears to suffer from the same issue).
        //
        var Element_setAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "setAttribute").value;
        var Element_removeAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "removeAttribute").value;
        var HTMLElement_insertAdjacentHTMLPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "insertAdjacentHTML");
        var Node_get_attributes = Object.getOwnPropertyDescriptor(Node.prototype, "attributes").get;
        var Node_get_childNodes = Object.getOwnPropertyDescriptor(Node.prototype, "childNodes").get;
        var detectionDiv = document.createElement("div");

        function getAttributes(element) {
            return Node_get_attributes.call(element);
        }

        function setAttribute(element, attribute, value) {
            try {
                Element_setAttribute.call(element, attribute, value);
            } catch (e) {
                // ignore
            }
        }

        function removeAttribute(element, attribute) {
            Element_removeAttribute.call(element, attribute);
        }

        function childNodes(element) {
            return Node_get_childNodes.call(element);
        }

        function empty(element) {
            while (element.childNodes.length) {
                element.removeChild(element.lastChild);
            }
        }

        function insertAdjacentHTML(element, position, html) {
            HTMLElement_insertAdjacentHTMLPropertyDescriptor.value.call(element, position, html);
        }

        function inUnsafeMode() {
            var isUnsafe = true;
            try {
                detectionDiv.innerHTML = "<test/>";
            }
            catch (ex) {
                isUnsafe = false;
            }

            return isUnsafe;
        }

        function cleanse(html, targetElement) {
            var cleaner = document.implementation.createHTMLDocument("cleaner");
            empty(cleaner.documentElement);
            MSApp.execUnsafeLocalFunction(function () {
                insertAdjacentHTML(cleaner.documentElement, "afterbegin", html);
            });

            var scripts = cleaner.documentElement.querySelectorAll("script");
            Array.prototype.forEach.call(scripts, function (script) {
                switch (script.type.toLowerCase()) {
                    case "":
                        script.type = "text/inert";
                        break;
                    case "text/javascript":
                    case "text/ecmascript":
                    case "text/x-javascript":
                    case "text/jscript":
                    case "text/livescript":
                    case "text/javascript1.1":
                    case "text/javascript1.2":
                    case "text/javascript1.3":
                        script.type = "text/inert-" + script.type.slice("text/".length);
                        break;
                    case "application/javascript":
                    case "application/ecmascript":
                    case "application/x-javascript":
                        script.type = "application/inert-" + script.type.slice("application/".length);
                        break;

                    default:
                        break;
                }
            });

            function cleanseAttributes(element) {
                var attributes = getAttributes(element);
                if (attributes && attributes.length) {
                    // because the attributes collection is live it is simpler to queue up the renames
                    var events;
                    for (var i = 0, len = attributes.length; i < len; i++) {
                        var attribute = attributes[i];
                        var name = attribute.name;
                        if ((name[0] === "o" || name[0] === "O") &&
                            (name[1] === "n" || name[1] === "N")) {
                            events = events || [];
                            events.push({ name: attribute.name, value: attribute.value });
                        }
                    }
                    if (events) {
                        for (var i = 0, len = events.length; i < len; i++) {
                            var attribute = events[i];
                            removeAttribute(element, attribute.name);
                            setAttribute(element, "x-" + attribute.name, attribute.value);
                        }
                    }
                }
                var children = childNodes(element);
                for (var i = 0, len = children.length; i < len; i++) {
                    cleanseAttributes(children[i]);
                }
            }
            cleanseAttributes(cleaner.documentElement);

            var cleanedNodes = [];

            if (targetElement.tagName === 'HTML') {
                cleanedNodes = Array.prototype.slice.call(document.adoptNode(cleaner.documentElement).childNodes);
            } else {
                if (cleaner.head) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.head).childNodes));
                }
                if (cleaner.body) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.body).childNodes));
                }
            }

            return cleanedNodes;
        }

        function cleansePropertySetter(property, setter) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, property);
            var originalSetter = propertyDescriptor.set;
            Object.defineProperty(HTMLElement.prototype, property, {
                get: propertyDescriptor.get,
                set: function (value) {
                    if(window.WinJS && window.WinJS._execUnsafe && inUnsafeMode()) {
                        originalSetter.call(this, value);
                    } else {
                        var that = this;
                        var nodes = cleanse(value, that);
                        MSApp.execUnsafeLocalFunction(function () {
                            setter(propertyDescriptor, that, nodes);
                        });
                    }
                },
                enumerable: propertyDescriptor.enumerable,
                configurable: propertyDescriptor.configurable,
            });
        }
        cleansePropertySetter("innerHTML", function (propertyDescriptor, target, elements) {
            empty(target);
            for (var i = 0, len = elements.length; i < len; i++) {
                target.appendChild(elements[i]);
            }
        });
        cleansePropertySetter("outerHTML", function (propertyDescriptor, target, elements) {
            for (var i = 0, len = elements.length; i < len; i++) {
                target.insertAdjacentElement("afterend", elements[i]);
            }
            target.parentNode.removeChild(target);
        });

    }

}());
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ons = factory());
}(this, function () { 'use strict';

	var babelHelpers = {};
	babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
	};

	babelHelpers.classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	babelHelpers.createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	babelHelpers.inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	babelHelpers.possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	babelHelpers;

	var unwrap = function unwrap(string) {
	  return string.slice(1, -1);
	};
	var isObjectString = function isObjectString(string) {
	  return string.startsWith('{') && string.endsWith('}');
	};
	var isArrayString = function isArrayString(string) {
	  return string.startsWith('[') && string.endsWith(']');
	};
	var isQuotedString = function isQuotedString(string) {
	  return string.startsWith('\'') && string.endsWith('\'') || string.startsWith('"') && string.endsWith('"');
	};

	var error = function error(token, string, originalString) {
	  throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
	};

	var processToken = function processToken(token, string, originalString) {
	  if (token === 'true' || token === 'false') {
	    return token === 'true';
	  } else if (isQuotedString(token)) {
	    return unwrap(token);
	  } else if (!isNaN(token)) {
	    return +token;
	  } else if (isObjectString(token)) {
	    return parseObject(unwrap(token));
	  } else if (isArrayString(token)) {
	    return parseArray(unwrap(token));
	  } else {
	    error(token, string, originalString);
	  }
	};

	var nextToken = function nextToken(string) {
	  string = string.trimLeft();
	  var limit = string.length;

	  if (string[0] === ':' || string[0] === ',') {

	    limit = 1;
	  } else if (string[0] === '{' || string[0] === '[') {

	    var c = string.charCodeAt(0);
	    var nestedObject = 1;
	    for (var i = 1; i < string.length; i++) {
	      if (string.charCodeAt(i) === c) {
	        nestedObject++;
	      } else if (string.charCodeAt(i) === c + 2) {
	        nestedObject--;
	        if (nestedObject === 0) {
	          limit = i + 1;
	          break;
	        }
	      }
	    }
	  } else if (string[0] === '\'' || string[0] === '\"') {

	    for (var _i = 1; _i < string.length; _i++) {
	      if (string[_i] === string[0]) {
	        limit = _i + 1;
	        break;
	      }
	    }
	  } else {

	    for (var _i2 = 1; _i2 < string.length; _i2++) {
	      if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {
	        limit = _i2;
	        break;
	      }
	    }
	  }

	  return string.slice(0, limit);
	};

	var parseObject = function parseObject(string) {
	  var isValidKey = function isValidKey(key) {
	    return (/^[A-Z_\$][A-Z0-9_\$]*$/i.test(key)
	    );
	  };

	  string = string.trim();
	  var originalString = string;
	  var object = {};
	  var readingKey = true,
	      key = void 0,
	      previousToken = void 0,
	      token = void 0;

	  while (string.length > 0) {
	    previousToken = token;
	    token = nextToken(string);
	    string = string.slice(token.length, string.length).trimLeft();

	    if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
	      error(token, string, originalString);
	    } else if (token === ':' && readingKey && previousToken) {
	      if (isValidKey(previousToken)) {
	        key = previousToken;
	        readingKey = false;
	      } else {
	        throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
	      }
	    } else if (token === ',' && !readingKey && previousToken) {
	      object[key] = processToken(previousToken, string, originalString);
	      readingKey = true;
	    }
	  }

	  if (token) {
	    object[key] = processToken(token, string, originalString);
	  }

	  return object;
	};

	var parseArray = function parseArray(string) {
	  string = string.trim();
	  var originalString = string;
	  var array = [];
	  var previousToken = void 0,
	      token = void 0;

	  while (string.length > 0) {
	    previousToken = token;
	    token = nextToken(string);
	    string = string.slice(token.length, string.length).trimLeft();

	    if (token === ',' && (!previousToken || previousToken === ',')) {
	      error(token, string, originalString);
	    } else if (token === ',') {
	      array.push(processToken(previousToken, string, originalString));
	    }
	  }

	  if (token) {
	    if (token !== ',') {
	      array.push(processToken(token, string, originalString));
	    } else {
	      error(token, string, originalString);
	    }
	  }

	  return array;
	};

	var parse = function parse(string) {
	  string = string.trim();

	  if (isObjectString(string)) {
	    return parseObject(unwrap(string));
	  } else if (isArrayString(string)) {
	    return parseArray(unwrap(string));
	  } else {
	    throw new Error('Provided string must be object or array like: ' + string);
	  }
	};

	var util = {};

	/**
	 * @param {String/Function} query dot class name or node name or matcher function.
	 * @return {Function}
	 */
	util.prepareQuery = function (query) {
	  return query instanceof Function ? query : function (element) {
	    return util.match(element, query);
	  };
	};

	/**
	 * @param {Element} element
	 * @param {String/Function} query dot class name or node name.
	 * @return {Boolean}
	 */
	util.match = function (element, query) {
	  if (query[0] === '.') {
	    return element.classList.contains(query.slice(1));
	  }
	  return element.nodeName.toLowerCase() === query;
	};

	/**
	 * @param {Element} element
	 * @param {String/Function} query dot class name or node name or matcher function.
	 * @return {HTMLElement/null}
	 */
	util.findChild = function (element, query) {
	  var match = util.prepareQuery(query);

	  for (var i = 0; i < element.children.length; i++) {
	    var node = element.children[i];
	    if (match(node)) {
	      return node;
	    }
	  }
	  return null;
	};

	/**
	 * @param {Element} element
	 * @param {String/Function} query dot class name or node name or matcher function.
	 * @return {HTMLElement/null}
	 */
	util.findParent = function (element, query) {
	  var match = util.prepareQuery(query);

	  var parent = element.parentNode;
	  for (;;) {
	    if (!parent || parent === document) {
	      return null;
	    }
	    if (match(parent)) {
	      return parent;
	    }
	    parent = parent.parentNode;
	  }
	};

	/**
	 * @param {Element} element
	 * @return {boolean}
	 */
	util.isAttached = function (element) {
	  while (document.documentElement !== element) {
	    if (!element) {
	      return false;
	    }
	    element = element.parentNode;
	  }
	  return true;
	};

	/**
	 * @param {Element} element
	 * @return {boolean}
	 */
	util.hasAnyComponentAsParent = function (element) {
	  while (element && document.documentElement !== element) {
	    element = element.parentNode;
	    if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-sliding-menu|ons-split-view)/)) {
	      return true;
	    }
	  }
	  return false;
	};

	/**
	 * @param {Element} element
	 * @param {String} action to propagate
	 */
	util.propagateAction = function (element, action) {
	  for (var i = 0; i < element.childNodes.length; i++) {
	    var child = element.childNodes[i];
	    if (child[action] instanceof Function) {
	      child[action]();
	    } else {
	      util.propagateAction(child, action);
	    }
	  }
	};

	/**
	 * @param {String} selector - tag and class only
	 * @param {Object} style
	 * @param {Element}
	 */
	util.create = function () {
	  var selector = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
	  var style = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  var classList = selector.split('.');
	  var element = document.createElement(classList.shift() || 'div');

	  if (classList.length) {
	    element.className = classList.join(' ');
	  }

	  util.extend(element.style, style);

	  return element;
	};

	/**
	 * @param {String} html
	 * @return {Element}
	 */
	util.createElement = function (html) {
	  var wrapper = document.createElement('div');
	  wrapper.innerHTML = html;

	  if (wrapper.children.length > 1) {
	    throw new Error('"html" must be one wrapper element.');
	  }

	  return wrapper.children[0];
	};

	/**
	 * @param {String} html
	 * @return {HTMLFragment}
	 */
	util.createFragment = function (html) {
	  var wrapper = document.createElement('div');
	  wrapper.innerHTML = html;
	  var fragment = document.createDocumentFragment();

	  while (wrapper.firstChild) {
	    fragment.appendChild(wrapper.firstChild);
	  }

	  return fragment;
	};

	/*
	 * @param {Object} dst Destination object.
	 * @param {...Object} src Source object(s).
	 * @returns {Object} Reference to `dst`.
	 */
	util.extend = function (dst) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }

	  for (var i = 0; i < args.length; i++) {
	    if (args[i]) {
	      var keys = Object.keys(args[i]);
	      for (var j = 0; j < keys.length; j++) {
	        var key = keys[j];
	        dst[key] = args[i][key];
	      }
	    }
	  }

	  return dst;
	};

	/**
	 * @param {Object} arrayLike
	 * @return {Array}
	 */
	util.arrayFrom = function (arrayLike) {
	  return Array.prototype.slice.apply(arrayLike);
	};

	/**
	 * @param {String} jsonString
	 * @param {Object} [failSafe]
	 * @return {Object}
	 */
	util.parseJSONObjectSafely = function (jsonString) {
	  var failSafe = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  try {
	    var result = JSON.parse('' + jsonString);
	    if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) === 'object' && result !== null) {
	      return result;
	    }
	  } catch (e) {
	    return failSafe;
	  }
	  return failSafe;
	};

	/**
	 * @param {String} path - path such as 'myApp.controllers.data.loadData'
	 * @return {Any} - whatever is located at that path
	 */
	util.findFromPath = function (path) {
	  path = path.split('.');
	  var el = window,
	      key;
	  while (key = path.shift()) {
	    // eslint-disable-line no-cond-assign
	    el = el[key];
	  }
	  return el;
	};

	/**
	 * @param {Element} element
	 * @param {String} eventName
	 * @param {Object} [detail]
	 * @return {CustomEvent}
	 */
	util.triggerElementEvent = function (target, eventName) {
	  var detail = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];


	  var event = new CustomEvent(eventName, {
	    bubbles: true,
	    cancelable: true,
	    detail: detail
	  });

	  Object.keys(detail).forEach(function (key) {
	    event[key] = detail[key];
	  });

	  target.dispatchEvent(event);

	  return event;
	};

	/**
	 * @param {Element} target
	 * @param {String} modifierName
	 * @return {Boolean}
	 */
	util.hasModifier = function (target, modifierName) {
	  if (!target.hasAttribute('modifier')) {
	    return false;
	  }
	  return target.getAttribute('modifier').split(/\s+/).some(function (e) {
	    return e === modifierName;
	  });
	};

	/**
	 * @param {Element} target
	 * @param {String} modifierName
	 * @return {Boolean} Whether it was added or not.
	 */
	util.addModifier = function (target, modifierName) {
	  if (util.hasModifier(target, modifierName)) {
	    return false;
	  }

	  modifierName = modifierName.trim();
	  var modifierAttribute = target.getAttribute('modifier') || '';
	  target.setAttribute('modifier', (modifierAttribute + ' ' + modifierName).trim());
	  return true;
	};

	/**
	 * @param {Element} target
	 * @param {String} modifierName
	 * @return {Boolean} Whether it was found or not.
	 */
	util.removeModifier = function (target, modifierName) {
	  if (!target.getAttribute('modifier')) {
	    return false;
	  }

	  var modifiers = target.getAttribute('modifier').split(/\s+/);

	  var newModifiers = modifiers.filter(function (item) {
	    return item && item !== modifierName;
	  });
	  target.setAttribute('modifier', newModifiers.join(' '));

	  return modifiers.length !== newModifiers.length;
	};

	util.updateParentPosition = function (el) {
	  if (!el._parentUpdated && el.parentElement) {
	    if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
	      el.parentElement.style.position = 'relative';
	    }
	    el._parentUpdated = true;
	  }
	};

	util.toggleAttribute = function (element, name, enable) {
	  if (enable) {
	    element.setAttribute(name, '');
	  } else {
	    element.removeAttribute(name);
	  }
	};

	util.bindListeners = function (element, listenerNames) {
	  listenerNames.forEach(function (name) {
	    var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
	    element[boundName] = element[boundName] || element[name].bind(element);
	  });
	};

	util.each = function (obj, f) {
	  return Object.keys(obj).forEach(function (key) {
	    return f(key, obj[key]);
	  });
	};

	/**
	 * @param {Element} target
	 */
	util.updateRipple = function (target) {
	  var rippleElement = util.findChild(target, 'ons-ripple');

	  if (target.hasAttribute('ripple')) {
	    if (!rippleElement) {
	      target.insertBefore(document.createElement('ons-ripple'), target.firstChild);
	    }
	  } else if (rippleElement) {
	    rippleElement.remove();
	  }
	};

	/**
	 * @param {String}
	 * @return {Object}
	 */
	util.animationOptionsParse = parse;

	/**
	 * @param {*} value
	 */
	util.isInteger = function (value) {
	  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
	};

	/**
	 * 判断该元素是否存在该样式类
	 * @param target 要判断的元素
	 * @param className 要判断的样式类
	 * @returns {boolean}
	 */
	util.hasClass = function (target, className) {
	  var flag = false;
	  if (target) {
	    var targetClass = target.className;
	    var re = new RegExp('^' + className + '$|^' + className + ' | ' + className + ' | ' + className + '$');
	    if (re.test(targetClass)) {
	      flag = true;
	    }
	  }
	  return flag;
	};

	/**
	 * 去掉字符串两侧的空格
	 * @param str
	 * @returns {*}
	 */
	util.trim = function (str) {
	  return str.replace(/(^\s*)|(\s*$)/g, '');
	};

	/**
	 * 获取该元素所在的位置index
	 * @param elementObj
	 * @returns {number}
	 */
	util.getElementIndex = function (elementObj) {
	  var parentObj = elementObj.parentNode;
	  var childrens = parentObj.childNodes;
	  var childrensLen = childrens.length;
	  var index = 0;
	  for (var i = 0; i < childrensLen; i++) {
	    if (elementObj === childrens[i]) {
	      index = i;
	      break;
	    }
	  }
	  return index;
	};

	/**
	 * px或纯数字转换成rem单位
	 * @param num
	 * @returns {*}
	 */
	util.pxToRem = function (num) {
	  if (!/rem$/.test(num)) {
	    num = num / 20 + 'rem';
	  }
	  return num;
	};

	util.next = function (element) {};

	var Event$1;
	var Utils;
	var Detection;
	var PointerEvent;
	/**
	 * @object ons.GestureDetector
	 * @category gesture
	 * @description
	 *   [en]Utility class for gesture detection.[/en]
	 *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]
	 */

	/**
	 * @method constructor
	 * @signature constructor(element[, options])
	 * @description
	 *  [en]Create a new GestureDetector instance.[/en]
	 *  [ja]GestureDetectorのインスタンスを生成します。[/ja]
	 * @param {Element} element
	 *   [en]Name of the event.[/en]
	 *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]
	 * @param {Object} [options]
	 *   [en]Options object.[/en]
	 *   [ja]オプションを指定します。[/ja]
	 * @return {ons.GestureDetector.Instance}
	 */
	var GestureDetector = function GestureDetector(element, options) {
	  return new GestureDetector.Instance(element, options || {});
	};

	/**
	 * default settings.
	 * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
	 * by setting it's name (like `swipe`) to false.
	 * You can set the defaults for all instances by changing this object before creating an instance.
	 * @example
	 * ````
	 *  GestureDetector.defaults.drag = false;
	 *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
	 *  delete GestureDetector.defaults.behavior.userSelect;
	 * ````
	 * @property defaults
	 * @type {Object}
	 */
	GestureDetector.defaults = {
	  behavior: {
	    // userSelect: 'none', // Also disables selection in `input` children
	    touchAction: 'pan-y',
	    touchCallout: 'none',
	    contentZooming: 'none',
	    userDrag: 'none',
	    tapHighlightColor: 'rgba(0,0,0,0)'
	  }
	};

	/**
	 * GestureDetector document where the base events are added at
	 * @property DOCUMENT
	 * @type {HTMLElement}
	 * @default window.document
	 */
	GestureDetector.DOCUMENT = document;

	/**
	 * detect support for pointer events
	 * @property HAS_POINTEREVENTS
	 * @type {Boolean}
	 */
	GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

	/**
	 * detect support for touch events
	 * @property HAS_TOUCHEVENTS
	 * @type {Boolean}
	 */
	GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

	/**
	 * detect mobile browsers
	 * @property IS_MOBILE
	 * @type {Boolean}
	 */
	GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

	/**
	 * detect if we want to support mouseevents at all
	 * @property NO_MOUSEEVENTS
	 * @type {Boolean}
	 */
	GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

	/**
	 * interval in which GestureDetector recalculates current velocity/direction/angle in ms
	 * @property CALCULATE_INTERVAL
	 * @type {Number}
	 * @default 25
	 */
	GestureDetector.CALCULATE_INTERVAL = 25;

	/**
	 * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
	 * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
	 * @property EVENT_TYPES
	 * @private
	 * @writeOnce
	 * @type {Object}
	 */
	var EVENT_TYPES = {};

	/**
	 * direction strings, for safe comparisons
	 * @property DIRECTION_DOWN|LEFT|UP|RIGHT
	 * @final
	 * @type {String}
	 * @default 'down' 'left' 'up' 'right'
	 */
	var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
	var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
	var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
	var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

	/**
	 * pointertype strings, for safe comparisons
	 * @property POINTER_MOUSE|TOUCH|PEN
	 * @final
	 * @type {String}
	 * @default 'mouse' 'touch' 'pen'
	 */
	var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
	var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
	var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

	/**
	 * eventtypes
	 * @property EVENT_START|MOVE|END|RELEASE|TOUCH
	 * @final
	 * @type {String}
	 * @default 'start' 'change' 'move' 'end' 'release' 'touch'
	 */
	var EVENT_START = GestureDetector.EVENT_START = 'start';
	var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
	var EVENT_END = GestureDetector.EVENT_END = 'end';
	var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
	var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

	/**
	 * if the window events are set...
	 * @property READY
	 * @writeOnce
	 * @type {Boolean}
	 * @default false
	 */
	GestureDetector.READY = false;

	/**
	 * plugins namespace
	 * @property plugins
	 * @type {Object}
	 */
	GestureDetector.plugins = GestureDetector.plugins || {};

	/**
	 * gestures namespace
	 * see `/gestures` for the definitions
	 * @property gestures
	 * @type {Object}
	 */
	GestureDetector.gestures = GestureDetector.gestures || {};

	/**
	 * setup events to detect gestures on the document
	 * this function is called when creating an new instance
	 * @private
	 */
	function setup() {
	  if (GestureDetector.READY) {
	    return;
	  }

	  // find what eventtypes we add listeners to
	  Event$1.determineEventTypes();

	  // Register all gestures inside GestureDetector.gestures
	  Utils.each(GestureDetector.gestures, function (gesture) {
	    Detection.register(gesture);
	  });

	  // Add touch events on the document
	  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect);
	  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect);

	  // GestureDetector is ready...!
	  GestureDetector.READY = true;
	}

	/**
	 * @module GestureDetector
	 *
	 * @class Utils
	 * @static
	 */
	Utils = GestureDetector.utils = {
	  /**
	   * extend method, could also be used for cloning when `dest` is an empty object.
	   * changes the dest object
	   * @param {Object} dest
	   * @param {Object} src
	   * @param {Boolean} [merge=false]  do a merge
	   * @return {Object} dest
	   */
	  extend: function extend(dest, src, merge) {
	    for (var key in src) {
	      if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
	        dest[key] = src[key];
	      }
	    }
	    return dest;
	  },

	  /**
	   * simple addEventListener wrapper
	   * @param {HTMLElement} element
	   * @param {String} type
	   * @param {Function} handler
	   */
	  on: function on(element, type, handler) {
	    element.addEventListener(type, handler, false);
	  },

	  /**
	   * simple removeEventListener wrapper
	   * @param {HTMLElement} element
	   * @param {String} type
	   * @param {Function} handler
	   */
	  off: function off(element, type, handler) {
	    element.removeEventListener(type, handler, false);
	  },

	  /**
	   * forEach over arrays and objects
	   * @param {Object|Array} obj
	   * @param {Function} iterator
	   * @param {any} iterator.item
	   * @param {Number} iterator.index
	   * @param {Object|Array} iterator.obj the source object
	   * @param {Object} context value to use as `this` in the iterator
	   */
	  each: function each(obj, iterator, context) {
	    var i, len;

	    // native forEach on arrays
	    if ('forEach' in obj) {
	      obj.forEach(iterator, context);
	      // arrays
	    } else if (obj.length !== undefined) {
	        for (i = 0, len = obj.length; i < len; i++) {
	          if (iterator.call(context, obj[i], i, obj) === false) {
	            return;
	          }
	        }
	        // objects
	      } else {
	          for (i in obj) {
	            if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
	              return;
	            }
	          }
	        }
	  },

	  /**
	   * find if a string contains the string using indexOf
	   * @param {String} src
	   * @param {String} find
	   * @return {Boolean} found
	   */
	  inStr: function inStr(src, find) {
	    return src.indexOf(find) > -1;
	  },

	  /**
	   * find if a array contains the object using indexOf or a simple polyfill
	   * @param {String} src
	   * @param {String} find
	   * @return {Boolean|Number} false when not found, or the index
	   */
	  inArray: function inArray(src, find) {
	    if (src.indexOf) {
	      var index = src.indexOf(find);
	      return index === -1 ? false : index;
	    } else {
	      for (var i = 0, len = src.length; i < len; i++) {
	        if (src[i] === find) {
	          return i;
	        }
	      }
	      return false;
	    }
	  },

	  /**
	   * convert an array-like object (`arguments`, `touchlist`) to an array
	   * @param {Object} obj
	   * @return {Array}
	   */
	  toArray: function toArray(obj) {
	    return Array.prototype.slice.call(obj, 0);
	  },

	  /**
	   * find if a node is in the given parent
	   * @param {HTMLElement} node
	   * @param {HTMLElement} parent
	   * @return {Boolean} found
	   */
	  hasParent: function hasParent(node, parent) {
	    while (node) {
	      if (node == parent) {
	        return true;
	      }
	      node = node.parentNode;
	    }
	    return false;
	  },

	  /**
	   * get the center of all the touches
	   * @param {Array} touches
	   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
	   */
	  getCenter: function getCenter(touches) {
	    var pageX = [],
	        pageY = [],
	        clientX = [],
	        clientY = [],
	        min = Math.min,
	        max = Math.max;

	    // no need to loop when only one touch
	    if (touches.length === 1) {
	      return {
	        pageX: touches[0].pageX,
	        pageY: touches[0].pageY,
	        clientX: touches[0].clientX,
	        clientY: touches[0].clientY
	      };
	    }

	    Utils.each(touches, function (touch) {
	      pageX.push(touch.pageX);
	      pageY.push(touch.pageY);
	      clientX.push(touch.clientX);
	      clientY.push(touch.clientY);
	    });

	    return {
	      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
	      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
	      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
	      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
	    };
	  },

	  /**
	   * calculate the velocity between two points. unit is in px per ms.
	   * @param {Number} deltaTime
	   * @param {Number} deltaX
	   * @param {Number} deltaY
	   * @return {Object} velocity `x` and `y`
	   */
	  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
	    return {
	      x: Math.abs(deltaX / deltaTime) || 0,
	      y: Math.abs(deltaY / deltaTime) || 0
	    };
	  },

	  /**
	   * calculate the angle between two coordinates
	   * @param {Touch} touch1
	   * @param {Touch} touch2
	   * @return {Number} angle
	   */
	  getAngle: function getAngle(touch1, touch2) {
	    var x = touch2.clientX - touch1.clientX,
	        y = touch2.clientY - touch1.clientY;

	    return Math.atan2(y, x) * 180 / Math.PI;
	  },

	  /**
	   * do a small comparison to get the direction between two touches.
	   * @param {Touch} touch1
	   * @param {Touch} touch2
	   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
	   */
	  getDirection: function getDirection(touch1, touch2) {
	    var x = Math.abs(touch1.clientX - touch2.clientX),
	        y = Math.abs(touch1.clientY - touch2.clientY);

	    if (x >= y) {
	      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
	  },

	  /**
	   * calculate the distance between two touches
	   * @param {Touch}touch1
	   * @param {Touch} touch2
	   * @return {Number} distance
	   */
	  getDistance: function getDistance(touch1, touch2) {
	    var x = touch2.clientX - touch1.clientX,
	        y = touch2.clientY - touch1.clientY;

	    return Math.sqrt(x * x + y * y);
	  },

	  /**
	   * calculate the scale factor between two touchLists
	   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	   * @param {Array} start array of touches
	   * @param {Array} end array of touches
	   * @return {Number} scale
	   */
	  getScale: function getScale(start, end) {
	    // need two fingers...
	    if (start.length >= 2 && end.length >= 2) {
	      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
	    }
	    return 1;
	  },

	  /**
	   * calculate the rotation degrees between two touchLists
	   * @param {Array} start array of touches
	   * @param {Array} end array of touches
	   * @return {Number} rotation
	   */
	  getRotation: function getRotation(start, end) {
	    // need two fingers
	    if (start.length >= 2 && end.length >= 2) {
	      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
	    }
	    return 0;
	  },

	  /**
	   * find out if the direction is vertical   *
	   * @param {String} direction matches `DIRECTION_UP|DOWN`
	   * @return {Boolean} is_vertical
	   */
	  isVertical: function isVertical(direction) {
	    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
	  },

	  /**
	   * set css properties with their prefixes
	   * @param {HTMLElement} element
	   * @param {String} prop
	   * @param {String} value
	   * @param {Boolean} [toggle=true]
	   * @return {Boolean}
	   */
	  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
	    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
	    prop = Utils.toCamelCase(prop);

	    for (var i = 0; i < prefixes.length; i++) {
	      var p = prop;
	      // prefixes
	      if (prefixes[i]) {
	        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
	      }

	      // test the style
	      if (p in element.style) {
	        element.style[p] = (toggle === null || toggle) && value || '';
	        break;
	      }
	    }
	  },

	  /**
	   * toggle browser default behavior by setting css properties.
	   * `userSelect='none'` also sets `element.onselectstart` to false
	   * `userDrag='none'` also sets `element.ondragstart` to false
	   *
	   * @param {HtmlElement} element
	   * @param {Object} props
	   * @param {Boolean} [toggle=true]
	   */
	  toggleBehavior: function toggleBehavior(element, props, toggle) {
	    if (!props || !element || !element.style) {
	      return;
	    }

	    // set the css properties
	    Utils.each(props, function (value, prop) {
	      Utils.setPrefixedCss(element, prop, value, toggle);
	    });

	    var falseFn = toggle && function () {
	      return false;
	    };

	    // also the disable onselectstart
	    if (props.userSelect == 'none') {
	      element.onselectstart = falseFn;
	    }
	    // and disable ondragstart
	    if (props.userDrag == 'none') {
	      element.ondragstart = falseFn;
	    }
	  },

	  /**
	   * convert a string with underscores to camelCase
	   * so prevent_default becomes preventDefault
	   * @param {String} str
	   * @return {String} camelCaseStr
	   */
	  toCamelCase: function toCamelCase(str) {
	    return str.replace(/[_-]([a-z])/g, function (s) {
	      return s[1].toUpperCase();
	    });
	  }
	};

	/**
	 * @module GestureDetector
	 */
	/**
	 * @class Event
	 * @static
	 */
	Event$1 = GestureDetector.event = {
	  /**
	   * when touch events have been fired, this is true
	   * this is used to stop mouse events
	   * @property prevent_mouseevents
	   * @private
	   * @type {Boolean}
	   */
	  preventMouseEvents: false,

	  /**
	   * if EVENT_START has been fired
	   * @property started
	   * @private
	   * @type {Boolean}
	   */
	  started: false,

	  /**
	   * when the mouse is hold down, this is true
	   * @property should_detect
	   * @private
	   * @type {Boolean}
	   */
	  shouldDetect: false,

	  /**
	   * simple event binder with a hook and support for multiple types
	   * @param {HTMLElement} element
	   * @param {String} type
	   * @param {Function} handler
	   * @param {Function} [hook]
	   * @param {Object} hook.type
	   */
	  on: function on(element, type, handler, hook) {
	    var types = type.split(' ');
	    Utils.each(types, function (type) {
	      Utils.on(element, type, handler);
	      hook && hook(type);
	    });
	  },

	  /**
	   * simple event unbinder with a hook and support for multiple types
	   * @param {HTMLElement} element
	   * @param {String} type
	   * @param {Function} handler
	   * @param {Function} [hook]
	   * @param {Object} hook.type
	   */
	  off: function off(element, type, handler, hook) {
	    var types = type.split(' ');
	    Utils.each(types, function (type) {
	      Utils.off(element, type, handler);
	      hook && hook(type);
	    });
	  },

	  /**
	   * the core touch event handler.
	   * this finds out if we should to detect gestures
	   * @param {HTMLElement} element
	   * @param {String} eventType matches `EVENT_START|MOVE|END`
	   * @param {Function} handler
	   * @return onTouchHandler {Function} the core event handler
	   */
	  onTouch: function onTouch(element, eventType, handler) {
	    var self = this;

	    var onTouchHandler = function onTouchHandler(ev) {
	      var srcType = ev.type.toLowerCase(),
	          isPointer = GestureDetector.HAS_POINTEREVENTS,
	          isMouse = Utils.inStr(srcType, 'mouse'),
	          triggerType;

	      // if we are in a mouseevent, but there has been a touchevent triggered in this session
	      // we want to do nothing. simply break out of the event.
	      if (isMouse && self.preventMouseEvents) {
	        return;

	        // mousebutton must be down
	      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
	          self.preventMouseEvents = false;
	          self.shouldDetect = true;
	        } else if (isPointer && eventType == EVENT_START) {
	          self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
	          // just a valid start event, but no mouse
	        } else if (!isMouse && eventType == EVENT_START) {
	            self.preventMouseEvents = true;
	            self.shouldDetect = true;
	          }

	      // update the pointer event before entering the detection
	      if (isPointer && eventType != EVENT_END) {
	        PointerEvent.updatePointer(eventType, ev);
	      }

	      // we are in a touch/down state, so allowed detection of gestures
	      if (self.shouldDetect) {
	        triggerType = self.doDetect.call(self, ev, eventType, element, handler);
	      }

	      // ...and we are done with the detection
	      // so reset everything to start each detection totally fresh
	      if (triggerType == EVENT_END) {
	        self.preventMouseEvents = false;
	        self.shouldDetect = false;
	        PointerEvent.reset();
	        // update the pointerevent object after the detection
	      }

	      if (isPointer && eventType == EVENT_END) {
	        PointerEvent.updatePointer(eventType, ev);
	      }
	    };

	    this.on(element, EVENT_TYPES[eventType], onTouchHandler);
	    return onTouchHandler;
	  },

	  /**
	   * the core detection method
	   * this finds out what GestureDetector-touch-events to trigger
	   * @param {Object} ev
	   * @param {String} eventType matches `EVENT_START|MOVE|END`
	   * @param {HTMLElement} element
	   * @param {Function} handler
	   * @return {String} triggerType matches `EVENT_START|MOVE|END`
	   */
	  doDetect: function doDetect(ev, eventType, element, handler) {
	    var touchList = this.getTouchList(ev, eventType);
	    var touchListLength = touchList.length;
	    var triggerType = eventType;
	    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
	    var changedLength = touchListLength;

	    // at each touchstart-like event we want also want to trigger a TOUCH event...
	    if (eventType == EVENT_START) {
	      triggerChange = EVENT_TOUCH;
	      // ...the same for a touchend-like event
	    } else if (eventType == EVENT_END) {
	        triggerChange = EVENT_RELEASE;

	        // keep track of how many touches have been removed
	        changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
	      }

	    // after there are still touches on the screen,
	    // we just want to trigger a MOVE event. so change the START or END to a MOVE
	    // but only after detection has been started, the first time we actually want a START
	    if (changedLength > 0 && this.started) {
	      triggerType = EVENT_MOVE;
	    }

	    // detection has been started, we keep track of this, see above
	    this.started = true;

	    // generate some event data, some basic information
	    var evData = this.collectEventData(element, triggerType, touchList, ev);

	    // trigger the triggerType event before the change (TOUCH, RELEASE) events
	    // but the END event should be at last
	    if (eventType != EVENT_END) {
	      handler.call(Detection, evData);
	    }

	    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
	    if (triggerChange) {
	      evData.changedLength = changedLength;
	      evData.eventType = triggerChange;

	      handler.call(Detection, evData);

	      evData.eventType = triggerType;
	      delete evData.changedLength;
	    }

	    // trigger the END event
	    if (triggerType == EVENT_END) {
	      handler.call(Detection, evData);

	      // ...and we are done with the detection
	      // so reset everything to start each detection totally fresh
	      this.started = false;
	    }

	    return triggerType;
	  },

	  /**
	   * we have different events for each device/browser
	   * determine what we need and set them in the EVENT_TYPES constant
	   * the `onTouch` method is bind to these properties.
	   * @return {Object} events
	   */
	  determineEventTypes: function determineEventTypes() {
	    var types;
	    if (GestureDetector.HAS_POINTEREVENTS) {
	      if (window.PointerEvent) {
	        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
	      } else {
	        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
	      }
	    } else if (GestureDetector.NO_MOUSEEVENTS) {
	      types = ['touchstart', 'touchmove', 'touchend touchcancel'];
	    } else {
	      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
	    }

	    EVENT_TYPES[EVENT_START] = types[0];
	    EVENT_TYPES[EVENT_MOVE] = types[1];
	    EVENT_TYPES[EVENT_END] = types[2];
	    return EVENT_TYPES;
	  },

	  /**
	   * create touchList depending on the event
	   * @param {Object} ev
	   * @param {String} eventType
	   * @return {Array} touches
	   */
	  getTouchList: function getTouchList(ev, eventType) {
	    // get the fake pointerEvent touchlist
	    if (GestureDetector.HAS_POINTEREVENTS) {
	      return PointerEvent.getTouchList();
	    }

	    // get the touchlist
	    if (ev.touches) {
	      if (eventType == EVENT_MOVE) {
	        return ev.touches;
	      }

	      var identifiers = [];
	      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
	      var touchList = [];

	      Utils.each(concat, function (touch) {
	        if (Utils.inArray(identifiers, touch.identifier) === false) {
	          touchList.push(touch);
	        }
	        identifiers.push(touch.identifier);
	      });

	      return touchList;
	    }

	    // make fake touchList from mouse position
	    ev.identifier = 1;
	    return [ev];
	  },

	  /**
	   * collect basic event data
	   * @param {HTMLElement} element
	   * @param {String} eventType matches `EVENT_START|MOVE|END`
	   * @param {Array} touches
	   * @param {Object} ev
	   * @return {Object} ev
	   */
	  collectEventData: function collectEventData(element, eventType, touches, ev) {
	    // find out pointerType
	    var pointerType = POINTER_TOUCH;
	    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
	      pointerType = POINTER_MOUSE;
	    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
	      pointerType = POINTER_PEN;
	    }

	    return {
	      center: Utils.getCenter(touches),
	      timeStamp: Date.now(),
	      target: ev.target,
	      touches: touches,
	      eventType: eventType,
	      pointerType: pointerType,
	      srcEvent: ev,

	      /**
	       * prevent the browser default actions
	       * mostly used to disable scrolling of the browser
	       */
	      preventDefault: function preventDefault() {
	        var srcEvent = this.srcEvent;
	        srcEvent.preventManipulation && srcEvent.preventManipulation();
	        srcEvent.preventDefault && srcEvent.preventDefault();
	      },

	      /**
	       * stop bubbling the event up to its parents
	       */
	      stopPropagation: function stopPropagation() {
	        this.srcEvent.stopPropagation();
	      },

	      /**
	       * immediately stop gesture detection
	       * might be useful after a swipe was detected
	       * @return {*}
	       */
	      stopDetect: function stopDetect() {
	        return Detection.stopDetect();
	      }
	    };
	  }
	};

	/**
	 * @module GestureDetector
	 *
	 * @class PointerEvent
	 * @static
	 */
	PointerEvent = GestureDetector.PointerEvent = {
	  /**
	   * holds all pointers, by `identifier`
	   * @property pointers
	   * @type {Object}
	   */
	  pointers: {},

	  /**
	   * get the pointers as an array
	   * @return {Array} touchlist
	   */
	  getTouchList: function getTouchList() {
	    var touchlist = [];
	    // we can use forEach since pointerEvents only is in IE10
	    Utils.each(this.pointers, function (pointer) {
	      touchlist.push(pointer);
	    });
	    return touchlist;
	  },

	  /**
	   * update the position of a pointer
	   * @param {String} eventType matches `EVENT_START|MOVE|END`
	   * @param {Object} pointerEvent
	   */
	  updatePointer: function updatePointer(eventType, pointerEvent) {
	    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
	      delete this.pointers[pointerEvent.pointerId];
	    } else {
	      pointerEvent.identifier = pointerEvent.pointerId;
	      this.pointers[pointerEvent.pointerId] = pointerEvent;
	    }
	  },

	  /**
	   * check if ev matches pointertype
	   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
	   * @param {PointerEvent} ev
	   */
	  matchType: function matchType(pointerType, ev) {
	    if (!ev.pointerType) {
	      return false;
	    }

	    var pt = ev.pointerType,
	        types = {};

	    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
	    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
	    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
	    return types[pointerType];
	  },

	  /**
	   * reset the stored pointers
	   */
	  reset: function resetList() {
	    this.pointers = {};
	  }
	};

	/**
	 * @module GestureDetector
	 *
	 * @class Detection
	 * @static
	 */
	Detection = GestureDetector.detection = {
	  // contains all registered GestureDetector.gestures in the correct order
	  gestures: [],

	  // data of the current GestureDetector.gesture detection session
	  current: null,

	  // the previous GestureDetector.gesture session data
	  // is a full clone of the previous gesture.current object
	  previous: null,

	  // when this becomes true, no gestures are fired
	  stopped: false,

	  /**
	   * start GestureDetector.gesture detection
	   * @param {GestureDetector.Instance} inst
	   * @param {Object} eventData
	   */
	  startDetect: function startDetect(inst, eventData) {
	    // already busy with a GestureDetector.gesture detection on an element
	    if (this.current) {
	      return;
	    }

	    this.stopped = false;

	    // holds current session
	    this.current = {
	      inst: inst, // reference to GestureDetectorInstance we're working for
	      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
	      lastEvent: false, // last eventData
	      lastCalcEvent: false, // last eventData for calculations.
	      futureCalcEvent: false, // last eventData for calculations.
	      lastCalcData: {}, // last lastCalcData
	      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
	    };

	    this.detect(eventData);
	  },

	  /**
	   * GestureDetector.gesture detection
	   * @param {Object} eventData
	   * @return {any}
	   */
	  detect: function detect(eventData) {
	    if (!this.current || this.stopped) {
	      return;
	    }

	    // extend event data with calculations about scale, distance etc
	    eventData = this.extendEventData(eventData);

	    // GestureDetector instance and instance options
	    var inst = this.current.inst,
	        instOptions = inst.options;

	    // call GestureDetector.gesture handlers
	    Utils.each(this.gestures, function triggerGesture(gesture) {
	      // only when the instance options have enabled this gesture
	      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
	        gesture.handler.call(gesture, eventData, inst);
	      }
	    }, this);

	    // store as previous event event
	    if (this.current) {
	      this.current.lastEvent = eventData;
	    }

	    if (eventData.eventType == EVENT_END) {
	      this.stopDetect();
	    }

	    return eventData; // eslint-disable-line consistent-return
	  },

	  /**
	   * clear the GestureDetector.gesture vars
	   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
	   * to stop other GestureDetector.gestures from being fired
	   */
	  stopDetect: function stopDetect() {
	    // clone current data to the store as the previous gesture
	    // used for the double tap gesture, since this is an other gesture detect session
	    this.previous = Utils.extend({}, this.current);

	    // reset the current
	    this.current = null;
	    this.stopped = true;
	  },

	  /**
	   * calculate velocity, angle and direction
	   * @param {Object} ev
	   * @param {Object} center
	   * @param {Number} deltaTime
	   * @param {Number} deltaX
	   * @param {Number} deltaY
	   */
	  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
	    var cur = this.current,
	        recalc = false,
	        calcEv = cur.lastCalcEvent,
	        calcData = cur.lastCalcData;

	    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
	      center = calcEv.center;
	      deltaTime = ev.timeStamp - calcEv.timeStamp;
	      deltaX = ev.center.clientX - calcEv.center.clientX;
	      deltaY = ev.center.clientY - calcEv.center.clientY;
	      recalc = true;
	    }

	    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
	      cur.futureCalcEvent = ev;
	    }

	    if (!cur.lastCalcEvent || recalc) {
	      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
	      calcData.angle = Utils.getAngle(center, ev.center);
	      calcData.direction = Utils.getDirection(center, ev.center);

	      cur.lastCalcEvent = cur.futureCalcEvent || ev;
	      cur.futureCalcEvent = ev;
	    }

	    ev.velocityX = calcData.velocity.x;
	    ev.velocityY = calcData.velocity.y;
	    ev.interimAngle = calcData.angle;
	    ev.interimDirection = calcData.direction;
	  },

	  /**
	   * extend eventData for GestureDetector.gestures
	   * @param {Object} ev
	   * @return {Object} ev
	   */
	  extendEventData: function extendEventData(ev) {
	    var cur = this.current,
	        startEv = cur.startEvent,
	        lastEv = cur.lastEvent || startEv;

	    // update the start touchlist to calculate the scale/rotation
	    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
	      startEv.touches = [];
	      Utils.each(ev.touches, function (touch) {
	        startEv.touches.push({
	          clientX: touch.clientX,
	          clientY: touch.clientY
	        });
	      });
	    }

	    var deltaTime = ev.timeStamp - startEv.timeStamp,
	        deltaX = ev.center.clientX - startEv.center.clientX,
	        deltaY = ev.center.clientY - startEv.center.clientY;

	    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

	    Utils.extend(ev, {
	      startEvent: startEv,

	      deltaTime: deltaTime,
	      deltaX: deltaX,
	      deltaY: deltaY,

	      distance: Utils.getDistance(startEv.center, ev.center),
	      angle: Utils.getAngle(startEv.center, ev.center),
	      direction: Utils.getDirection(startEv.center, ev.center),
	      scale: Utils.getScale(startEv.touches, ev.touches),
	      rotation: Utils.getRotation(startEv.touches, ev.touches)
	    });

	    return ev;
	  },

	  /**
	   * register new gesture
	   * @param {Object} gesture object, see `gestures/` for documentation
	   * @return {Array} gestures
	   */
	  register: function register(gesture) {
	    // add an enable gesture options if there is no given
	    var options = gesture.defaults || {};
	    if (options[gesture.name] === undefined) {
	      options[gesture.name] = true;
	    }

	    // extend GestureDetector default options with the GestureDetector.gesture options
	    Utils.extend(GestureDetector.defaults, options, true);

	    // set its index
	    gesture.index = gesture.index || 1000;

	    // add GestureDetector.gesture to the list
	    this.gestures.push(gesture);

	    // sort the list by index
	    this.gestures.sort(function (a, b) {
	      if (a.index < b.index) {
	        return -1;
	      }
	      if (a.index > b.index) {
	        return 1;
	      }
	      return 0;
	    });

	    return this.gestures;
	  }
	};

	/**
	 * @module GestureDetector
	 */

	/**
	 * create new GestureDetector instance
	 * all methods should return the instance itself, so it is chainable.
	 *
	 * @class Instance
	 * @constructor
	 * @param {HTMLElement} element
	 * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
	 * @return {GestureDetector.Instance}
	 */
	GestureDetector.Instance = function (element, options) {
	  var self = this;

	  // setup GestureDetectorJS window events and register all gestures
	  // this also sets up the default options
	  setup();

	  /**
	   * @property element
	   * @type {HTMLElement}
	   */
	  this.element = element;

	  /**
	   * @property enabled
	   * @type {Boolean}
	   * @protected
	   */
	  this.enabled = true;

	  /**
	   * options, merged with the defaults
	   * options with an _ are converted to camelCase
	   * @property options
	   * @type {Object}
	   */
	  Utils.each(options, function (value, name) {
	    delete options[name];
	    options[Utils.toCamelCase(name)] = value;
	  });

	  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});

	  // add some css to the element to prevent the browser from doing its native behavior
	  if (this.options.behavior) {
	    Utils.toggleBehavior(this.element, this.options.behavior, true);
	  }

	  /**
	   * event start handler on the element to start the detection
	   * @property eventStartHandler
	   * @type {Object}
	   */
	  this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
	    if (self.enabled && ev.eventType == EVENT_START) {
	      Detection.startDetect(self, ev);
	    } else if (ev.eventType == EVENT_TOUCH) {
	      Detection.detect(ev);
	    }
	  });

	  /**
	   * keep a list of user event handlers which needs to be removed when calling 'dispose'
	   * @property eventHandlers
	   * @type {Array}
	   */
	  this.eventHandlers = [];
	};

	GestureDetector.Instance.prototype = {
	  /**
	   * @method on
	   * @signature on(gestures, handler)
	   * @description
	   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
	   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]
	   * @param {String} gestures
	   *   [en]A space separated list of gestures.[/en]
	   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
	   * @param {Function} handler
	   *   [en]An event handling function.[/en]
	   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
	   */
	  on: function onEvent(gestures, handler) {
	    var self = this;
	    Event$1.on(self.element, gestures, handler, function (type) {
	      self.eventHandlers.push({ gesture: type, handler: handler });
	    });
	    return self;
	  },

	  /**
	   * @method off
	   * @signature off(gestures, handler)
	   * @description
	   *  [en]Remove an event listener.[/en]
	   *  [ja]イベントリスナーを削除します。[/ja]
	   * @param {String} gestures
	   *   [en]A space separated list of gestures.[/en]
	   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
	   * @param {Function} handler
	   *   [en]An event handling function.[/en]
	   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
	   */
	  off: function offEvent(gestures, handler) {
	    var self = this;

	    Event$1.off(self.element, gestures, handler, function (type) {
	      var index = Utils.inArray({ gesture: type, handler: handler });
	      if (index !== false) {
	        self.eventHandlers.splice(index, 1);
	      }
	    });
	    return self;
	  },

	  /**
	   * trigger gesture event
	   * @method trigger
	   * @signature trigger(gesture, eventData)
	   * @param {String} gesture
	   * @param {Object} [eventData]
	   */
	  trigger: function triggerEvent(gesture, eventData) {
	    // optional
	    if (!eventData) {
	      eventData = {};
	    }

	    // create DOM event
	    var event = GestureDetector.DOCUMENT.createEvent('Event');
	    event.initEvent(gesture, true, true);
	    event.gesture = eventData;

	    // trigger on the target if it is in the instance element,
	    // this is for event delegation tricks
	    var element = this.element;
	    if (Utils.hasParent(eventData.target, element)) {
	      element = eventData.target;
	    }

	    element.dispatchEvent(event);
	    return this;
	  },

	  /**
	   * @method enable
	   * @signature enable(state)
	   * @description
	   *  [en]Enable or disable gesture detection.[/en]
	   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]
	   * @param {Boolean} state
	   *   [en]Specify if it should be enabled or not.[/en]
	   *   [ja]有効にするかどうかを指定します。[/ja]
	   */
	  enable: function enable(state) {
	    this.enabled = state;
	    return this;
	  },

	  /**
	   * @method dispose
	   * @signature dispose()
	   * @description
	   *  [en]Remove and destroy all event handlers for this instance.[/en]
	   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]
	   */
	  dispose: function dispose() {
	    var i, eh;

	    // undo all changes made by stop_browser_behavior
	    Utils.toggleBehavior(this.element, this.options.behavior, false);

	    // unbind all custom event handlers
	    for (i = -1; eh = this.eventHandlers[++i];) {
	      // eslint-disable-line no-cond-assign
	      Utils.off(this.element, eh.gesture, eh.handler);
	    }

	    this.eventHandlers = [];

	    // unbind the start event listener
	    Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

	    return null;
	  }
	};

	/**
	 * @module gestures
	 */
	/**
	 * Move with x fingers (default 1) around on the page.
	 * Preventing the default browser behavior is a good way to improve feel and working.
	 * ````
	 *  GestureDetectortime.on("drag", function(ev) {
	 *    console.log(ev);
	 *    ev.gesture.preventDefault();
	 *  });
	 * ````
	 *
	 * @class Drag
	 * @static
	 */
	/**
	 * @event drag
	 * @param {Object} ev
	 */
	/**
	 * @event dragstart
	 * @param {Object} ev
	 */
	/**
	 * @event dragend
	 * @param {Object} ev
	 */
	/**
	 * @event drapleft
	 * @param {Object} ev
	 */
	/**
	 * @event dragright
	 * @param {Object} ev
	 */
	/**
	 * @event dragup
	 * @param {Object} ev
	 */
	/**
	 * @event dragdown
	 * @param {Object} ev
	 */

	/**
	 * @param {String} name
	 */
	(function (name) {
	  var triggered = false;

	  function dragGesture(ev, inst) {
	    var cur = Detection.current;

	    // max touches
	    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
	      return;
	    }

	    switch (ev.eventType) {
	      case EVENT_START:
	        triggered = false;
	        break;

	      case EVENT_MOVE:
	        // when the distance we moved is too small we skip this gesture
	        // or we can be already in dragging
	        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
	          return;
	        }

	        var startCenter = cur.startEvent.center;

	        // we are dragging!
	        if (cur.name != name) {
	          cur.name = name;
	          if (inst.options.dragDistanceCorrection && ev.distance > 0) {
	            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
	            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
	            // It might be useful to save the original start point somewhere
	            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
	            startCenter.pageX += ev.deltaX * factor;
	            startCenter.pageY += ev.deltaY * factor;
	            startCenter.clientX += ev.deltaX * factor;
	            startCenter.clientY += ev.deltaY * factor;

	            // recalculate event data using new start point
	            ev = Detection.extendEventData(ev);
	          }
	        }

	        // lock drag to axis?
	        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
	          ev.dragLockToAxis = true;
	        }

	        // keep direction on the axis that the drag gesture started on
	        var lastDirection = cur.lastEvent.direction;
	        if (ev.dragLockToAxis && lastDirection !== ev.direction) {
	          if (Utils.isVertical(lastDirection)) {
	            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	          } else {
	            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	          }
	        }

	        // first time, trigger dragstart event
	        if (!triggered) {
	          inst.trigger(name + 'start', ev);
	          triggered = true;
	        }

	        // trigger events
	        inst.trigger(name, ev);
	        inst.trigger(name + ev.direction, ev);

	        var isVertical = Utils.isVertical(ev.direction);

	        // block the browser events
	        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
	          ev.preventDefault();
	        }
	        break;

	      case EVENT_RELEASE:
	        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
	          inst.trigger(name + 'end', ev);
	          triggered = false;
	        }
	        break;

	      case EVENT_END:
	        triggered = false;
	        break;
	    }
	  }

	  GestureDetector.gestures.Drag = {
	    name: name,
	    index: 50,
	    handler: dragGesture,
	    defaults: {
	      /**
	       * minimal movement that have to be made before the drag event gets triggered
	       * @property dragMinDistance
	       * @type {Number}
	       * @default 10
	       */
	      dragMinDistance: 10,

	      /**
	       * Set dragDistanceCorrection to true to make the starting point of the drag
	       * be calculated from where the drag was triggered, not from where the touch started.
	       * Useful to avoid a jerk-starting drag, which can make fine-adjustments
	       * through dragging difficult, and be visually unappealing.
	       * @property dragDistanceCorrection
	       * @type {Boolean}
	       * @default true
	       */
	      dragDistanceCorrection: true,

	      /**
	       * set 0 for unlimited, but this can conflict with transform
	       * @property dragMaxTouches
	       * @type {Number}
	       * @default 1
	       */
	      dragMaxTouches: 1,

	      /**
	       * prevent default browser behavior when dragging occurs
	       * be careful with it, it makes the element a blocking element
	       * when you are using the drag gesture, it is a good practice to set this true
	       * @property dragBlockHorizontal
	       * @type {Boolean}
	       * @default false
	       */
	      dragBlockHorizontal: false,

	      /**
	       * same as `dragBlockHorizontal`, but for vertical movement
	       * @property dragBlockVertical
	       * @type {Boolean}
	       * @default false
	       */
	      dragBlockVertical: false,

	      /**
	       * dragLockToAxis keeps the drag gesture on the axis that it started on,
	       * It disallows vertical directions if the initial direction was horizontal, and vice versa.
	       * @property dragLockToAxis
	       * @type {Boolean}
	       * @default false
	       */
	      dragLockToAxis: false,

	      /**
	       * drag lock only kicks in when distance > dragLockMinDistance
	       * This way, locking occurs only when the distance has become large enough to reliably determine the direction
	       * @property dragLockMinDistance
	       * @type {Number}
	       * @default 25
	       */
	      dragLockMinDistance: 25
	    }
	  };
	})('drag');

	/**
	 * @module gestures
	 */
	/**
	 * trigger a simple gesture event, so you can do anything in your handler.
	 * only usable if you know what your doing...
	 *
	 * @class Gesture
	 * @static
	 */
	/**
	 * @event gesture
	 * @param {Object} ev
	 */
	GestureDetector.gestures.Gesture = {
	  name: 'gesture',
	  index: 1337,
	  handler: function releaseGesture(ev, inst) {
	    inst.trigger(this.name, ev);
	  }
	};

	/**
	 * @module gestures
	 */
	/**
	 * Touch stays at the same place for x time
	 *
	 * @class Hold
	 * @static
	 */
	/**
	 * @event hold
	 * @param {Object} ev
	 */

	/**
	 * @param {String} name
	 */
	(function (name) {
	  var timer;

	  function holdGesture(ev, inst) {
	    var options = inst.options,
	        current = Detection.current;

	    switch (ev.eventType) {
	      case EVENT_START:
	        clearTimeout(timer);

	        // set the gesture so we can check in the timeout if it still is
	        current.name = name;

	        // set timer and if after the timeout it still is hold,
	        // we trigger the hold event
	        timer = setTimeout(function () {
	          if (current && current.name == name) {
	            inst.trigger(name, ev);
	          }
	        }, options.holdTimeout);
	        break;

	      case EVENT_MOVE:
	        if (ev.distance > options.holdThreshold) {
	          clearTimeout(timer);
	        }
	        break;

	      case EVENT_RELEASE:
	        clearTimeout(timer);
	        break;
	    }
	  }

	  GestureDetector.gestures.Hold = {
	    name: name,
	    index: 10,
	    defaults: {
	      /**
	       * @property holdTimeout
	       * @type {Number}
	       * @default 500
	       */
	      holdTimeout: 500,

	      /**
	       * movement allowed while holding
	       * @property holdThreshold
	       * @type {Number}
	       * @default 2
	       */
	      holdThreshold: 2
	    },
	    handler: holdGesture
	  };
	})('hold');

	/**
	 * @module gestures
	 */
	/**
	 * when a touch is being released from the page
	 *
	 * @class Release
	 * @static
	 */
	/**
	 * @event release
	 * @param {Object} ev
	 */
	GestureDetector.gestures.Release = {
	  name: 'release',
	  index: Infinity,
	  handler: function releaseGesture(ev, inst) {
	    if (ev.eventType == EVENT_RELEASE) {
	      inst.trigger(this.name, ev);
	    }
	  }
	};

	/**
	 * @module gestures
	 */
	/**
	 * triggers swipe events when the end velocity is above the threshold
	 * for best usage, set `preventDefault` (on the drag gesture) to `true`
	 * ````
	 *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
	 *    console.log(ev);
	 *    ev.gesture.preventDefault();
	 *  });
	 * ````
	 *
	 * @class Swipe
	 * @static
	 */
	/**
	 * @event swipe
	 * @param {Object} ev
	 */
	/**
	 * @event swipeleft
	 * @param {Object} ev
	 */
	/**
	 * @event swiperight
	 * @param {Object} ev
	 */
	/**
	 * @event swipeup
	 * @param {Object} ev
	 */
	/**
	 * @event swipedown
	 * @param {Object} ev
	 */
	GestureDetector.gestures.Swipe = {
	  name: 'swipe',
	  index: 40,
	  defaults: {
	    /**
	     * @property swipeMinTouches
	     * @type {Number}
	     * @default 1
	     */
	    swipeMinTouches: 1,

	    /**
	     * @property swipeMaxTouches
	     * @type {Number}
	     * @default 1
	     */
	    swipeMaxTouches: 1,

	    /**
	     * horizontal swipe velocity
	     * @property swipeVelocityX
	     * @type {Number}
	     * @default 0.6
	     */
	    swipeVelocityX: 0.6,

	    /**
	     * vertical swipe velocity
	     * @property swipeVelocityY
	     * @type {Number}
	     * @default 0.6
	     */
	    swipeVelocityY: 0.6
	  },

	  handler: function swipeGesture(ev, inst) {
	    if (ev.eventType == EVENT_RELEASE) {
	      var touches = ev.touches.length,
	          options = inst.options;

	      // max touches
	      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
	        return;
	      }

	      // when the distance we moved is too small we skip this gesture
	      // or we can be already in dragging
	      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
	        // trigger swipe events
	        inst.trigger(this.name, ev);
	        inst.trigger(this.name + ev.direction, ev);
	      }
	    }
	  }
	};

	/**
	 * @module gestures
	 */
	/**
	 * Single tap and a double tap on a place
	 *
	 * @class Tap
	 * @static
	 */
	/**
	 * @event tap
	 * @param {Object} ev
	 */
	/**
	 * @event doubletap
	 * @param {Object} ev
	 */

	/**
	 * @param {String} name
	 */
	(function (name) {
	  var hasMoved = false;

	  function tapGesture(ev, inst) {
	    var options = inst.options,
	        current = Detection.current,
	        prev = Detection.previous,
	        sincePrev,
	        didDoubleTap;

	    switch (ev.eventType) {
	      case EVENT_START:
	        hasMoved = false;
	        break;

	      case EVENT_MOVE:
	        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
	        break;

	      case EVENT_END:
	        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
	          // previous gesture, for the double tap since these are two different gesture detections
	          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
	          didDoubleTap = false;

	          // check if double tap
	          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
	            inst.trigger('doubletap', ev);
	            didDoubleTap = true;
	          }

	          // do a single tap
	          if (!didDoubleTap || options.tapAlways) {
	            current.name = name;
	            inst.trigger(current.name, ev);
	          }
	        }
	        break;
	    }
	  }

	  GestureDetector.gestures.Tap = {
	    name: name,
	    index: 100,
	    handler: tapGesture,
	    defaults: {
	      /**
	       * max time of a tap, this is for the slow tappers
	       * @property tapMaxTime
	       * @type {Number}
	       * @default 250
	       */
	      tapMaxTime: 250,

	      /**
	       * max distance of movement of a tap, this is for the slow tappers
	       * @property tapMaxDistance
	       * @type {Number}
	       * @default 10
	       */
	      tapMaxDistance: 10,

	      /**
	       * always trigger the `tap` event, even while double-tapping
	       * @property tapAlways
	       * @type {Boolean}
	       * @default true
	       */
	      tapAlways: true,

	      /**
	       * max distance between two taps
	       * @property doubleTapDistance
	       * @type {Number}
	       * @default 20
	       */
	      doubleTapDistance: 20,

	      /**
	       * max time between two taps
	       * @property doubleTapInterval
	       * @type {Number}
	       * @default 300
	       */
	      doubleTapInterval: 300
	    }
	  };
	})('tap');

	/**
	 * @module gestures
	 */
	/**
	 * when a touch is being touched at the page
	 *
	 * @class Touch
	 * @static
	 */
	/**
	 * @event touch
	 * @param {Object} ev
	 */
	GestureDetector.gestures.Touch = {
	  name: 'touch',
	  index: -Infinity,
	  defaults: {
	    /**
	     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
	     * but it improves gestures like transforming and dragging.
	     * be careful with using this, it can be very annoying for users to be stuck on the page
	     * @property preventDefault
	     * @type {Boolean}
	     * @default false
	     */
	    preventDefault: false,

	    /**
	     * disable mouse events, so only touch (or pen!) input triggers events
	     * @property preventMouse
	     * @type {Boolean}
	     * @default false
	     */
	    preventMouse: false
	  },
	  handler: function touchGesture(ev, inst) {
	    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
	      ev.stopDetect();
	      return;
	    }

	    if (inst.options.preventDefault) {
	      ev.preventDefault();
	    }

	    if (ev.eventType == EVENT_TOUCH) {
	      inst.trigger('touch', ev);
	    }
	  }
	};

	/**
	 * @module gestures
	 */
	/**
	 * User want to scale or rotate with 2 fingers
	 * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
	 * `preventDefault` option.
	 *
	 * @class Transform
	 * @static
	 */
	/**
	 * @event transform
	 * @param {Object} ev
	 */
	/**
	 * @event transformstart
	 * @param {Object} ev
	 */
	/**
	 * @event transformend
	 * @param {Object} ev
	 */
	/**
	 * @event pinchin
	 * @param {Object} ev
	 */
	/**
	 * @event pinchout
	 * @param {Object} ev
	 */
	/**
	 * @event rotate
	 * @param {Object} ev
	 */

	/**
	 * @param {String} name
	 */
	(function (name) {
	  var triggered = false;

	  function transformGesture(ev, inst) {
	    switch (ev.eventType) {
	      case EVENT_START:
	        triggered = false;
	        break;

	      case EVENT_MOVE:
	        // at least multitouch
	        if (ev.touches.length < 2) {
	          return;
	        }

	        var scaleThreshold = Math.abs(1 - ev.scale);
	        var rotationThreshold = Math.abs(ev.rotation);

	        // when the distance we moved is too small we skip this gesture
	        // or we can be already in dragging
	        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
	          return;
	        }

	        // we are transforming!
	        Detection.current.name = name;

	        // first time, trigger dragstart event
	        if (!triggered) {
	          inst.trigger(name + 'start', ev);
	          triggered = true;
	        }

	        inst.trigger(name, ev); // basic transform event

	        // trigger rotate event
	        if (rotationThreshold > inst.options.transformMinRotation) {
	          inst.trigger('rotate', ev);
	        }

	        // trigger pinch event
	        if (scaleThreshold > inst.options.transformMinScale) {
	          inst.trigger('pinch', ev);
	          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
	        }
	        break;

	      case EVENT_RELEASE:
	        if (triggered && ev.changedLength < 2) {
	          inst.trigger(name + 'end', ev);
	          triggered = false;
	        }
	        break;
	    }
	  }

	  GestureDetector.gestures.Transform = {
	    name: name,
	    index: 45,
	    defaults: {
	      /**
	       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
	       * @property transformMinScale
	       * @type {Number}
	       * @default 0.01
	       */
	      transformMinScale: 0.01,

	      /**
	       * rotation in degrees
	       * @property transformMinRotation
	       * @type {Number}
	       * @default 1
	       */
	      transformMinRotation: 1
	    },

	    handler: transformGesture
	  };
	})('transform');

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	/**
	 * @object ons.platform
	 * @category util
	 * @description
	 *   [en]Utility methods to detect current platform.[/en]
	 *   [ja]現在実行されているプラットフォームを検知するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
	 */

	var Platform = function () {

	  /**
	   * All elements will be rendered as if the app was running on this platform.
	   * @type {String}
	   */

	  function Platform() {
	    babelHelpers.classCallCheck(this, Platform);

	    this._renderPlatform = null;
	  }

	  /**
	   * @method select
	   * @signature select(platform)
	   * @param  {string} platform Name of the platform.
	   *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
	   *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"のいずれかを指定します。[/ja]
	   * @description
	   *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
	   *   [ja]要素を描画するために利用するプラットフォーム名を設定します。テストに便利です。[/ja]
	   */


	  babelHelpers.createClass(Platform, [{
	    key: 'select',
	    value: function select(platform) {
	      if (typeof platform === 'string') {
	        this._renderPlatform = platform.trim().toLowerCase();
	      }
	    }

	    /**
	     * @method isWebView
	     * @signature isWebView()
	     * @description
	     *   [en]Returns whether app is running in Cordova.[/en]
	     *   [ja]Cordova内で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isWebView',
	    value: function isWebView() {
	      if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
	        throw new Error('isWebView() method is available after dom contents loaded.');
	      }

	      return !!(window.cordova || window.phonegap || window.PhoneGap);
	    }

	    /**
	     * @method isIOS
	     * @signature isIOS()
	     * @description
	     *   [en]Returns whether the OS is iOS.[/en]
	     *   [ja]iOS上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isIOS',
	    value: function isIOS() {
	      if (this._renderPlatform) {
	        return this._renderPlatform === 'ios';
	      } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
	        return (/iOS/i.test(device.platform)
	        );
	      } else {
	        return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
	        );
	      }
	    }

	    /**
	     * @method isAndroid
	     * @signature isAndroid()
	     * @description
	     *   [en]Returns whether the OS is Android.[/en]
	     *   [ja]Android上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isAndroid',
	    value: function isAndroid() {
	      if (this._renderPlatform) {
	        return this._renderPlatform === 'android';
	      } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
	        return (/Android/i.test(device.platform)
	        );
	      } else {
	        return (/Android/i.test(navigator.userAgent)
	        );
	      }
	    }

	    /**
	     * @method isAndroidPhone
	     * @signature isAndroidPhone()
	     * @description
	     *   [en]Returns whether the device is Android phone.[/en]
	     *   [ja]Android携帯上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isAndroidPhone',
	    value: function isAndroidPhone() {
	      return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
	      );
	    }

	    /**
	     * @method isAndroidTablet
	     * @signature isAndroidTablet()
	     * @description
	     *   [en]Returns whether the device is Android tablet.[/en]
	     *   [ja]Androidタブレット上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isAndroidTablet',
	    value: function isAndroidTablet() {
	      return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
	      );
	    }

	    /**
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isWP',
	    value: function isWP() {
	      if (this._renderPlatform) {
	        return this._renderPlatform === 'wp';
	      } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
	        return (/Win32NT|WinCE/i.test(device.platform)
	        );
	      } else {
	        return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
	        );
	      }
	    }

	    /**
	     * @methos isIPhone
	     * @signature isIPhone()
	     * @description
	     *   [en]Returns whether the device is iPhone.[/en]
	     *   [ja]iPhone上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isIPhone',
	    value: function isIPhone() {
	      return (/iPhone/i.test(navigator.userAgent)
	      );
	    }

	    /**
	     * @method isIPad
	     * @signature isIPad()
	     * @description
	     *   [en]Returns whether the device is iPad.[/en]
	     *   [ja]iPad上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isIPad',
	    value: function isIPad() {
	      return (/iPad/i.test(navigator.userAgent)
	      );
	    }

	    /**
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isIPod',
	    value: function isIPod() {
	      return (/iPod/i.test(navigator.userAgent)
	      );
	    }

	    /**
	     * @method isBlackBerry
	     * @signature isBlackBerry()
	     * @description
	     *   [en]Returns whether the device is BlackBerry.[/en]
	     *   [ja]BlackBerry上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isBlackBerry',
	    value: function isBlackBerry() {
	      if (this._renderPlatform) {
	        return this._renderPlatform === 'blackberry';
	      } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
	        return (/BlackBerry/i.test(device.platform)
	        );
	      } else {
	        return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
	        );
	      }
	    }

	    /**
	     * @method isOpera
	     * @signature isOpera()
	     * @description
	     *   [en]Returns whether the browser is Opera.[/en]
	     *   [ja]Opera上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isOpera',
	    value: function isOpera() {
	      if (this._renderPlatform) {
	        return this._renderPlatform === 'opera';
	      } else {
	        return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
	      }
	    }

	    /**
	     * @method isFirefox
	     * @signature isFirefox()
	     * @description
	     *   [en]Returns whether the browser is Firefox.[/en]
	     *   [ja]Firefox上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isFirefox',
	    value: function isFirefox() {
	      if (this._renderPlatform) {
	        return this._renderPlatform === 'firefox';
	      } else {
	        return typeof InstallTrigger !== 'undefined';
	      }
	    }

	    /**
	     * @method isSafari
	     * @signature isSafari()
	     * @description
	     *   [en]Returns whether the browser is Safari.[/en]
	     *   [ja]Safari上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isSafari',
	    value: function isSafari() {
	      if (this._renderPlatform) {
	        return this._renderPlatform === 'safari';
	      } else {
	        return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
	      }
	    }

	    /**
	     * @method isChrome
	     * @signature isChrome()
	     * @description
	     *   [en]Returns whether the browser is Chrome.[/en]
	     *   [ja]Chrome上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isChrome',
	    value: function isChrome() {
	      if (this._renderPlatform) {
	        return this._renderPlatform === 'chrome';
	      } else {
	        return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
	      }
	    }

	    /**
	     * @method isIE
	     * @signature isIE()
	     * @description
	     *   [en]Returns whether the browser is Internet Explorer.[/en]
	     *   [ja]Internet Explorer上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isIE',
	    value: function isIE() {
	      if (this._renderPlatform) {
	        return this._renderPlatform === 'ie';
	      } else {
	        return false || !!document.documentMode;
	      }
	    }

	    /**
	     * @method isEdge
	     * @signature isEdge()
	     * @description
	     *   [en]Returns whether the browser is Edge.[/en]
	     *   [ja]Edge上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isEdge',
	    value: function isEdge() {
	      if (this._renderPlatform) {
	        return this._renderPlatform === 'edge';
	      } else {
	        return navigator.userAgent.indexOf(' Edge/') >= 0;
	      }
	    }

	    /**
	     * @method isIOS7above
	     * @signature isIOS7above()
	     * @description
	     *   [en]Returns whether the iOS version is 7 or above.[/en]
	     *   [ja]iOS7以上で実行されているかどうかを返します。[/ja]
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isIOS7above',
	    value: function isIOS7above() {
	      if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
	        return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
	        );
	      } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
	        var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
	        return parseInt(ver.split('.')[0]) >= 7;
	      }
	      return false;
	    }

	    /**
	     * @return {String}
	     */

	  }, {
	    key: 'getMobileOS',
	    value: function getMobileOS() {
	      if (this.isAndroid()) {
	        return 'android';
	      } else if (this.isIOS()) {
	        return 'ios';
	      } else if (this.isWP()) {
	        return 'wp';
	      } else {
	        return 'other';
	      }
	    }

	    /**
	     * @return {String}
	     */

	  }, {
	    key: 'getIOSDevice',
	    value: function getIOSDevice() {
	      if (this.isIPhone()) {
	        return 'iphone';
	      } else if (this.isIPad()) {
	        return 'ipad';
	      } else if (this.isIPod()) {
	        return 'ipod';
	      } else {
	        return 'na';
	      }
	    }
	  }]);
	  return Platform;
	}();

	var platform = new Platform();

	/**
	 * @object ons.notification
	 * @category dialog
	 * @codepen Qwwxyp
	 * @tutorial vanilla/Reference/dialog
	 * @description
	 *   [en]
	 *     Utility methods to create different kinds of alert dialogs. There are three methods available:
	 *
	 *     * `ons.notification.alert()`
	 *     * `ons.notification.confirm()`
	 *     * `ons.notification.prompt()`
	 *
	 *     It will automatically display a Material Design dialog on Android devices.
	 *   [/en]
	 *   [ja]いくつかの種類のアラートダイアログを作成するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
	 * @example
	 * ons.notification.alert('Hello, world!');
	 *
	 * ons.notification.confirm('Are you ready?')
	 *   .then(
	 *     function(answer) {
	 *       if (answer === 1) {
	 *         ons.notification.alert('Let\'s go!');
	 *       }
	 *     }
	 *   );
	 *
	 * ons.notification.prompt('How old are ?')
	 *   .then(
	 *     function(age) {
	 *       ons.notification.alert('You are ' + age + ' years old.');
	 *     }
	 *   );
	 */
	var notification = {};

	notification._createAlertDialog = function (title, message, buttonLabels, primaryButtonIndex, modifier, animation, id, _callback, messageIsHTML, cancelable, promptDialog, autofocus, placeholder, defaultValue, submitOnEnter, compile) {

	  compile = compile || function (object) {
	    return object;
	  };

	  var titleElementHTML = typeof title === 'string' ? '<div class="alert-dialog-title"></div>' : '';

	  var dialogElement = util.createElement('\n  <ons-alert-dialog>\n    ' + titleElementHTML + '\n    <div class="alert-dialog-content"></div>\n    <div class="alert-dialog-footer"></div>\n  </ons-alert-dialog>');

	  CustomElements.upgrade(dialogElement);

	  if (id) {
	    dialogElement.setAttribute('id', id);
	  }

	  var titleElement = dialogElement.querySelector('.alert-dialog-title');
	  var messageElement = dialogElement.querySelector('.alert-dialog-content');
	  var footerElement = dialogElement.querySelector('.alert-dialog-footer');
	  var inputElement = void 0;
	  var result = {};

	  result.promise = new Promise(function (resolve, reject) {
	    result.resolve = resolve;
	    result.reject = reject;
	  });

	  modifier = modifier || dialogElement.getAttribute('modifier');

	  if (typeof title === 'string') {
	    titleElement.textContent = title;
	  }

	  titleElement = null;

	  dialogElement.setAttribute('animation', animation);

	  if (messageIsHTML) {
	    messageElement.innerHTML = message;
	  } else {
	    messageElement.textContent = message;
	  }

	  if (promptDialog) {
	    inputElement = util.createElement('<input class="text-input text-input--underbar" type="text"></input>');

	    if (modifier) {
	      inputElement.classList.add('text-input--' + modifier);
	    }

	    inputElement.setAttribute('placeholder', placeholder);
	    inputElement.value = defaultValue;
	    inputElement.style.width = '100%';
	    inputElement.style.marginTop = '10px';

	    messageElement.appendChild(inputElement);

	    if (submitOnEnter) {
	      inputElement.addEventListener('keypress', function (event) {
	        if (event.keyCode === 13) {
	          dialogElement.hide({
	            callback: function callback() {
	              _callback(inputElement.value);
	              result.resolve(inputElement.value);
	              dialogElement.remove();
	              dialogElement = null;
	            }
	          });
	        }
	      }, false);
	    }
	  }

	  document.body.appendChild(dialogElement);

	  compile(dialogElement);

	  if (buttonLabels.length <= 2) {
	    footerElement.classList.add('alert-dialog-footer--one');
	  }

	  var createButton = function createButton(i) {
	    var buttonElement = util.createElement('<button class="alert-dialog-button"></button>');
	    buttonElement.appendChild(document.createTextNode(buttonLabels[i]));

	    if (i == primaryButtonIndex) {
	      buttonElement.classList.add('alert-dialog-button--primal');
	    }

	    if (buttonLabels.length <= 2) {
	      buttonElement.classList.add('alert-dialog-button--one');
	    }

	    var onClick = function onClick() {
	      buttonElement.removeEventListener('click', onClick, false);

	      dialogElement.hide({
	        callback: function callback() {
	          if (promptDialog) {
	            _callback(inputElement.value);
	            result.resolve(inputElement.value);
	          } else {
	            _callback(i);
	            result.resolve(i);
	          }
	          dialogElement.remove();
	          dialogElement = inputElement = buttonElement = null;
	        }
	      });
	    };

	    buttonElement.addEventListener('click', onClick, false);
	    footerElement.appendChild(buttonElement);
	  };

	  for (var i = 0; i < buttonLabels.length; i++) {
	    createButton(i);
	  }

	  if (cancelable) {
	    dialogElement.cancelable = true;
	    dialogElement.addEventListener('cancel', function () {
	      if (promptDialog) {
	        _callback(null);
	        result.reject(null);
	      } else {
	        _callback(-1);
	        result.reject(-1);
	      }
	      setTimeout(function () {
	        dialogElement.remove();
	        dialogElement = null;
	        inputElement = null;
	      });
	    }, false);
	  }

	  dialogElement.show({
	    callback: function callback() {
	      if (inputElement && promptDialog && autofocus) {
	        inputElement.focus();
	      }
	    }
	  });

	  messageElement = footerElement = null;

	  if (modifier) {
	    dialogElement.setAttribute('modifier', '');
	    dialogElement.setAttribute('modifier', modifier);
	  }

	  return result.promise;
	};

	notification._alertOriginal = function (message) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  typeof message === 'string' ? options.message = message : options = message;

	  var defaults = {
	    buttonLabel: '确定',
	    animation: 'default',
	    title: '',
	    callback: function callback() {}
	  };

	  options = util.extend({}, defaults, options);
	  if (!options.message && !options.messageHTML) {
	    throw new Error('Alert dialog must contain a message.');
	  }

	  return notification._createAlertDialog(options.title, options.message || options.messageHTML, [options.buttonLabel], 0, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, false, false, false, '', '', false, options.compile);
	};

	/**
	 * @method alert
	 * @signature alert(message [, options] | options)
	 * @return {Promise}
	 *   [en]Will resolve when the dialog is closed.[/en]
	 *   [ja][/ja]
	 * @param {String} message
	 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
	 *   [ja][/ja]
	 * @param {Object} options
	 *   [en]Parameter object.[/en]
	 *   [ja]オプションを指定するオブジェクトです。[/ja]
	 * @param {String} [options.message]
	 *   [en]Alert message.[/en]
	 *   [ja]アラートダイアログに表示する文字列を指定します。[/ja]
	 * @param {String} [options.messageHTML]
	 *   [en]Alert message in HTML.[/en]
	 *   [ja]アラートダイアログに表示するHTMLを指定します。[/ja]
	 * @param {String} [options.buttonLabel]
	 *   [en]Label for confirmation button. Default is `"OK"`.[/en]
	 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
	 * @param {String} [options.animation]
	 *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
	 *   [ja]アラートダイアログを表示する際のアニメーション名を指定します。"none", "fade", "slide"のいずれかを指定できます。[/ja]
	 * @param {String} [options.id]
	 *   [en]The `<ons-alert-dialog>` element's ID.[/en]
	 *   [ja]ons-alert-dialog要素のID。[/ja]
	 * @param {String} [options.title]
	 *   [en]Dialog title. Default is `"Alert"`.[/en]
	 *   [ja]アラートダイアログの上部に表示するタイトルを指定します。"Alert"がデフォルトです。[/ja]
	 * @param {String} [options.modifier]
	 *   [en]Modifier for the dialog.[/en]
	 *   [ja]アラートダイアログのmodifier属性の値を指定します。[/ja]
	 * @param {Function} [options.callback]
	 *   [en]Function that executes after dialog has been closed.[/en]
	 *   [ja]アラートダイアログが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
	 * @description
	 *   [en]
	 *     Display an alert dialog to show the user a message.
	 *
	 *     The content of the message can be either simple text or HTML.
	 *
	 *     It can be called in the following ways:
	 *
	 *     ```
	 *     ons.notification.alert(message, options);
	 *     ons.notification.alert(options);
	 *     ```
	 *
	 *     Must specify either `message` or `messageHTML`.
	 *   [/en]
	 *   [ja]
	 *     ユーザーへメッセージを見せるためのアラートダイアログを表示します。
	 *     表示するメッセージは、テキストかもしくはHTMLを指定できます。
	 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
	 *   [/ja]
	 */
	notification.alert = notification._alertOriginal;

	notification._confirmOriginal = function (message) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  typeof message === 'string' ? options.message = message : options = message;

	  var defaults = {
	    buttonLabels: ['取消', '确定'],
	    primaryButtonIndex: 1,
	    animation: 'default',
	    title: '',
	    callback: function callback() {},
	    cancelable: false
	  };

	  options = util.extend({}, defaults, options);

	  if (!options.message && !options.messageHTML) {
	    throw new Error('Confirm dialog must contain a message.');
	  }

	  return notification._createAlertDialog(options.title, options.message || options.messageHTML, options.buttonLabels, options.primaryButtonIndex, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, options.cancelable, false, false, '', '', false, options.compile);
	};

	/**
	 * @method confirm
	 * @signature confirm(message [, options] | options)
	 * @return {Promise}
	 *   [en]Will resolve to the index of the button that was pressed.[/en]
	 *   [ja][/ja]
	 * @param {String} message
	 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
	 *   [ja][/ja]
	 * @param {Object} options
	 *   [en]Parameter object.[/en]
	 * @param {String} [options.message]
	 *   [en]Confirmation question.[/en]
	 *   [ja]確認ダイアログに表示するメッセージを指定します。[/ja]
	 * @param {String} [options.messageHTML]
	 *   [en]Dialog content in HTML.[/en]
	 *   [ja]確認ダイアログに表示するHTMLを指定します。[/ja]
	 * @param {Array} [options.buttonLabels]
	 *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
	 *   [ja]ボタンのラベルの配列を指定します。["Cancel", "OK"]がデフォルトです。[/ja]
	 * @param {Number} [options.primaryButtonIndex]
	 *   [en]Index of primary button. Default is `1`.[/en]
	 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]
	 * @param {Boolean} [options.cancelable]
	 *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
	 *   [ja]ダイアログがキャンセル可能かどうかを指定します。[/ja]
	 * @param {String} [options.animation]
	 *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
	 *   [ja]アニメーション名を指定します。"none", "fade", "slide"のいずれかを指定します。[/ja]
	 * @param {String} [options.id]
	 *   [en]The `<ons-alert-dialog>` element's ID.[/en]
	 *   [ja]ons-alert-dialog要素のID。[/ja]
	 * @param {String} [options.title]
	 *   [en]Dialog title. Default is `"Confirm"`.[/en]
	 *   [ja]ダイアログのタイトルを指定します。"Confirm"がデフォルトです。[/ja]
	 * @param {String} [options.modifier]
	 *   [en]Modifier for the dialog.[/en]
	 *   [ja]ダイアログのmodifier属性の値を指定します。[/ja]
	 * @param {Function} [options.callback]
	 *   [en]
	 *     Function that executes after the dialog has been closed.
	 *     Argument for the function is the index of the button that was pressed or `-1` if the dialog was canceled.
	 *   [/en]
	 *   [ja]
	 *     ダイアログが閉じられた後に呼び出される関数オブジェクトを指定します。
	 *     この関数の引数として、押されたボタンのインデックス値が渡されます。
	 *     もしダイアログがキャンセルされた場合には-1が渡されます。
	 *   [/ja]
	 * @description
	 *   [en]
	 *     Display a dialog to ask the user for confirmation.
	 *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
	 *
	 *     It can be called in the following ways:
	 *
	 *     ```
	 *     ons.notification.confirm(message, options);
	 *     ons.notification.confirm(options);
	 *     ```
	 *
	 *     Must specify either `message` or `messageHTML`.
	 *   [/en]
	 *   [ja]
	 *     ユーザに確認を促すダイアログを表示します。
	 *     デオルとのボタンラベルは、"Cancel"と"OK"ですが、これはこのメソッドの引数でカスタマイズできます。
	 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
	 *   [/ja]
	 */
	notification.confirm = notification._confirmOriginal;

	notification._promptOriginal = function (message) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  typeof message === 'string' ? options.message = message : options = message;

	  var defaults = {
	    buttonLabel: '确定',
	    animation: 'default',
	    title: '',
	    defaultValue: '',
	    placeholder: '',
	    callback: function callback() {},
	    cancelable: false,
	    autofocus: true,
	    submitOnEnter: true
	  };

	  options = util.extend({}, defaults, options);
	  if (!options.message && !options.messageHTML) {
	    throw new Error('Prompt dialog must contain a message.');
	  }

	  return notification._createAlertDialog(options.title, options.message || options.messageHTML, [options.buttonLabel], 0, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, options.cancelable, true, options.autofocus, options.placeholder, options.defaultValue, options.submitOnEnter, options.compile);
	};

	/**
	 * @method prompt
	 * @signature prompt(message [, options] | options)
	 * @param {String} message
	 *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
	 *   [ja][/ja]
	 * @return {Promise}
	 *   [en]Will resolve to the input value when the dialog is closed.[/en]
	 *   [ja][/ja]
	 * @param {Object} options
	 *   [en]Parameter object.[/en]
	 *   [ja]オプションを指定するオブジェクトです。[/ja]
	 * @param {String} [options.message]
	 *   [en]Prompt question.[/en]
	 *   [ja]ダイアログに表示するメッセージを指定します。[/ja]
	 * @param {String} [options.messageHTML]
	 *   [en]Dialog content in HTML.[/en]
	 *   [ja]ダイアログに表示するHTMLを指定します。[/ja]
	 * @param {String} [options.buttonLabel]
	 *   [en]Label for confirmation button. Default is `"OK"`.[/en]
	 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
	 * @param {Number} [options.primaryButtonIndex]
	 *   [en]Index of primary button. Default is `1`.[/en]
	 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]
	 * @param {Boolean} [options.cancelable]
	 *   [en]Whether the dialog is cancelable or not. Default is false. When the dialog is cancelable it will be closed if the user taps the background or presses the Android back button.[/en]
	 *   [ja]ダイアログがキャンセル可能かどうかを指定します。デフォルトは false です。[/ja]
	 * @param {String} [options.animation]
	 *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
	 *   [ja]アニメーション名を指定します。"none", "fade", "slide"のいずれかを指定します。[/ja]
	 * @param {String} [options.id]
	 *   [en]The `<ons-alert-dialog>` element's ID.[/en]
	 *   [ja]ons-alert-dialog要素のID。[/ja]
	 * @param {String} [options.title]
	 *   [en]Dialog title. Default is `"Alert"`.[/en]
	 *   [ja]ダイアログのタイトルを指定します。デフォルトは "Alert" です。[/ja]
	 * @param {String} [options.placeholder]
	 *   [en]Placeholder for the text input.[/en]
	 *   [ja]テキスト欄のプレースホルダに表示するテキストを指定します。[/ja]
	 * @param {String} [options.defaultValue]
	 *   [en]Default value for the text input.[/en]
	 *   [ja]テキスト欄のデフォルトの値を指定します。[/ja]
	 * @param {Boolean} [options.autofocus]
	 *   [en]Autofocus the input element. Default is `true`.[/en]
	 *   [ja]input要素に自動的にフォーカスするかどうかを指定します。デフォルトはtrueです。[/ja]
	 * @param {String} [options.modifier]
	 *   [en]Modifier for the dialog.[/en]
	 *   [ja]ダイアログのmodifier属性の値を指定します。[/ja]
	 * @param {Function} [options.callback]
	 *   [en]
	 *     Function that executes after the dialog has been closed.
	 *     Argument for the function is the value of the input field or `null` if the dialog was canceled.
	 *   [/en]
	 *   [ja]
	 *     ダイアログが閉じられた後に実行される関数オブジェクトを指定します。
	 *     関数の引数として、インプット要素の中の値が渡されます。ダイアログがキャンセルされた場合には、nullが渡されます。
	 *   [/ja]
	 * @param {Boolean} [options.submitOnEnter]
	 *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
	 *   [ja]Enterが押された際にそのformをsubmitするかどうかを指定します。デフォルトはtrueです。[/ja]
	 * @description
	 *   [en]
	 *     Display a dialog with a prompt to ask the user a question.
	 *
	 *     It can be called in the following ways:
	 *
	 *     ```
	 *     ons.notification.prompt(message, options);
	 *     ons.notification.prompt(options);
	 *     ```
	 *
	 *     Must specify either `message` or `messageHTML`.
	 *   [/en]
	 *   [ja]
	 *     ユーザーに入力を促すダイアログを表示します。
	 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
	 *   [/ja]
	 */
	notification.prompt = notification._promptOriginal;

	var pageAttributeExpression = {
	  _variables: {},

	  /**
	   * Define a variable.
	   *
	   * @param {String} name Name of the variable
	   * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
	   * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
	   */
	  defineVariable: function defineVariable(name, value) {
	    var overwrite = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	    if (typeof name !== 'string') {
	      throw new Error('Variable name must be a string.');
	    } else if (typeof value !== 'string' && typeof value !== 'function') {
	      throw new Error('Variable value must be a string or a function.');
	    } else if (this._variables.hasOwnProperty(name) && !overwrite) {
	      throw new Error('"' + name + '" is already defined.');
	    }
	    this._variables[name] = value;
	  },

	  /**
	   * Get a variable.
	   *
	   * @param {String} name Name of the variable.
	   * @return {String|Function|null}
	   */
	  getVariable: function getVariable(name) {
	    if (!this._variables.hasOwnProperty(name)) {
	      return null;
	    }

	    return this._variables[name];
	  },

	  /**
	   * Remove a variable.
	   *
	   * @param {String} name Name of the varaible.
	   */
	  removeVariable: function removeVariable(name) {
	    delete this._variables[name];
	  },

	  /**
	   * Get all variables.
	   *
	   * @return {Object}
	   */
	  getAllVariables: function getAllVariables() {
	    return this._variables;
	  },
	  _parsePart: function _parsePart(part) {
	    var c = void 0,
	        inInterpolation = false,
	        currentIndex = 0;

	    var tokens = [];

	    if (part.length === 0) {
	      throw new Error('Unable to parse empty string.');
	    }

	    for (var i = 0; i < part.length; i++) {
	      c = part.charAt(i);

	      if (c === '$' && part.charAt(i + 1) === '{') {
	        if (inInterpolation) {
	          throw new Error('Nested interpolation not supported.');
	        }

	        var token = part.substring(currentIndex, i);
	        if (token.length > 0) {
	          tokens.push(part.substring(currentIndex, i));
	        }

	        currentIndex = i;
	        inInterpolation = true;
	      } else if (c === '}') {
	        if (!inInterpolation) {
	          throw new Error('} must be preceeded by ${');
	        }

	        var _token = part.substring(currentIndex, i + 1);
	        if (_token.length > 0) {
	          tokens.push(part.substring(currentIndex, i + 1));
	        }

	        currentIndex = i + 1;
	        inInterpolation = false;
	      }
	    }

	    if (inInterpolation) {
	      throw new Error('Unterminated interpolation.');
	    }

	    tokens.push(part.substring(currentIndex, part.length));

	    return tokens;
	  },
	  _replaceToken: function _replaceToken(token) {
	    var re = /^\${(.*?)}$/,
	        match = token.match(re);

	    if (match) {
	      var name = match[1].trim();
	      var variable = this.getVariable(name);

	      if (variable === null) {
	        throw new Error('Variable "' + name + '" does not exist.');
	      } else if (typeof variable === 'string') {
	        return variable;
	      } else {
	        var rv = variable();

	        if (typeof rv !== 'string') {
	          throw new Error('Must return a string.');
	        }

	        return rv;
	      }
	    } else {
	      return token;
	    }
	  },
	  _replaceTokens: function _replaceTokens(tokens) {
	    return tokens.map(this._replaceToken.bind(this));
	  },
	  _parseExpression: function _parseExpression(expression) {
	    return expression.split(',').map(function (part) {
	      return part.trim();
	    }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
	      return part.join('');
	    });
	  },

	  /**
	   * Evaluate an expression.
	   *
	   * @param {String} expression An page attribute expression.
	   * @return {Array}
	   */
	  evaluate: function evaluate(expression) {
	    if (!expression) {
	      return [];
	    }

	    return this._parseExpression(expression);
	  }
	};

	// Define default variables.
	pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
	pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
	pageAttributeExpression.defineVariable('runtime', function () {
	  return platform.isWebView() ? 'cordova' : 'browser';
	});

	var internal = {};

	internal.config = {
	  autoStatusBarFill: true,
	  animationsDisabled: false
	};

	internal.nullElement = window.document.createElement('div');

	/**
	 * @return {Boolean}
	 */
	internal.isEnabledAutoStatusBarFill = function () {
	  return !!internal.config.autoStatusBarFill;
	};

	/**
	 * @param {String} html
	 * @return {String}
	 */
	internal.normalizePageHTML = function (html) {
	  html = ('' + html).trim();

	  if (!html.match(/^<ons-page/)) {
	    html = '<ons-page _muted>' + html + '</ons-page>';
	  }

	  return html;
	};

	internal.waitDOMContentLoaded = function (callback) {
	  if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
	    window.document.addEventListener('DOMContentLoaded', callback);
	  } else {
	    setImmediate(callback);
	  }
	};

	internal.autoStatusBarFill = function (action) {
	  var onReady = function onReady() {
	    if (internal.shouldFillStatusBar()) {
	      action();
	    }
	    document.removeEventListener('deviceready', onReady);
	    document.removeEventListener('DOMContentLoaded', onReady);
	  };

	  if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
	    document.addEventListener('deviceready', onReady);
	  } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
	    document.addEventListener('DOMContentLoaded', function () {
	      onReady();
	    });
	  } else {
	    onReady();
	  }
	};

	internal.shouldFillStatusBar = function () {
	  return internal.isEnabledAutoStatusBarFill() && platform.isWebView() && platform.isIOS7above();
	};

	internal.templateStore = {
	  _storage: {},

	  /**
	   * @param {String} key
	   * @return {String/null} template
	   */
	  get: function get(key) {
	    return internal.templateStore._storage[key] || null;
	  },


	  /**
	   * @param {String} key
	   * @param {String} template
	   */
	  set: function set(key, template) {
	    internal.templateStore._storage[key] = template;
	  }
	};

	window.document.addEventListener('_templateloaded', function (e) {
	  if (e.target.nodeName.toLowerCase() === 'ons-template') {
	    internal.templateStore.set(e.templateId, e.template);
	  }
	}, false);

	window.document.addEventListener('DOMContentLoaded', function () {
	  register('script[type="text/ons-template"]');
	  register('script[type="text/template"]');
	  register('script[type="text/ng-template"]');

	  function register(query) {
	    var templates = window.document.querySelectorAll(query);
	    for (var i = 0; i < templates.length; i++) {
	      internal.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent);
	    }
	  }
	}, false);

	/**
	 * @param {String} page
	 * @return {Promise}
	 */
	internal.getTemplateHTMLAsync = function (page) {
	  return new Promise(function (resolve, reject) {
	    setImmediate(function () {
	      var cache = internal.templateStore.get(page);

	      if (cache) {
	        var html = typeof cache === 'string' ? cache : cache[1];
	        resolve(html);
	      } else {
	        (function () {
	          var xhr = new XMLHttpRequest();
	          xhr.open('GET', page, true);
	          xhr.onload = function (response) {
	            var html = xhr.responseText;
	            if (xhr.status >= 400 && xhr.status < 600) {
	              reject(html);
	            } else {
	              resolve(html);
	            }
	          };
	          xhr.onerror = function () {
	            throw new Error('The page is not found: ' + page);
	          };
	          xhr.send(null);
	        })();
	      }
	    });
	  });
	};

	/**
	 * @param {String} page
	 * @return {Promise}
	 */
	internal.getPageHTMLAsync = function (page) {
	  var pages = pageAttributeExpression.evaluate(page);

	  var getPage = function getPage(page) {
	    if (typeof page !== 'string') {
	      return Promise.reject('Must specify a page.');
	    }

	    return internal.getTemplateHTMLAsync(page).then(function (html) {
	      return internal.normalizePageHTML(html);
	    }, function (error) {
	      if (pages.length === 0) {
	        return Promise.reject(error);
	      }

	      return getPage(pages.shift());
	    }).then(function (html) {
	      return internal.normalizePageHTML(html);
	    });
	  };

	  return getPage(pages.shift());
	};

	var AnimatorFactory = function () {

	  /**
	   * @param {Object} opts
	   * @param {Object} opts.animators The dictionary for animator classes
	   * @param {Function} opts.baseClass The base class of animators
	   * @param {String} [opts.baseClassName] The name of the base class of animators
	   * @param {String} [opts.defaultAnimation] The default animation name
	   * @param {Object} [opts.defaultAnimationOptions] The default animation options
	   */

	  function AnimatorFactory(opts) {
	    babelHelpers.classCallCheck(this, AnimatorFactory);

	    this._animators = opts.animators;
	    this._baseClass = opts.baseClass;
	    this._baseClassName = opts.baseClassName || opts.baseClass.name;
	    this._animation = opts.defaultAnimation || 'default';
	    this._animationOptions = opts.defaultAnimationOptions || {};

	    if (!this._animators[this._animation]) {
	      throw new Error('No such animation: ' + this._animation);
	    }
	  }

	  /**
	   * @param {String} jsonString
	   * @return {Object/null}
	   */


	  babelHelpers.createClass(AnimatorFactory, [{
	    key: 'setAnimationOptions',


	    /**
	     * @param {Object} options
	     */
	    value: function setAnimationOptions(options) {
	      this._animationOptions = options;
	    }

	    /**
	     * @param {Object} options
	     * @param {String} [options.animation] The animation name
	     * @param {Object} [options.animationOptions] The animation options
	     * @param {Object} defaultAnimator The default animator instance
	     * @return {Object} An animator instance
	     */

	  }, {
	    key: 'newAnimator',
	    value: function newAnimator() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	      var defaultAnimator = arguments[1];


	      var animator = null;

	      if (options.animation instanceof this._baseClass) {
	        return options.animation;
	      }

	      var Animator = null;

	      if (typeof options.animation === 'string') {
	        Animator = this._animators[options.animation];
	      }

	      if (!Animator && defaultAnimator) {
	        animator = defaultAnimator;
	      } else {
	        Animator = Animator || this._animators[this._animation];

	        var animationOpts = util.extend({}, this._animationOptions, options.animationOptions || {}, internal.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

	        animator = new Animator(animationOpts);

	        if (typeof animator === 'function') {
	          animator = new animator(animationOpts); // eslint-disable-line new-cap
	        }
	      }

	      if (!(animator instanceof this._baseClass)) {
	        throw new Error('"animator" is not an instance of ' + this._baseClassName + '.');
	      }

	      return animator;
	    }
	  }], [{
	    key: 'parseAnimationOptionsString',
	    value: function parseAnimationOptionsString(jsonString) {
	      try {
	        if (typeof jsonString === 'string') {
	          var result = util.animationOptionsParse(jsonString);
	          if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) === 'object' && result !== null) {
	            return result;
	          } else {
	            console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
	          }
	        }
	        return {};
	      } catch (e) {
	        console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
	        return {};
	      }
	    }
	  }]);
	  return AnimatorFactory;
	}();

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	var ModifierUtil = function () {
	  function ModifierUtil() {
	    babelHelpers.classCallCheck(this, ModifierUtil);
	  }

	  babelHelpers.createClass(ModifierUtil, null, [{
	    key: 'diff',

	    /**
	     * @param {String} last
	     * @param {String} current
	     */
	    value: function diff(last, current) {
	      last = makeDict(('' + last).trim());
	      current = makeDict(('' + current).trim());

	      var removed = Object.keys(last).reduce(function (result, token) {
	        if (!current[token]) {
	          result.push(token);
	        }
	        return result;
	      }, []);

	      var added = Object.keys(current).reduce(function (result, token) {
	        if (!last[token]) {
	          result.push(token);
	        }
	        return result;
	      }, []);

	      return { added: added, removed: removed };

	      function makeDict(modifier) {
	        var dict = {};
	        ModifierUtil.split(modifier).forEach(function (token) {
	          return dict[token] = token;
	        });
	        return dict;
	      }
	    }

	    /**
	     * @param {Object} diff
	     * @param {Object} classList
	     * @param {String} template
	     */

	  }, {
	    key: 'applyDiffToClassList',
	    value: function applyDiffToClassList(diff, classList, template) {
	      diff.added.map(function (modifier) {
	        return template.replace(/\*/g, modifier);
	      }).forEach(function (klass) {
	        return classList.add(klass);
	      });

	      diff.removed.map(function (modifier) {
	        return template.replace(/\*/g, modifier);
	      }).forEach(function (klass) {
	        return classList.remove(klass);
	      });
	    }

	    /**
	     * @param {Object} diff
	     * @param {HTMLElement} element
	     * @param {Object} scheme
	     */

	  }, {
	    key: 'applyDiffToElement',
	    value: function applyDiffToElement(diff, element, scheme) {
	      var matches = function matches(e, s) {
	        return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
	      };
	      for (var selector in scheme) {
	        if (scheme.hasOwnProperty(selector)) {
	          var targetElements = !selector || matches(element, selector) ? [element] : element.querySelectorAll(selector);
	          for (var i = 0; i < targetElements.length; i++) {
	            ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
	          }
	        }
	      }
	    }

	    /**
	     * @param {String} last
	     * @param {String} current
	     * @param {HTMLElement} element
	     * @param {Object} scheme
	     */

	  }, {
	    key: 'onModifierChanged',
	    value: function onModifierChanged(last, current, element, scheme) {
	      return ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
	    }

	    /**
	     * @param {HTMLElement} element
	     * @param {Object} scheme
	     */

	  }, {
	    key: 'initModifier',
	    value: function initModifier(element, scheme) {
	      var modifier = element.getAttribute('modifier');
	      if (typeof modifier !== 'string') {
	        return;
	      }

	      ModifierUtil.applyDiffToElement({
	        removed: [],
	        added: ModifierUtil.split(modifier)
	      }, element, scheme);
	    }
	  }, {
	    key: 'split',
	    value: function split(modifier) {
	      if (typeof modifier !== 'string') {
	        return [];
	      }

	      return modifier.trim().split(/ +/).filter(function (token) {
	        return token !== '';
	      });
	    }
	  }]);
	  return ModifierUtil;
	}();

	var LazyRepeatDelegate = function () {
	  function LazyRepeatDelegate(userDelegate) {
	    var templateElement = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    babelHelpers.classCallCheck(this, LazyRepeatDelegate);

	    if ((typeof userDelegate === 'undefined' ? 'undefined' : babelHelpers.typeof(userDelegate)) !== 'object' || userDelegate === null) {
	      throw Error('"delegate" parameter must be an object.');
	    }
	    this._userDelegate = userDelegate;

	    if (!(templateElement instanceof Element) && templateElement !== null) {
	      throw Error('"templateElement" parameter must be an instance of Element or null.');
	    }
	    this._templateElement = templateElement;
	  }

	  babelHelpers.createClass(LazyRepeatDelegate, [{
	    key: 'hasRenderFunction',


	    /**
	     * @return {Boolean}
	     */
	    value: function hasRenderFunction() {
	      return this._userDelegate._render instanceof Function;
	    }

	    /**
	     * @return {void}
	     */

	  }, {
	    key: '_render',
	    value: function _render(items, height) {
	      this._userDelegate._render(items, height);
	    }

	    /**
	     * @param {Number} index
	     * @param {Element} parent
	     * @param {Function} done A function that take item object as parameter.
	     */

	  }, {
	    key: 'loadItemElement',
	    value: function loadItemElement(index, parent, done) {
	      if (this._userDelegate.loadItemElement instanceof Function) {
	        this._userDelegate.loadItemElement(index, parent, function (element) {
	          return done({ element: element });
	        });
	      } else {
	        var element = this._userDelegate.createItemContent(index, this._templateElement);
	        if (!(element instanceof Element)) {
	          throw Error('createItemContent() must return an instance of Element.');
	        }
	        parent.appendChild(element);
	        done({ element: element });
	      }
	    }

	    /**
	     * @return {Number}
	     */

	  }, {
	    key: 'countItems',
	    value: function countItems() {
	      var count = this._userDelegate.countItems();
	      if (typeof count !== 'number') {
	        throw Error('countItems() must return a number.');
	      }
	      return count;
	    }

	    /**
	     * @param {Number} index
	     * @param {Object} item
	     * @param {Element} item.element
	     */

	  }, {
	    key: 'updateItem',
	    value: function updateItem(index, item) {
	      if (this._userDelegate.updateItemContent instanceof Function) {
	        this._userDelegate.updateItemContent(index, item);
	      }
	    }

	    /**
	     * @return {Number}
	     */

	  }, {
	    key: 'calculateItemHeight',
	    value: function calculateItemHeight(index) {
	      if (this._userDelegate.calculateItemHeight instanceof Function) {
	        var height = this._userDelegate.calculateItemHeight(index);

	        if (typeof height !== 'number') {
	          throw Error('calculateItemHeight() must return a number.');
	        }

	        return height;
	      }

	      return 0;
	    }

	    /**
	     * @param {Number} index
	     * @param {Object} item
	     */

	  }, {
	    key: 'destroyItem',
	    value: function destroyItem(index, item) {
	      if (this._userDelegate.destroyItem instanceof Function) {
	        this._userDelegate.destroyItem(index, item);
	      }
	    }

	    /**
	     * @return {void}
	     */

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      if (this._userDelegate.destroy instanceof Function) {
	        this._userDelegate.destroy();
	      }

	      this._userDelegate = this._templateElement = null;
	    }
	  }, {
	    key: 'itemHeight',
	    get: function get() {
	      return this._userDelegate.itemHeight;
	    }
	  }]);
	  return LazyRepeatDelegate;
	}();

	/**
	 * This class provide core functions for ons-lazy-repeat.
	 */
	var LazyRepeatProvider = function () {

	  /**
	   * @param {Element} wrapperElement
	   * @param {LazyRepeatDelegate} delegate
	   */

	  function LazyRepeatProvider(wrapperElement, delegate) {
	    babelHelpers.classCallCheck(this, LazyRepeatProvider);

	    if (!(delegate instanceof LazyRepeatDelegate)) {
	      throw Error('"delegate" parameter must be an instance of LazyRepeatDelegate.');
	    }

	    this._wrapperElement = wrapperElement;
	    this._delegate = delegate;

	    if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
	      wrapperElement.classList.add('lazy-list');
	    }

	    this._pageContent = util.findParent(wrapperElement, '.page__content');

	    if (!this._pageContent) {
	      throw new Error('ons-lazy-repeat must be a descendant of an <ons-page> or an element.');
	    }

	    this._topPositions = [];
	    this._renderedItems = {};

	    if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {
	      this._unknownItemHeight = true;
	    }
	    this._addEventListeners();
	    this._onChange();
	  }

	  babelHelpers.createClass(LazyRepeatProvider, [{
	    key: '_checkItemHeight',
	    value: function _checkItemHeight(callback) {
	      var _this = this;

	      this._delegate.loadItemElement(0, this._wrapperElement, function (item) {
	        if (!_this._unknownItemHeight) {
	          throw Error('Invalid state');
	        }

	        var done = function done() {
	          _this._wrapperElement.removeChild(item.element);
	          delete _this._unknownItemHeight;
	          callback();
	        };

	        _this._itemHeight = item.element.offsetHeight;

	        if (_this._itemHeight > 0) {
	          done();
	          return;
	        }

	        // retry to measure offset height
	        // dirty fix for angular2 directive
	        var lastVisibility = _this._wrapperElement.style.visibility;
	        _this._wrapperElement.style.visibility = 'hidden';
	        item.element.style.visibility = 'hidden';

	        setImmediate(function () {
	          _this._itemHeight = item.element.offsetHeight;
	          if (_this._itemHeight == 0) {
	            throw Error('Invalid state: this._itemHeight must be greater than zero.');
	          }
	          _this._wrapperElement.style.visibility = lastVisibility;
	          done();
	        });
	      });
	    }
	  }, {
	    key: '_countItems',
	    value: function _countItems() {
	      return this._delegate.countItems();
	    }
	  }, {
	    key: '_getItemHeight',
	    value: function _getItemHeight(i) {
	      return this.staticItemHeight || this._delegate.calculateItemHeight(i);
	    }
	  }, {
	    key: '_onChange',
	    value: function _onChange() {
	      this._render();
	    }
	  }, {
	    key: 'refresh',
	    value: function refresh() {
	      this._removeAllElements();
	      this._onChange();
	    }
	  }, {
	    key: '_render',
	    value: function _render() {
	      var _this2 = this;

	      if (this._unknownItemHeight) {
	        return this._checkItemHeight(this._render.bind(this));
	      }

	      var items = this._getItemsInView();

	      if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
	        this._delegate._render(items, this._listHeight);
	        return null;
	      }

	      var keep = {};

	      items.forEach(function (item) {
	        _this2._renderElement(item);
	        keep[item.index] = true;
	      });

	      Object.keys(this._renderedItems).forEach(function (key) {
	        return keep[key] || _this2._removeElement(key);
	      });

	      this._wrapperElement.style.height = this._listHeight + 'px';
	    }

	    /**
	     * @param {Object} item
	     * @param {Number} item.index
	     * @param {Number} item.top
	     */

	  }, {
	    key: '_renderElement',
	    value: function _renderElement(_ref) {
	      var _this3 = this;

	      var index = _ref.index;
	      var top = _ref.top;

	      var item = this._renderedItems[index];
	      if (item) {
	        this._delegate.updateItem(index, item); // update if it exists
	        item.element.style.top = top + 'px';
	        return;
	      }

	      this._delegate.loadItemElement(index, this._wrapperElement, function (item) {
	        util.extend(item.element.style, {
	          position: 'absolute',
	          top: top + 'px',
	          left: 0,
	          right: 0
	        });

	        _this3._renderedItems[index] = item;
	      });
	    }

	    /**
	     * @param {Number} index
	     */

	  }, {
	    key: '_removeElement',
	    value: function _removeElement(index) {
	      var item = this._renderedItems[index];

	      this._delegate.destroyItem(index, item);

	      if (item.element.parentElement) {
	        item.element.parentElement.removeChild(item.element);
	      }

	      delete this._renderedItems[index];
	    }
	  }, {
	    key: '_removeAllElements',
	    value: function _removeAllElements() {
	      var _this4 = this;

	      Object.keys(this._renderedItems).forEach(function (key) {
	        return _this4._removeElement(key);
	      });
	    }
	  }, {
	    key: '_calculateStartIndex',
	    value: function _calculateStartIndex(current) {
	      var start = 0;
	      var end = this._itemCount - 1;

	      if (this.staticItemHeight) {
	        return parseInt(-current / this.staticItemHeight);
	      }

	      // Binary search for index at top of screen so we can speed up rendering.
	      for (;;) {
	        var middle = Math.floor((start + end) / 2);
	        var value = current + this._topPositions[middle];

	        if (end < start) {
	          return 0;
	        } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
	          return middle;
	        } else if (isNaN(value) || value >= 0) {
	          end = middle - 1;
	        } else {
	          start = middle + 1;
	        }
	      }
	    }
	  }, {
	    key: '_recalculateTopPositions',
	    value: function _recalculateTopPositions() {
	      var l = Math.min(this._topPositions.length, this._itemCount);
	      this._topPositions[0] = 0;
	      for (var i = 1, _l; i < _l; i++) {
	        this._topPositions[i] = this._topPositions[i - 1] + this._getItemHeight(i);
	      }
	    }
	  }, {
	    key: '_getItemsInView',
	    value: function _getItemsInView() {
	      var offset = this._wrapperElement.getBoundingClientRect().top;
	      var limit = 4 * window.innerHeight - offset;
	      var count = this._countItems();

	      if (count !== this._itemCount) {
	        this._itemCount = count;
	        this._recalculateTopPositions();
	      }

	      var i = Math.max(0, this._calculateStartIndex(offset) - 30);

	      var items = [];
	      for (var top = this._topPositions[i]; i < count && top < limit; i++) {
	        if (i >= this._topPositions.length) {
	          // perf optimization
	          this._topPositions.length += 100;
	        }

	        this._topPositions[i] = top;
	        items.push({ top: top, index: i });
	        top += this._getItemHeight(i);
	      }
	      this._listHeight = top;

	      return items;
	    }
	  }, {
	    key: '_debounce',
	    value: function _debounce(func, wait, immediate) {
	      var timeout = void 0;
	      return function () {
	        var _this5 = this,
	            _arguments = arguments;

	        var callNow = immediate && !timeout;
	        clearTimeout(timeout);
	        if (callNow) {
	          func.apply(this, arguments);
	        } else {
	          timeout = setTimeout(function () {
	            timeout = null;
	            func.apply(_this5, _arguments);
	          }, wait);
	        }
	      };
	    }
	  }, {
	    key: '_doubleFireOnTouchend',
	    value: function _doubleFireOnTouchend() {
	      this._render();
	      this._debounce(this._render.bind(this), 100);
	    }
	  }, {
	    key: '_addEventListeners',
	    value: function _addEventListeners() {
	      util.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

	      if (platform.isIOS()) {
	        this._boundOnChange = this._debounce(this._boundOnChange, 30);
	      }

	      this._pageContent.addEventListener('scroll', this._boundOnChange, true);

	      if (platform.isIOS()) {
	        this._pageContent.addEventListener('touchmove', this._boundOnChange, true);
	        this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
	      }

	      window.document.addEventListener('resize', this._boundOnChange, true);
	    }
	  }, {
	    key: '_removeEventListeners',
	    value: function _removeEventListeners() {
	      this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

	      if (platform.isIOS()) {
	        this._pageContent.removeEventListener('touchmove', this._boundOnChange, true);
	        this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
	      }

	      window.document.removeEventListener('resize', this._boundOnChange, true);
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this._removeAllElements();
	      this._delegate.destroy();
	      this._parentElement = this._delegate = this._renderedItems = null;
	      this._removeEventListeners();
	    }
	  }, {
	    key: 'staticItemHeight',
	    get: function get() {
	      return this._delegate.itemHeight || this._itemHeight;
	    }
	  }]);
	  return LazyRepeatProvider;
	}();

	internal.AnimatorFactory = AnimatorFactory;
	internal.ModifierUtil = ModifierUtil;
	internal.LazyRepeatProvider = LazyRepeatProvider;
	internal.LazyRepeatDelegate = LazyRepeatDelegate;

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	var create = function create() {

	  /**
	   * @object ons.orientation
	   * @category util
	   * @description
	   *   [en]Utility methods for orientation detection.[/en]
	   *   [ja]画面のオリエンテーション検知のためのユーティリティメソッドを収めているオブジェクトです。[/ja]
	   */
	  var obj = {
	    /**
	     * @event change
	     * @description
	     *   [en]Fired when the device orientation changes.[/en]
	     *   [ja]デバイスのオリエンテーションが変化した際に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクトです。[/ja]
	     * @param {Boolean} event.isPortrait
	     *   [en]Will be true if the current orientation is portrait mode.[/en]
	     *   [ja]現在のオリエンテーションがportraitの場合にtrueを返します。[/ja]
	     */

	    /**
	     * @method on
	     * @signature on(eventName, listener)
	     * @description
	     *   [en]Add an event listener.[/en]
	     *   [ja]イベントリスナーを追加します。[/ja]
	     * @param {String} eventName
	     *   [en]Name of the event.[/en]
	     *   [ja]イベント名を指定します。[/ja]
	     * @param {Function} listener
	     *   [en]Function to execute when the event is triggered.[/en]
	     *   [ja]このイベントが発火された際に呼び出される関数オブジェクトを指定します。[/ja]
	     */

	    /**
	     * @method once
	     * @signature once(eventName, listener)
	     * @description
	     *  [en]Add an event listener that's only triggered once.[/en]
	     *  [ja]一度だけ呼び出されるイベントリスナーを追加します。[/ja]
	     * @param {String} eventName
	     *   [en]Name of the event.[/en]
	     *   [ja]イベント名を指定します。[/ja]
	     * @param {Function} listener
	     *   [en]Function to execute when the event is triggered.[/en]
	     *   [ja]イベントが発火した際に呼び出される関数オブジェクトを指定します。[/ja]
	     */

	    /**
	     * @method off
	     * @signature off(eventName, [listener])
	     * @description
	     *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
	     *  [ja]イベントリスナーを削除します。もしイベントリスナーを指定しなかった場合には、そのイベントに紐づく全てのイベントリスナーが削除されます。[/ja]
	     * @param {String} eventName
	     *   [en]Name of the event.[/en]
	     *   [ja]イベント名を指定します。[/ja]
	     * @param {Function} listener
	     *   [en]Function to execute when the event is triggered.[/en]
	     *   [ja]削除するイベントリスナーを指定します。[/ja]
	     */

	    // actual implementation to detect if whether current screen is portrait or not
	    _isPortrait: false,

	    /**
	     * @method isPortrait
	     * @signature isPortrait()
	     * @return {Boolean}
	     *   [en]Will be true if the current orientation is portrait mode.[/en]
	     *   [ja]オリエンテーションがportraitモードの場合にtrueになります。[/ja]
	     * @description
	     *   [en]Returns whether the current screen orientation is portrait or not.[/en]
	     *   [ja]オリエンテーションがportraitモードかどうかを返します。[/ja]
	     */
	    isPortrait: function isPortrait() {
	      return this._isPortrait();
	    },

	    /**
	     * @method isLandscape
	     * @signature isLandscape()
	     * @return {Boolean}
	     *   [en]Will be true if the current orientation is landscape mode.[/en]
	     *   [ja]オリエンテーションがlandscapeモードの場合にtrueになります。[/ja]
	     * @description
	     *   [en]Returns whether the current screen orientation is landscape or not.[/en]
	     *   [ja]オリエンテーションがlandscapeモードかどうかを返します。[/ja]
	     */
	    isLandscape: function isLandscape() {
	      return !this.isPortrait();
	    },

	    _init: function _init() {
	      document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

	      if ('orientation' in window) {
	        window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
	      } else {
	        window.addEventListener('resize', this._onResize.bind(this), false);
	      }

	      this._isPortrait = function () {
	        return window.innerHeight > window.innerWidth;
	      };

	      return this;
	    },

	    _onDOMContentLoaded: function _onDOMContentLoaded() {
	      this._installIsPortraitImplementation();
	      this.emit('change', { isPortrait: this.isPortrait() });
	    },

	    _installIsPortraitImplementation: function _installIsPortraitImplementation() {
	      var isPortrait = window.innerWidth < window.innerHeight;

	      if (!('orientation' in window)) {
	        this._isPortrait = function () {
	          return window.innerHeight > window.innerWidth;
	        };
	      } else if (window.orientation % 180 === 0) {
	        this._isPortrait = function () {
	          return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
	        };
	      } else {
	        this._isPortrait = function () {
	          return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
	        };
	      }
	    },

	    _onOrientationChange: function _onOrientationChange() {
	      var _this = this;

	      var isPortrait = this._isPortrait();

	      // Wait for the dimensions to change because
	      // of Android inconsistency.
	      var nIter = 0;
	      var interval = setInterval(function () {
	        nIter++;

	        var w = window.innerWidth;
	        var h = window.innerHeight;

	        if (isPortrait && w <= h || !isPortrait && w >= h) {
	          _this.emit('change', { isPortrait: isPortrait });
	          clearInterval(interval);
	        } else if (nIter === 50) {
	          _this.emit('change', { isPortrait: isPortrait });
	          clearInterval(interval);
	        }
	      }, 20);
	    },

	    // Run on not mobile browser.
	    _onResize: function _onResize() {
	      this.emit('change', { isPortrait: this.isPortrait() });
	    }
	  };

	  MicroEvent.mixin(obj);

	  return obj;
	};

	var orientation = create()._init();

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	var softwareKeyboard = new MicroEvent();
	softwareKeyboard._visible = false;

	var onShow = function onShow() {
	  softwareKeyboard._visible = true;
	  softwareKeyboard.emit('show');
	};

	var onHide = function onHide() {
	  softwareKeyboard._visible = false;
	  softwareKeyboard.emit('hide');
	};

	var bindEvents = function bindEvents() {
	  if (typeof Keyboard !== 'undefined') {
	    // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
	    Keyboard.onshow = onShow;
	    Keyboard.onhide = onHide;
	    softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

	    return true;
	  } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
	    // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
	    window.addEventListener('native.keyboardshow', onShow);
	    window.addEventListener('native.keyboardhide', onHide);
	    softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

	    return true;
	  }

	  return false;
	};

	var noPluginError = function noPluginError() {
	  console.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
	};

	document.addEventListener('deviceready', function () {
	  if (!bindEvents()) {
	    if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
	      noPluginError();
	    }

	    softwareKeyboard.on = noPluginError;
	  }
	});

	var util$1 = {
	  _ready: false,

	  _domContentLoaded: false,

	  _onDOMContentLoaded: function _onDOMContentLoaded() {
	    util$1._domContentLoaded = true;

	    if (platform.isWebView()) {
	      window.document.addEventListener('deviceready', function () {
	        util$1._ready = true;
	      }, false);
	    } else {
	      util$1._ready = true;
	    }
	  },

	  addBackButtonListener: function addBackButtonListener(fn) {
	    if (!this._domContentLoaded) {
	      throw new Error('This method is available after DOMContentLoaded');
	    }

	    if (this._ready) {
	      window.document.addEventListener('backbutton', fn, false);
	    } else {
	      window.document.addEventListener('deviceready', function () {
	        window.document.addEventListener('backbutton', fn, false);
	      });
	    }
	  },

	  removeBackButtonListener: function removeBackButtonListener(fn) {
	    if (!this._domContentLoaded) {
	      throw new Error('This method is available after DOMContentLoaded');
	    }

	    if (this._ready) {
	      window.document.removeEventListener('backbutton', fn, false);
	    } else {
	      window.document.addEventListener('deviceready', function () {
	        window.document.removeEventListener('backbutton', fn, false);
	      });
	    }
	  }
	};
	window.addEventListener('DOMContentLoaded', function () {
	  return util$1._onDOMContentLoaded();
	}, false);

	var HandlerRepository = {
	  _store: {},

	  _genId: function () {
	    var i = 0;
	    return function () {
	      return i++;
	    };
	  }(),

	  set: function set(element, handler) {
	    if (element.dataset.deviceBackButtonHandlerId) {
	      this.remove(element);
	    }
	    var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
	    this._store[id] = handler;
	  },

	  remove: function remove(element) {
	    if (element.dataset.deviceBackButtonHandlerId) {
	      delete this._store[element.dataset.deviceBackButtonHandlerId];
	      delete element.dataset.deviceBackButtonHandlerId;
	    }
	  },

	  get: function get(element) {
	    if (!element.dataset.deviceBackButtonHandlerId) {
	      return undefined;
	    }

	    var id = element.dataset.deviceBackButtonHandlerId;

	    if (!this._store[id]) {
	      throw new Error();
	    }

	    return this._store[id];
	  },

	  has: function has(element) {
	    if (!element.dataset) {
	      return false;
	    }

	    var id = element.dataset.deviceBackButtonHandlerId;

	    return !!this._store[id];
	  }
	};

	var DeviceBackButtonDispatcher = function () {
	  function DeviceBackButtonDispatcher() {
	    babelHelpers.classCallCheck(this, DeviceBackButtonDispatcher);

	    this._isEnabled = false;
	    this._boundCallback = this._callback.bind(this);
	  }

	  /**
	   * Enable to handle 'backbutton' events.
	   */


	  babelHelpers.createClass(DeviceBackButtonDispatcher, [{
	    key: 'enable',
	    value: function enable() {
	      if (!this._isEnabled) {
	        util$1.addBackButtonListener(this._boundCallback);
	        this._isEnabled = true;
	      }
	    }

	    /**
	     * Disable to handle 'backbutton' events.
	     */

	  }, {
	    key: 'disable',
	    value: function disable() {
	      if (this._isEnabled) {
	        util$1.removeBackButtonListener(this._boundCallback);
	        this._isEnabled = false;
	      }
	    }

	    /**
	     * Fire a 'backbutton' event manually.
	     */

	  }, {
	    key: 'fireDeviceBackButtonEvent',
	    value: function fireDeviceBackButtonEvent() {
	      var event = document.createEvent('Event');
	      event.initEvent('backbutton', true, true);
	      document.dispatchEvent(event);
	    }
	  }, {
	    key: '_callback',
	    value: function _callback() {
	      this._dispatchDeviceBackButtonEvent();
	    }

	    /**
	     * @param {HTMLElement} element
	     * @param {Function} callback
	     */

	  }, {
	    key: 'createHandler',
	    value: function createHandler(element, callback) {
	      if (!(element instanceof HTMLElement)) {
	        throw new Error('element must be an instance of HTMLElement');
	      }

	      if (!(callback instanceof Function)) {
	        throw new Error('callback must be an instance of Function');
	      }

	      var handler = {
	        _callback: callback,
	        _element: element,

	        disable: function disable() {
	          HandlerRepository.remove(element);
	        },

	        setListener: function setListener(callback) {
	          this._callback = callback;
	        },

	        enable: function enable() {
	          HandlerRepository.set(element, this);
	        },

	        isEnabled: function isEnabled() {
	          return HandlerRepository.get(element) === this;
	        },

	        destroy: function destroy() {
	          HandlerRepository.remove(element);
	          this._callback = this._element = null;
	        }
	      };

	      handler.enable();

	      return handler;
	    }
	  }, {
	    key: '_dispatchDeviceBackButtonEvent',
	    value: function _dispatchDeviceBackButtonEvent() {
	      var tree = this._captureTree();

	      var element = this._findHandlerLeafElement(tree);

	      var handler = HandlerRepository.get(element);
	      handler._callback(createEvent(element));

	      function createEvent(element) {
	        return {
	          _element: element,
	          callParentHandler: function callParentHandler() {
	            var parent = this._element.parentNode;

	            while (parent) {
	              handler = HandlerRepository.get(parent);
	              if (handler) {
	                return handler._callback(createEvent(parent));
	              }
	              parent = parent.parentNode;
	            }
	          }
	        };
	      }
	    }

	    /**
	     * @return {Object}
	     */

	  }, {
	    key: '_captureTree',
	    value: function _captureTree() {
	      return createTree(document.body);

	      function createTree(element) {
	        return {
	          element: element,
	          children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

	            if (childElement.style.display === 'none') {
	              return [];
	            }

	            if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
	              return [];
	            }

	            var result = createTree(childElement);

	            if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
	              return [];
	            }

	            return [result];
	          }))
	        };
	      }

	      function arrayOf(target) {
	        var result = [];
	        for (var i = 0; i < target.length; i++) {
	          result.push(target[i]);
	        }
	        return result;
	      }
	    }

	    /**
	     * @param {Object} tree
	     * @return {HTMLElement}
	     */

	  }, {
	    key: '_findHandlerLeafElement',
	    value: function _findHandlerLeafElement(tree) {
	      return find(tree);

	      function find(node) {
	        if (node.children.length === 0) {
	          return node.element;
	        }

	        if (node.children.length === 1) {
	          return find(node.children[0]);
	        }

	        return node.children.map(function (childNode) {
	          return childNode.element;
	        }).reduce(function (left, right) {
	          if (!left) {
	            return right;
	          }

	          var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
	          var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

	          if (!isNaN(leftZ) && !isNaN(rightZ)) {
	            return leftZ > rightZ ? left : right;
	          }

	          throw new Error('Capturing backbutton-handler is failure.');
	        }, null);
	      }
	    }
	  }]);
	  return DeviceBackButtonDispatcher;
	}();

	var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

	//屏蔽onsen自动转换样式主题
	var autoStyleEnabled = false;
	// let autoStyleEnabled = true;

	// Modifiers
	var modifiersMap = {
	  'quiet': 'material--flat',
	  'light': 'material--flat',
	  'outline': 'material--flat',
	  'cta': '',
	  'large--quiet': 'material--flat large',
	  'large--cta': 'large',
	  'noborder': '',
	  'chevron': '',
	  'tappable': ''
	};

	var platforms = {};

	platforms.android = function (element) {

	  if (!/ons-fab|ons-speed-dial|ons-progress/.test(element.tagName.toLowerCase()) && !/material/.test(element.getAttribute('modifier'))) {

	    var oldModifier = element.getAttribute('modifier') || '';

	    var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
	      return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
	    });
	    newModifier.unshift('material');

	    element.setAttribute('modifier', newModifier.join(' ').trim());
	  }

	  // Effects
	  if (/ons-button|ons-list-item|ons-fab|ons-speed-dial|ons-tab$/.test(element.tagName.toLowerCase()) && !element.hasAttribute('ripple') && !util.findChild(element, 'ons-ripple')) {

	    if (element.tagName.toLowerCase() === 'ons-list-item') {
	      if (element.hasAttribute('tappable')) {
	        element.setAttribute('ripple', '');
	        element.removeAttribute('tappable');
	      }
	    } else {
	      element.setAttribute('ripple', '');
	    }
	  }
	};

	platforms.ios = function (element) {

	  // Modifiers
	  if (/material/.test(element.getAttribute('modifier'))) {
	    util.removeModifier(element, 'material');

	    if (util.removeModifier(element, 'material--flat')) {
	      util.addModifier(element, util.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
	    }

	    if (!element.getAttribute('modifier')) {
	      element.removeAttribute('modifier');
	    }
	  }

	  // Effects
	  if (element.hasAttribute('ripple')) {
	    if (element.tagName.toLowerCase() === 'ons-list-item') {
	      element.setAttribute('tappable', '');
	    }

	    element.removeAttribute('ripple');
	  }
	};

	var unlocked = {
	  android: true
	};

	var prepareAutoStyle = function prepareAutoStyle(element, force) {
	  if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
	    var mobileOS = platform.getMobileOS();
	    if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
	      platforms[mobileOS](element);
	    }
	  }
	};

	var autoStyle = {
	  isEnabled: function isEnabled() {
	    return autoStyleEnabled;
	  },
	  enable: function enable() {
	    return autoStyleEnabled = true;
	  },
	  disable: function disable() {
	    return autoStyleEnabled = false;
	  },
	  prepare: prepareAutoStyle
	};

	var generateId = function () {
	  var i = 0;
	  return function () {
	    return i++;
	  };
	}();

	/**
	 * Door locking system.
	 *
	 * @param {Object} [options]
	 * @param {Function} [options.log]
	 */

	var DoorLock = function () {
	  function DoorLock() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    babelHelpers.classCallCheck(this, DoorLock);

	    this._lockList = [];
	    this._waitList = [];
	    this._log = options.log || function () {};
	  }

	  /**
	   * Register a lock.
	   *
	   * @return {Function} Callback for unlocking.
	   */


	  babelHelpers.createClass(DoorLock, [{
	    key: 'lock',
	    value: function lock() {
	      var _this = this;

	      var unlock = function unlock() {
	        _this._unlock(unlock);
	      };
	      unlock.id = generateId();
	      this._lockList.push(unlock);
	      this._log('lock: ' + unlock.id);

	      return unlock;
	    }
	  }, {
	    key: '_unlock',
	    value: function _unlock(fn) {
	      var index = this._lockList.indexOf(fn);
	      if (index === -1) {
	        throw new Error('This function is not registered in the lock list.');
	      }

	      this._lockList.splice(index, 1);
	      this._log('unlock: ' + fn.id);

	      this._tryToFreeWaitList();
	    }
	  }, {
	    key: '_tryToFreeWaitList',
	    value: function _tryToFreeWaitList() {
	      while (!this.isLocked() && this._waitList.length > 0) {
	        this._waitList.shift()();
	      }
	    }

	    /**
	     * Register a callback for waiting unlocked door.
	     *
	     * @params {Function} callback Callback on unlocking the door completely.
	     */

	  }, {
	    key: 'waitUnlock',
	    value: function waitUnlock(callback) {
	      if (!(callback instanceof Function)) {
	        throw new Error('The callback param must be a function.');
	      }

	      if (this.isLocked()) {
	        this._waitList.push(callback);
	      } else {
	        callback();
	      }
	    }

	    /**
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isLocked',
	    value: function isLocked() {
	      return this._lockList.length > 0;
	    }
	  }]);
	  return DoorLock;
	}();

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/
	var readyMap = new WeakMap();
	var queueMap = new WeakMap();

	function isContentReady(element) {
	  if (element.childNodes.length > 0) {
	    setContentReady(element);
	  }
	  return readyMap.has(element);
	}

	function setContentReady(element) {
	  readyMap.set(element, true);
	}

	function addCallback(element, fn) {
	  if (!queueMap.has(element)) {
	    queueMap.set(element, []);
	  }
	  queueMap.get(element).push(fn);
	}

	function consumeQueue(element) {
	  var callbacks = queueMap.get(element, []) || [];
	  queueMap.delete(element);
	  callbacks.forEach(function (callback) {
	    return callback();
	  });
	}

	function contentReady(element, fn) {
	  addCallback(element, fn);

	  if (isContentReady(element)) {
	    consumeQueue(element);
	    return;
	  }

	  var observer = new MutationObserver(function (changes) {
	    setContentReady(element);
	    consumeQueue(element);
	  });
	  observer.observe(element, { childList: true, characterData: true });

	  // failback for elements has empty content.
	  setImmediate(function () {
	    setContentReady(element);
	    consumeQueue(element);
	  });
	}

	/**
	 * @object ons
	 * @category util
	 * @description
	 *   [ja]Onsen UIで利用できるグローバルなオブジェクトです。[/ja]
	 *   [en]A global object that's used in Onsen UI. [/en]
	 */
	var ons = {};

	ons._util = util;
	ons._deviceBackButtonDispatcher = deviceBackButtonDispatcher;
	ons._internal = internal;
	ons.GestureDetector = GestureDetector;
	ons.platform = platform;
	ons.softwareKeyboard = softwareKeyboard;
	ons.pageAttributeExpression = pageAttributeExpression;
	ons.orientation = orientation;
	ons.notification = notification;
	ons._animationOptionsParser = parse;
	ons._autoStyle = autoStyle;
	ons._DoorLock = DoorLock;
	ons._contentReady = contentReady;

	ons._readyLock = new DoorLock();

	ons.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

	waitDeviceReady();

	/**
	 * @method isReady
	 * @signature isReady()
	 * @return {Boolean}
	 *   [en]Will be true if Onsen UI is initialized.[/en]
	 *   [ja]初期化されているかどうかを返します。[/ja]
	 * @description
	 *   [en]Returns true if Onsen UI is initialized.[/en]
	 *   [ja]Onsen UIがすでに初期化されているかどうかを返すメソッドです。[/ja]
	 */
	ons.isReady = function () {
	  return !ons._readyLock.isLocked();
	};

	/**
	 * @method isWebView
	 * @signature isWebView()
	 * @return {Boolean}
	 *   [en]Will be true if the app is running in Cordova.[/en]
	 *   [ja]Cordovaで実行されている場合にtrueになります。[/ja]
	 * @description
	 *   [en]Returns true if running inside Cordova.[/en]
	 *   [ja]Cordovaで実行されているかどうかを返すメソッドです。[/ja]
	 */
	ons.isWebView = ons.platform.isWebView;

	/**
	 * @method ready
	 * @signature ready(callback)
	 * @description
	 *   [ja]アプリの初期化に利用するメソッドです。渡された関数は、Onsen UIの初期化が終了している時点で必ず呼ばれます。[/ja]
	 *   [en]Method used to wait for app initialization. The callback will not be executed until Onsen UI has been completely initialized.[/en]
	 * @param {Function} callback
	 *   [en]Function that executes after Onsen UI has been initialized.[/en]
	 *   [ja]Onsen UIが初期化が完了した後に呼び出される関数オブジェクトを指定します。[/ja]
	 */
	ons.ready = function (callback) {
	  if (ons.isReady()) {
	    callback();
	  } else {
	    ons._readyLock.waitUnlock(callback);
	  }
	};

	/**
	 * @method setDefaultDeviceBackButtonListener
	 * @signature setDefaultDeviceBackButtonListener(listener)
	 * @param {Function} listener
	 *   [en]Function that executes when device back button is pressed.[/en]
	 *   [ja]デバイスのバックボタンが押された時に実行される関数オブジェクトを指定します。[/ja]
	 * @description
	 *   [en]Set default handler for device back button.[/en]
	 *   [ja]デバイスのバックボタンのためのデフォルトのハンドラを設定します。[/ja]
	 */
	ons.setDefaultDeviceBackButtonListener = function (listener) {
	  ons._defaultDeviceBackButtonHandler.setListener(listener);
	};

	/**
	 * @method disableDeviceBackButtonHandler
	 * @signature disableDeviceBackButtonHandler()
	 * @description
	 * [en]Disable device back button event handler.[/en]
	 * [ja]デバイスのバックボタンのイベントを受け付けないようにします。[/ja]
	 */
	ons.disableDeviceBackButtonHandler = function () {
	  ons._deviceBackButtonDispatcher.disable();
	};

	/**
	 * @method enableDeviceBackButtonHandler
	 * @signature enableDeviceBackButtonHandler()
	 * @description
	 * [en]Enable device back button event handler.[/en]
	 * [ja]デバイスのバックボタンのイベントを受け付けるようにします。[/ja]
	 */
	ons.enableDeviceBackButtonHandler = function () {
	  ons._deviceBackButtonDispatcher.enable();
	};

	/**
	 * @method enableAutoStatusBarFill
	 * @signature enableAutoStatusBarFill()
	 * @description
	 *   [en]Enable status bar fill feature on iOS7 and above.[/en]
	 *   [ja]iOS7以上で、ステータスバー部分の高さを自動的に埋める処理を有効にします。[/ja]
	 */
	ons.enableAutoStatusBarFill = function () {
	  if (ons.isReady()) {
	    throw new Error('This method must be called before ons.isReady() is true.');
	  }
	  ons._internal.config.autoStatusBarFill = true;
	};

	/**
	 * @method disableAutoStatusBarFill
	 * @signature disableAutoStatusBarFill()
	 * @description
	 *   [en]Disable status bar fill feature on iOS7 and above.[/en]
	 *   [ja]iOS7以上で、ステータスバー部分の高さを自動的に埋める処理を無効にします。[/ja]
	 */
	ons.disableAutoStatusBarFill = function () {
	  if (ons.isReady()) {
	    throw new Error('This method must be called before ons.isReady() is true.');
	  }
	  ons._internal.config.autoStatusBarFill = false;
	};

	/**
	 * @method disableAnimations
	 * @signature disableAnimations()
	 * @description
	 *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
	 *   [ja]アニメーションを全て無効にします。テストの際に便利です。[/ja]
	 */
	ons.disableAnimations = function () {
	  ons._internal.config.animationsDisabled = true;
	};

	/**
	 * @method enableAnimations
	 * @signature enableAnimations()
	 * @description
	 *   [en]Enable animations (default).[/en]
	 *   [ja]アニメーションを有効にします。[/ja]
	 */
	ons.enableAnimations = function () {
	  ons._internal.config.animationsDisabled = false;
	};

	/**
	 * @method disableAutoStyling
	 * @signature disableAutoStyling()
	 * @description
	 *   [en]Disable automatic styling.[/en]
	 *   [ja][/ja]
	 */
	ons.disableAutoStyling = ons._autoStyle.disable;

	/**
	 * @method enableAutoStyling
	 * @signature enableAutoStyling()
	 * @description
	 *   [en]Enable automatic styling based on OS (default).[/en]
	 *   [ja][/ja]
	 */
	ons.enableAutoStyling = ons._autoStyle.enable;

	/**
	 * @method forcePlatformStyling
	 * @signature forcePlatformStyling(platform)
	 * @description
	 *   [en]Refresh styling for the given platform.[/en]
	 *   [ja][/ja]
	 * @param {string} platform New platform to style the elements.
	 */
	ons.forcePlatformStyling = function (newPlatform) {
	  ons.enableAutoStyling();
	  ons.platform.select(newPlatform || 'ios');

	  ons._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
	    if (element.tagName.toLowerCase() === 'ons-if') {
	      element._platformUpdate();
	    } else if (element.tagName.match(/^ons-/i)) {
	      ons._autoStyle.prepare(element, true);
	      if (element.tagName.toLowerCase() === 'ons-tabbar') {
	        element._updatePosition();
	      }
	    }
	  });
	};

	/**
	 * @param {String} page
	 * @param {Object} [options]
	 * @param {Function} [options.link]
	 * @return {Promise}
	 */
	ons._createPopoverOriginal = function (page) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


	  if (!page) {
	    throw new Error('Page url must be defined.');
	  }

	  return ons._internal.getPageHTMLAsync(page).then(function (html) {
	    html = html.match(/<ons-popover/gi) ? '<div>' + html + '</div>' : '<ons-popover>' + html + '</ons-popover>';
	    var div = ons._util.createElement('<div>' + html + '</div>');

	    var popover = div.querySelector('ons-popover');
	    CustomElements.upgrade(popover);
	    document.body.appendChild(popover);

	    if (options.link instanceof Function) {
	      options.link(popover);
	    }

	    return popover;
	  });
	};

	/**
	 * @method createPopover
	 * @signature createPopover(page, [options])
	 * @param {String} page
	 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
	 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
	 * @param {Object} [options]
	 *   [en]Parameter object.[/en]
	 *   [ja]オプションを指定するオブジェクト。[/ja]
	 * @param {Object} [options.parentScope]
	 *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
	 *   [ja]ダイアログ内で利用する親スコープを指定します。ダイアログからモデルやスコープのメソッドにアクセスするのに使います。このパラメータはAngularJSバインディングでのみ利用できます。[/ja]
	 * @return {Promise}
	 *   [en]Promise object that resolves to the popover component object.[/en]
	 *   [ja]ポップオーバーのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
	 * @description
	 *   [en]Create a popover instance from a template.[/en]
	 *   [ja]テンプレートからポップオーバーのインスタンスを生成します。[/ja]
	 */
	ons.createPopover = ons._createPopoverOriginal;

	/**
	 * @param {String} page
	 * @param {Object} [options]
	 * @param {Function} [options.link]
	 * @return {Promise}
	 */
	ons._createDialogOriginal = function (page) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


	  if (!page) {
	    throw new Error('Page url must be defined.');
	  }

	  return ons._internal.getPageHTMLAsync(page).then(function (html) {
	    html = html.match(/<ons-dialog/gi) ? '<div>' + html + '</div>' : '<ons-dialog>' + html + '</ons-dialog>';
	    var div = ons._util.createElement('<div>' + html + '</div>');

	    var dialog = div.querySelector('ons-dialog');
	    CustomElements.upgrade(dialog);
	    document.body.appendChild(dialog);

	    if (options.link instanceof Function) {
	      options.link(dialog);
	    }

	    return dialog;
	  });
	};

	/**
	 * @method createDialog
	 * @signature createDialog(page, [options])
	 * @param {String} page
	 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
	 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
	 * @param {Object} [options]
	 *   [en]Parameter object.[/en]
	 *   [ja]オプションを指定するオブジェクト。[/ja]
	 * @return {Promise}
	 *   [en]Promise object that resolves to the dialog component object.[/en]
	 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
	 * @description
	 *   [en]Create a dialog instance from a template.[/en]
	 *   [ja]テンプレートからダイアログのインスタンスを生成します。[/ja]
	 */
	ons.createDialog = ons._createDialogOriginal;

	/**
	 * @param {String} page
	 * @param {Object} [options]
	 * @param {Function} [options.link]
	 * @return {Promise}
	 */
	ons._createAlertDialogOriginal = function (page) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


	  if (!page) {
	    throw new Error('Page url must be defined.');
	  }

	  return ons._internal.getPageHTMLAsync(page).then(function (html) {
	    html = html.match(/<ons-alert-dialog/gi) ? '<div>' + html + '</div>' : '<ons-alert-dialog>' + html + '</ons-alert-dialog>';
	    var div = ons._util.createElement('<div>' + html + '</div>');

	    var alertDialog = div.querySelector('ons-alert-dialog');
	    CustomElements.upgrade(alertDialog);
	    document.body.appendChild(alertDialog);

	    if (options.link instanceof Function) {
	      options.link(alertDialog);
	    }

	    return alertDialog;
	  });
	};

	/**
	 * @method createAlertDialog
	 * @signature createAlertDialog(page, [options])
	 * @param {String} page
	 *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-alert-dialog> component.[/en]
	 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
	 * @param {Object} [options]
	 *   [en]Parameter object.[/en]
	 *   [ja]オプションを指定するオブジェクト。[/ja]
	 * @return {Promise}
	 *   [en]Promise object that resolves to the alert dialog component object.[/en]
	 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
	 * @description
	 *   [en]Create a alert dialog instance from a template.[/en]
	 *   [ja]テンプレートからアラートダイアログのインスタンスを生成します。[/ja]
	 */
	ons.createAlertDialog = ons._createAlertDialogOriginal;

	/**
	 * @param {String} page
	 * @param {Function} link
	 */
	ons._resolveLoadingPlaceholderOriginal = function (page, link) {
	  var elements = ons._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

	  if (elements.length > 0) {
	    elements.filter(function (element) {
	      return !element.getAttribute('page');
	    }).forEach(function (element) {
	      element.setAttribute('ons-loading-placeholder', page);
	      ons._resolveLoadingPlaceholder(element, page, link);
	    });
	  } else {
	    throw new Error('No ons-loading-placeholder exists.');
	  }
	};

	/**
	 * @method resolveLoadingPlaceholder
	 * @signature resolveLoadingPlaceholder(page)
	 * @param {String} page
	 *   [en]Page name. Can be either an HTML file or an <ons-template> element.[/en]
	 *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
	 * @description
	 *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
	 *   [ja]ons-loading-placeholderの属性値としてページが指定されていない場合は、ページロード前に呼ばれるons.resolveLoadingPlaceholder処理が行われるまで表示されません。[/ja]
	 */
	ons.resolveLoadingPlaceholder = ons._resolveLoadingPlaceholderOriginal;

	ons._setupLoadingPlaceHolders = function () {
	  ons.ready(function () {
	    var elements = ons._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

	    elements.forEach(function (element) {
	      var page = element.getAttribute('ons-loading-placeholder');
	      if (typeof page === 'string') {
	        ons._resolveLoadingPlaceholder(element, page);
	      }
	    });
	  });
	};

	ons._resolveLoadingPlaceholder = function (element, page, link) {
	  link = link || function (element, done) {
	    done();
	  };
	  ons._internal.getPageHTMLAsync(page).then(function (html) {

	    while (element.firstChild) {
	      element.removeChild(element.firstChild);
	    }

	    var contentElement = ons._util.createElement('<div>' + html + '</div>');
	    contentElement.style.display = 'none';

	    element.appendChild(contentElement);

	    link(contentElement, function () {
	      contentElement.style.display = '';
	    });
	  }).catch(function (error) {
	    throw new Error('Unabled to resolve placeholder: ' + error);
	  });
	};

	function waitDeviceReady() {
	  var unlockDeviceReady = ons._readyLock.lock();
	  window.addEventListener('WebComponentsReady', function () {
	    if (ons.isWebView()) {
	      window.document.addEventListener('deviceready', unlockDeviceReady, false);
	    } else {
	      unlockDeviceReady();
	    }
	  }, false);
	}

	window._superSecretOns = ons;

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	function getElementClass() {
	  if (typeof HTMLElement !== 'function') {
	    var _BaseElement = function _BaseElement() {};
	    _BaseElement.prototype = document.createElement('div');
	    return _BaseElement;
	  } else {
	    return HTMLElement;
	  }
	}

	var BaseElement = function (_getElementClass) {
	  babelHelpers.inherits(BaseElement, _getElementClass);

	  function BaseElement() {
	    babelHelpers.classCallCheck(this, BaseElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BaseElement).apply(this, arguments));
	  }

	  return BaseElement;
	}(getElementClass());

	/**
	 * @element ons-template
	 * @category template
	 * @description
	 *   [en]
	 *     Define a separate HTML fragment and use as a template.
	 *
	 *     These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs.
	 *   [/en]
	 *   [ja]テンプレートとして使用するためのHTMLフラグメントを定義します。この要素でHTMLを宣言すると、id属性に指定した名前をpageのURLとしてons-navigatorなどのコンポーネントから参照できます。[/ja]
	 * @guide DefiningMultiplePagesinSingleHTML
	 *   [en]Defining multiple pages in single html[/en]
	 *   [ja]複数のページを1つのHTMLに記述する[/ja]
	 * @seealso ons-navigator
	 *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
	 *   [ja][/ja]
	 * @seealso ons-tabbar
	 *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
	 *   [ja][/ja]
	 * @seealso ons-splitter
	 *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
	 *   [ja][/ja]
	 * @example
	 * <ons-template id="foobar.html">
	 *   <ons-page>
	 *     Page content
	 *   </ons-page>
	 * </ons-template>
	 *
	 * <ons-navigator page="foobar.html">
	 * </ons-navigator>
	 */

	var TemplateElement = function (_BaseElement) {
	  babelHelpers.inherits(TemplateElement, _BaseElement);

	  function TemplateElement() {
	    babelHelpers.classCallCheck(this, TemplateElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TemplateElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(TemplateElement, [{
	    key: 'createdCallback',


	    /**
	     * @property template
	     * @type {String}
	     * @description
	     *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
	     *  [ja][/ja]
	     */
	    value: function createdCallback() {
	      this.template = this.innerHTML;

	      while (this.firstChild) {
	        this.removeChild(this.firstChild);
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
	      event.template = this.template;
	      event.templateId = this.getAttribute('id');

	      this.dispatchEvent(event);
	    }
	  }]);
	  return TemplateElement;
	}(BaseElement);

	window.OnsTemplateElement = document.registerElement('ons-template', {
	  prototype: TemplateElement.prototype
	});

	/**
	 * @element ons-if
	 * @category conditional
	 * @tutorial vanilla/Reference/if
	 * @description
	 *   [en]
	 *     Conditionally display content depending on the platform, device orientation or both.
	 *
	 *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
	 *   [/en]
	 *   [ja][/ja]
	 * @guide UtilityAPIs
	 *   [en]Other utility APIs[/en]
	 *   [ja]他のユーティリティAPI[/ja]
	 * @example
	 * <ons-page>
	 *   <ons-if orientation="landscape">
	 *     Landscape view!
	 *   </ons-if>
	 *   <ons-if platform="android">
	 *     This is Android.
	 *   </ons-if>
	 *   <ons-if platform="ios other">
	 *     This is not Android.
	 *   </ons-if>
	 * </ons-page>
	 */

	var ConditionalElement = function (_BaseElement) {
	  babelHelpers.inherits(ConditionalElement, _BaseElement);

	  function ConditionalElement() {
	    babelHelpers.classCallCheck(this, ConditionalElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ConditionalElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(ConditionalElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute platform
	     * @initonly
	     * @type {string}
	     * @description
	     *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
	     *  [ja][/ja]
	     */

	    /**
	     * @attribute orientation
	     * @type {string}
	     * @description
	     *  [en]Either `"portrait"` or `"landscape"`.[/en]
	     *  [ja]portraitもしくはlandscapeを指定します[/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        if (platform._renderPlatform !== null) {
	          _this2._platformUpdate();
	        } else if (!_this2._isAllowedPlatform()) {
	          while (_this2.childNodes[0]) {
	            _this2.childNodes[0].remove();
	          }
	          _this2._platformUpdate();
	        }
	      });

	      this._onOrientationChange();
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      orientation.on('change', this._onOrientationChange.bind(this));
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name) {
	      if (name === 'orientation') {
	        this._onOrientationChange();
	      }
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      orientation.off('change', this._onOrientationChange);
	    }
	  }, {
	    key: '_platformUpdate',
	    value: function _platformUpdate() {
	      this.style.display = this._isAllowedPlatform() ? '' : 'none';
	    }
	  }, {
	    key: '_isAllowedPlatform',
	    value: function _isAllowedPlatform() {
	      return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
	    }
	  }, {
	    key: '_onOrientationChange',
	    value: function _onOrientationChange() {
	      if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
	        var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
	        var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

	        this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
	      }
	    }
	  }]);
	  return ConditionalElement;
	}(BaseElement);

	window.OnsConditionalElement = document.registerElement('ons-if', {
	  prototype: ConditionalElement.prototype
	});

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	var AlertDialogAnimator = function () {
	  function AlertDialogAnimator() {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    var _ref$timing = _ref.timing;
	    var timing = _ref$timing === undefined ? 'linear' : _ref$timing;
	    var _ref$delay = _ref.delay;
	    var delay = _ref$delay === undefined ? 0 : _ref$delay;
	    var _ref$duration = _ref.duration;
	    var duration = _ref$duration === undefined ? 0.2 : _ref$duration;
	    babelHelpers.classCallCheck(this, AlertDialogAnimator);

	    this.timing = timing;
	    this.delay = delay;
	    this.duration = duration;
	  }

	  /**
	   * @param {HTMLElement} dialog
	   * @param {Function} done
	   */


	  babelHelpers.createClass(AlertDialogAnimator, [{
	    key: 'show',
	    value: function show(dialog, done) {
	      done();
	    }

	    /**
	     * @param {HTMLElement} dialog
	     * @param {Function} done
	     */

	  }, {
	    key: 'hide',
	    value: function hide(dialog, done) {
	      done();
	    }
	  }]);
	  return AlertDialogAnimator;
	}();

	/**
	 * Android style animator for alert dialog.
	 */
	var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
	  babelHelpers.inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

	  function AndroidAlertDialogAnimator() {
	    var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    var _ref2$timing = _ref2.timing;
	    var timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing;
	    var _ref2$duration = _ref2.duration;
	    var duration = _ref2$duration === undefined ? 0.2 : _ref2$duration;
	    var _ref2$delay = _ref2.delay;
	    var delay = _ref2$delay === undefined ? 0 : _ref2$delay;
	    babelHelpers.classCallCheck(this, AndroidAlertDialogAnimator);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AndroidAlertDialogAnimator).call(this, { duration: duration, timing: timing, delay: delay }));
	  }

	  /**
	   * @param {Object} dialog
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(AndroidAlertDialogAnimator, [{
	    key: 'show',
	    value: function show(dialog, callback) {
	      callback = callback ? callback : function () {};

	      animit.runAll(animit(dialog._mask).queue({
	        opacity: 0
	      }).wait(this.delay).queue({
	        opacity: 1.0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }), animit(dialog._dialog).saveStyle().queue({
	        css: {
	          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
	          opacity: 0.0
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
	          opacity: 1.0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }

	    /**
	     * @param {Object} dialog
	     * @param {Function} callback
	     */

	  }, {
	    key: 'hide',
	    value: function hide(dialog, callback) {
	      callback = callback ? callback : function () {};

	      animit.runAll(animit(dialog._mask).queue({
	        opacity: 1.0
	      }).wait(this.delay).queue({
	        opacity: 0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }), animit(dialog._dialog).saveStyle().queue({
	        css: {
	          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
	          opacity: 1.0
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
	          opacity: 0.0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }
	  }]);
	  return AndroidAlertDialogAnimator;
	}(AlertDialogAnimator);

	/**
	 * iOS style animator for alert dialog.
	 */
	var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
	  babelHelpers.inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

	  function IOSAlertDialogAnimator() {
	    var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    var _ref3$timing = _ref3.timing;
	    var timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing;
	    var _ref3$duration = _ref3.duration;
	    var duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;
	    var _ref3$delay = _ref3.delay;
	    var delay = _ref3$delay === undefined ? 0 : _ref3$delay;
	    babelHelpers.classCallCheck(this, IOSAlertDialogAnimator);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSAlertDialogAnimator).call(this, { duration: duration, timing: timing, delay: delay }));
	  }

	  /*
	   * @param {Object} dialog
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(IOSAlertDialogAnimator, [{
	    key: 'show',
	    value: function show(dialog, callback) {
	      callback = callback ? callback : function () {};

	      animit.runAll(animit(dialog._mask).queue({
	        opacity: 0
	      }).wait(this.delay).queue({
	        opacity: 1.0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }), animit(dialog._dialog).saveStyle().queue({
	        css: {
	          transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1.0)',
	          opacity: 0.0
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
	          opacity: 1.0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }

	    /**
	     * @param {Object} dialog
	     * @param {Function} callback
	     */

	  }, {
	    key: 'hide',
	    value: function hide(dialog, callback) {
	      callback = callback ? callback : function () {};

	      animit.runAll(animit(dialog._mask).queue({
	        opacity: 1.0
	      }).wait(this.delay).queue({
	        opacity: 0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }), animit(dialog._dialog).saveStyle().queue({
	        css: {
	          opacity: 1.0
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          opacity: 0.0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }
	  }]);
	  return IOSAlertDialogAnimator;
	}(AlertDialogAnimator);

	var scheme = {
	  '.alert-dialog': 'alert-dialog--*',
	  '.alert-dialog-container': 'alert-dialog-container--*',
	  '.alert-dialog-title': 'alert-dialog-title--*',
	  '.alert-dialog-content': 'alert-dialog-content--*',
	  '.alert-dialog-footer': 'alert-dialog-footer--*',
	  '.alert-dialog-button': 'alert-dialog-button--*',
	  '.alert-dialog-footer--one': 'alert-dialog-footer--one--*',
	  '.alert-dialog-button--one': 'alert-dialog-button--one--*',
	  '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
	  '.alert-dialog-mask': 'alert-dialog-mask--*'
	};

	var _animatorDict = {
	  'none': AlertDialogAnimator,
	  'default': function _default() {
	    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
	  },
	  'fade': function fade() {
	    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
	  }
	};

	/**
	 * @element ons-alert-dialog
	 * @category dialog
	 * @description
	 *   [en]
	 *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
	 *
	 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<ons-template>` tag.
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen Qwwxyp
	 * @tutorial vanilla/Reference/dialog
	 * @modifier material
	 *   [en]Material Design style[/en]
	 *   [ja][/ja]
	 * @guide UsingAlert
	 *   [en]Learn how to use the alert dialog.[/en]
	 *   [ja]アラートダイアログの使い方の解説。[/ja]
	 * @seealso ons-dialog
	 *   [en]ons-dialog component[/en]
	 *   [ja]ons-dialogコンポーネント[/ja]
	 * @seealso ons-popover
	 *   [en]ons-popover component[/en]
	 *   [ja]ons-dialogコンポーネント[/ja]
	 * @seealso ons.notification
	 *   [en]Using ons.notification utility functions.[/en]
	 *   [ja]アラートダイアログを表示するには、ons.notificationオブジェクトのメソッドを使うこともできます。[/ja]
	 * @example
	 * <ons-alert-dialog id="alert-dialog">
	 *   <div class="alert-dialog-title">Warning!</div>
	 *   <div class="alert-dialog-content">
	 *     An error has occurred!
	 *   </div>
	 *   <div class="alert-dialog-footer">
	 *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
	 *   </div>
	 * </ons-alert-dialog>
	 * <script>
	 *   document.getElementById('alert-dialog').show();
	 * </script>
	 */

	var AlertDialogElement = function (_BaseElement) {
	  babelHelpers.inherits(AlertDialogElement, _BaseElement);

	  function AlertDialogElement() {
	    babelHelpers.classCallCheck(this, AlertDialogElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AlertDialogElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(AlertDialogElement, [{
	    key: 'createdCallback',
	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        return _this2._compile();
	      });

	      this._visible = false;
	      this._doorLock = new DoorLock();
	      this._boundCancel = this._cancel.bind(this);

	      this._updateAnimatorFactory();
	    }
	  }, {
	    key: '_updateAnimatorFactory',
	    value: function _updateAnimatorFactory() {
	      this._animatorFactory = new AnimatorFactory({
	        animators: _animatorDict,
	        baseClass: AlertDialogAnimator,
	        baseClassName: 'AlertDialogAnimator',
	        defaultAnimation: this.getAttribute('animation')
	      });
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      this.style.display = 'none';

	      /**
	       * Expected result after compile:
	       *
	       * <ons-alert-dialog style="none">
	       *   <div class="alert-dialog-mask"></div>
	       *   <div class="alert-dialog">
	       *     <div class="alert-dialog-container">...</div>
	       *   </div>
	       * </ons-alert-dialog>
	       */

	      var content = document.createDocumentFragment();

	      if (!this._mask && !this._dialog) {
	        while (this.firstChild) {
	          content.appendChild(this.firstChild);
	        }
	      }

	      if (!this._mask) {
	        var mask = document.createElement('div');
	        mask.classList.add('alert-dialog-mask');
	        this.insertBefore(mask, this.children[0]);
	      }

	      if (!this._dialog) {
	        var dialog = document.createElement('div');
	        dialog.classList.add('alert-dialog');
	        this.insertBefore(dialog, null);
	      }

	      if (!util.findChild(this._dialog, '.alert-dialog-container')) {
	        var container = document.createElement('div');
	        container.classList.add('alert-dialog-container');
	        this._dialog.appendChild(container);
	      }

	      this._dialog.children[0].appendChild(content);

	      this._dialog.style.zIndex = 20001;
	      this._mask.style.zIndex = 20000;

	      if (this.getAttribute('mask-color')) {
	        this._mask.style.backgroundColor = this.getAttribute('mask-color');
	      }

	      ModifierUtil.initModifier(this, scheme);
	    }

	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: 'show',


	    /**
	     * @method show
	     * @signature show([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクトです。[/ja]
	     * @param {String} [options.animation]
	     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
	     *   [ja]アニメーション名を指定します。指定できるのは、"fade", "none"のいずれかです。[/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
	     * @param {Function} [options.callback]
	     *   [en]Function to execute after the dialog has been revealed.[/en]
	     *   [ja]ダイアログが表示され終わった時に呼び出されるコールバックを指定します。[/ja]
	     * @description
	     *   [en]Show the alert dialog.[/en]
	     *   [ja]ダイアログを表示します。[/ja]
	     * @return {Promise}
	     *   [en]A `Promise` object that resolves to the displayed element.[/en]
	     *   [ja][/ja]
	     */
	    value: function show() {
	      var _this3 = this;

	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      var _cancel2 = false;
	      var callback = options.callback || function () {};

	      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

	      util.triggerElementEvent(this, 'preshow', {
	        alertDialog: this,
	        cancel: function cancel() {
	          _cancel2 = true;
	        }
	      });

	      if (!_cancel2) {
	        var _ret = function () {
	          var tryShow = function tryShow() {
	            var unlock = _this3._doorLock.lock();
	            var animator = _this3._animatorFactory.newAnimator(options);

	            _this3.style.display = 'block';
	            _this3._mask.style.opacity = '1';

	            return new Promise(function (resolve) {
	              contentReady(_this3, function () {
	                animator.show(_this3, function () {
	                  _this3._visible = true;
	                  unlock();

	                  util.triggerElementEvent(_this3, 'postshow', { alertDialog: _this3 });

	                  callback();
	                  resolve(_this3);
	                });
	              });
	            });
	          };

	          return {
	            v: new Promise(function (resolve) {
	              _this3._doorLock.waitUnlock(function () {
	                return resolve(tryShow());
	              });
	            })
	          };
	        }();

	        if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
	      } else {
	        return Promise.reject('Canceled in preshow event.');
	      }
	    }

	    /**
	     * @method hide
	     * @signature hide([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {String} [options.animation]
	     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
	     *   [ja]アニメーション名を指定します。"fade", "none"のいずれかを指定します。[/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
	     * @param {Function} [options.callback]
	     *   [en]Function to execute after the dialog has been hidden.[/en]
	     *   [ja]このダイアログが閉じた時に呼び出されるコールバックを指定します。[/ja]
	     * @description
	     *   [en]Hide the alert dialog.[/en]
	     *   [ja]ダイアログを閉じます。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the hidden element[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'hide',
	    value: function hide() {
	      var _this4 = this;

	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      var _cancel3 = false;
	      var callback = options.callback || function () {};

	      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

	      util.triggerElementEvent(this, 'prehide', {
	        alertDialog: this,
	        cancel: function cancel() {
	          _cancel3 = true;
	        }
	      });

	      if (!_cancel3) {
	        var _ret2 = function () {
	          var tryHide = function tryHide() {
	            var unlock = _this4._doorLock.lock();
	            var animator = _this4._animatorFactory.newAnimator(options);

	            return new Promise(function (resolve) {
	              contentReady(_this4, function () {
	                animator.hide(_this4, function () {
	                  _this4.style.display = 'none';
	                  _this4._visible = false;
	                  unlock();

	                  util.triggerElementEvent(_this4, 'posthide', { alertDialog: _this4 });

	                  callback();
	                  resolve(_this4);
	                });
	              });
	            });
	          };

	          return {
	            v: new Promise(function (resolve) {
	              _this4._doorLock.waitUnlock(function () {
	                return resolve(tryHide());
	              });
	            })
	          };
	        }();

	        if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
	      } else {
	        return Promise.reject('Canceled in prehide event.');
	      }
	    }

	    /**
	     * @property visible
	     * @readonly
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the dialog is visible or not.[/en]
	     *   [ja]要素が見える場合に`true`。[/ja]
	     */

	  }, {
	    key: '_cancel',
	    value: function _cancel() {
	      var _this5 = this;

	      if (this.cancelable && !this._running) {
	        this._running = true;
	        this.hide({
	          callback: function callback() {
	            _this5._running = false;
	            util.triggerElementEvent(_this5, 'dialog-cancel');
	          }
	        });
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this6 = this;

	      this.onDeviceBackButton = function (e) {
	        return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
	      };

	      contentReady(this, function () {
	        _this6._mask.addEventListener('click', _this6._boundCancel, false);
	      });
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this._backButtonHandler.destroy();
	      this._backButtonHandler = null;

	      this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme);
	      } else if (name === 'animation') {
	        this._updateAnimatorFactory();
	      }
	    }
	  }, {
	    key: '_mask',


	    /**
	     * @event preshow
	     * @description
	     *   [en]Fired just before the alert dialog is displayed.[/en]
	     *   [ja]アラートダイアログが表示される直前に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.alertDialog
	     *   [en]Alert dialog object.[/en]
	     *   [ja]アラートダイアログのオブジェクト。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Execute to stop the dialog from showing.[/en]
	     *   [ja]この関数を実行すると、アラートダイアログの表示を止めます。[/ja]
	     */

	    /**
	     * @event postshow
	     * @description
	     *   [en]Fired just after the alert dialog is displayed.[/en]
	     *   [ja]アラートダイアログが表示された直後に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.alertDialog
	     *   [en]Alert dialog object.[/en]
	     *   [ja]アラートダイアログのオブジェクト。[/ja]
	     */

	    /**
	     * @event prehide
	     * @description
	     *   [en]Fired just before the alert dialog is hidden.[/en]
	     *   [ja]アラートダイアログが隠れる直前に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.alertDialog
	     *   [en]Alert dialog object.[/en]
	     *   [ja]アラートダイアログのオブジェクト。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Execute to stop the dialog from hiding.[/en]
	     *   [ja]この関数を実行すると、アラートダイアログが閉じようとするのを止めます。[/ja]
	     */

	    /**
	     * @event posthide
	     * @description
	     * [en]Fired just after the alert dialog is hidden.[/en]
	     * [ja]アラートダイアログが隠れた後に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.alertDialog
	     *   [en]Alert dialog object.[/en]
	     *   [ja]アラートダイアログのオブジェクト。[/ja]
	     */

	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *  [en]The appearance of the dialog.[/en]
	     *  [ja]ダイアログの見た目を指定します。[/ja]
	     */

	    /**
	     * @attribute cancelable
	     * @description
	     *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
	     *  [ja][/ja]
	     */

	    /**
	     * @attribute disabled
	     * @description
	     *  [en]If this attribute is set the dialog is disabled.[/en]
	     *  [ja]この属性がある時、アラートダイアログはdisabled状態になります。[/ja]
	     */

	    /**
	     * @attribute animation
	     * @type {String}
	     * @default default
	     * @description
	     *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
	     *  [ja]ダイアログを表示する際のアニメーション名を指定します。デフォルトでは"none"か"default"が指定できます。[/ja]
	     */

	    /**
	     * @attribute animation-options
	     * @type {Expression}
	     * @description
	     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
	     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
	     */

	    /**
	     * @attribute mask-color
	     * @type {String}
	     * @default rgba(0, 0, 0, 0.2)
	     * @description
	     *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
	     *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
	     */

	    /**
	     * @return {Element}
	     */
	    get: function get() {
	      return util.findChild(this, '.alert-dialog-mask');
	    }

	    /**
	     * @return {Element}
	     */

	  }, {
	    key: '_dialog',
	    get: function get() {
	      return util.findChild(this, '.alert-dialog');
	    }

	    /**
	     * @return {Element}
	     */

	  }, {
	    key: '_titleElement',
	    get: function get() {
	      return util.findChild(this._dialog.children[0], '.alert-dialog-title');
	    }

	    /**
	     * @return {Element}
	     */

	  }, {
	    key: '_contentElement',
	    get: function get() {
	      return util.findChild(this._dialog.children[0], '.alert-dialog-content');
	    }
	  }, {
	    key: 'disabled',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'disabled', value);
	    },
	    get: function get() {
	      return this.hasAttribute('disabled');
	    }

	    /**
	     * @property cancelable
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'cancelable',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'cancelable', value);
	    },
	    get: function get() {
	      return this.hasAttribute('cancelable');
	    }
	  }, {
	    key: 'visible',
	    get: function get() {
	      return this._visible;
	    }

	    /**
	     * @property onDeviceBackButton
	     * @type {Object}
	     * @description
	     *   [en]Back-button handler.[/en]
	     *   [ja]バックボタンハンドラ。[/ja]
	     */

	  }, {
	    key: 'onDeviceBackButton',
	    get: function get() {
	      return this._backButtonHandler;
	    },
	    set: function set(callback) {
	      if (this._backButtonHandler) {
	        this._backButtonHandler.destroy();
	      }

	      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
	    }
	  }]);
	  return AlertDialogElement;
	}(BaseElement);

	var OnsAlertDialogElement = window.OnsAlertDialogElement = document.registerElement('ons-alert-dialog', {
	  prototype: AlertDialogElement.prototype
	});

	/**
	 * @param {String} name
	 * @param {DialogAnimator} Animator
	 */
	OnsAlertDialogElement.registerAnimator = function (name, Animator) {
	  if (!(Animator.prototype instanceof AlertDialogAnimator)) {
	    throw new Error('"Animator" param must inherit OnsAlertDialogElement.AlertDialogAnimator');
	  }
	  _animatorDict[name] = Animator;
	};

	OnsAlertDialogElement.AlertDialogAnimator = AlertDialogAnimator;

	var scheme$1 = {
	  '': 'back-button--*',
	  '.back-button__icon': 'back-button--*__icon',
	  '.back-button__label': 'back-button--*__label'
	};

	/**
	 * @element ons-back-button
	 * @category toolbar
	 * @description
	 *   [en]
	 *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
	 *
	 *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen aHmGL
	 * @tutorial vanilla/Reference/navigator
	 * @modifier material
	 *   [en]Material Design style[/en]
	 *   [ja][/ja]
	 * @seealso ons-toolbar
	 *   [en]ons-toolbar component[/en]
	 *   [ja]ons-toolbarコンポーネント[/ja]
	 * @seealso ons-navigator
	 *   [en]ons-navigator component[/en]
	 *   [ja]ons-navigatorコンポーネント[/ja]
	 * @guide Addingatoolbar
	 *   [en]Adding a toolbar[/en]
	 *   [ja]ツールバーの追加[/ja]
	 * @guide Returningfromapage
	 *   [en]Returning from a page[/en]
	 *   [ja]一つ前のページに戻る[/ja]
	 * @example
	 * <ons-toolbar>
	 *   <div class="left">
	 *     <ons-back-button>Back</ons-back-button>
	 *   </div>
	 *   <div class="center">
	 *     Title
	 *   <div>
	 * </ons-toolbar>
	 */

	var BackButtonElement = function (_BaseElement) {
	  babelHelpers.inherits(BackButtonElement, _BaseElement);

	  function BackButtonElement() {
	    babelHelpers.classCallCheck(this, BackButtonElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BackButtonElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(BackButtonElement, [{
	    key: 'createdCallback',

	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *  [en]The appearance of the back button.[/en]
	     *  [ja]バックボタンの見た目を指定します。[/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        if (!_this2.hasAttribute('_compiled')) {
	          _this2._compile();
	        }
	      });

	      this._options = {};
	      this._boundOnClick = this._onClick.bind(this);
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      this.classList.add('back-button');

	      if (!util.findChild(this, '.back-button__label')) {
	        var label = util.create('span.back-button__label');

	        while (this.childNodes[0]) {
	          label.appendChild(this.childNodes[0]);
	        }
	        this.appendChild(label);
	      }

	      if (!util.findChild(this, '.back-button__icon')) {
	        var icon = util.create('span.back-button__icon');

	        this.insertBefore(icon, this.children[0]);
	      }

	      ModifierUtil.initModifier(this, scheme$1);

	      this.setAttribute('_compiled', '');
	    }

	    /**
	     * @property options
	     * @type {Object}
	     * @description
	     *   [en]Options object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     */

	    /**
	     * @property options.animation
	     * @type {String}
	     * @description
	     *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
	     *     These are platform based animations. For fixed animations, add "-ios" or "-md"
	     *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
	     *   [/en]
	     *   [ja][/ja]
	     */

	    /**
	     * @property options.animationOptions
	     * @type {String}
	     * @description
	     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
	     */

	    /**
	     * @property options.callback
	     * @type {String}
	     * @description
	     *   [en]Function that is called when the transition has ended.[/en]
	     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
	     */

	    /**
	     * @property options.refresh
	     * @description
	     *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
	     *   [ja]popPageする前に、前にあるページを生成しなおして更新する場合にtrueを指定します。[/ja]
	     */

	  }, {
	    key: '_onClick',


	    /**
	     * @property onClick
	     * @type {Function}
	     * @description
	     *   [en]Used to override the default back button behavior.[/en]
	     *   [ja][/ja]
	     */
	    value: function _onClick() {
	      if (this.onClick) {
	        this.onClick.apply(this);
	      } else {
	        var navigator = util.findParent(this, 'ons-navigator');
	        if (navigator) {
	          navigator.popPage(this.options);
	        }
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      this.addEventListener('click', this._boundOnClick, false);
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$1);
	      }
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this.removeEventListener('click', this._boundOnClick, false);
	    }
	  }, {
	    key: 'show',
	    value: function show() {
	      this.style.display = 'inline-block';
	    }
	  }, {
	    key: 'hide',
	    value: function hide() {
	      this.style.display = 'none';
	    }
	  }, {
	    key: 'options',
	    get: function get() {
	      return this._options;
	    },
	    set: function set(object) {
	      this._options = object;
	    }
	  }]);
	  return BackButtonElement;
	}(BaseElement);

	window.OnsBackButtonElement = document.registerElement('ons-back-button', {
	  prototype: BackButtonElement.prototype
	});

	var scheme$2 = { '': 'bottom-bar--*' };

	/**
	 * @element ons-bottom-toolbar
	 * @category toolbar
	 * @description
	 *   [en]Toolbar component that is positioned at the bottom of the page.[/en]
	 *   [ja]ページ下部に配置されるツールバー用コンポーネントです。[/ja]
	 * @modifier transparent
	 *   [en]Make the toolbar transparent.[/en]
	 *   [ja]ツールバーの背景を透明にして表示します。[/ja]
	 * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbarコンポーネント[/ja]
	 * @guide Addingatoolbar
	 *   [en]Adding a toolbar[/en]
	 *   [ja]ツールバーの追加[/ja]
	 * @example
	 * <ons-bottom-toolbar>
	 *   Content
	 * </ons-bottom-toolbar>
	 */

	var BottomToolbarElement = function (_BaseElement) {
	  babelHelpers.inherits(BottomToolbarElement, _BaseElement);

	  function BottomToolbarElement() {
	    babelHelpers.classCallCheck(this, BottomToolbarElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BottomToolbarElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(BottomToolbarElement, [{
	    key: 'createdCallback',

	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *   [en]The appearance of the toolbar.[/en]
	     *   [ja]ツールバーの見た目の表現を指定します。[/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      this.classList.add('bottom-bar');

	      ModifierUtil.initModifier(this, scheme$2);

	      this._tryToEnsureNodePosition();
	      setImmediate(function () {
	        return _this2._tryToEnsureNodePosition();
	      });
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this3 = this;

	      this._tryToEnsureNodePosition();
	      setImmediate(function () {
	        return _this3._tryToEnsureNodePosition();
	      });
	    }
	  }, {
	    key: '_tryToEnsureNodePosition',
	    value: function _tryToEnsureNodePosition() {
	      var page = util.findParent(this, 'ons-page');

	      if (page && page !== this.parentNode) {
	        page._registerBottomToolbar(this);
	      }
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        ModifierUtil.onModifierChanged(last, current, this, scheme$2);
	      }
	    }
	  }]);
	  return BottomToolbarElement;
	}(BaseElement);

	window.OnsBottomToolbarElement = document.registerElement('ons-bottom-toolbar', {
	  prototype: BottomToolbarElement.prototype
	});

	var scheme$3 = { '': 'button--*' };

	/**
	 * @element ons-button
	 * @category button
	 * @modifier outline
	 *   [en]Button with outline and transparent background[/en]
	 *   [ja]アウトラインを持ったボタンを表示します。[/ja]
	 * @modifier light
	 *   [en]Button that doesn't stand out.[/en]
	 *   [ja]目立たないボタンを表示します。[/ja]
	 * @modifier quiet
	 *   [en]Button with no outline and or background..[/en]
	 *   [ja]枠線や背景が無い文字だけのボタンを表示します。[/ja]
	 * @modifier cta
	 *   [en]Button that really stands out.[/en]
	 *   [ja]目立つボタンを表示します。[/ja]
	 * @modifier large
	 *   [en]Large button that covers the width of the screen.[/en]
	 *   [ja]横いっぱいに広がる大きなボタンを表示します。[/ja]
	 * @modifier large--quiet
	 *   [en]Large quiet button.[/en]
	 *   [ja]横いっぱいに広がるquietボタンを表示します。[/ja]
	 * @modifier large--cta
	 *   [en]Large call to action button.[/en]
	 *   [ja]横いっぱいに広がるctaボタンを表示します。[/ja]
	 * @modifier material
	 *   [en]Material Design button[/en]
	 *   [ja]マテリアルデザインのボタン[/ja]
	 * @modifier material--flat
	 *   [en]Material Design flat button[/en]
	 *   [ja]マテリアルデザインのフラットボタン[/ja]
	 * @description
	 *   [en]
	 *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
	 *
	 *     Will automatically display as a Material Design button with a ripple effect on Android.
	 *   [/en]
	 *   [ja]ボタン用コンポーネント。ツールバーにボタンを設置する場合は、ons-toolbar-buttonもしくはons-back-buttonコンポーネントを使用します。[/ja]
	 * @codepen hLayx
	 * @tutorial vanilla/Reference/button
	 * @guide Button [en]Guide for `<ons-button>`[/en][ja]<ons-button>の使い方[/ja]
	 * @guide OverridingCSSstyles [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
	 * @example
	 * <ons-button modifier="large--cta">
	 *   Tap Me
	 * </ons-button>
	 */

	var ButtonElement = function (_BaseElement) {
	  babelHelpers.inherits(ButtonElement, _BaseElement);

	  function ButtonElement() {
	    babelHelpers.classCallCheck(this, ButtonElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ButtonElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(ButtonElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *  [en]The appearance of the button.[/en]
	     *  [ja]ボタンの表現を指定します。[/ja]
	     */

	    /**
	     * @attribute ripple
	     * @description
	     *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
	     *  [ja][/ja]
	     */

	    /**
	     * @attribute disabled
	     * @description
	     *   [en]Specify if button should be disabled.[/en]
	     *   [ja]ボタンを無効化する場合は指定します。[/ja]
	     */
	    value: function createdCallback() {
	      if (!this.hasAttribute('_compiled')) {
	        this._compile();
	      }
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      switch (name) {
	        case 'modifier':
	          ModifierUtil.onModifierChanged(last, current, this, scheme$3);
	          break;
	        case 'ripple':
	          this._updateRipple();
	      }
	    }

	    //noinspection JSAnnotator
	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the button is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      this.classList.add('button');

	      this._updateRipple();

	      ModifierUtil.initModifier(this, scheme$3);

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: '_updateRipple',
	    value: function _updateRipple() {
	      util.updateRipple(this);
	    }
	  }, {
	    key: 'disabled',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'disabled', value);
	    },
	    get: function get() {
	      return this.hasAttribute('disabled');
	    }
	  }]);
	  return ButtonElement;
	}(BaseElement);

	window.OnsButtonElement = document.registerElement('ons-button', {
	  prototype: ButtonElement.prototype
	});

	var scheme$4 = { '': 'carousel-item--*' };

	/**
	 * @element ons-carousel-item
	 * @category carousel
	 * @description
	 *   [en]
	 *     Carousel item component. Used as a child of the `<ons-carousel>` element.
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen xbbzOQ
	 * @tutorial vanilla/Reference/carousel
	 * @seealso ons-carousel
	 *   [en]`<ons-carousel>` components[/en]
	 *   [ja]<ons-carousel>コンポーネント[/ja]
	 * @example
	 * <ons-carousel style="width: 100%; height: 200px">
	 *   <ons-carousel-item>
	 *    ...
	 *   </ons-carousel-item>
	 *   <ons-carousel-item>
	 *    ...
	 *   </ons-carousel-item>
	 * </ons-carousel>
	 */

	var CarouselItemElement = function (_BaseElement) {
	  babelHelpers.inherits(CarouselItemElement, _BaseElement);

	  function CarouselItemElement() {
	    babelHelpers.classCallCheck(this, CarouselItemElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CarouselItemElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(CarouselItemElement, [{
	    key: 'createdCallback',
	    value: function createdCallback() {
	      this.style.width = '100%';
	      ModifierUtil.initModifier(this, scheme$4);
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$4);
	      }
	    }
	  }]);
	  return CarouselItemElement;
	}(BaseElement);

	window.OnsCarouselItemElement = document.registerElement('ons-carousel-item', {
	  prototype: CarouselItemElement.prototype
	});

	var VerticalModeTrait = {

	  _getScrollDelta: function _getScrollDelta(event) {
	    return event.gesture.deltaY;
	  },

	  _getScrollVelocity: function _getScrollVelocity(event) {
	    return event.gesture.velocityY;
	  },

	  _getElementSize: function _getElementSize() {
	    if (!this._currentElementSize) {
	      this._currentElementSize = this.getBoundingClientRect().height;
	    }

	    return this._currentElementSize;
	  },

	  _generateScrollTransform: function _generateScrollTransform(scroll) {
	    return 'translate3d(0px, ' + -scroll + 'px, 0px)';
	  },

	  _updateDimensionData: function _updateDimensionData() {
	    this._style = window.getComputedStyle(this);
	    this._dimensions = this.getBoundingClientRect();
	  },

	  _updateOffset: function _updateOffset() {
	    if (this.centered) {
	      var height = (this._dimensions.height || 0) - parseInt(this._style.paddingTop, 10) - parseInt(this._style.paddingBottom, 10);
	      this._offset = -(height - this._getCarouselItemSize()) / 2;
	    }
	  },

	  _layoutCarouselItems: function _layoutCarouselItems() {
	    var children = this._getCarouselItemElements();

	    var sizeAttr = this._getCarouselItemSizeAttr();
	    var sizeInfo = this._decomposeSizeString(sizeAttr);

	    for (var i = 0; i < children.length; i++) {
	      children[i].style.position = 'absolute';
	      children[i].style.height = sizeAttr;
	      children[i].style.visibility = 'visible';
	      children[i].style.top = i * sizeInfo.number + sizeInfo.unit;
	    }
	  },

	  _setup: function _setup() {
	    this._updateDimensionData();
	    this._updateOffset();
	    this._layoutCarouselItems();
	  }
	};

	var HorizontalModeTrait = {

	  _getScrollDelta: function _getScrollDelta(event) {
	    return event.gesture.deltaX;
	  },

	  _getScrollVelocity: function _getScrollVelocity(event) {
	    return event.gesture.velocityX;
	  },

	  _getElementSize: function _getElementSize() {
	    if (!this._currentElementSize) {
	      this._currentElementSize = this.getBoundingClientRect().width;
	    }

	    return this._currentElementSize;
	  },

	  _generateScrollTransform: function _generateScrollTransform(scroll) {
	    return 'translate3d(' + -scroll + 'px, 0px, 0px)';
	  },

	  _updateDimensionData: function _updateDimensionData() {
	    this._style = window.getComputedStyle(this);
	    this._dimensions = this.getBoundingClientRect();
	  },

	  _updateOffset: function _updateOffset() {
	    if (this.centered) {
	      var width = (this._dimensions.width || 0) - parseInt(this._style.paddingLeft, 10) - parseInt(this._style.paddingRight, 10);
	      this._offset = -(width - this._getCarouselItemSize()) / 2;
	    }
	  },

	  _layoutCarouselItems: function _layoutCarouselItems() {
	    var children = this._getCarouselItemElements();

	    var sizeAttr = this._getCarouselItemSizeAttr();
	    var sizeInfo = this._decomposeSizeString(sizeAttr);

	    for (var i = 0; i < children.length; i++) {
	      children[i].style.position = 'absolute';
	      children[i].style.width = sizeAttr;
	      children[i].style.visibility = 'visible';
	      children[i].style.left = i * sizeInfo.number + sizeInfo.unit;
	    }
	  },

	  _setup: function _setup() {
	    this._updateDimensionData();
	    this._updateOffset();
	    this._layoutCarouselItems();
	  }
	};

	/**
	 * @element ons-carousel
	 * @category carousel
	 * @description
	 *   [en]
	 *     Carousel component. A carousel can be used to display several items in the same space.
	 *
	 *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen xbbzOQ
	 * @tutorial vanilla/Reference/carousel
	 * @seealso ons-carousel-item
	 *   [en]`<ons-carousel-item>` component[/en]
	 *   [ja]ons-carousel-itemコンポーネント[/ja]
	 * @guide UsingCarousel
	 *   [en]Learn how to use the carousel component.[/en]
	 *   [ja]carouselコンポーネントの使い方[/ja]
	 * @example
	 * <ons-carousel style="width: 100%; height: 200px">
	 *   <ons-carousel-item>
	 *    ...
	 *   </ons-carousel-item>
	 *   <ons-carousel-item>
	 *    ...
	 *   </ons-carousel-item>
	 * </ons-carousel>
	 */

	var CarouselElement = function (_BaseElement) {
	  babelHelpers.inherits(CarouselElement, _BaseElement);

	  function CarouselElement() {
	    babelHelpers.classCallCheck(this, CarouselElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CarouselElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(CarouselElement, [{
	    key: 'createdCallback',


	    /**
	     * @event postchange
	     * @description
	     *   [en]Fired just after the current carousel item has changed.[/en]
	     *   [ja]現在表示しているカルーセルの要素が変わった時に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクトです。[/ja]
	     * @param {Object} event.carousel
	     *   [en]Carousel object.[/en]
	     *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
	     * @param {Number} event.activeIndex
	     *   [en]Current active index.[/en]
	     *   [ja]現在アクティブになっている要素のインデックス。[/ja]
	     * @param {Number} event.lastActiveIndex
	     *   [en]Previous active index.[/en]
	     *   [ja]以前アクティブだった要素のインデックス。[/ja]
	     */

	    /**
	     * @event refresh
	     * @description
	     *   [en]Fired when the carousel has been refreshed.[/en]
	     *   [ja]カルーセルが更新された時に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクトです。[/ja]
	     * @param {Object} event.carousel
	     *   [en]Carousel object.[/en]
	     *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
	     */

	    /**
	     * @event overscroll
	     * @description
	     *   [en]Fired when the carousel has been overscrolled.[/en]
	     *   [ja]カルーセルがオーバースクロールした時に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクトです。[/ja]
	     * @param {Object} event.carousel
	     *   [en]Fired when the carousel has been refreshed.[/en]
	     *   [ja]カルーセルが更新された時に発火します。[/ja]
	     * @param {Number} event.activeIndex
	     *   [en]Current active index.[/en]
	     *   [ja]現在アクティブになっている要素のインデックス。[/ja]
	     * @param {String} event.direction
	     *   [en]Can be one of either "up", "down", "left" or "right".[/en]
	     *   [ja]オーバースクロールされた方向が得られます。"up", "down", "left", "right"のいずれかの方向が渡されます。[/ja]
	     * @param {Function} event.waitToReturn
	     *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
	     *   [ja]この関数はPromiseオブジェクトを引数として受け取ります。渡したPromiseオブジェクトがresolveされるかrejectされるまで、カルーセルはスクロールバックしません。[/ja]
	     */

	    /**
	     * @attribute direction
	     * @type {String}
	     * @description
	     *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
	     *   [ja]カルーセルの方向を指定します。"horizontal"か"vertical"を指定できます。"horizontal"がデフォルト値です。[/ja]
	     */

	    /**
	     * @attribute fullscreen
	     * @description
	     *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
	     *   [ja]この属性があると、absoluteポジションを使ってカルーセルが自動的に画面いっぱいに広がります。[/ja]
	     */

	    /**
	     * @attribute overscrollable
	     * @description
	     *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
	     *   [ja]この属性がある時、タッチやドラッグで端までスクロールした時に、バウンドするような効果が当たります。[/ja]
	     */

	    /**
	     * @attribute centered
	     * @description
	     *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
	     *   [ja]この属性がある時、選んでいるons-carousel-itemはカルーセルの真ん中へ行きます。項目がカルーセルよりも小さい場合にのみ、これは便利です。[/ja]
	     */

	    /**
	     * @attribute item-width
	     * @type {String}
	     * @description
	     *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
	     *    [ja]ons-carousel-itemの幅を指定します。この属性は、direction属性に"horizontal"を指定した時のみ有効になります。[/ja]
	     */

	    /**
	     * @attribute item-height
	     * @type {String}
	     * @description
	     *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
	     *   [ja]ons-carousel-itemの高さを指定します。この属性は、direction属性に"vertical"を指定した時のみ有効になります。[/ja]
	     */

	    /**
	     * @attribute auto-scroll
	     * @description
	     *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
	     *   [ja]この属性がある時、一番近いcarousel-itemの境界まで自動的にスクロールするようになります。[/ja]
	     */

	    /**
	     * @attribute auto-scroll-ratio
	     * @type {Number}
	     * @description
	     *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
	     *    [ja]0.0から1.0までの値を指定します。カルーセルの要素をどれぐらいの割合までドラッグすると次の要素に自動的にスクロールするかを指定します。[/ja]
	     */

	    /**
	     * @attribute swipeable
	     * @description
	     *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
	     *   [ja]この属性がある時、カルーセルをスワイプやドラッグで移動できるようになります。[/ja]
	     */

	    /**
	     * @attribute disabled
	     * @description
	     *   [en]If this attribute is set the carousel is disabled.[/en]
	     *   [ja]この属性がある時、dragやtouchやswipeを受け付けなくなります。[/ja]
	     */

	    /**
	     * @attribute initial-index
	     * @initonly
	     * @type {Number}
	     * @description
	     *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
	     *   [ja]最初に表示するons-carousel-itemを0始まりのインデックスで指定します。デフォルト値は 0 です。[/ja]
	     */

	    /**
	     * @attribute auto-refresh
	     * @description
	     *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
	     *   [ja]この属性がある時、子要素の数が変わるとカルーセルは自動的に更新されるようになります。[/ja]
	     */

	    /**
	     * @attribute animation-options
	     * @type {Expression}
	     * @description
	     *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
	     */

	    value: function createdCallback() {
	      this._doorLock = new DoorLock();
	      this._scroll = 0;
	      this._offset = 0;
	      this._lastActiveIndex = 0;

	      this._boundOnDrag = this._onDrag.bind(this);
	      this._boundOnDragEnd = this._onDragEnd.bind(this);
	      this._boundOnResize = this._onResize.bind(this);

	      this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);

	      this._setup();
	      //添加轮播的点
	      this._addImageBtns();
	      this._setupInitialIndex();

	      this._saveLastState();
	    }
	  }, {
	    key: '_addImageBtns',
	    value: function _addImageBtns() {
	      //当标签上有image属性时,则是图片轮播
	      if (this.hasAttribute('image')) {
	        var children = this._getCarouselItemElements();
	        var btns = util.create('bh-carousel-btns');
	        //设置图片总数
	        btns.setAttribute('count', children.length);
	        //设置位置
	        btns.setAttribute('center', true);
	        btns.setAttribute('bottom', true);
	        this.appendChild(btns);
	      }
	    }
	  }, {
	    key: '_onResize',
	    value: function _onResize() {
	      var i = this._scroll / this._currentElementSize;
	      delete this._currentElementSize;
	      this.setActiveIndex(i);
	    }
	  }, {
	    key: '_onDirectionChange',
	    value: function _onDirectionChange() {
	      if (this._isVertical()) {
	        this.style.overflowX = 'auto';
	        this.style.overflowY = '';
	      } else {
	        this.style.overflowX = '';
	        this.style.overflowY = 'auto';
	      }

	      this.refresh();
	    }
	  }, {
	    key: '_saveLastState',
	    value: function _saveLastState() {
	      this._lastState = {
	        elementSize: this._getCarouselItemSize(),
	        carouselElementCount: this.itemCount,
	        width: this._getCarouselItemSize() * this.itemCount
	      };
	    }

	    /**
	     * @return {Number}
	     */

	  }, {
	    key: '_getCarouselItemSize',
	    value: function _getCarouselItemSize() {
	      var sizeAttr = this._getCarouselItemSizeAttr();
	      var sizeInfo = this._decomposeSizeString(sizeAttr);
	      var elementSize = this._getElementSize();

	      if (sizeInfo.unit === '%') {
	        return Math.round(sizeInfo.number / 100 * elementSize);
	      } else if (sizeInfo.unit === 'px') {
	        return sizeInfo.number;
	      } else {
	        throw new Error('Invalid state');
	      }
	    }

	    /**
	     * @return {Number}
	     */

	  }, {
	    key: '_getInitialIndex',
	    value: function _getInitialIndex() {
	      var index = parseInt(this.getAttribute('initial-index'), 10);

	      if (typeof index === 'number' && !isNaN(index)) {
	        return Math.max(Math.min(index, this.itemCount - 1), 0);
	      } else {
	        return 0;
	      }
	    }

	    /**
	     * @return {String}
	     */

	  }, {
	    key: '_getCarouselItemSizeAttr',
	    value: function _getCarouselItemSizeAttr() {
	      var attrName = 'item-' + (this._isVertical() ? 'height' : 'width');
	      var itemSizeAttr = ('' + this.getAttribute(attrName)).trim();

	      return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
	    }

	    /**
	     * @return {Object}
	     */

	  }, {
	    key: '_decomposeSizeString',
	    value: function _decomposeSizeString(size) {
	      var matches = size.match(/^(\d+)(px|%)/);

	      return {
	        number: parseInt(matches[1], 10),
	        unit: matches[2]
	      };
	    }
	  }, {
	    key: '_setupInitialIndex',
	    value: function _setupInitialIndex() {
	      this._scroll = (this._offset || 0) + this._getCarouselItemSize() * this._getInitialIndex();
	      this._lastActiveIndex = this._getInitialIndex();
	      this._scrollTo(this._scroll);
	    }

	    /**
	     * @method setActiveIndex
	     * @signature setActiveIndex(index, [options])
	     * @param {Number} index
	     *   [en]The index that the carousel should be set to.[/en]
	     *   [ja]carousel要素のインデックスを指定します。[/ja]
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja][/ja]
	     * @param {Function} [options.callback]
	     *   [en]A function that will be called after the animation is finished.[/en]
	     *   [ja][/ja]
	     * @param {String} [options.animation]
	     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
	     *   [ja][/ja]
	     * @param {Object} [options.animationOptions]
	     *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
	     *   [ja][/ja]
	     * @description
	     *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
	     *   [ja]表示するons-carousel-itemをindexで指定します。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the carousel element.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'setActiveIndex',
	    value: function setActiveIndex(index) {
	      var _this2 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
	        throw new Error('options must be an object. You supplied ' + options);
	      }

	      options.animationOptions = util.extend({ duration: 0.3, timing: 'cubic-bezier(.1, .7, .1, 1)' }, options.animationOptions || {}, this.hasAttribute('animation-options') ? util.animationOptionsParse(this.getAttribute('animation-options')) : {});

	      index = Math.max(0, Math.min(index, this.itemCount - 1));
	      var scroll = (this._offset || 0) + this._getCarouselItemSize() * index;
	      var max = this._calculateMaxScroll();

	      this._scroll = Math.max(0, Math.min(max, scroll));
	      return this._scrollTo(this._scroll, options).then(function () {
	        _this2._tryFirePostChangeEvent();
	        return _this2;
	      });
	    }

	    /**
	     * @method getActiveIndex
	     * @signature getActiveIndex()
	     * @return {Number}
	     *   [en]The current carousel item index.[/en]
	     *   [ja]現在表示しているカルーセル要素のインデックスが返されます。[/ja]
	     * @description
	     *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
	     *   [ja]現在表示されているons-carousel-item要素のインデックスを返します。[/ja]
	     */

	  }, {
	    key: 'getActiveIndex',
	    value: function getActiveIndex() {
	      var scroll = this._scroll - (this._offset || 0);
	      var count = this.itemCount;
	      var size = this._getCarouselItemSize();

	      if (scroll < 0) {
	        return 0;
	      }

	      var i = void 0;
	      for (i = 0; i < count; i++) {
	        if (size * i <= scroll && size * (i + 1) > scroll) {
	          return i;
	        }
	      }

	      // max carousel index
	      return i;
	    }

	    /**
	     * @method next
	     * @signature next([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja][/ja]
	     * @param {Function} [options.callback]
	     *   [en]A function that will be executed after the animation has finished.[/en]
	     *   [ja][/ja]
	     * @param {String} [options.animation]
	     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
	     *   [ja][/ja]
	     * @param {Object} [options.animationOptions]
	     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
	     *   [ja][/ja]
	     * @return {Promise}
	     *   [en]Resolves to the carousel element[/en]
	     *   [ja][/ja]
	     * @description
	     *   [en]Show next `<ons-carousel-item>`.[/en]
	     *   [ja]次のons-carousel-itemを表示します。[/ja]
	     */

	  }, {
	    key: 'next',
	    value: function next(options) {
	      return this.setActiveIndex(this.getActiveIndex() + 1, options);
	    }

	    /**
	     * @method prev
	     * @signature prev([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja][/ja]
	     * @param {Function} [options.callback]
	     *   [en]A function that will be executed after the animation has finished.[/en]
	     *   [ja][/ja]
	     * @param {String} [options.animation]
	     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
	     *   [ja][/ja]
	     * @param {Object} [options.animationOptions]
	     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
	     *   [ja][/ja]
	     * @return {Promise}
	     *   [en]Resolves to the carousel element[/en]
	     *   [ja][/ja]
	     * @description
	     *   [en]Show previous `<ons-carousel-item>`.[/en]
	     *   [ja]前のons-carousel-itemを表示します。[/ja]
	     */

	  }, {
	    key: 'prev',
	    value: function prev(options) {
	      return this.setActiveIndex(this.getActiveIndex() - 1, options);
	    }

	    /**
	     * @return {Boolean}
	     */

	  }, {
	    key: '_isEnabledChangeEvent',
	    value: function _isEnabledChangeEvent() {
	      var elementSize = this._getElementSize();
	      var carouselItemSize = this._getCarouselItemSize();

	      return this.autoScroll && elementSize === carouselItemSize;
	    }

	    /**
	     * @return {Boolean}
	     */

	  }, {
	    key: '_isVertical',
	    value: function _isVertical() {
	      return this.getAttribute('direction') === 'vertical';
	    }
	  }, {
	    key: '_prepareEventListeners',
	    value: function _prepareEventListeners() {
	      var _this3 = this;

	      this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1 });
	      this._mutationObserver = new MutationObserver(function () {
	        return _this3.refresh();
	      });

	      this._updateSwipeable();
	      this._updateAutoRefresh();

	      window.addEventListener('resize', this._boundOnResize, true);
	    }
	  }, {
	    key: '_removeEventListeners',
	    value: function _removeEventListeners() {
	      this._gestureDetector.dispose();
	      this._gestureDetector = null;

	      this._mutationObserver.disconnect();
	      this._mutationObserver = null;

	      window.removeEventListener('resize', this._boundOnResize, true);
	    }
	  }, {
	    key: '_updateSwipeable',
	    value: function _updateSwipeable() {
	      if (this._gestureDetector) {
	        if (this.swipeable) {
	          this._gestureDetector.on('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
	          this._gestureDetector.on('dragend', this._boundOnDragEnd);
	        } else {
	          this._gestureDetector.off('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
	          this._gestureDetector.off('dragend', this._boundOnDragEnd);
	        }
	      }
	    }
	  }, {
	    key: '_updateAutoRefresh',
	    value: function _updateAutoRefresh() {
	      if (this._mutationObserver) {
	        if (this.hasAttribute('auto-refresh')) {
	          this._mutationObserver.observe(this, { childList: true });
	        } else {
	          this._mutationObserver.disconnect();
	        }
	      }
	    }
	  }, {
	    key: '_tryFirePostChangeEvent',
	    value: function _tryFirePostChangeEvent() {
	      var currentIndex = this.getActiveIndex();

	      if (this._lastActiveIndex !== currentIndex) {
	        var lastActiveIndex = this._lastActiveIndex;
	        this._lastActiveIndex = currentIndex;

	        util.triggerElementEvent(this, 'postchange', {
	          carousel: this,
	          activeIndex: currentIndex,
	          lastActiveIndex: lastActiveIndex
	        });
	      }
	    }
	  }, {
	    key: '_onDrag',
	    value: function _onDrag(event) {
	      var direction = event.gesture.direction;
	      if (this._isVertical() && (direction === 'left' || direction === 'right') || !this._isVertical() && (direction === 'up' || direction === 'down')) {
	        return;
	      }

	      event.stopPropagation();

	      this._lastDragEvent = event;

	      var scroll = this._scroll - this._getScrollDelta(event);
	      this._scrollTo(scroll);
	      event.gesture.preventDefault();

	      this._tryFirePostChangeEvent();
	    }
	  }, {
	    key: '_onDragEnd',
	    value: function _onDragEnd(event) {
	      var _this4 = this;

	      this._currentElementSize = undefined;

	      this._scroll = this._scroll - this._getScrollDelta(event);

	      if (this._getScrollDelta(event) !== 0) {
	        event.stopPropagation();
	      }

	      if (this._isOverScroll(this._scroll)) {
	        var waitForAction = false;
	        util.triggerElementEvent(this, 'overscroll', {
	          carousel: this,
	          activeIndex: this.getActiveIndex(),
	          direction: this._getOverScrollDirection(),
	          waitToReturn: function waitToReturn(promise) {
	            waitForAction = true;
	            promise.then(function () {
	              return _this4._scrollToKillOverScroll();
	            });
	          }
	        });

	        if (!waitForAction) {
	          this._scrollToKillOverScroll();
	        }
	      } else {
	        this._startMomentumScroll();
	        //轮播切换时,切换高亮的点
	        if (this.hasAttribute('image')) {
	          var i = this._scroll / this._currentElementSize;
	          util.findChild(this, 'bh-carousel-btns').setActiveIndex(i);
	        }
	      }
	      this._lastDragEvent = null;

	      event.gesture.preventDefault();
	    }

	    /**
	     * @param {Object} trait
	     */

	  }, {
	    key: '_mixin',
	    value: function _mixin(trait) {
	      Object.keys(trait).forEach(function (key) {
	        this[key] = trait[key];
	      }.bind(this));
	    }
	  }, {
	    key: '_startMomentumScroll',
	    value: function _startMomentumScroll() {
	      if (this._lastDragEvent) {
	        var velocity = this._getScrollVelocity(this._lastDragEvent);
	        var duration = 0.3;
	        var scrollDelta = duration * 100 * velocity;
	        var scroll = this._normalizeScrollPosition(this._scroll + (this._getScrollDelta(this._lastDragEvent) > 0 ? -scrollDelta : scrollDelta));

	        this._scroll = scroll;

	        animit(this._getCarouselItemElements()).queue({
	          transform: this._generateScrollTransform(this._scroll)
	        }, {
	          duration: duration,
	          timing: 'cubic-bezier(.1, .7, .1, 1)'
	        }).queue(function (done) {
	          done();
	          this._tryFirePostChangeEvent();
	        }.bind(this)).play();
	      }
	    }
	  }, {
	    key: '_normalizeScrollPosition',
	    value: function _normalizeScrollPosition(scroll) {
	      var max = this._calculateMaxScroll();

	      if (!this.autoScroll) {
	        return Math.max(0, Math.min(max, scroll));
	      }
	      var arr = [];
	      var size = this._getCarouselItemSize();
	      var nbrOfItems = this.itemCount;

	      for (var i = 0; i < nbrOfItems; i++) {
	        if (i * size + this._offset < max) {
	          arr.push(i * size + this._offset);
	        }
	      }
	      arr.push(max);

	      arr.sort(function (left, right) {
	        left = Math.abs(left - scroll);
	        right = Math.abs(right - scroll);

	        return left - right;
	      });

	      arr = arr.filter(function (item, pos) {
	        return !pos || item != arr[pos - 1];
	      });

	      var lastScroll = this._lastActiveIndex * size + this._offset;
	      var scrollRatio = Math.abs(scroll - lastScroll) / size;
	      var result = arr[0];

	      if (scrollRatio <= this.autoScrollRatio) {
	        result = lastScroll;
	      } else if (scrollRatio < 1.0) {
	        if (arr[0] === lastScroll && arr.length > 1) {
	          result = arr[1];
	        }
	      }

	      return Math.max(0, Math.min(max, result));
	    }

	    /**
	     * @return {Array}
	     */

	  }, {
	    key: '_getCarouselItemElements',
	    value: function _getCarouselItemElements() {
	      return util.arrayFrom(this.children).filter(function (child) {
	        return child.nodeName.toLowerCase() === 'ons-carousel-item';
	      });
	    }

	    /**
	     * @param {Number} scroll
	     * @param {Object} [options]
	     * @return {Promise} Resolves to the carousel element
	     */

	  }, {
	    key: '_scrollTo',
	    value: function _scrollTo(scroll) {
	      var _this5 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var isOverscrollable = this.overscrollable;

	      var normalizeScroll = function normalizeScroll(scroll) {
	        var ratio = 0.35;

	        if (scroll < 0) {
	          return isOverscrollable ? Math.round(scroll * ratio) : 0;
	        }

	        var maxScroll = _this5._calculateMaxScroll();
	        if (maxScroll < scroll) {
	          return isOverscrollable ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
	        }

	        return scroll;
	      };

	      return new Promise(function (resolve) {
	        animit(_this5._getCarouselItemElements()).queue({
	          transform: _this5._generateScrollTransform(normalizeScroll(scroll))
	        }, options.animation !== 'none' ? options.animationOptions : {}).play(function () {
	          if (options.callback instanceof Function) {
	            options.callback();
	          }
	          resolve();
	        });
	      });
	    }
	  }, {
	    key: '_calculateMaxScroll',
	    value: function _calculateMaxScroll() {
	      var max = this.itemCount * this._getCarouselItemSize() - this._getElementSize();
	      return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
	    }
	  }, {
	    key: '_isOverScroll',
	    value: function _isOverScroll(scroll) {
	      if (scroll < 0 || scroll > this._calculateMaxScroll()) {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: '_getOverScrollDirection',
	    value: function _getOverScrollDirection() {
	      if (this._isVertical()) {
	        return this._scroll <= 0 ? 'up' : 'down';
	      } else {
	        return this._scroll <= 0 ? 'left' : 'right';
	      }
	    }
	  }, {
	    key: '_scrollToKillOverScroll',
	    value: function _scrollToKillOverScroll() {
	      var duration = 0.4;

	      if (this._scroll < 0) {
	        animit(this._getCarouselItemElements()).queue({
	          transform: this._generateScrollTransform(0)
	        }, {
	          duration: duration,
	          timing: 'cubic-bezier(.1, .4, .1, 1)'
	        }).queue(function (done) {
	          done();
	          this._tryFirePostChangeEvent();
	        }.bind(this)).play();
	        this._scroll = 0;
	        return;
	      }

	      var maxScroll = this._calculateMaxScroll();

	      if (maxScroll < this._scroll) {
	        animit(this._getCarouselItemElements()).queue({
	          transform: this._generateScrollTransform(maxScroll)
	        }, {
	          duration: duration,
	          timing: 'cubic-bezier(.1, .4, .1, 1)'
	        }).queue(function (done) {
	          done();
	          this._tryFirePostChangeEvent();
	        }.bind(this)).play();
	        this._scroll = maxScroll;
	        return;
	      }

	      return;
	    }

	    /**
	     * @property itemCount
	     * @readonly
	     * @type {Number}
	     * @description
	     *   [en]The number of carousel items.[/en]
	     *   [ja]カルーセル要素の数です。[/ja]
	     */

	  }, {
	    key: 'refresh',


	    /**
	     * @method refresh
	     * @signature refresh()
	     * @description
	     *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
	     *   [ja]レイアウトや内部の状態を最新のものに更新します。ons-carousel-itemを動的に増やしたり、ons-carouselの大きさを動的に変える際に利用します。[/ja]
	     */
	    value: function refresh() {
	      // Bug fix
	      if (this._getCarouselItemSize() === 0) {
	        return;
	      }

	      this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
	      this._setup();

	      if (this._lastState && this._lastState.width > 0) {
	        var scroll = this._scroll; // - this._offset;

	        if (this._isOverScroll(scroll)) {
	          this._scrollToKillOverScroll();
	        } else {
	          if (this.autoScroll) {
	            scroll = this._normalizeScrollPosition(scroll);
	          }

	          this._scrollTo(scroll);
	        }
	      }

	      this._saveLastState();

	      util.triggerElementEvent(this, 'refresh', { carousel: this });
	    }

	    /**
	     * @method first
	     * @signature first()
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja][/ja]
	     * @param {Function} [options.callback]
	     *   [en]A function that will be executed after the animation has finished.[/en]
	     *   [ja][/ja]
	     * @param {String} [options.animation]
	     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
	     *   [ja][/ja]
	     * @param {Object} [options.animationOptions]
	     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
	     *   [ja][/ja]
	     * @return {Promise}
	     *   [en]Resolves to the carousel element[/en]
	     *   [ja][/ja]
	     * @description
	     *   [en]Show first `<ons-carousel-item>`.[/en]
	     *   [ja]最初のons-carousel-itemを表示します。[/ja]
	     */

	  }, {
	    key: 'first',
	    value: function first(options) {
	      return this.setActiveIndex(0, options);
	    }

	    /**
	     * @method last
	     * @signature last()
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja][/ja]
	     * @param {Function} [options.callback]
	     *   [en]A function that will be executed after the animation has finished.[/en]
	     *   [ja][/ja]
	     * @param {String} [options.animation]
	     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
	     *   [ja][/ja]
	     * @param {Object} [options.animationOptions]
	     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
	     *   [ja][/ja]
	     * @return {Promise}
	     *   [en]Resolves to the carousel element[/en]
	     *   [ja]Resolves to the carousel element[/ja]
	     * @description
	     *   [en]Show last ons-carousel item.[/en]
	     *   [ja]最後のons-carousel-itemを表示します。[/ja]
	     */

	  }, {
	    key: 'last',
	    value: function last(options) {
	      this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this6 = this;

	      this._prepareEventListeners();

	      this._setup();
	      this._setupInitialIndex();

	      this._saveLastState();

	      // Fix rendering glitch on Android 4.1
	      if (this.offsetHeight === 0) {
	        setImmediate(function () {
	          return _this6.refresh();
	        });
	      }
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      switch (name) {
	        case 'swipeable':
	          this._updateSwipeable();
	          break;
	        case 'auto-refresh':
	          this._updateAutoRefresh();
	          break;
	        case 'direction':
	          this._onDirectionChange();
	      }
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this._removeEventListeners();
	    }

	    /**
	     * @property autoScrollRatio
	     * @type {Number}
	     * @description
	     *   [en]The current auto scroll ratio. [/en]
	     *   [ja]現在のオートスクロールのratio値。[/ja]
	     */

	  }, {
	    key: 'itemCount',
	    get: function get() {
	      return this._getCarouselItemElements().length;
	    }
	  }, {
	    key: 'autoScrollRatio',
	    get: function get() {
	      var attr = this.getAttribute('auto-scroll-ratio');

	      if (!attr) {
	        return 0.5;
	      }

	      var scrollRatio = parseFloat(attr);
	      if (scrollRatio < 0.0 || scrollRatio > 1.0) {
	        throw new Error('Invalid ratio.');
	      }

	      return isNaN(scrollRatio) ? 0.5 : scrollRatio;
	    },
	    set: function set(ratio) {
	      if (ratio < 0.0 || ratio > 1.0) {
	        throw new Error('Invalid ratio.');
	      }

	      this.setAttribute('auto-scroll-ratio', ratio);
	    }

	    /**
	     * @property swipeable
	     * @type {Boolean}
	     * @description
	     *   [en]true if the carousel is swipeable.[/en]
	     *   [ja]swipeableであればtrueを返します。[/ja]
	     */

	  }, {
	    key: 'swipeable',
	    get: function get() {
	      return this.hasAttribute('swipeable');
	    },
	    set: function set(value) {
	      return util.toggleAttribute(this, 'swipeable', value);
	    }

	    /**
	     * @property autoScroll
	     * @type {Boolean}
	     * @description
	     *   [en]true if auto scroll is enabled.[/en]
	     *   [ja]オートスクロールが有効であればtrueを返します。[/ja]
	     */

	  }, {
	    key: 'autoScroll',
	    get: function get() {
	      return this.hasAttribute('auto-scroll');
	    },
	    set: function set(value) {
	      return util.toggleAttribute(this, 'auto-scroll', value);
	    }

	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the carousel is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: 'disabled',
	    get: function get() {
	      return this.hasAttribute('disabled');
	    },
	    set: function set(value) {
	      return util.toggleAttribute(this, 'disabled', value);
	    }

	    /**
	     * @property overscrollable
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the carousel is overscrollable or not.[/en]
	     *   [ja]overscrollできればtrueを返します。[/ja]
	     */

	  }, {
	    key: 'overscrollable',
	    get: function get() {
	      return this.hasAttribute('overscrollable');
	    },
	    set: function set(value) {
	      return util.toggleAttribute(this, 'overscrollable', value);
	    }

	    /**
	     * @property centered
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the carousel is centered or not.[/en]
	     *   [ja]centered状態になっていればtrueを返します。[/ja]
	     */

	  }, {
	    key: 'centered',
	    get: function get() {
	      return this.hasAttribute('centered');
	    },
	    set: function set(value) {
	      return util.toggleAttribute(this, 'centered', value);
	    }
	  }]);
	  return CarouselElement;
	}(BaseElement);

	window.OnsCarouselElement = document.registerElement('ons-carousel', {
	  prototype: CarouselElement.prototype
	});

	/**
	 * @element ons-col
	 * @category grid
	 * @description
	 *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
	 *   [ja]グリッドシステムにて列を定義します。ons-rowとともに使用し、コンポーネントのレイアウトに利用します。[/ja]
	 * @note
	 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
	 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-columnを組み合わせた場合に描画が崩れる場合があります。[/ja]
	 * @codepen GgujC {wide}
	 * @guide layouting [en]Layouting guide[/en][ja]レイアウト機能[/ja]
	 * @seealso ons-row
	 *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
	 *   [ja]ons-rowコンポーネント[/ja]
	 * @example
	 * <ons-row>
	 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
	 *   <ons-col>Text</ons-col>
	 * </ons-row>
	 */

	/**
	 * @attribute vertical-align
	 * @type {String}
	 * @description
	 *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
	 *   [ja]縦の配置を指定する。"top", "center", "bottom"のいずれかを指定します。[/ja]
	 */

	/**
	 * @attribute width
	 * @type {String}
	 * @description
	 *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
	 *   [ja]カラムの横幅を指定する。パーセントもしくはピクセルで指定します（10%や50px）。[/ja]
	 */

	var ColumnElement = function (_BaseElement) {
	  babelHelpers.inherits(ColumnElement, _BaseElement);

	  function ColumnElement() {
	    babelHelpers.classCallCheck(this, ColumnElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ColumnElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(ColumnElement, [{
	    key: 'createdCallback',
	    value: function createdCallback() {
	      if (this.getAttribute('width')) {
	        this._updateWidth();
	      }
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'width') {
	        this._updateWidth();
	      }
	    }
	  }, {
	    key: '_updateWidth',
	    value: function _updateWidth() {
	      var width = this.getAttribute('width');
	      if (typeof width === 'string') {
	        width = ('' + width).trim();
	        width = width.match(/^\d+$/) ? width + '%' : width;

	        this.style.webkitBoxFlex = '0';
	        this.style.webkitFlex = '0 0 ' + width;
	        this.style.mozBoxFlex = '0';
	        this.style.mozFlex = '0 0 ' + width;
	        this.style.msFlex = '0 0 ' + width;
	        this.style.flex = '0 0 ' + width;
	        this.style.maxWidth = width;
	      }
	    }
	  }]);
	  return ColumnElement;
	}(BaseElement);

	window.OnsColElement = document.registerElement('ons-col', {
	  prototype: ColumnElement.prototype
	});

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	var DialogAnimator = function () {
	  function DialogAnimator() {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    var _ref$timing = _ref.timing;
	    var timing = _ref$timing === undefined ? 'linear' : _ref$timing;
	    var _ref$delay = _ref.delay;
	    var delay = _ref$delay === undefined ? 0 : _ref$delay;
	    var _ref$duration = _ref.duration;
	    var duration = _ref$duration === undefined ? 0.2 : _ref$duration;
	    babelHelpers.classCallCheck(this, DialogAnimator);

	    this.timing = timing;
	    this.delay = delay;
	    this.duration = duration;
	  }

	  /**
	   * @param {HTMLElement} dialog
	   * @param {Function} done
	   */


	  babelHelpers.createClass(DialogAnimator, [{
	    key: 'show',
	    value: function show(dialog, done) {
	      done();
	    }

	    /**
	     * @param {HTMLElement} dialog
	     * @param {Function} done
	     */

	  }, {
	    key: 'hide',
	    value: function hide(dialog, done) {
	      done();
	    }
	  }]);
	  return DialogAnimator;
	}();

	/**
	 * Android style animator for dialog.
	 */
	var AndroidDialogAnimator = function (_DialogAnimator) {
	  babelHelpers.inherits(AndroidDialogAnimator, _DialogAnimator);

	  function AndroidDialogAnimator() {
	    var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    var _ref2$timing = _ref2.timing;
	    var timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing;
	    var _ref2$delay = _ref2.delay;
	    var delay = _ref2$delay === undefined ? 0 : _ref2$delay;
	    var _ref2$duration = _ref2.duration;
	    var duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;
	    babelHelpers.classCallCheck(this, AndroidDialogAnimator);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AndroidDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
	  }

	  /**
	   * @param {Object} dialog
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(AndroidDialogAnimator, [{
	    key: 'show',
	    value: function show(dialog, callback) {
	      callback = callback ? callback : function () {};

	      animit.runAll(animit(dialog._mask).queue({
	        opacity: 0
	      }).wait(this.delay).queue({
	        opacity: 1.0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }), animit(dialog._dialog).saveStyle().queue({
	        css: {
	          transform: 'translate3d(-50%, -60%, 0)',
	          opacity: 0.0
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3d(-50%, -50%, 0)',
	          opacity: 1.0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }

	    /**
	     * @param {Object} dialog
	     * @param {Function} callback
	     */

	  }, {
	    key: 'hide',
	    value: function hide(dialog, callback) {
	      callback = callback ? callback : function () {};

	      animit.runAll(animit(dialog._mask).queue({
	        opacity: 1.0
	      }).wait(this.delay).queue({
	        opacity: 0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }), animit(dialog._dialog).saveStyle().queue({
	        css: {
	          transform: 'translate3d(-50%, -50%, 0)',
	          opacity: 1.0
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3d(-50%, -60%, 0)',
	          opacity: 0.0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }
	  }]);
	  return AndroidDialogAnimator;
	}(DialogAnimator);

	/**
	 * iOS style animator for dialog.
	 */
	var IOSDialogAnimator = function (_DialogAnimator2) {
	  babelHelpers.inherits(IOSDialogAnimator, _DialogAnimator2);

	  function IOSDialogAnimator() {
	    var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    var _ref3$timing = _ref3.timing;
	    var timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing;
	    var _ref3$delay = _ref3.delay;
	    var delay = _ref3$delay === undefined ? 0 : _ref3$delay;
	    var _ref3$duration = _ref3.duration;
	    var duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;
	    babelHelpers.classCallCheck(this, IOSDialogAnimator);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
	  }

	  /**
	   * @param {Object} dialog
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(IOSDialogAnimator, [{
	    key: 'show',
	    value: function show(dialog, callback) {
	      callback = callback ? callback : function () {};

	      animit.runAll(animit(dialog._mask).queue({
	        opacity: 0
	      }).wait(this.delay).queue({
	        opacity: 1.0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }), animit(dialog._dialog).saveStyle().queue({
	        css: {
	          transform: 'translate3d(-50%, 300%, 0)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3d(-50%, -50%, 0)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }

	    /**
	     * @param {Object} dialog
	     * @param {Function} callback
	     */

	  }, {
	    key: 'hide',
	    value: function hide(dialog, callback) {
	      callback = callback ? callback : function () {};

	      animit.runAll(animit(dialog._mask).queue({
	        opacity: 1.0
	      }).wait(this.delay).queue({
	        opacity: 0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }), animit(dialog._dialog).saveStyle().queue({
	        css: {
	          transform: 'translate3d(-50%, -50%, 0)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3d(-50%, 300%, 0)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }
	  }]);
	  return IOSDialogAnimator;
	}(DialogAnimator);

	/**
	 * Slide animator for dialog.
	 */
	var SlideDialogAnimator = function (_DialogAnimator3) {
	  babelHelpers.inherits(SlideDialogAnimator, _DialogAnimator3);

	  function SlideDialogAnimator() {
	    var _ref4 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    var _ref4$timing = _ref4.timing;
	    var timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing;
	    var _ref4$delay = _ref4.delay;
	    var delay = _ref4$delay === undefined ? 0 : _ref4$delay;
	    var _ref4$duration = _ref4.duration;
	    var duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;
	    babelHelpers.classCallCheck(this, SlideDialogAnimator);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SlideDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
	  }

	  /**
	   * @param {Object} dialog
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(SlideDialogAnimator, [{
	    key: 'show',
	    value: function show(dialog, callback) {
	      callback = callback ? callback : function () {};

	      animit.runAll(animit(dialog._mask).queue({
	        opacity: 0
	      }).wait(this.delay).queue({
	        opacity: 1.0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }), animit(dialog._dialog).saveStyle().queue({
	        css: {
	          transform: 'translate3D(-50%, -350%, 0)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(-50%, -50%, 0)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }

	    /**
	     * @param {Object} dialog
	     * @param {Function} callback
	     */

	  }, {
	    key: 'hide',
	    value: function hide(dialog, callback) {
	      callback = callback ? callback : function () {};

	      animit.runAll(animit(dialog._mask).queue({
	        opacity: 1.0
	      }).wait(this.delay).queue({
	        opacity: 0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }), animit(dialog._dialog).saveStyle().queue({
	        css: {
	          transform: 'translate3D(-50%, -50%, 0)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(-50%, -350%, 0)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }
	  }]);
	  return SlideDialogAnimator;
	}(DialogAnimator);

	var scheme$5 = {
	  '.dialog': 'dialog--*',
	  '.dialog-container': 'dialog-container--*',
	  '.dialog-mask': 'dialog-mask--*'
	};

	var _animatorDict$1 = {
	  'default': function _default() {
	    return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
	  },
	  'fade': function fade() {
	    return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
	  },
	  'slide': SlideDialogAnimator,
	  'none': DialogAnimator
	};

	/**
	 * @element ons-dialog
	 * @category dialog
	 * @description
	 *   [en]
	 *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
	 *
	 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `<ons.createDialog(template)` utility function and the `<ons-template>` tag.
	 *
	 *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
	 *
	 *     It will automatically be displayed as Material Design when running on an Android device.
	 *   [/en]
	 *   [ja][/ja]
	 * @modifier material
	 *   [en]Display a Material Design dialog.[/en]
	 *   [ja]マテリアルデザインのダイアログを表示します。[/ja]
	 * @codepen zxxaGa
	 * @tutorial vanilla/Reference/dialog
	 * @guide UsingDialog
	 *   [en]Learn how to use the dialog component.[/en]
	 *   [ja]ダイアログコンポーネントの使い方[/ja]
	 * @seealso ons-alert-dialog
	 *   [en]`<ons-alert-dialog>` component[/en]
	 *   [ja]ons-alert-dialogコンポーネント[/ja]
	 * @seealso ons-popover
	 *   [en]`<ons-popover>` component[/en]
	 *   [ja]ons-popoverコンポーネント[/ja]
	 * @example
	 * <ons-dialog id="dialog">
	 *   <p>This is a dialog!</p>
	 * </ons-dialog>
	 *
	 * <script>
	 *   document.getElementById('dialog').show();
	 * </script>
	 */

	var DialogElement = function (_BaseElement) {
	  babelHelpers.inherits(DialogElement, _BaseElement);

	  function DialogElement() {
	    babelHelpers.classCallCheck(this, DialogElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(DialogElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(DialogElement, [{
	    key: 'createdCallback',
	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        return _this2._compile();
	      });

	      this._visible = false;
	      this._doorLock = new DoorLock();
	      this._boundCancel = this._cancel.bind(this);

	      this._updateAnimatorFactory();
	    }
	  }, {
	    key: '_updateAnimatorFactory',
	    value: function _updateAnimatorFactory() {
	      this._animatorFactory = new AnimatorFactory({
	        animators: _animatorDict$1,
	        baseClass: DialogAnimator,
	        baseClassName: 'DialogAnimator',
	        defaultAnimation: this.getAttribute('animation')
	      });
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      this.style.display = 'none';

	      /* Expected result:
	       *   <ons-dialog>
	       *     <div class="dialog-mask"></div>
	       *     <div class="dialog">
	       *       <div class="dialog-container">...</div>
	       *     </div>
	       *   </ons-dialog>
	       */

	      if (!this._dialog) {
	        var dialog = document.createElement('div');
	        dialog.classList.add('dialog');

	        var container = document.createElement('div');
	        dialog.classList.add('dialog-container');

	        dialog.appendChild(container);

	        while (this.firstChild) {
	          container.appendChild(this.firstChild);
	        }

	        this.appendChild(dialog);
	      }

	      if (!this._mask) {
	        var mask = document.createElement('div');
	        mask.classList.add('dialog-mask');
	        this.insertBefore(mask, this.firstChild);
	      }

	      this._dialog.style.zIndex = 20001;
	      this._mask.style.zIndex = 20000;

	      this.setAttribute('status-bar-fill', '');

	      ModifierUtil.initModifier(this, scheme$5);
	    }

	    /**
	     * @property onDeviceBackButton
	     * @type {Object}
	     * @description
	     *   [en]Back-button handler.[/en]
	     *   [ja]バックボタンハンドラ。[/ja]
	     */

	  }, {
	    key: '_cancel',
	    value: function _cancel() {
	      var _this3 = this;

	      if (this.cancelable && !this._running) {
	        this._running = true;
	        this.hide({
	          callback: function callback() {
	            _this3._running = false;
	            util.triggerElementEvent(_this3, 'dialog-cancel');
	          }
	        });
	      }
	    }

	    /**
	     * @method show
	     * @signature show([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {String} [options.animation]
	     *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
	     *   [ja]アニメーション名を指定します。"none", "fade", "slide"のいずれかを指定します。[/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
	     * @param {Function} [options.callback]
	     *   [en]This function is called after the dialog has been revealed.[/en]
	     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
	     * @description
	     *  [en]Show the dialog.[/en]
	     *  [ja]ダイアログを開きます。[/ja]
	     * @return {Promise} Resolves to the displayed element.
	     */

	  }, {
	    key: 'show',
	    value: function show() {
	      var _this4 = this;

	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      var _cancel2 = false;
	      var callback = options.callback || function () {};

	      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

	      util.triggerElementEvent(this, 'preshow', {
	        dialog: this,
	        cancel: function cancel() {
	          _cancel2 = true;
	        }
	      });

	      if (!_cancel2) {
	        var _ret = function () {
	          var tryShow = function tryShow() {
	            var unlock = _this4._doorLock.lock();
	            var animator = _this4._animatorFactory.newAnimator(options);

	            _this4.style.display = 'block';
	            _this4._mask.style.opacity = '1';

	            return new Promise(function (resolve) {
	              contentReady(_this4, function () {
	                animator.show(_this4, function () {
	                  _this4._visible = true;
	                  unlock();

	                  util.triggerElementEvent(_this4, 'postshow', { dialog: _this4 });

	                  callback();
	                  resolve(_this4);
	                });
	              });
	            });
	          };

	          return {
	            v: new Promise(function (resolve) {
	              _this4._doorLock.waitUnlock(function () {
	                return resolve(tryShow());
	              });
	            })
	          };
	        }();

	        if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
	      } else {
	        return Promise.reject('Canceled in preshow event.');
	      }
	    }

	    /**
	     * @method hide
	     * @signature hide([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {String} [options.animation]
	     *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
	     *   [ja]アニメーション名を指定します。"none", "fade", "slide"のいずれかを指定できます。[/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
	     * @param {Function} [options.callback]
	     *   [en]This functions is called after the dialog has been hidden.[/en]
	     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
	     * @description
	     *   [en]Hide the dialog.[/en]
	     *   [ja]ダイアログを閉じます。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the hidden element[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'hide',
	    value: function hide() {
	      var _this5 = this;

	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      var _cancel3 = false;
	      var callback = options.callback || function () {};

	      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

	      util.triggerElementEvent(this, 'prehide', {
	        dialog: this,
	        cancel: function cancel() {
	          _cancel3 = true;
	        }
	      });

	      if (!_cancel3) {
	        var _ret2 = function () {
	          var tryHide = function tryHide() {
	            var unlock = _this5._doorLock.lock();
	            var animator = _this5._animatorFactory.newAnimator(options);

	            return new Promise(function (resolve) {
	              contentReady(_this5, function () {
	                animator.hide(_this5, function () {
	                  _this5.style.display = 'none';
	                  _this5._visible = false;
	                  unlock();

	                  util.triggerElementEvent(_this5, 'posthide', { dialog: _this5 });

	                  callback();
	                  resolve(_this5);
	                });
	              });
	            });
	          };

	          return {
	            v: new Promise(function (resolve) {
	              _this5._doorLock.waitUnlock(function () {
	                return resolve(tryHide());
	              });
	            })
	          };
	        }();

	        if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
	      } else {
	        return Promise.reject('Canceled in prehide event.');
	      }
	    }

	    /**
	     * @property visible
	     * @readonly
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the dialog is visible or not.[/en]
	     *   [ja]要素が見える場合に`true`。[/ja]
	     */

	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this6 = this;

	      this.onDeviceBackButton = function (e) {
	        return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
	      };

	      contentReady(this, function () {
	        _this6._mask.addEventListener('click', _this6._boundCancel, false);
	      });
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this._backButtonHandler.destroy();
	      this._backButtonHandler = null;

	      this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
	      } else if (name === 'animation') {
	        this._updateAnimatorFactory();
	      }
	    }
	  }, {
	    key: '_mask',


	    /**
	     * @event preshow
	     * @description
	     * [en]Fired just before the dialog is displayed.[/en]
	     * [ja]ダイアログが表示される直前に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.dialog
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Execute this function to stop the dialog from being shown.[/en]
	     *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
	     */

	    /**
	     * @event postshow
	     * @description
	     * [en]Fired just after the dialog is displayed.[/en]
	     * [ja]ダイアログが表示された直後に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.dialog
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     */

	    /**
	     * @event prehide
	     * @description
	     * [en]Fired just before the dialog is hidden.[/en]
	     * [ja]ダイアログが隠れる直前に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.dialog
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Execute this function to stop the dialog from being hidden.[/en]
	     *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
	     */

	    /**
	     * @event posthide
	     * @description
	     * [en]Fired just after the dialog is hidden.[/en]
	     * [ja]ダイアログが隠れた後に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.dialog
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     */

	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *  [en]The appearance of the dialog.[/en]
	     *  [ja]ダイアログの表現を指定します。[/ja]
	     */

	    /**
	     * @attribute cancelable
	     * @description
	     *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
	     *  [ja][/ja]
	     */

	    /**
	     * @attribute disabled
	     * @description
	     *  [en]If this attribute is set the dialog is disabled.[/en]
	     *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
	     */

	    /**
	     * @attribute animation
	     * @type {String}
	     * @default default
	     * @description
	     *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
	     *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
	     */

	    /**
	     * @attribute animation-options
	     * @type {Expression}
	     * @description
	     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
	     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
	     */

	    /**
	     * @attribute mask-color
	     * @type {String}
	     * @default rgba(0, 0, 0, 0.2)
	     * @description
	     *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
	     *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
	     */

	    get: function get() {
	      return util.findChild(this, '.dialog-mask');
	    }
	  }, {
	    key: '_dialog',
	    get: function get() {
	      return util.findChild(this, '.dialog');
	    }
	  }, {
	    key: 'onDeviceBackButton',
	    get: function get() {
	      return this._backButtonHandler;
	    },
	    set: function set(callback) {
	      if (this._backButtonHandler) {
	        this._backButtonHandler.destroy();
	      }

	      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
	    }
	  }, {
	    key: 'visible',
	    get: function get() {
	      return this._visible;
	    }

	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the dialog is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: 'disabled',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'disabled', value);
	    },
	    get: function get() {
	      return this.hasAttribute('disabled');
	    }

	    /**
	     * @property cancelable
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'cancelable',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'cancelable', value);
	    },
	    get: function get() {
	      return this.hasAttribute('cancelable');
	    }
	  }]);
	  return DialogElement;
	}(BaseElement);

	var OnsDialogElement = window.OnsDialogElement = document.registerElement('ons-dialog', {
	  prototype: DialogElement.prototype
	});

	/**
	 * @param {String} name
	 * @param {DialogAnimator} Animator
	 */
	OnsDialogElement.registerAnimator = function (name, Animator) {
	  if (!(Animator.prototype instanceof DialogAnimator)) {
	    throw new Error('"Animator" param must inherit OnsDialogElement.DialogAnimator');
	  }
	  _animatorDict$1[name] = Animator;
	};

	OnsDialogElement.DialogAnimator = DialogAnimator;

	var scheme$6 = {
	  '': 'fab--*'
	};

	/**
	 * @element ons-fab
	 * @category fab
	 * @description
	 *   [en]
	 *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
	 *
	 *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
	 *   [/en]
	 *   [ja][/ja]
	 * @tutorial vanilla/Reference/fab
	 * @seealso ons-speed-dial
	 *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
	 *   [ja][/ja]
	 */

	var FabElement = function (_BaseElement) {
	  babelHelpers.inherits(FabElement, _BaseElement);

	  function FabElement() {
	    babelHelpers.classCallCheck(this, FabElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(FabElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(FabElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *  [en]The appearance of the button.[/en]
	     *  [ja]ボタンの表現を指定します。[/ja]
	     */

	    /**
	     * @attribute ripple
	     * @description
	     *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
	     *  [ja][/ja]
	     */

	    /**
	     * @attribute position
	     * @type {String}
	     * @description
	     *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
	     *  [ja][/ja]
	     */

	    /**
	     * @attribute disabled
	     * @description
	     *   [en]Specify if button should be disabled.[/en]
	     *   [ja]ボタンを無効化する場合は指定します。[/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        _this2._compile();
	      });
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      var _this3 = this;

	      autoStyle.prepare(this);

	      this.classList.add('fab');

	      if (!util.findChild(this, '.fab__icon')) {
	        (function () {
	          var content = document.createElement('span');
	          content.classList.add('fab__icon');

	          util.arrayFrom(_this3.childNodes).forEach(function (element) {
	            if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
	              content.appendChild(element);
	            }
	          });
	          _this3.appendChild(content);
	        })();
	      }

	      this._updateRipple();

	      ModifierUtil.initModifier(this, scheme$6);

	      this._updatePosition();

	      this.show();
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      switch (name) {
	        case 'modifier':
	          ModifierUtil.onModifierChanged(last, current, this, scheme$6);
	          break;
	        case 'ripple':
	          this._updateRipple();
	          break;
	        case 'position':
	          this._updatePosition();
	      }
	    }
	  }, {
	    key: '_show',
	    value: function _show() {
	      this.show();
	    }
	  }, {
	    key: '_hide',
	    value: function _hide() {
	      this.hide();
	    }
	  }, {
	    key: '_updateRipple',
	    value: function _updateRipple() {
	      util.updateRipple(this);
	    }
	  }, {
	    key: '_updatePosition',
	    value: function _updatePosition() {
	      var position = this.getAttribute('position');
	      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
	      switch (position) {
	        case 'top right':
	        case 'right top':
	          this.classList.add('fab--top__right');
	          break;
	        case 'top left':
	        case 'left top':
	          this.classList.add('fab--top__left');
	          break;
	        case 'bottom right':
	        case 'right bottom':
	          this.classList.add('fab--bottom__right');
	          break;
	        case 'bottom left':
	        case 'left bottom':
	          this.classList.add('fab--bottom__left');
	          break;
	        case 'center top':
	        case 'top center':
	          this.classList.add('fab--top__center');
	          break;
	        case 'center bottom':
	        case 'bottom center':
	          this.classList.add('fab--bottom__center');
	          break;
	        default:
	          break;
	      }
	    }

	    /**
	     * @method show
	     * @signature show()
	     * @description
	     *  [en]Show the floating action button.[/en]
	     *  [ja][/ja]
	     */

	  }, {
	    key: 'show',
	    value: function show() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      this.style.transform = 'scale(1)';
	      this.style.webkitTransform = 'scale(1)';
	    }

	    /**
	     * @method hide
	     * @signature hide()
	     * @description
	     *  [en]Hide the floating action button.[/en]
	     *  [ja][/ja]
	     */

	  }, {
	    key: 'hide',
	    value: function hide() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      this.style.transform = 'scale(0)';
	      this.style.webkitTransform = 'scale(0)';
	    }

	    //noinspection JSAnnotator
	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: 'toggle',


	    /**
	     * @method toggle
	     * @signature toggle()
	     * @description
	     *   [en]Toggle the visibility of the button.[/en]
	     *   [ja][/ja]
	     */
	    value: function toggle() {
	      this.visible ? this.hide() : this.show();
	    }
	  }, {
	    key: 'disabled',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'disabled', value);
	    },
	    get: function get() {
	      return this.hasAttribute('disabled');
	    }

	    /**
	     * @property visible
	     * @readonly
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is visible or not.[/en]
	     *   [ja]要素が見える場合に`true`。[/ja]
	     */

	  }, {
	    key: 'visible',
	    get: function get() {
	      return this.style.transform === 'scale(1)' && this.style.display !== 'none';
	    }
	  }]);
	  return FabElement;
	}(BaseElement);

	window.OnsFabElement = document.registerElement('ons-fab', {
	  prototype: FabElement.prototype
	});

	/**
	 * @element ons-gesture-detector
	 * @category gesture
	 * @description
	 *   [en]Component to detect finger gestures within the wrapped element. See the guide for more details.[/en]
	 *   [ja]要素内のジェスチャー操作を検知します。詳しくはガイドを参照してください。[/ja]
	 * @guide DetectingFingerGestures
	 *   [en]Detecting finger gestures[/en]
	 *   [ja]ジェスチャー操作の検知[/ja]
	 * @example
	 * <ons-gesture-detector style="height: 100%; width: 100%;">
	 *   ...
	 * </ons-gesture-detector>
	 */

	var GestureDetectorElement = function (_BaseElement) {
	  babelHelpers.inherits(GestureDetectorElement, _BaseElement);

	  function GestureDetectorElement() {
	    babelHelpers.classCallCheck(this, GestureDetectorElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(GestureDetectorElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(GestureDetectorElement, [{
	    key: 'createdCallback',
	    value: function createdCallback() {
	      this._gestureDetector = new GestureDetector(this);
	    }
	  }]);
	  return GestureDetectorElement;
	}(BaseElement);

	window.OnsGestureDetectorElement = document.registerElement('ons-gesture-detector', {
	  prototype: GestureDetectorElement.prototype
	});

	/**
	 * @element ons-icon
	 * @category icon
	 * @description
	 *   [en]
	 *     Displays an icon. The following icon suites are available:
	 *
	 *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
	 *     * [Ionicons](http://ionicons.com/)
	 *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen xAhvg
	 * @tutorial vanilla/Reference/icon
	 * @guide UsingIcons [en]Using icons[/en][ja]アイコンを使う[/ja]
	 * @example
	 * <ons-icon
	 *   icon="md-car"
	 *   size="20px"
	 *   style="color: red">
	 * </ons-icon>
	 *
	 * <ons-button>
	 *   <ons-icon icon="md-car"></ons-icon>
	 *   Car
	 * </ons-button>
	 */

	var IconElement = function (_BaseElement) {
	    babelHelpers.inherits(IconElement, _BaseElement);

	    function IconElement() {
	        babelHelpers.classCallCheck(this, IconElement);
	        return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IconElement).apply(this, arguments));
	    }

	    babelHelpers.createClass(IconElement, [{
	        key: 'createdCallback',


	        /**
	         * @attribute icon
	         * @type {String}
	         * @description
	         *   [en]
	         *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
	         *
	         *     See all available icons on their respective sites:
	         *
	         *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
	         *     * [Ionicons](http://ionicons.com)
	         *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
	         *
	         *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
	         *
	         *     The code:
	         *
	         *     ```
	         *     <ons-icon
	         *       icon="ion-edit, material:md-edit">
	         *     </ons-icon>
	         *     ```
	         *
	         *     will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
	         *   [/en]
	         *   [ja][/ja]
	         */

	        /**
	         * @attribute size
	         * @type {String}
	         * @description
	         *   [en]
	         *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
	         *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
	         *
	         *     The code:
	         *
	         *     ```
	         *     <ons-icon
	         *       icon="ion-edit"
	         *       size="32px, material:24px">
	         *     </ons-icon>
	         *     ```
	         *
	         *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
	         *   [/en]
	         *   [ja][/ja]
	         */

	        /**
	         * @attribute rotate
	         * @type {Number}
	         * @description
	         *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
	         *   [ja]アイコンを回転して表示します。90, 180, 270から指定できます。[/ja]
	         */

	        /**
	         * @attribute fixed-width
	         * @type {Boolean}
	         * @default false
	         * @description
	         *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
	         *  [ja][/ja]
	         */

	        /**
	         * @attribute spin
	         * @description
	         *   [en]Specify whether the icon should be spinning.[/en]
	         *   [ja]アイコンを回転するかどうかを指定します。[/ja]
	         */

	        value: function createdCallback() {
	            if (!this.hasAttribute('_compiled')) {
	                this._compile();
	            }
	        }
	    }, {
	        key: 'attributeChangedCallback',
	        value: function attributeChangedCallback(name, last, current) {
	            if (['icon', 'size', 'modifier'].indexOf(name) !== -1) {
	                this._update();
	            }
	        }
	    }, {
	        key: '_compile',
	        value: function _compile() {
	            autoStyle.prepare(this);
	            this._update();
	            this.setAttribute('_compiled', '');
	        }
	    }, {
	        key: '_update',
	        value: function _update() {
	            var _this2 = this;

	            this._cleanClassAttribute();

	            var _buildClassAndStyle2 = this._buildClassAndStyle(this._getAttribute('icon'), this._getAttribute('size'));

	            var classList = _buildClassAndStyle2.classList;
	            var style = _buildClassAndStyle2.style;

	            util.extend(this.style, style);

	            classList.forEach(function (className) {
	                return _this2.classList.add(className);
	            });
	        }
	    }, {
	        key: '_getAttribute',
	        value: function _getAttribute(attr) {
	            var parts = (this.getAttribute(attr) || '').split(/\s*,\s*/);
	            var def = parts[0];
	            var md = parts[1];
	            md = (md || '').split(/\s*:\s*/);
	            return (util.hasModifier(this, md[0]) ? md[1] : def) || '';
	        }

	        /**
	         * Remove unneeded class value.
	         */

	    }, {
	        key: '_cleanClassAttribute',
	        value: function _cleanClassAttribute() {
	            var _this3 = this;

	            util.arrayFrom(this.classList).filter(function (className) {
	                return (/^(fa$|fa-|ion-|zmdi-)/.test(className)
	                );
	            }).forEach(function (className) {
	                return _this3.classList.remove(className);
	            });

	            this.classList.remove('zmdi');
	            this.classList.remove('ons-icon--ion');
	        }
	    }, {
	        key: '_buildClassAndStyle',
	        value: function _buildClassAndStyle(iconName, size) {
	            var classList = ['ons-icon'];
	            var style = {};

	            // Icon
	            // if (iconName.indexOf('ion-') === 0) {
	            //     classList.push(iconName);
	            //     classList.push('ons-icon--ion');
	            // } else if (iconName.indexOf('fa-') === 0) {
	            //     classList.push(iconName);
	            //     classList.push('fa');
	            // } else if (iconName.indexOf('md-') === 0) {
	            //     classList.push('zmdi');
	            //     classList.push('zmdi-' + iconName.split(/\-(.+)?/)[1]);
	            // } else {
	            // }

	            iconName = iconName.replace(/icon\-/g, '');

	            classList.push('iconfont');
	            classList.push('icon-' + iconName);

	            // Size
	            if (size.match(/^[1-5]x|lg$/)) {
	                classList.push('fa-' + size);
	                this.style.removeProperty('font-size');
	            } else {
	                style.fontSize = size;
	            }

	            return {
	                classList: classList,
	                style: style
	            };
	        }
	    }]);
	    return IconElement;
	}(BaseElement);

	window.OnsIconElement = document.registerElement('ons-icon', {
	    prototype: IconElement.prototype
	});

	/**
	 * @element ons-lazy-repeat
	 * @category lazy-repeat
	 * @description
	 *   [en]
	 *     Using this component a list with millions of items can be rendered without a drop in performance.
	 *     It does that by "lazily" loading elements into the DOM when they come into view and
	 *     removing items from the DOM when they are not visible.
	 *   [/en]
	 *   [ja]
	 *     このコンポーネント内で描画されるアイテムのDOM要素の読み込みは、画面に見えそうになった時まで自動的に遅延され、
	 *     画面から見えなくなった場合にはその要素は動的にアンロードされます。
	 *     このコンポーネントを使うことで、パフォーマンスを劣化させること無しに巨大な数の要素を描画できます。
	 *   [/ja]
	 * @codepen QwrGBm
	 * @tutorial vanilla/Reference/lazy-repeat
	 * @seealso ons-list
	 *   [en]The `<ons-list>` element is used to render a list.[/en]
	 *   [ja]`<ons-list>`要素はリストを描画するのに使われます。[/ja]
	 * @guide UsingLazyRepeat
	 *   [en]How to use Lazy Repeat[/en]
	 *   [ja]レイジーリピートの使い方[/ja]
	 * @example
	 * <script>
	 *   window.addEventListener('load', function() {
	 *     var lazyRepeat = document.querySelector('#list');
	 *     lazyRepeat.delegate = {
	 *      createItemContent: function(i, template) {
	 *        var dom = template.cloneNode(true);
	 *        dom.innerText = i;
	 *
	 *        return dom;
	 *      },
	 *      countItems: function() {
	 *        return 10000000;
	 *      },
	 *      destroyItem: function(index, item) {
	 *        console.log('Destroyed item with index: ' + index);
	 *      }
	 *     };
	 *   });
	 * </script>
	 *
	 * <ons-list id="list">
	 *   <ons-lazy-repeat>
	 *     <ons-list-item></ons-list-item>
	 *   </ons-lazy-repeat>
	 * </ons-list>
	 */

	var LazyRepeatElement = function (_BaseElement) {
	  babelHelpers.inherits(LazyRepeatElement, _BaseElement);

	  function LazyRepeatElement() {
	    babelHelpers.classCallCheck(this, LazyRepeatElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(LazyRepeatElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(LazyRepeatElement, [{
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      util.updateParentPosition(this);

	      // not very good idea and also not documented
	      if (this.hasAttribute('delegate')) {
	        this.delegate = window[this.getAttribute('delegate')];
	      }
	    }

	    /**
	     * @property delegate
	     * @type {Object}
	     * @description
	     *  [en]Specify a delegate object to load and unload item elements.[/en]
	     *  [ja]要素のロード、アンロードなどの処理を委譲するオブジェクトを指定します。[/ja]
	     */

	    /**
	     * @property delegate.createItemContent
	     * @type {Function}
	     * @description
	     *   [en]
	     *     This function should return a `HTMLElement`.
	     *
	     *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
	     *   [/en]
	     *   [ja]
	     *     この関数は`HTMLElement`を返してください。
	     *     要素を生成しやすくするために、現在のアイテムのインデックスとテンプレートが引数に渡されます。
	     *     このテンプレートは、`<ons-lazy-repeat>`要素のコンテンツが渡されます。
	     *   [/ja]
	     */

	    /**
	     * @property delegate.countItems
	     * @type {Function}
	     * @description
	     *   [en]Should return the number of items in the list.[/en]
	     *   [ja]リスト内のアイテム数を返してください。[/ja]
	     */

	    /**
	     * @property delegate.calculateItemHeight
	     * @type {Function}
	     * @description
	     *   [en]
	     *     Should return the height of an item. The index is provided as an argument.
	     *
	     *     This is important when rendering lists where the items have different height.
	     *
	     *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
	     *   [/en]
	     *   [ja]
	     *     アイテムの高さ(ピクセル)を返してください。アイテムのインデックス値は引数で渡されます。
	     *     この関数は、それぞれのアイムが違った高さを持つリストをレンダリングする際に重要です。
	     *     この関数はオプショナルです。もしこの関数が無い場合には、
	     *     最初のアイテムの高さが他のすべてのアイテムの高さとして利用されます。
	     *   [/ja]
	     */

	    /**
	     * @property delegate.destroyItem
	     * @type {Function}
	     * @description
	     *   [en]
	     *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
	     *
	     *     The function is optional but may be important in order to avoid memory leaks.
	     *   [/en]
	     *   [ja]
	     *     この関数は、あるアイテムがDOMツリーから除かれた時に呼び出されます。
	     *     アイテムのインデックス値とDOM要素が引数として渡されます。
	     *     この関数はオプショナルですが、各アイテムの後処理が必要な場合にはメモリーリークを避けるために重要です。
	     *   [/ja]
	     */

	  }, {
	    key: 'refresh',


	    /**
	     * @method refresh
	     * @signature refresh()
	     * @description
	     *   [en]Refresh the list. Use this method when the data has changed.[/en]
	     *   [ja]リストを更新します。もしデータが変わった場合にはこのメソッドを使ってください。[/ja]
	     */
	    value: function refresh() {
	      this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {}
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      if (this._lazyRepeatProvider) {
	        this._lazyRepeatProvider.destroy();
	        this._lazyRepeatProvider = null;
	      }
	    }
	  }, {
	    key: 'delegate',
	    set: function set(userDelegate) {
	      this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

	      if (!this._templateElement && this.children[0]) {
	        this._templateElement = this.removeChild(this.children[0]);
	      }

	      var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
	      this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
	    },
	    get: function get() {
	      throw new Error('This property can only be used to set the delegate object.');
	    }
	  }]);
	  return LazyRepeatElement;
	}(BaseElement);

	window.OnsLazyRepeatElement = document.registerElement('ons-lazy-repeat', {
	  prototype: LazyRepeatElement.prototype
	});

	var scheme$7 = { '': 'list__header--*' };

	/**
	 * @element ons-list-header
	 * @category list
	 * @description
	 *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
	 *   [ja]リスト要素に使用するヘッダー用コンポーネント。ons-listと共に使用します。[/ja]
	 * @seealso ons-list
	 *   [en]The `<ons-list>` component[/en]
	 *   [ja]ons-listコンポーネント[/ja]
	 * @seealso ons-list-item
	 *   [en]The `<ons-list-item>` component[/en]
	 *   [ja]ons-list-itemコンポーネント[/ja]
	 * @guide UsingList [en]Using lists[/en][ja]リストを使う[/ja]
	 * @codepen yxcCt
	 * @tutorial vanilla/Reference/list
	 * @modifier material
	 *   [en]Display a Material Design list header.[/en]
	 *   [ja][/ja]
	 * @example
	 * <ons-list>
	 *   <ons-list-header>Header Text</ons-list-header>
	 *   <ons-list-item>Item</ons-list-item>
	 *   <ons-list-item>Item</ons-list-item>
	 * </ons-list>
	 */

	var ListHeaderElement = function (_BaseElement) {
	  babelHelpers.inherits(ListHeaderElement, _BaseElement);

	  function ListHeaderElement() {
	    babelHelpers.classCallCheck(this, ListHeaderElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListHeaderElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(ListHeaderElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *   [en]The appearance of the list header.[/en]
	     *   [ja]ヘッダーの表現を指定します。[/ja]
	     */
	    value: function createdCallback() {
	      if (!this.hasAttribute('_compiled')) {
	        this._compile();
	      }
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      this.classList.add('list__header');
	      ModifierUtil.initModifier(this, scheme$7);

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$7);
	      }
	    }
	  }]);
	  return ListHeaderElement;
	}(BaseElement);

	window.OnsListHeaderElement = document.registerElement('ons-list-header', {
	  prototype: ListHeaderElement.prototype
	});

	var scheme$8 = {
	    '.list__item': 'list__item--*',
	    '.list__item__left': 'list__item--*__left',
	    '.list__item__center': 'list__item--*__center',
	    '.list__item__right': 'list__item--*__right',
	    '.list__item__label': 'list__item--*__label',
	    '.list__item__title': 'list__item--*__title',
	    '.list__item__subtitle': 'list__item--*__subtitle',
	    '.list__item__thumbnail': 'list__item--*__thumbnail',
	    '.list__item__icon': 'list__item--*__icon'
	};

	/**
	 * @element ons-list-item
	 * @category list
	 * @modifier tappable
	 *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
	 *   [ja]タップやクリックした時に効果が表示されるようになります。[/ja]
	 * @modifier chevron
	 *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped. The chevron is not displayed in Material Design.[/en]
	 *   [ja][/ja]
	 * @modifier longdivider
	 *   [en]Displays a long horizontal divider between items.[/en]
	 *   [ja][/ja]
	 * @modifier nodivider
	 *   [en]Removes the divider between list items.[/en]
	 *   [ja][/ja]
	 * @modifier material
	 *   [en]Display a Material Design list item.[/en]
	 *   [ja][/ja]
	 * @description
	 *   [en]
	 *     Component that represents each item in the list. Must be put inside the `<ons-list>` component.
	 *
	 *     The list item is composed of three parts that are represented with the `left`, `center` and `right` classes. These classes can be used to ensure that the content of the list items is properly aligned.
	 *
	 *     ```
	 *     <ons-list-item>
	 *       <div class="left">Left</div>
	 *       <div class="center">Center</div>
	 *       <div class="right">Right</div>
	 *     </ons-list-item>
	 *     ```
	 *
	 *     There is also a number of classes (prefixed with `list__item__*`) that help when putting things like icons and thumbnails into the list items.
	 *   [/en]
	 *   [ja][/ja]
	 * @seealso ons-list
	 *   [en]ons-list component[/en]
	 *   [ja]ons-listコンポーネント[/ja]
	 * @seealso ons-list-header
	 *   [en]ons-list-header component[/en]
	 *   [ja]ons-list-headerコンポーネント[/ja]
	 * @guide UsingList
	 *   [en]Using lists[/en]
	 *   [ja]リストを使う[/ja]
	 * @codepen yxcCt
	 * @tutorial vanilla/Reference/list
	 * @example
	 * <ons-list-item>
	 *   <div class="left">
	 *     <ons-icon icon="md-face" class="list__item__icon"></ons-icon>
	 *   </div>
	 *   <div class="center">
	 *     <div class="list__item__title">Title</div>
	 *     <div class="list__item__subtitle">Subtitle</div>
	 *   </div>
	 *   <div class="right">
	 *     <ons-switch></ons-switch>
	 *   </div>
	 * </ons-list-item>
	 */

	var ListItemElement = function (_BaseElement) {
	    babelHelpers.inherits(ListItemElement, _BaseElement);

	    function ListItemElement() {
	        babelHelpers.classCallCheck(this, ListItemElement);
	        return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListItemElement).apply(this, arguments));
	    }

	    babelHelpers.createClass(ListItemElement, [{
	        key: 'createdCallback',


	        /**
	         * @attribute modifier
	         * @type {String}
	         * @description
	         *   [en]The appearance of the list item.[/en]
	         *   [ja]各要素の表現を指定します。[/ja]
	         */

	        /**
	         * @attribute lock-on-drag
	         * @type {String}
	         * @description
	         *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
	         *   [ja]この属性があると、ユーザーがこの要素を横方向にドラッグしている時に、縦方向のスクロールが起きないようになります。[/ja]
	         */

	        /**
	         * @attribute tappable
	         * @type {Boolean}
	         * @description
	         *   [en]Makes the element react to taps.[/en]
	         *   [ja][/ja]
	         */

	        /**
	         * @attribute tap-background-color
	         * @type {Color}
	         * @description
	         *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
	         *   [ja][/ja]
	         */

	        value: function createdCallback() {
	            var _this2 = this;

	            contentReady(this, function () {
	                _this2._compile();
	            });
	        }
	    }, {
	        key: '_compile',
	        value: function _compile() {
	            autoStyle.prepare(this);
	            this.classList.add('list__item');

	            var left = void 0,
	                center = void 0,
	                right = void 0;

	            for (var i = 0; i < this.children.length; i++) {
	                var el = this.children[i];

	                if (el.classList.contains('left')) {
	                    el.classList.add('list__item__left');
	                    left = el;
	                } else if (el.classList.contains('center')) {
	                    center = el;
	                } else if (el.classList.contains('right')) {
	                    el.classList.add('list__item__right');
	                    right = el;
	                }
	            }

	            if (!center) {
	                center = document.createElement('div');

	                if (!left && !right) {
	                    while (this.childNodes[0]) {
	                        center.appendChild(this.childNodes[0]);
	                    }
	                } else {
	                    for (var _i = this.childNodes.length - 1; _i >= 0; _i--) {
	                        var _el = this.childNodes[_i];
	                        if (_el !== left && _el !== right) {
	                            center.insertBefore(_el, center.firstChild);
	                        }
	                    }
	                }

	                this.insertBefore(center, right || null);
	            }

	            center.classList.add('center');
	            center.classList.add('list__item__center');

	            this._updateRipple();

	            ModifierUtil.initModifier(this, scheme$8);
	        }
	    }, {
	        key: 'attributeChangedCallback',
	        value: function attributeChangedCallback(name, last, current) {
	            switch (name) {
	                case 'modifier':
	                    ModifierUtil.onModifierChanged(last, current, this, scheme$8);
	                    break;
	                case 'ripple':
	                    this._updateRipple();
	            }
	        }
	    }, {
	        key: 'attachedCallback',
	        value: function attachedCallback() {
	            this.addEventListener('drag', this._onDrag);
	            this.addEventListener('touchstart', this._onTouch);
	            this.addEventListener('mousedown', this._onTouch);
	            this.addEventListener('touchend', this._onRelease);
	            this.addEventListener('touchmove', this._onRelease);
	            this.addEventListener('touchcancel', this._onRelease);
	            this.addEventListener('mouseup', this._onRelease);
	            this.addEventListener('mouseout', this._onRelease);
	            this.addEventListener('touchleave', this._onRelease);
	            // if (util.match(this, '.list__item--expand')) {  // 点击展开
	            this.addEventListener('click', this._onClick);
	            // }
	            this._originalBackgroundColor = this.style.backgroundColor;

	            this.tapped = false;
	        }
	    }, {
	        key: 'detachedCallback',
	        value: function detachedCallback() {
	            this.removeEventListener('drag', this._onDrag);
	            this.removeEventListener('touchstart', this._onTouch);
	            this.removeEventListener('mousedown', this._onTouch);
	            this.removeEventListener('touchend', this._onRelease);
	            this.removeEventListener('touchmove', this._onRelease);
	            this.removeEventListener('touchcancel', this._onRelease);
	            this.removeEventListener('mouseup', this._onRelease);
	            this.removeEventListener('mouseout', this._onRelease);
	            this.removeEventListener('touchleave', this._onRelease);
	        }
	    }, {
	        key: '_updateRipple',
	        value: function _updateRipple() {
	            util.updateRipple(this);
	        }
	    }, {
	        key: '_onClick',
	        value: function _onClick(event) {
	            var target = this.getAttribute('target');
	            var next = this.nextElementSibling;
	            if (next && next.nodeName == 'ONS-LIST' && util.hasClass('list--subList')) {
	                if (this.hasAttribute('expand')) {
	                    this.removeAttribute('expand');
	                    next.removeAttribute('expand');
	                } else {
	                    this.setAttribute('expand', '');
	                    next.setAttribute('expand', '');
	                }
	            }
	        }
	    }, {
	        key: '_onDrag',
	        value: function _onDrag(event) {
	            var gesture = event.gesture;
	            // Prevent vertical scrolling if the users pans left or right.
	            if (this._shouldLockOnDrag() && ['left', 'right'].indexOf(gesture.direction) > -1) {
	                gesture.preventDefault();
	            }
	        }
	    }, {
	        key: '_onTouch',
	        value: function _onTouch() {
	            if (this.tapped) {
	                return;
	            }

	            this.tapped = true;

	            this.style.transition = this._transition;
	            this.style.webkitTransition = this._transition;
	            this.style.MozTransition = this._transition;

	            if (this._tappable) {
	                if (this.style.backgroundColor) {
	                    this._originalBackgroundColor = this.style.backgroundColor;
	                }

	                this.style.backgroundColor = this._tapBackgroundColor;
	                this.style.boxShadow = '0px -1px 0px 0px ' + this._tapBackgroundColor;
	            }
	        }
	    }, {
	        key: '_onRelease',
	        value: function _onRelease() {
	            this.tapped = false;

	            this.style.transition = '';
	            this.style.webkitTransition = '';
	            this.style.MozTransition = '';

	            this.style.backgroundColor = this._originalBackgroundColor || '';
	            this.style.boxShadow = '';
	        }
	    }, {
	        key: '_shouldLockOnDrag',
	        value: function _shouldLockOnDrag() {
	            return this.hasAttribute('lock-on-drag');
	        }
	    }, {
	        key: '_transition',
	        get: function get() {
	            return 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s';
	        }
	    }, {
	        key: '_tappable',
	        get: function get() {
	            return this.hasAttribute('tappable');
	        }
	    }, {
	        key: '_tapBackgroundColor',
	        get: function get() {
	            return this.getAttribute('tap-background-color') || '#d9d9d9';
	        }
	    }]);
	    return ListItemElement;
	}(BaseElement);

	window.OnsListItemElement = document.registerElement('ons-list-item', {
	    prototype: ListItemElement.prototype
	});

	var scheme$9 = { '': 'list--*' };

	/**
	 * @element ons-list
	 * @category list
	 * @modifier inset
	 *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
	 *   [ja]親要素の画面いっぱいに広がらないリストを表示します。[/ja]
	 * @modifier noborder
	 *   [en]A list with no borders at the top and bottom.[/en]
	 *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
	 * @description
	 *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
	 *   [ja]リストを表現するためのコンポーネント。ons-list-itemのコンテナとして使用します。[/ja]
	 * @seealso ons-list-item
	 *   [en]ons-list-item component[/en]
	 *   [ja]ons-list-itemコンポーネント[/ja]
	 * @seealso ons-list-header
	 *   [en]ons-list-header component[/en]
	 *   [ja]ons-list-headerコンポーネント[/ja]
	 * @guide UsingList
	 *   [en]Using lists[/en]
	 *   [ja]リストを使う[/ja]
	 * @codepen yxcCt
	 * @tutorial vanilla/Reference/list
	 * @example
	 * <ons-list>
	 *   <ons-list-header>Header Text</ons-list-header>
	 *   <ons-list-item>Item</ons-list-item>
	 *   <ons-list-item>Item</ons-list-item>
	 * </ons-list>
	 */

	var ListElement = function (_BaseElement) {
	  babelHelpers.inherits(ListElement, _BaseElement);

	  function ListElement() {
	    babelHelpers.classCallCheck(this, ListElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(ListElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *   [en]The appearance of the list.[/en]
	     *   [ja]リストの表現を指定します。[/ja]
	     */

	    value: function createdCallback() {
	      if (!this.hasAttribute('_compiled')) {
	        this._compile();
	      }
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      this.classList.add('list');
	      ModifierUtil.initModifier(this, scheme$9);

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$9);
	      }
	    }
	  }]);
	  return ListElement;
	}(BaseElement);

	window.OnsListElement = document.registerElement('ons-list', {
	  prototype: ListElement.prototype
	});

	var scheme$10 = {
	  '.text-input': 'text-input--*',
	  '.text-input__label': 'text-input--*__label',
	  '.radio-button': 'radio-button--*',
	  '.radio-button__input': 'radio-button--*__input',
	  '.radio-button__checkmark': 'radio-button--*__checkmark',
	  '.checkbox': 'checkbox--*',
	  '.checkbox__input': 'checkbox--*__input',
	  '.checkbox__checkmark': 'checkbox--*__checkmark'
	};

	var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'size', 'step', 'type', 'validator', 'value'];

	/**
	 * @element ons-input
	 * @category input
	 * @modifier material
	 *  [en]Displays a Material Design input.[/en]
	 *  [ja][/ja]
	 * @modifier underbar
	 *  [en]Displays a horizontal line underneath a text input.[/en]
	 *  [ja][/ja]
	 * @description
	 *  [en]
	 *    An input element. The `type` attribute can be used to change the input type. All text input types as well as `checkbox` and `radio` are supported.
	 *
	 *    The component will automatically render as a Material Design input on Android devices.
	 *
	 *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.
	 *  [/en]
	 *  [ja][/ja]
	 * @codepen ojQxLj
	 * @tutorial vanilla/Reference/input
	 * @seealso ons-range
	 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
	 *   [ja][/ja]
	 * @seealso ons-switch
	 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
	 *   [ja][/ja]
	 * @guide UsingFormComponents
	 *   [en]Using form components[/en]
	 *   [ja]フォームを使う[/ja]
	 * @guide EventHandling
	 *   [en]Event handling descriptions[/en]
	 *   [ja]イベント処理の使い方[/ja]
	 * @example
	 * <ons-input placeholder="Username" float></ons-input>
	 * <ons-input type="checkbox" checked></ons-input>
	 */

	var InputElement = function (_BaseElement) {
	  babelHelpers.inherits(InputElement, _BaseElement);

	  function InputElement() {
	    babelHelpers.classCallCheck(this, InputElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(InputElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(InputElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute placeholder
	     * @type {String}
	     * @description
	     *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
	     *   [ja][/ja]
	     */

	    /**
	     * @attribute float
	     * @description
	     *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
	     *  [ja]この属性が設定された時、ラベルはアニメーションするようになります。[/ja]
	     */

	    /**
	     * @attribute type
	     * @type {String}
	     * @description
	     *  [en]
	     *    Specify the input type. This is the same as the "type" attribute for normal inputs. However, for "range" you should instead use <ons-range> element.
	     *
	     *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
	     *  [/en]
	     *  [ja][/ja]
	     */

	    /**
	     * @attribute input-id
	     * @type {String}
	     * @description
	     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using <label for="..."> elements.[/en]
	     *  [ja][/ja]
	     */

	    /**
	     * @attribute content-left
	     * @description
	     *  [en]The HTML content of `<ons-input>` is placed before the actual input as a label. Omit this to display it after the input.[/en]
	     *  [ja][/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        _this2._compile();
	        _this2.attributeChangedCallback('checked', null, _this2.getAttribute('checked'));
	      });

	      this._boundOnInput = this._onInput.bind(this);
	      this._boundOnFocusin = this._onFocusin.bind(this);
	      this._boundOnFocusout = this._onFocusout.bind(this);
	      this._boundDelegateEvent = this._delegateEvent.bind(this);
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      if (this.children.length !== 0) {
	        return;
	      }

	      var helper = document.createElement('span');
	      helper.classList.add('_helper');

	      var container = document.createElement('label');
	      container.appendChild(document.createElement('input'));
	      container.appendChild(helper);

	      var label = document.createElement('span');
	      label.classList.add('input-label');

	      util.arrayFrom(this.childNodes).forEach(function (element) {
	        return label.appendChild(element);
	      });
	      this.hasAttribute('content-left') ? container.insertBefore(label, container.firstChild) : container.appendChild(label);

	      this.appendChild(container);

	      switch (this.getAttribute('type')) {
	        case 'checkbox':
	          this.classList.add('checkbox');
	          this._input.classList.add('checkbox__input');
	          this._helper.classList.add('checkbox__checkmark');
	          this._updateBoundAttributes();
	          break;

	        case 'radio':
	          this.classList.add('radio-button');
	          this._input.classList.add('radio-button__input');
	          this._helper.classList.add('radio-button__checkmark');
	          this._updateBoundAttributes();
	          break;

	        default:
	          this._input.classList.add('text-input');
	          this._helper.classList.add('text-input__label');
	          this._input.parentElement.classList.add('text-input__container');

	          this._updateLabel();
	          this._updateLabelColor();
	          this._updateBoundAttributes();
	          this._updateLabelClass();
	          break;
	      }

	      if (this.hasAttribute('input-id')) {
	        this._input.id = this.getAttribute('input-id');
	      }

	      ModifierUtil.initModifier(this, scheme$10);
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      var _this3 = this;

	      if (name === 'modifier') {
	        return contentReady(this, function () {
	          return ModifierUtil.onModifierChanged(last, current, _this3, scheme$10);
	        });
	      } else if (name === 'placeholder') {
	        return contentReady(this, function () {
	          return _this3._updateLabel();
	        });
	      }if (name === 'input-id') {
	        contentReady(this, function () {
	          return _this3._input.id = current;
	        });
	      }if (name === 'checked') {
	        this.checked = current !== null;
	      } else if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
	        return contentReady(this, function () {
	          return _this3._updateBoundAttributes();
	        });
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this4 = this;

	      contentReady(this, function () {
	        if (_this4._input.type !== 'checkbox' && _this4._input.type !== 'radio') {
	          _this4._input.addEventListener('input', _this4._boundOnInput);
	          _this4._input.addEventListener('focusin', _this4._boundOnFocusin);
	          _this4._input.addEventListener('focusout', _this4._boundOnFocusout);
	        }

	        _this4._input.addEventListener('focus', _this4._boundDelegateEvent);
	        _this4._input.addEventListener('blur', _this4._boundDelegateEvent);
	      });
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      var _this5 = this;

	      contentReady(this, function () {
	        _this5._input.removeEventListener('input', _this5._boundOnInput);
	        _this5._input.removeEventListener('focusin', _this5._boundOnFocusin);
	        _this5._input.removeEventListener('focusout', _this5._boundOnFocusout);
	        _this5._input.removeEventListener('focus', _this5._boundDelegateEvent);
	        _this5._input.removeEventListener('blur', _this5._boundDelegateEvent);
	      });
	    }
	  }, {
	    key: '_setLabel',
	    value: function _setLabel(value) {
	      if (typeof this._helper.textContent !== 'undefined') {
	        this._helper.textContent = value;
	      } else {
	        this._helper.innerText = value;
	      }
	    }
	  }, {
	    key: '_updateLabel',
	    value: function _updateLabel() {
	      this._setLabel(this.hasAttribute('placeholder') ? this.getAttribute('placeholder') : '');
	    }
	  }, {
	    key: '_updateBoundAttributes',
	    value: function _updateBoundAttributes() {
	      var _this6 = this;

	      INPUT_ATTRIBUTES.forEach(function (attr) {
	        if (_this6.hasAttribute(attr)) {
	          _this6._input.setAttribute(attr, _this6.getAttribute(attr));
	        } else {
	          _this6._input.removeAttribute(attr);
	        }
	      });
	    }
	  }, {
	    key: '_updateLabelColor',
	    value: function _updateLabelColor() {
	      if (this.value.length > 0 && this._input === document.activeElement) {
	        this._helper.style.color = '';
	      } else {
	        this._helper.style.color = 'rgba(0, 0, 0, 0.5)';
	      }
	    }
	  }, {
	    key: '_updateLabelClass',
	    value: function _updateLabelClass() {
	      if (this.value === '') {
	        this._helper.classList.remove('text-input__label--active');
	      } else if (['checkbox', 'radio'].indexOf(this.getAttribute('type')) === -1) {
	        this._helper.classList.add('text-input__label--active');
	      }
	    }
	  }, {
	    key: '_delegateEvent',
	    value: function _delegateEvent(event) {
	      var e = new CustomEvent(event.type, {
	        bubbles: false,
	        cancelable: true
	      });

	      return this.dispatchEvent(e);
	    }
	  }, {
	    key: '_onInput',
	    value: function _onInput(event) {
	      this._updateLabelClass();
	      this._updateLabelColor();
	    }
	  }, {
	    key: '_onFocusin',
	    value: function _onFocusin(event) {
	      this._updateLabelClass();
	      this._updateLabelColor();
	    }
	  }, {
	    key: '_onFocusout',
	    value: function _onFocusout(event) {
	      this._updateLabelColor();
	    }
	  }, {
	    key: '_input',
	    get: function get() {
	      return this.querySelector('input');
	    }
	  }, {
	    key: '_helper',
	    get: function get() {
	      return this.querySelector('._helper');
	    }

	    /**
	     * @property value
	     * @type {String}
	     * @description
	     *   [en]The current value of the input.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'value',
	    get: function get() {
	      return this._input === null ? this.getAttribute('value') : this._input.value;
	    },
	    set: function set(val) {
	      var _this7 = this;

	      this.setAttribute('value', val);

	      contentReady(this, function () {
	        _this7._input.value = val;
	        _this7._onInput();
	      });

	      return val;
	    }

	    /**
	     * @property checked
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the input is checked or not. Only works for `radio` and `checkbox` type inputs.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'checked',
	    get: function get() {
	      return this._input.checked;
	    },
	    set: function set(val) {
	      var _this8 = this;

	      contentReady(this, function () {
	        _this8._input.checked = val;
	      });
	    }

	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the input is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: 'disabled',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'disabled', value);
	    },
	    get: function get() {
	      return this.hasAttribute('disabled');
	    }
	  }, {
	    key: '_isTextInput',
	    get: function get() {
	      return this.type !== 'radio' && this.type !== 'checkbox';
	    }
	  }, {
	    key: 'type',
	    get: function get() {
	      return this.getAttribute('type');
	    }
	  }]);
	  return InputElement;
	}(BaseElement);

	window.OnsInputElement = document.registerElement('ons-input', {
	  prototype: InputElement.prototype
	});

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	var ModalAnimator = function () {

	  /**
	   * @param {Object} options
	   * @param {String} options.timing
	   * @param {Number} options.duration
	   * @param {Number} options.delay
	   */

	  function ModalAnimator() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    babelHelpers.classCallCheck(this, ModalAnimator);

	    this.delay = 0;
	    this.duration = 0.2;

	    this.timing = options.timing || this.timing;
	    this.duration = options.duration !== undefined ? options.duration : this.duration;
	    this.delay = options.delay !== undefined ? options.delay : this.delay;
	  }

	  /**
	   * @param {HTMLElement} modal
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(ModalAnimator, [{
	    key: "show",
	    value: function show(modal, callback) {
	      callback();
	    }

	    /**
	     * @param {HTMLElement} modal
	     * @param {Function} callback
	     */

	  }, {
	    key: "hide",
	    value: function hide(modal, callback) {
	      callback();
	    }
	  }]);
	  return ModalAnimator;
	}();

	/**
	 * iOS style animator for dialog.
	 */

	var FadeModalAnimator = function (_ModalAnimator) {
	  babelHelpers.inherits(FadeModalAnimator, _ModalAnimator);

	  function FadeModalAnimator(options) {
	    babelHelpers.classCallCheck(this, FadeModalAnimator);

	    options.timing = options.timing || 'linear';
	    options.duration = options.duration || '0.3';
	    options.delay = options.delay || 0;

	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(FadeModalAnimator).call(this, options));
	  }

	  /**
	   * @param {HTMLElement} modal
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(FadeModalAnimator, [{
	    key: 'show',
	    value: function show(modal, callback) {
	      callback = callback ? callback : function () {};

	      animit(modal).queue({
	        opacity: 0
	      }).wait(this.delay).queue({
	        opacity: 1.0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }).queue(function (done) {
	        callback();
	        done();
	      }).play();
	    }

	    /**
	     * @param {HTMLElement} modal
	     * @param {Function} callback
	     */

	  }, {
	    key: 'hide',
	    value: function hide(modal, callback) {
	      callback = callback ? callback : function () {};

	      animit(modal).queue({
	        opacity: 1
	      }).wait(this.delay).queue({
	        opacity: 0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }).queue(function (done) {
	        callback();
	        done();
	      }).play();
	    }
	  }]);
	  return FadeModalAnimator;
	}(ModalAnimator);

	var scheme$11 = {
	  '': 'modal--*',
	  'modal__content': 'modal--*__content'
	};

	var _animatorDict$2 = {
	  'default': ModalAnimator,
	  'fade': FadeModalAnimator,
	  'none': ModalAnimator
	};

	/**
	 * @element ons-modal
	 * @category modal
	 * @description
	 *   [en]
	 *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
	 *
	 *     This component can be used to block user input while some operation is running or to show some information to the user.
	 *   [/en]
	 *   [ja]
	 *     画面全体をマスクするモーダル用コンポーネントです。下側にあるコンポーネントは、
	 *     モーダルが表示されている間はイベント通知が行われません。
	 *   [/ja]
	 * @guide UsingModal
	 *   [en]Using ons-modal component[/en]
	 *   [ja]モーダルの使い方[/ja]
	 * @guide CallingComponentAPIsfromJavaScript
	 *   [en]Using navigator from JavaScript[/en]
	 *   [ja]JavaScriptからコンポーネントを呼び出す[/ja]
	 * @seealso ons-dialog
	 *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
	 *   [ja][/ja]
	 * @codepen devIg
	 * @example
	 * <ons-modal id="modal">
	 *   Modal content
	 * </ons-modal>
	 * <script>
	 *   var modal = document.getElementById('modal');
	 *   modal.show();
	 * </script>
	 */

	var ModalElement = function (_BaseElement) {
	  babelHelpers.inherits(ModalElement, _BaseElement);

	  function ModalElement() {
	    babelHelpers.classCallCheck(this, ModalElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ModalElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(ModalElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute animation
	     * @type {String}
	     * @default default
	     * @description
	     *  [en]The animation used when showing and hiding the modal. Can be either `"none"` or `"fade"`.[/en]
	     *  [ja]モーダルを表示する際のアニメーション名を指定します。"none"もしくは"fade"を指定できます。[/ja]
	     */

	    /**
	     * @attribute animation-options
	     * @type {Expression}
	     * @description
	     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
	     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        _this2._compile();
	      });

	      this._doorLock = new DoorLock();

	      this._animatorFactory = new AnimatorFactory({
	        animators: _animatorDict$2,
	        baseClass: ModalAnimator,
	        baseClassName: 'ModalAnimator',
	        defaultAnimation: this.getAttribute('animation')
	      });
	    }

	    /**
	     * @property onDeviceBackButton
	     * @type {Object}
	     * @description
	     *   [en]Back-button handler.[/en]
	     *   [ja]バックボタンハンドラ。[/ja]
	     */

	  }, {
	    key: '_compile',
	    value: function _compile() {
	      this.style.display = 'none';
	      this.classList.add('modal');

	      if (!util.findChild(this, '.modal__content')) {
	        var content = document.createElement('div');
	        content.classList.add('modal__content');

	        while (this.childNodes[0]) {
	          var node = this.childNodes[0];
	          this.removeChild(node);
	          content.insertBefore(node, null);
	        }

	        this.appendChild(content);
	      }

	      ModifierUtil.initModifier(this, scheme$11);
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      if (this._backButtonHandler) {
	        this._backButtonHandler.destroy();
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      setImmediate(this._ensureNodePosition.bind(this));
	      this.onDeviceBackButton = function () {
	        return undefined;
	      };
	    }
	  }, {
	    key: '_ensureNodePosition',
	    value: function _ensureNodePosition() {
	      if (!this.parentNode || this.hasAttribute('inline')) {
	        return;
	      }

	      if (this.parentNode.nodeName.toLowerCase() !== 'ons-page') {
	        var page = this;
	        for (;;) {
	          page = page.parentNode;

	          if (!page) {
	            return;
	          }

	          if (page.nodeName.toLowerCase() === 'ons-page') {
	            break;
	          }
	        }
	        page._registerExtraElement(this);
	      }
	    }

	    /**
	     * @property visible
	     * @readonly
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is visible or not.[/en]
	     *   [ja]要素が見える場合に`true`。[/ja]
	     */

	  }, {
	    key: 'show',


	    /**
	     * @method show
	     * @signature show([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {String} [options.animation]
	     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
	     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
	     * @description
	     *   [en]Show modal.[/en]
	     *   [ja]モーダルを表示します。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the displayed element[/en]
	     *   [ja][/ja]
	     */
	    value: function show() {
	      var _this3 = this;

	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

	      var callback = options.callback || function () {};

	      var tryShow = function tryShow() {
	        var unlock = _this3._doorLock.lock();
	        var animator = _this3._animatorFactory.newAnimator(options);

	        _this3.style.display = 'table';
	        return new Promise(function (resolve) {
	          animator.show(_this3, function () {
	            unlock();

	            callback();
	            resolve(_this3);
	          });
	        });
	      };

	      return new Promise(function (resolve) {
	        _this3._doorLock.waitUnlock(function () {
	          return resolve(tryShow());
	        });
	      });
	    }

	    /**
	     * @method toggle
	     * @signature toggle([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {String} [options.animation]
	     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
	     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
	     * @description
	     *   [en]Toggle modal visibility.[/en]
	     *   [ja]モーダルの表示を切り替えます。[/ja]
	     */

	  }, {
	    key: 'toggle',
	    value: function toggle() {
	      if (this.visible) {
	        return this.hide.apply(this, arguments);
	      } else {
	        return this.show.apply(this, arguments);
	      }
	    }

	    /**
	     * @method hide
	     * @signature hide([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {String} [options.animation]
	     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
	     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
	     * @description
	     *   [en]Hide modal.[/en]
	     *   [ja]モーダルを非表示にします。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the hidden element[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'hide',
	    value: function hide() {
	      var _this4 = this;

	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

	      var callback = options.callback || function () {};

	      var tryHide = function tryHide() {
	        var unlock = _this4._doorLock.lock();
	        var animator = _this4._animatorFactory.newAnimator(options);

	        return new Promise(function (resolve) {
	          animator.hide(_this4, function () {
	            _this4.style.display = 'none';
	            unlock();

	            callback();
	            resolve(_this4);
	          });
	        });
	      };

	      return new Promise(function (resolve) {
	        _this4._doorLock.waitUnlock(function () {
	          return resolve(tryHide());
	        });
	      });
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$11);
	      }
	    }
	  }, {
	    key: 'onDeviceBackButton',
	    get: function get() {
	      return this._backButtonHandler;
	    },
	    set: function set(handler) {
	      if (this._backButtonHandler) {
	        this._backButtonHandler.destroy();
	      }

	      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, handler);
	    }
	  }, {
	    key: 'visible',
	    get: function get() {
	      return this.style.display !== 'none';
	    }
	  }]);
	  return ModalElement;
	}(BaseElement);

	window.OnsModalElement = document.registerElement('ons-modal', {
	  prototype: ModalElement.prototype
	});

	/**
	 * @param {String} name
	 * @param {Function} Animator
	 */
	window.OnsModalElement.registerAnimator = function (name, Animator) {
	  if (!(Animator.prototype instanceof ModalAnimator)) {
	    throw new Error('"Animator" param must inherit OnsModalElement.ModalAnimator');
	  }
	  _animatorDict$2[name] = Animator;
	};

	window.OnsModalElement.ModalAnimator = ModalAnimator;

	var NavigatorTransitionAnimator = function () {

	  /**
	   * @param {Object} options
	   * @param {String} options.timing
	   * @param {Number} options.duration
	   * @param {Number} options.delay
	   */

	  function NavigatorTransitionAnimator(options) {
	    babelHelpers.classCallCheck(this, NavigatorTransitionAnimator);

	    options = util.extend({
	      timing: 'linear',
	      duration: '0.4',
	      delay: '0'
	    }, options || {});

	    this.timing = options.timing;
	    this.duration = options.duration;
	    this.delay = options.delay;
	  }

	  babelHelpers.createClass(NavigatorTransitionAnimator, [{
	    key: 'push',
	    value: function push(enterPage, leavePage, callback) {
	      callback();
	    }
	  }, {
	    key: 'pop',
	    value: function pop(enterPage, leavePage, callback) {
	      callback();
	    }
	  }]);
	  return NavigatorTransitionAnimator;
	}();

	/**
	 * Slide animator for navigator transition like iOS's screen slide transition.
	 */

	var IOSSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
	  babelHelpers.inherits(IOSSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

	  function IOSSlideNavigatorTransitionAnimator(options) {
	    babelHelpers.classCallCheck(this, IOSSlideNavigatorTransitionAnimator);

	    options = util.extend({
	      duration: 0.4,
	      timing: 'cubic-bezier(.1, .7, .1, 1)',
	      delay: 0
	    }, options || {});

	    var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator).call(this, options));

	    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black; opacity: 0; z-index: 2"></div>\n    ');
	    return _this;
	  }

	  babelHelpers.createClass(IOSSlideNavigatorTransitionAnimator, [{
	    key: '_decompose',
	    value: function _decompose(page) {
	      CustomElements.upgrade(page);
	      var toolbar = page._getToolbarElement();
	      CustomElements.upgrade(toolbar);
	      var left = toolbar._getToolbarLeftItemsElement();
	      var right = toolbar._getToolbarRightItemsElement();

	      var excludeBackButtonLabel = function excludeBackButtonLabel(elements) {
	        var result = [];

	        for (var i = 0; i < elements.length; i++) {
	          if (elements[i].nodeName.toLowerCase() === 'ons-back-button') {
	            var iconElement = elements[i].querySelector('.back-button__icon');
	            if (iconElement) {
	              result.push(iconElement);
	            }
	          } else {
	            result.push(elements[i]);
	          }
	        }

	        return result;
	      };

	      var other = [].concat(left.children.length === 0 ? left : excludeBackButtonLabel(left.children)).concat(right.children.length === 0 ? right : excludeBackButtonLabel(right.children));

	      var pageLabels = [toolbar._getToolbarCenterItemsElement(), toolbar._getToolbarBackButtonLabelElement()];

	      return {
	        pageLabels: pageLabels,
	        other: other,
	        content: page._getContentElement(),
	        background: page._getBackgroundElement(),
	        toolbar: toolbar,
	        bottomToolbar: page._getBottomToolbarElement()
	      };
	    }
	  }, {
	    key: '_shouldAnimateToolbar',
	    value: function _shouldAnimateToolbar(enterPage, leavePage) {
	      var bothPageHasToolbar = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();

	      var noMaterialToolbar = !enterPage._getToolbarElement().classList.contains('navigation-bar--material') && !leavePage._getToolbarElement().classList.contains('navigation-bar--material');

	      return bothPageHasToolbar && noMaterialToolbar;
	    }

	    /**
	     * @param {Object} enterPage
	     * @param {Object} leavePage
	     * @param {Function} callback
	     */

	  }, {
	    key: 'push',
	    value: function push(enterPage, leavePage, callback) {
	      var _this2 = this;

	      this.backgroundMask.remove();
	      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage.nextSibling);

	      var enterPageDecomposition = this._decompose(enterPage);
	      var leavePageDecomposition = this._decompose(leavePage);

	      var delta = function () {
	        var rect = leavePage.getBoundingClientRect();
	        return Math.round((rect.right - rect.left) / 2 * 0.6);
	      }();

	      var maskClear = animit(this.backgroundMask).saveStyle().queue({
	        opacity: 0,
	        transform: 'translate3d(0, 0, 0)'
	      }).wait(this.delay).queue({
	        opacity: 0.1
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        _this2.backgroundMask.remove();
	        done();
	      });

	      var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

	      if (shouldAnimateToolbar) {
	        animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
	          css: {
	            transform: 'translate3D(100%, 0px, 0px)'
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3D(0px, 0px, 0px)'
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle(), animit(enterPageDecomposition.pageLabels).saveStyle().queue({
	          css: {
	            transform: 'translate3d(' + delta + 'px, 0, 0)',
	            opacity: 0
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3d(0, 0, 0)',
	            opacity: 1.0
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
	          css: { opacity: 0 },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: { opacity: 1 },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle(), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).saveStyle().queue({
	          css: {
	            transform: 'translate3D(0, 0, 0)'
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3D(-25%, 0px, 0px)'
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle().queue(function (done) {
	          callback();
	          done();
	        }), animit(leavePageDecomposition.pageLabels).saveStyle().queue({
	          css: {
	            transform: 'translate3d(0, 0, 0)',
	            opacity: 1.0
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3d(-' + delta + 'px, 0, 0)',
	            opacity: 0
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle(), animit(leavePageDecomposition.other).saveStyle().queue({
	          css: { opacity: 1 },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: { opacity: 0 },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle());
	      } else {

	        animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
	          css: {
	            transform: 'translate3D(100%, 0px, 0px)'
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3D(0px, 0px, 0px)'
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle(), animit(leavePage).saveStyle().queue({
	          css: {
	            transform: 'translate3D(0, 0, 0)'
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3D(-25%, 0px, 0px)'
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle().queue(function (done) {
	          callback();
	          done();
	        }));
	      }
	    }

	    /**
	     * @param {Object} enterPage
	     * @param {Object} leavePage
	     * @param {Function} done
	     */

	  }, {
	    key: 'pop',
	    value: function pop(enterPage, leavePage, done) {
	      this.backgroundMask.remove();
	      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

	      var enterPageDecomposition = this._decompose(enterPage);
	      var leavePageDecomposition = this._decompose(leavePage);

	      var delta = function () {
	        var rect = leavePage.getBoundingClientRect();
	        return Math.round((rect.right - rect.left) / 2 * 0.6);
	      }();

	      var maskClear = animit(this.backgroundMask).saveStyle().queue({
	        opacity: 0.1,
	        transform: 'translate3d(0, 0, 0)'
	      }).wait(this.delay).queue({
	        opacity: 0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        done();
	      });

	      var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

	      if (shouldAnimateToolbar) {
	        animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
	          css: {
	            transform: 'translate3D(-25%, 0px, 0px)',
	            opacity: 0.9
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3D(0px, 0px, 0px)',
	            opacity: 1.0
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle(), animit(enterPageDecomposition.pageLabels).saveStyle().queue({
	          css: {
	            transform: 'translate3d(-' + delta + 'px, 0, 0)',
	            opacity: 0
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3d(0, 0, 0)',
	            opacity: 1.0
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle(), animit(enterPageDecomposition.toolbar).saveStyle().queue({
	          css: {
	            transform: 'translate3d(0, 0, 0)',
	            opacity: 1.0
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3d(0, 0, 0)',
	            opacity: 1.0
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
	          css: { opacity: 0 },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: { opacity: 1 },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle(), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).queue({
	          css: {
	            transform: 'translate3D(0px, 0px, 0px)'
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3D(100%, 0px, 0px)'
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).wait(0).queue(function (finish) {
	          this.backgroundMask.remove();
	          done();
	          finish();
	        }.bind(this)), animit(leavePageDecomposition.other).queue({
	          css: {
	            transform: 'translate3d(0, 0, 0)',
	            opacity: 1
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3d(0, 0, 0)',
	            opacity: 0
	          },
	          duration: this.duration,
	          timing: this.timing
	        }), animit(leavePageDecomposition.toolbar).queue({
	          css: {
	            background: 'none',
	            backgroundColor: 'rgba(0, 0, 0, 0)',
	            borderColor: 'rgba(0, 0, 0, 0)'
	          },
	          duration: 0
	        }), animit(leavePageDecomposition.pageLabels).queue({
	          css: {
	            transform: 'translate3d(0, 0, 0)',
	            opacity: 1.0
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3d(' + delta + 'px, 0, 0)',
	            opacity: 0
	          },
	          duration: this.duration,
	          timing: this.timing
	        }));
	      } else {
	        animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
	          css: {
	            transform: 'translate3D(-25%, 0px, 0px)',
	            opacity: 0.9
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3D(0px, 0px, 0px)',
	            opacity: 1.0
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).restoreStyle(), animit(leavePage).queue({
	          css: {
	            transform: 'translate3D(0px, 0px, 0px)'
	          },
	          duration: 0
	        }).wait(this.delay).queue({
	          css: {
	            transform: 'translate3D(100%, 0px, 0px)'
	          },
	          duration: this.duration,
	          timing: this.timing
	        }).queue(function (finish) {
	          this.backgroundMask.remove();
	          done();
	          finish();
	        }.bind(this)));
	      }
	    }
	  }]);
	  return IOSSlideNavigatorTransitionAnimator;
	}(NavigatorTransitionAnimator);

	/**
	 * Lift screen transition.
	 */

	var IOSLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
	  babelHelpers.inherits(IOSLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

	  function IOSLiftNavigatorTransitionAnimator(options) {
	    babelHelpers.classCallCheck(this, IOSLiftNavigatorTransitionAnimator);

	    options = util.extend({
	      duration: 0.4,
	      timing: 'cubic-bezier(.1, .7, .1, 1)',
	      delay: 0
	    }, options || {});

	    var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator).call(this, options));

	    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background: linear-gradient(black, white);"></div>\n    ');
	    return _this;
	  }

	  /**
	   * @param {Object} enterPage
	   * @param {Object} leavePage
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(IOSLiftNavigatorTransitionAnimator, [{
	    key: 'push',
	    value: function push(enterPage, leavePage, callback) {
	      var _this2 = this;

	      this.backgroundMask.remove();
	      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

	      var maskClear = animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
	        _this2.backgroundMask.remove();
	        done();
	      });

	      animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
	        css: {
	          transform: 'translate3D(0, 100%, 0)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }), animit(leavePage).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 1.0
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, -10%, 0)',
	          opacity: 0.9
	        },
	        duration: this.duration,
	        timing: this.timing
	      }));
	    }

	    /**
	     * @param {Object} enterPage
	     * @param {Object} leavePage
	     * @param {Function} callback
	     */

	  }, {
	    key: 'pop',
	    value: function pop(enterPage, leavePage, callback) {
	      var _this3 = this;

	      this.backgroundMask.remove();
	      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

	      animit.runAll(animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
	        _this3.backgroundMask.remove();
	        done();
	      }), animit(enterPage).queue({
	        css: {
	          transform: 'translate3D(0, -10%, 0)',
	          opacity: 0.9
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 1.0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).queue(function (done) {
	        callback();
	        done();
	      }), animit(leavePage).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 100%, 0)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }));
	    }
	  }]);
	  return IOSLiftNavigatorTransitionAnimator;
	}(NavigatorTransitionAnimator);

	/**
	 * Fade-in screen transition.
	 */

	var IOSFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
	  babelHelpers.inherits(IOSFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

	  function IOSFadeNavigatorTransitionAnimator(options) {
	    babelHelpers.classCallCheck(this, IOSFadeNavigatorTransitionAnimator);

	    options = util.extend({
	      timing: 'linear',
	      duration: '0.4',
	      delay: '0'
	    }, options || {});

	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator).call(this, options));
	  }

	  /**
	   * @param {Object} enterPage
	   * @param {Object} leavePage
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(IOSFadeNavigatorTransitionAnimator, [{
	    key: 'push',
	    value: function push(enterPage, leavePage, callback) {

	      animit.runAll(animit([enterPage._getContentElement(), enterPage._getBackgroundElement()]).saveStyle().queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 0
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 1
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }), animit(enterPage._getToolbarElement()).saveStyle().queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 0
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 1
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle());
	    }

	    /**
	     * @param {Object} enterPage
	     * @param {Object} leavePage
	     * @param {Function} done
	     */

	  }, {
	    key: 'pop',
	    value: function pop(enterPage, leavePage, callback) {
	      animit.runAll(animit([leavePage._getContentElement(), leavePage._getBackgroundElement()]).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 1
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).queue(function (done) {
	        callback();
	        done();
	      }), animit(leavePage._getToolbarElement()).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 1
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }));
	    }
	  }]);
	  return IOSFadeNavigatorTransitionAnimator;
	}(NavigatorTransitionAnimator);

	/**
	 * Slide animator for navigator transition.
	 */

	var MDSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
	  babelHelpers.inherits(MDSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

	  function MDSlideNavigatorTransitionAnimator(options) {
	    babelHelpers.classCallCheck(this, MDSlideNavigatorTransitionAnimator);

	    options = util.extend({
	      duration: 0.3,
	      timing: 'cubic-bezier(.1, .7, .4, 1)',
	      delay: 0
	    }, options || {});

	    var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator).call(this, options));

	    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%; z-index: 2;\n        background-color: black; opacity: 0;"></div>\n    ');
	    _this.blackMaskOpacity = 0.4;
	    return _this;
	  }

	  /**
	   * @param {Object} enterPage
	   * @param {Object} leavePage
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(MDSlideNavigatorTransitionAnimator, [{
	    key: 'push',
	    value: function push(enterPage, leavePage, callback) {
	      var _this2 = this;

	      this.backgroundMask.remove();
	      leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

	      animit.runAll(animit(this.backgroundMask).saveStyle().queue({
	        opacity: 0,
	        transform: 'translate3d(0, 0, 0)'
	      }).wait(this.delay).queue({
	        opacity: this.blackMaskOpacity
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        _this2.backgroundMask.remove();
	        done();
	      }), animit(enterPage).saveStyle().queue({
	        css: {
	          transform: 'translate3D(100%, 0, 0)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle(), animit(leavePage).saveStyle().queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(-45%, 0px, 0px)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().wait(0.2).queue(function (done) {
	        callback();
	        done();
	      }));
	    }

	    /**
	     * @param {Object} enterPage
	     * @param {Object} leavePage
	     * @param {Function} done
	     */

	  }, {
	    key: 'pop',
	    value: function pop(enterPage, leavePage, done) {
	      var _this3 = this;

	      this.backgroundMask.remove();
	      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

	      animit.runAll(animit(this.backgroundMask).saveStyle().queue({
	        opacity: this.blackMaskOpacity,
	        transform: 'translate3d(0, 0, 0)'
	      }).wait(this.delay).queue({
	        opacity: 0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        _this3.backgroundMask.remove();
	        done();
	      }), animit(enterPage).saveStyle().queue({
	        css: {
	          transform: 'translate3D(-45%, 0px, 0px)',
	          opacity: 0.9
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0px, 0px, 0px)',
	          opacity: 1.0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle(), animit(leavePage).queue({
	        css: {
	          transform: 'translate3D(0px, 0px, 0px)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(100%, 0px, 0px)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).wait(0.2).queue(function (finish) {
	        done();
	        finish();
	      }));
	    }
	  }]);
	  return MDSlideNavigatorTransitionAnimator;
	}(NavigatorTransitionAnimator);

	/**
	 * Lift screen transition.
	 */

	var MDLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
	  babelHelpers.inherits(MDLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

	  function MDLiftNavigatorTransitionAnimator(options) {
	    babelHelpers.classCallCheck(this, MDLiftNavigatorTransitionAnimator);

	    options = util.extend({
	      duration: 0.4,
	      timing: 'cubic-bezier(.1, .7, .1, 1)',
	      delay: 0.05
	    }, options || {});

	    var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator).call(this, options));

	    _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black;"></div>\n    ');
	    return _this;
	  }

	  /**
	   * @param {Object} enterPage
	   * @param {Object} leavePage
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(MDLiftNavigatorTransitionAnimator, [{
	    key: 'push',
	    value: function push(enterPage, leavePage, callback) {
	      var _this2 = this;

	      this.backgroundMask.remove();
	      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

	      var maskClear = animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
	        _this2.backgroundMask.remove();
	        done();
	      });

	      animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
	        css: {
	          transform: 'translate3D(0, 100%, 0)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }), animit(leavePage).queue({
	        css: {
	          opacity: 1.0
	        },
	        duration: 0
	      }).queue({
	        css: {
	          opacity: 0.4
	        },
	        duration: this.duration,
	        timing: this.timing
	      }));
	    }

	    /**
	     * @param {Object} enterPage
	     * @param {Object} leavePage
	     * @param {Function} callback
	     */

	  }, {
	    key: 'pop',
	    value: function pop(enterPage, leavePage, callback) {
	      var _this3 = this;

	      this.backgroundMask.remove();
	      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

	      animit.runAll(animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
	        _this3.backgroundMask.remove();
	        done();
	      }), animit(enterPage).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 0.4
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 1.0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).queue(function (done) {
	        callback();
	        done();
	      }), animit(leavePage).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)'
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 100%, 0)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }));
	    }
	  }]);
	  return MDLiftNavigatorTransitionAnimator;
	}(NavigatorTransitionAnimator);

	/**
	 * Fade-in + Lift screen transition.
	 */

	var MDFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
	  babelHelpers.inherits(MDFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

	  function MDFadeNavigatorTransitionAnimator(options) {
	    babelHelpers.classCallCheck(this, MDFadeNavigatorTransitionAnimator);

	    options = util.extend({
	      timing: 'ease-out',
	      duration: '0.25',
	      delay: '0'
	    }, options || {});

	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator).call(this, options));
	  }

	  /**
	   * @param {Object} enterPage
	   * @param {Object} leavePage
	   * @param {Function} callback
	   */


	  babelHelpers.createClass(MDFadeNavigatorTransitionAnimator, [{
	    key: 'push',
	    value: function push(enterPage, leavePage, callback) {

	      animit.runAll(animit(enterPage).saveStyle().queue({
	        css: {
	          transform: 'translate3D(0, 42px, 0)',
	          opacity: 0
	        },
	        duration: 0
	      }).wait(this.delay).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)',
	          opacity: 1
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (done) {
	        callback();
	        done();
	      }));
	    }

	    /**
	     * @param {Object} enterPage
	     * @param {Object} leavePage
	     * @param {Function} done
	     */

	  }, {
	    key: 'pop',
	    value: function pop(enterPage, leavePage, callback) {
	      animit.runAll(animit(leavePage).queue({
	        css: {
	          transform: 'translate3D(0, 0, 0)'
	        },
	        duration: 0
	      }).wait(0.15).queue({
	        css: {
	          transform: 'translate3D(0, 38px, 0)'
	        },
	        duration: this.duration,
	        timing: this.timing
	      }).queue(function (done) {
	        callback();
	        done();
	      }), animit(leavePage).queue({
	        css: {
	          opacity: 1
	        },
	        duration: 0
	      }).wait(0.04).queue({
	        css: {
	          opacity: 0
	        },
	        duration: this.duration,
	        timing: this.timing
	      }));
	    }
	  }]);
	  return MDFadeNavigatorTransitionAnimator;
	}(NavigatorTransitionAnimator);

	var NoneNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
	  babelHelpers.inherits(NoneNavigatorTransitionAnimator, _NavigatorTransitionA);

	  function NoneNavigatorTransitionAnimator(options) {
	    babelHelpers.classCallCheck(this, NoneNavigatorTransitionAnimator);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(NoneNavigatorTransitionAnimator).call(this, options));
	  }

	  babelHelpers.createClass(NoneNavigatorTransitionAnimator, [{
	    key: 'push',
	    value: function push(enterPage, leavePage, callback) {
	      callback();
	    }
	  }, {
	    key: 'pop',
	    value: function pop(enterPage, leavePage, callback) {
	      callback();
	    }
	  }]);
	  return NoneNavigatorTransitionAnimator;
	}(NavigatorTransitionAnimator);

	var _animatorDict$3 = {
	  'default': function _default() {
	    return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
	  },
	  'slide': function slide() {
	    return platform.isAndroid() ? MDSlideNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
	  },
	  'lift': function lift() {
	    return platform.isAndroid() ? MDLiftNavigatorTransitionAnimator : IOSLiftNavigatorTransitionAnimator;
	  },
	  'fade': function fade() {
	    return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSFadeNavigatorTransitionAnimator;
	  },
	  'slide-ios': IOSSlideNavigatorTransitionAnimator,
	  'slide-md': MDSlideNavigatorTransitionAnimator,
	  'lift-ios': IOSLiftNavigatorTransitionAnimator,
	  'lift-md': MDLiftNavigatorTransitionAnimator,
	  'fade-ios': IOSFadeNavigatorTransitionAnimator,
	  'fade-md': MDFadeNavigatorTransitionAnimator,
	  'none': NoneNavigatorTransitionAnimator
	};

	var rewritables = {
	  /**
	   * @param {Element} navigatorSideElement
	   * @param {Function} callback
	   */

	  ready: function ready(navigatorElement, callback) {
	    callback();
	  },


	  /**
	   * @param {Element} navigatorElement
	   * @param {Element} target
	   * @param {Object} options
	   * @param {Function} callback
	   */
	  link: function link(navigatorElement, target, options, callback) {
	    callback(target);
	  }
	};

	/**
	 * @element ons-navigator
	 * @category navigation
	 * @description
	 *   [en]
	 *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
	 *
	 *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen yrhtv
	 * @tutorial vanilla/Reference/navigator
	 * @guide PageNavigation
	 *   [en]Guide for page navigation[/en]
	 *   [ja]ページナビゲーションの概要[/ja]
	 * @guide CallingComponentAPIsfromJavaScript
	 *   [en]Using navigator from JavaScript[/en]
	 *   [ja]JavaScriptからコンポーネントを呼び出す[/ja]
	 * @guide EventHandling
	 *   [en]Event handling descriptions[/en]
	 *   [ja]イベント処理の使い方[/ja]
	 * @guide DefiningMultiplePagesinSingleHTML
	 *   [en]Defining multiple pages in single html[/en]
	 *   [ja]複数のページを1つのHTMLに記述する[/ja]
	 * @seealso ons-toolbar
	 *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
	 *   [ja][/ja]
	 * @seealso ons-back-button
	 *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
	 *   [ja][/ja]
	 * @example
	 * <ons-navigator id="navigator">
	 *   <ons-page>
	 *     <ons-toolbar>
	 *       <div class="center">
	 *         Title
	 *       </div>
	 *     </ons-toolbar>
	 *     <p>
	 *       <ons-button
	 *         onclick="document.getElementById('navigator').pushPage('page.html')">
	 *         Push page
	 *       </ons-button>
	 *     </p>
	 *   </ons-page>
	 * </ons-navigator>
	 *
	 * <ons-template id="page.html">
	 *   <ons-page>
	 *     <ons-toolbar>
	 *       <div class="left">
	 *         <ons-back-button>Back</ons-back-button>
	 *       </div>
	 *       <div class="center">
	 *         Another page
	 *       </div>
	 *     </ons-toolbar>
	 *   </ons-page>
	 * </ons-template>
	 */

	var NavigatorElement = function (_BaseElement) {
	  babelHelpers.inherits(NavigatorElement, _BaseElement);

	  function NavigatorElement() {
	    babelHelpers.classCallCheck(this, NavigatorElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(NavigatorElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(NavigatorElement, [{
	    key: 'createdCallback',
	    value: function createdCallback() {
	      this._isRunning = false;

	      this._updateAnimatorFactory();
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this2 = this;

	      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);

	      rewritables.ready(this, function () {
	        if (_this2.pages.length === 0 && _this2.hasAttribute('page')) {
	          _this2.pushPage(_this2.getAttribute('page'), { animation: 'none' });
	        } else {
	          for (var i = 0; i < _this2.pages.length; i++) {
	            if (_this2.pages[i].nodeName !== 'ONS-PAGE') {
	              throw new Error('The children of <ons-navigator> need to be of type <ons-page>');
	            }
	          }

	          if (_this2.topPage) {
	            setTimeout(function () {
	              _this2.topPage._show();
	              _this2._updateLastPageBackButton();
	            }, 0);
	          }
	        }
	      });
	    }
	  }, {
	    key: '_updateAnimatorFactory',
	    value: function _updateAnimatorFactory() {
	      this._animatorFactory = new AnimatorFactory({
	        animators: _animatorDict$3,
	        baseClass: NavigatorTransitionAnimator,
	        baseClassName: 'NavigatorTransitionAnimator',
	        defaultAnimation: this.getAttribute('animation')
	      });
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this._backButtonHandler.destroy();
	      this._backButtonHandler = null;
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'animation') {
	        this._updateAnimatorFactory();
	      }
	    }

	    /**
	     * @method popPage
	     * @signature popPage([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {String} [options.animation]
	     *   [en]
	     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
	     *
	     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
	     *   [/en]
	     *   [ja][/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
	     * @param {Boolean} [options.refresh]
	     *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
	     *   [ja]popPageする前に、前にあるページを生成しなおして更新する場合にtrueを指定します。[/ja]
	     * @param {Function} [options.callback]
	     *   [en]Function that is called when the transition has ended.[/en]
	     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
	     * @return {Promise}
	     *   [en]Promise which resolves to the revealed page.[/en]
	     *   [ja]明らかにしたページを解決するPromiseを返します。[/ja]
	     * @description
	     *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
	     *   [ja]現在表示中のページをページスタックから取り除きます。一つ前のページに戻ります。[/ja]
	     */

	  }, {
	    key: 'popPage',
	    value: function popPage() {
	      var _this3 = this;

	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      var popUpdate = function popUpdate() {
	        return new Promise(function (resolve) {
	          _this3.pages[_this3.pages.length - 1]._destroy();
	          resolve();
	        });
	      };
	      options = this._prepareOptions(options);

	      if (!options.refresh) {
	        return this._popPage(options, popUpdate);
	      }
	      var index = this.pages.length - 2;

	      if (!this.pages[index].name) {
	        throw new Error('Refresh option cannot be used with pages directly inside the Navigator. Use ons-template instead.');
	      }

	      return new Promise(function (resolve) {
	        internal.getPageHTMLAsync(_this3.pages[index].name).then(function (templateHTML) {
	          var element = util.extend(_this3._createPageElement(templateHTML), {
	            name: _this3.pages[index].name,
	            data: _this3.pages[index].data,
	            pushedOptions: _this3.pages[index].pushedOptions
	          });

	          rewritables.link(_this3, element, _this3.pages[index].options, function (element) {
	            _this3.insertBefore(element, _this3.pages[index] ? _this3.pages[index] : null);
	            _this3.pages[index + 1]._destroy();
	            resolve();
	          });
	        });
	      }).then(function () {
	        return _this3._popPage(options, popUpdate);
	      });
	    }
	  }, {
	    key: '_popPage',
	    value: function _popPage(options) {
	      var _this4 = this;

	      var update = arguments.length <= 1 || arguments[1] === undefined ? function () {
	        return Promise.resolve();
	      } : arguments[1];
	      var pages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

	      if (this._isRunning) {
	        return Promise.reject('popPage is already running.');
	      }

	      if (this.pages.length <= 1) {
	        return Promise.reject('ons-navigator\'s page stack is empty.');
	      }

	      if (this._emitPrePopEvent()) {
	        return Promise.reject('Canceled in prepop event.');
	      }

	      var l = this.pages.length;

	      this._isRunning = true;

	      this.pages[l - 2].updateBackButton(l - 2 > 0);

	      return new Promise(function (resolve) {
	        var leavePage = _this4.pages[l - 1];
	        var enterPage = _this4.pages[l - 2];
	        enterPage.style.display = 'block';

	        options.animation = leavePage.pushedOptions.animation || options.animation;
	        options.animationOptions = util.extend({}, leavePage.pushedOptions.animationOptions, options.animationOptions || {});

	        var callback = function callback() {
	          pages.pop();
	          update(pages, _this4).then(function () {
	            _this4._isRunning = false;

	            enterPage._show();
	            util.triggerElementEvent(_this4, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this4 });

	            if (typeof options.callback === 'function') {
	              options.callback();
	            }

	            resolve(enterPage);
	          });
	        };

	        leavePage._hide();
	        var animator = _this4._animatorFactory.newAnimator(options);
	        animator.pop(_this4.pages[l - 2], _this4.pages[l - 1], callback);
	      }).catch(function () {
	        return _this4._isRunning = false;
	      });
	    }

	    /**
	     * @method pushPage
	     * @signature pushPage(page, [options])
	     * @param {String} [page]
	     *   [en]Page URL. Can be either a HTML document or a template defined with the `<ons-template>` tag.[/en]
	     *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {String} [options.page]
	     *   [en]Page URL. Only necessary if `page` parameter is omitted.[/en]
	     *   [ja][/ja]
	     * @param {String} [options.pageHTML]
	     *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
	     *   [ja][/ja]
	     * @param {String} [options.animation]
	     *   [en]
	     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
	     *
	     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
	     *   [/en]
	     *   [ja][/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
	     * @param {Function} [options.callback]
	     *   [en]Function that is called when the transition has ended.[/en]
	     *   [ja]pushPage()による画面遷移が終了した時に呼び出される関数オブジェクトを指定します。[/ja]
	     * @param {Any} [options.data]
	     *   [en]Custom data that will be stored in the new page element.[/en]
	     *   [ja][/ja]
	     * @return {Promise}
	     *   [en]Promise which resolves to the pushed page.[/en]
	     *   [ja]追加したページを解決するPromiseを返します。[/ja]
	     * @description
	     *   [en]Pushes the specified page into the stack.[/en]
	     *   [ja]指定したpageを新しいページスタックに追加します。新しいページが表示されます。[/ja]
	     */

	  }, {
	    key: 'pushPage',
	    value: function pushPage(page) {
	      var _this5 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      options = this._prepareOptions(options, page);
	      var run = function run(templateHTML) {
	        return new Promise(function (resolve) {
	          var element = util.extend(_this5._createPageElement(templateHTML), {
	            name: options.page,
	            data: options.data
	          });
	          element.style.display = 'none';
	          _this5.appendChild(element);
	          resolve();
	        });
	      };

	      if (options.pageHTML) {
	        return this._pushPage(options, function () {
	          return run(options.pageHTML);
	        });
	      }
	      return this._pushPage(options, function () {
	        return internal.getPageHTMLAsync(options.page).then(run);
	      });
	    }
	  }, {
	    key: '_pushPage',
	    value: function _pushPage() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	      var update = arguments.length <= 1 || arguments[1] === undefined ? function () {
	        return Promise.resolve();
	      } : arguments[1];

	      var _this6 = this;

	      var pages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
	      var page = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

	      if (this._isRunning) {
	        return Promise.reject('pushPage is already running.');
	      }

	      if (this._emitPrePushEvent()) {
	        return Promise.reject('Canceled in prepush event.');
	      }

	      this._isRunning = true;

	      var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
	      options = util.extend({}, this.options || {}, { animationOptions: animationOptions }, options);

	      var animator = this._animatorFactory.newAnimator(options);

	      pages.push(page);

	      return update(pages, this).then(function () {
	        var pageLength = _this6.pages.length;

	        var enterPage = _this6.pages[pageLength - 1];
	        var leavePage = _this6.pages[pageLength - 2];

	        if (enterPage.nodeName !== 'ONS-PAGE') {
	          throw new Error('Only elements of type <ons-page> can be pushed to the navigator');
	        }

	        enterPage.updateBackButton(pageLength - 1);

	        enterPage.pushedOptions = options;
	        enterPage.data = enterPage.data || options.data;
	        enterPage.name = enterPage.name || options.page;

	        return new Promise(function (resolve) {
	          var done = function done() {
	            _this6._isRunning = false;

	            if (leavePage) {
	              leavePage.style.display = 'none';
	            }

	            enterPage._show();
	            util.triggerElementEvent(_this6, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this6 });

	            if (typeof options.callback === 'function') {
	              options.callback();
	            }

	            resolve(enterPage);
	          };

	          enterPage.style.display = 'none';

	          var push = function push() {
	            enterPage.style.display = 'block';
	            if (leavePage) {
	              leavePage._hide();
	              animator.push(enterPage, leavePage, done);
	            } else {
	              done();
	            }
	          };

	          options._linked ? push() : rewritables.link(_this6, enterPage, options, push);
	        });
	      }).catch(function (error) {
	        _this6._isRunning = false;
	        throw error;
	      });
	    }

	    /**
	     * @method replacePage
	     * @signature replacePage(page, [options])
	     * @return {Promise}
	     *   [en]Promise which resolves to the new page.[/en]
	     *   [ja]新しいページを解決するPromiseを返します。[/ja]
	     * @description
	     *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
	     *   [ja]現在表示中のページをを指定したページに置き換えます。[/ja]
	     */

	  }, {
	    key: 'replacePage',
	    value: function replacePage(page) {
	      var _this7 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      options = this._prepareOptions(options, page);
	      var callback = options.callback;

	      options.callback = function () {
	        if (_this7.pages.length > 1) {
	          _this7.pages[_this7.pages.length - 2]._destroy();
	        }
	        _this7._updateLastPageBackButton();
	        callback && callback();
	      };

	      return this.pushPage(options);
	    }

	    /**
	     * @method insertPage
	     * @signature insertPage(index, page, [options])
	     * @param {Number} index
	     *   [en]The index where it should be inserted.[/en]
	     *   [ja]スタックに挿入する位置のインデックスを指定します。[/ja]
	     * @return {Promise}
	     *   [en]Promise which resolves to the inserted page.[/en]
	     *   [ja]指定したページを解決するPromiseを返します。[/ja]
	     * @description
	     *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
	     *   [ja]指定したpageをページスタックのindexで指定した位置に追加します。[/ja]
	     */

	  }, {
	    key: 'insertPage',
	    value: function insertPage(index, page) {
	      var _this8 = this;

	      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	      options = this._prepareOptions(options, page);
	      index = this._normalizeIndex(index);

	      if (index >= this.pages.length) {
	        return this.pushPage(options);
	      }

	      var run = function run(templateHTML) {
	        var element = util.extend(_this8._createPageElement(templateHTML), {
	          name: options.page,
	          data: options.data,
	          pushedOptions: options
	        });

	        options.animationOptions = util.extend({}, AnimatorFactory.parseAnimationOptionsString(_this8.getAttribute('animation-options')), options.animationOptions || {});

	        return new Promise(function (resolve) {
	          element.style.display = 'none';
	          _this8.insertBefore(element, _this8.pages[index]);
	          _this8.topPage.updateBackButton(true);

	          rewritables.link(_this8, element, options, function (element) {
	            setTimeout(function () {
	              element = null;
	              resolve(_this8.pages[index]);
	            }, 1000 / 60);
	          });
	        });
	      };

	      if (options.pageHTML) {
	        return run(options.pageHTML);
	      } else {
	        return internal.getPageHTMLAsync(options.page).then(run);
	      }
	    }

	    /**
	     * @method resetToPage
	     * @signature resetToPage(page, [options])
	     * @return {Promise}
	     *   [en]Promise which resolves to the new top page.[/en]
	     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
	     * @description
	     *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
	     *   [ja]ページスタックをリセットし、指定したページを表示します。[/ja]
	     */

	  }, {
	    key: 'resetToPage',
	    value: function resetToPage(page) {
	      var _this9 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      options = this._prepareOptions(options, page);

	      if (!options.animator && !options.animation) {
	        options.animation = 'none';
	      }

	      var callback = options.callback;

	      options.callback = function () {
	        while (_this9.pages.length > 1) {
	          _this9.pages[0]._destroy();
	        }

	        _this9.pages[0].updateBackButton(false);
	        callback && callback();
	      };

	      if (!options.page && !options.pageHTML && this.hasAttribute('page')) {
	        options.page = this.getAttribute('page');
	      }

	      return this.pushPage(options);
	    }

	    /**
	     * @method bringPageTop
	     * @signature bringPageTop(item, [options])
	     * @param {String|Number} item
	     *   [en]Page URL or index of an existing page in navigator's stack.[/en]
	     *   [ja]ページのURLかもしくはons-navigatorのページスタックのインデックス値を指定します。[/ja]
	     * @return {Promise}
	     *   [en]Promise which resolves to the new top page.[/en]
	     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
	     * @description
	     *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
	     *   [ja]指定したページをページスタックの一番上に移動します。もし指定したページが無かった場合新しくpushされます。[/ja]
	     */

	  }, {
	    key: 'bringPageTop',
	    value: function bringPageTop(item) {
	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : babelHelpers.typeof(item)) === -1) {
	        throw new Error('First argument must be a page name or the index of an existing page. You supplied ' + item);
	      }
	      var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
	      var page = this.pages[index];

	      if (index < 0) {
	        return this.pushPage(item, options);
	      }
	      options = this._prepareOptions(options);

	      if (index === this.pages.length - 1) {
	        return Promise.resolve(page);
	      }
	      if (!page) {
	        throw new Error('Failed to find item ' + item);
	      }
	      if (this._isRunning) {
	        return Promise.reject('pushPage is already running.');
	      }
	      if (this._emitPrePushEvent()) {
	        return Promise.reject('Canceled in prepush event.');
	      }

	      util.extend(options, {
	        page: page.name,
	        _linked: true
	      });
	      page.style.display = 'none';
	      page.setAttribute('_skipinit', '');
	      page.parentNode.appendChild(page);
	      return this._pushPage(options);
	    }
	  }, {
	    key: '_prepareOptions',
	    value: function _prepareOptions() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	      var page = arguments[1];

	      if ((typeof page === 'undefined' ? 'undefined' : babelHelpers.typeof(page)) === 'object' && page !== null) {
	        options = page;
	        page = options.page;
	      }
	      if ((typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
	        throw new Error('options must be an object. You supplied ' + options);
	      }
	      page = page || options.page;

	      return util.extend({}, this.options || {}, options, { page: page });
	    }
	  }, {
	    key: '_updateLastPageBackButton',
	    value: function _updateLastPageBackButton() {
	      var index = this.pages.length - 1;
	      if (index >= 0) {
	        this.pages[index].updateBackButton(index > 0);
	      }
	    }
	  }, {
	    key: '_normalizeIndex',
	    value: function _normalizeIndex(index) {
	      return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
	    }
	  }, {
	    key: '_onDeviceBackButton',
	    value: function _onDeviceBackButton(event) {
	      if (this.pages.length > 1) {
	        this.popPage();
	      } else {
	        event.callParentHandler();
	      }
	    }
	  }, {
	    key: '_lastIndexOfPage',
	    value: function _lastIndexOfPage(pageName) {
	      var index = void 0;
	      for (index = this.pages.length - 1; index >= 0; index--) {
	        if (this.pages[index].name === pageName) {
	          break;
	        }
	      }
	      return index;
	    }
	  }, {
	    key: '_emitPreEvent',
	    value: function _emitPreEvent(name) {
	      var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var isCanceled = false;

	      util.triggerElementEvent(this, 'pre' + name, util.extend({
	        navigator: this,
	        currentPage: this.pages[this.pages.length - 1],
	        cancel: function cancel() {
	          return isCanceled = true;
	        }
	      }, data));

	      return isCanceled;
	    }
	  }, {
	    key: '_emitPrePushEvent',
	    value: function _emitPrePushEvent() {
	      return this._emitPreEvent('push');
	    }
	  }, {
	    key: '_emitPrePopEvent',
	    value: function _emitPrePopEvent() {
	      var l = this.pages.length;
	      return this._emitPreEvent('pop', {
	        leavePage: this.pages[l - 1],
	        enterPage: this.pages[l - 2]
	      });
	    }
	  }, {
	    key: '_createPageElement',
	    value: function _createPageElement(templateHTML) {
	      var pageElement = util.createElement(internal.normalizePageHTML(templateHTML));

	      if (pageElement.nodeName.toLowerCase() !== 'ons-page') {
	        throw new Error('You must supply an "ons-page" element to "ons-navigator".');
	      }

	      CustomElements.upgrade(pageElement);

	      return pageElement;
	    }

	    /**
	     * @property onDeviceBackButton
	     * @type {Object}
	     * @description
	     *   [en]Back-button handler.[/en]
	     *   [ja]バックボタンハンドラ。[/ja]
	     */

	  }, {
	    key: '_show',
	    value: function _show() {
	      if (this.topPage) {
	        this.topPage._show();
	      }
	    }
	  }, {
	    key: '_hide',
	    value: function _hide() {
	      if (this.topPage) {
	        this.topPage._hide();
	      }
	    }
	  }, {
	    key: '_destroy',
	    value: function _destroy() {
	      for (var i = this.pages.length - 1; i >= 0; i--) {
	        this.pages[i]._destroy();
	      }

	      this.remove();
	    }
	  }, {
	    key: 'animatorFactory',


	    /**
	     * @attribute page
	     * @initonly
	     * @type {String}
	     * @description
	     *   [en]First page to show when navigator is initialized.[/en]
	     *   [ja]ナビゲーターが初期化された時に表示するページを指定します。[/ja]
	     */

	    /**
	     * @attribute animation
	     * @type {String}
	     * @default default
	     * @description
	     *   [en]
	     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
	     *
	     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
	     *   [/en]
	     *   [ja][/ja]
	     */

	    /**
	     * @attribute animation-options
	     * @type {Expression}
	     * @description
	     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
	     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
	     */

	    /**
	     * @event prepush
	     * @description
	     *   [en]Fired just before a page is pushed.[/en]
	     *   [ja]pageがpushされる直前に発火されます。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.navigator
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {Object} event.currentPage
	     *   [en]Current page object.[/en]
	     *   [ja]現在のpageオブジェクト。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Call this function to cancel the push.[/en]
	     *   [ja]この関数を呼び出すと、push処理がキャンセルされます。[/ja]
	     */

	    /**
	     * @event prepop
	     * @description
	     *   [en]Fired just before a page is popped.[/en]
	     *   [ja]pageがpopされる直前に発火されます。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.navigator
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {Object} event.currentPage
	     *   [en]Current page object.[/en]
	     *   [ja]現在のpageオブジェクト。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Call this function to cancel the pop.[/en]
	     *   [ja]この関数を呼び出すと、pageのpopがキャンセルされます。[/ja]
	     */

	    /**
	     * @event postpush
	     * @description
	     *   [en]Fired just after a page is pushed.[/en]
	     *   [ja]pageがpushされてアニメーションが終了してから発火されます。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.navigator
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {Object} event.enterPage
	     *   [en]Object of the next page.[/en]
	     *   [ja]pushされたpageオブジェクト。[/ja]
	     * @param {Object} event.leavePage
	     *   [en]Object of the previous page.[/en]
	     *   [ja]以前のpageオブジェクト。[/ja]
	     */

	    /**
	     * @event postpop
	     * @description
	     *   [en]Fired just after a page is popped.[/en]
	     *   [ja]pageがpopされてアニメーションが終わった後に発火されます。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.navigator
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {Object} event.enterPage
	     *   [en]Object of the next page.[/en]
	     *   [ja]popされて表示されるページのオブジェクト。[/ja]
	     * @param {Object} event.leavePage
	     *   [en]Object of the previous page.[/en]
	     *   [ja]popされて消えるページのオブジェクト。[/ja]
	     */

	    get: function get() {
	      return this._animatorFactory;
	    }
	  }, {
	    key: 'onDeviceBackButton',
	    get: function get() {
	      return this._backButtonHandler;
	    },
	    set: function set(callback) {
	      if (this._backButtonHandler) {
	        this._backButtonHandler.destroy();
	      }

	      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
	    }

	    /**
	     * @property topPage
	     * @readonly
	     * @type {HTMLElement}
	     * @description
	     *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
	     *   [ja]現在のページを取得します。pushPage()やresetToPage()メソッドの引数を取得できます。[/ja]
	     */

	  }, {
	    key: 'topPage',
	    get: function get() {
	      return this.pages[this.pages.length - 1] || null;
	    }

	    /**
	     * @property pages
	     * @readonly
	     * @type {HTMLCollection}
	     * @description
	     *   [en]Navigator's page stack.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'pages',
	    get: function get() {
	      return this.children;
	    }

	    /**
	     * @property options
	     * @type {Object}
	     * @description
	     *   [en]Default options object. Attributes have priority over this property.[/en]
	     *   [ja][/ja]
	     */

	    /**
	     * @property options.animation
	     * @type {String}
	     * @description
	     *   [en]
	     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
	     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
	     *   [/en]
	     *   [ja][/ja]
	     */

	    /**
	     * @property options.animationOptions
	     * @type {String}
	     * @description
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
	     */

	    /**
	     * @property options.callback
	     * @type {String}
	     * @description
	     *   [en]Function that is called when the transition has ended.[/en]
	     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
	     */

	    /**
	     * @property options.refresh
	     * @default  false
	     * @type {Boolean}
	     * @description
	     *   [en]If this parameter is `true`, the previous page will be refreshed (destroyed and created again) before `popPage()` action.[/en]
	     *   [ja]popPageする前に、前にあるページを生成しなおして更新する場合にtrueを指定します。[/ja]
	     */

	  }, {
	    key: 'options',
	    get: function get() {
	      return this._options;
	    },
	    set: function set(object) {
	      this._options = object;
	    }
	  }, {
	    key: '_isRunning',
	    set: function set(value) {
	      this.setAttribute('_is-running', value ? 'true' : 'false');
	    },
	    get: function get() {
	      return JSON.parse(this.getAttribute('_is-running'));
	    }
	  }]);
	  return NavigatorElement;
	}(BaseElement);

	window.OnsNavigatorElement = document.registerElement('ons-navigator', {
	  prototype: NavigatorElement.prototype
	});

	/**
	 * @param {String} name
	 * @param {Function} Animator
	 */
	window.OnsNavigatorElement.registerAnimator = function (name, Animator) {
	  if (!(Animator.prototype instanceof NavigatorTransitionAnimator)) {
	    throw new Error('"Animator" param must inherit OnsNavigatorElement.NavigatorTransitionAnimator');
	  }

	  _animatorDict$3[name] = Animator;
	};

	window.OnsNavigatorElement.rewritables = rewritables;
	window.OnsNavigatorElement.NavigatorTransitionAnimator = NavigatorTransitionAnimator;

	var scheme$12 = {
	  '': 'page--*',
	  '.page__content': 'page--*__content',
	  '.page__background': 'page--*__background'
	};

	var nullToolbarElement = document.createElement('ons-toolbar');

	/**
	 * @element ons-page
	 * @category page
	 * @modifier material
	 *   [en]Material Design style[/en]
	 *   [ja][/ja]
	 * @description
	 *   [en]
	 *     This component defines the root of each page. If the content is large it will become scrollable.
	 *
	 *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
	 *   [/en]
	 *   [ja]ページ定義のためのコンポーネントです。このコンポーネントの内容はスクロールが許可されます。[/ja]
	 * @tutorial vanilla/Reference/page
	 * @guide ManagingMultiplePages
	 *   [en]Managing multiple pages[/en]
	 *   [ja]複数のページを管理する[/ja]
	 * @guide Pagelifecycle
	 *   [en]Page life cycle events[/en]
	 *   [ja]ページライフサイクルイベント[/ja]
	 * @guide HandlingBackButton
	 *   [en]Handling back button[/en]
	 *   [ja]バックボタンに対応する[/ja]
	 * @guide OverridingCSSstyles
	 *   [en]Overriding CSS styles[/en]
	 *   [ja]CSSスタイルのオーバーライド[/ja]
	 * @guide DefiningMultiplePagesinSingleHTML
	 *   [en]Defining multiple pages in single html[/en]
	 *   [ja]複数のページを1つのHTMLに記述する[/ja]
	 * @seealso ons-toolbar
	 *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
	 *   [ja][/ja]
	 * @example
	 * <ons-page>
	 *   <ons-toolbar>
	 *     <div class="left">
	 *       <ons-back-button>Back</ons-back-button>
	 *     </div>
	 *     <div class="center">Title</div>
	 *     <div class="right">
	 *       <ons-toolbar-button>
	 *         <ons-icon icon="md-menu"></ons-icon>
	 *       </ons-toolbar-button>
	 *     </div>
	 *   </ons-toolbar>
	 *
	 *   <p>Page content</p>
	 * </ons-page>
	 *
	 * // Infinite Scroll handler
	 * page.onInfiniteScroll = function(done) {
	 *   loadMore().then(done);
	 * };
	 */

	var PageElement = function (_BaseElement) {
	  babelHelpers.inherits(PageElement, _BaseElement);

	  function PageElement() {
	    babelHelpers.classCallCheck(this, PageElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PageElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(PageElement, [{
	    key: 'createdCallback',


	    /**
	     * @event init
	     * @description
	     *   [en]Fired right after the page is attached.[/en]
	     *   [ja]ページがアタッチされた後に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     */

	    /**
	     * @event show
	     * @description
	     *   [en]Fired right after the page is shown.[/en]
	     *   [ja]ページが表示された後に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     */

	    /**
	     * @event hide
	     * @description
	     *   [en]Fired right after the page is hidden.[/en]
	     *   [ja]ページが隠れた後に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     */

	    /**
	     * @event destroy
	     * @description
	     *   [en]Fired right before the page is destroyed.[/en]
	     *   [ja]ページが破棄される前に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     */

	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *   [en]Specify modifier name to specify custom styles.[/en]
	     *   [ja]スタイル定義をカスタマイズするための名前を指定します。[/ja]
	     */

	    /**
	     * @attribute on-infinite-scroll
	     * @type {String}
	     * @description
	     *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
	     *   [ja][/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      this.classList.add('page');

	      contentReady(this, function () {
	        if (!_this2.hasAttribute('_compiled')) {
	          _this2._compile();
	        }

	        _this2._isShown = false;
	        _this2._contentElement = _this2._getContentElement();
	        _this2._isMuted = _this2.hasAttribute('_muted');
	        _this2._skipInit = _this2.hasAttribute('_skipinit');
	        _this2.pushedOptions = {};
	      });
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this3 = this;

	      contentReady(this, function () {
	        if (!_this3._isMuted) {
	          if (_this3._skipInit) {
	            _this3.removeAttribute('_skipinit');
	          } else {
	            setImmediate(function () {
	              return util.triggerElementEvent(_this3, 'init');
	            });
	          }
	        }

	        if (!util.hasAnyComponentAsParent(_this3)) {
	          setImmediate(function () {
	            return _this3._show();
	          });
	        }

	        _this3._tryToFillStatusBar();

	        if (_this3.hasAttribute('on-infinite-scroll')) {
	          _this3.attributeChangedCallback('on-infinite-scroll', null, _this3.getAttribute('on-infinite-scroll'));
	        }
	      });
	    }
	  }, {
	    key: 'updateBackButton',
	    value: function updateBackButton(show) {
	      if (this.backButton) {
	        show ? this.backButton.show() : this.backButton.hide();
	      }
	    }
	  }, {
	    key: '_tryToFillStatusBar',
	    value: function _tryToFillStatusBar() {
	      var _this4 = this;

	      internal.autoStatusBarFill(function () {
	        var filled = util.findParent(_this4, function (e) {
	          return e.hasAttribute('status-bar-fill');
	        });
	        util.toggleAttribute(_this4, 'status-bar-fill', !filled && (_this4._canAnimateToolbar() || !_this4._hasAPageControlChild()));
	      });
	    }
	  }, {
	    key: '_hasAPageControlChild',
	    value: function _hasAPageControlChild() {
	      return util.findChild(this._contentElement, function (e) {
	        return e.nodeName.match(/ons-(splitter|sliding-menu|navigator|tabbar)/i);
	      });
	    }

	    /**
	     * @property onInfiniteScroll
	     * @description
	     *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
	     *  [ja][/ja]
	     */

	  }, {
	    key: '_onScroll',
	    value: function _onScroll() {
	      var _this5 = this;

	      var c = this._contentElement,
	          overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

	      if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
	        this._loadingContent = true;
	        this._onInfiniteScroll(function () {
	          return _this5._loadingContent = false;
	        });
	      }
	    }

	    /**
	     * @property onDeviceBackButton
	     * @type {Object}
	     * @description
	     *   [en]Back-button handler.[/en]
	     *   [ja]バックボタンハンドラ。[/ja]
	     */

	  }, {
	    key: '_getContentElement',


	    /**
	     * @return {HTMLElement}
	     */
	    value: function _getContentElement() {
	      var result = util.findChild(this, '.page__content');
	      if (result) {
	        return result;
	      }
	      throw Error('fail to get ".page__content" element.');
	    }

	    /**
	     * @return {Boolean}
	     */

	  }, {
	    key: '_canAnimateToolbar',
	    value: function _canAnimateToolbar() {
	      if (util.findChild(this, 'ons-toolbar')) {
	        return true;
	      }
	      return !!util.findChild(this._contentElement, function (el) {
	        return util.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
	      });
	    }

	    /**
	     * @return {HTMLElement}
	     */

	  }, {
	    key: '_getBackgroundElement',
	    value: function _getBackgroundElement() {
	      var result = util.findChild(this, '.page__background');
	      if (result) {
	        return result;
	      }
	      throw Error('fail to get ".page__background" element.');
	    }

	    /**
	     * @return {HTMLElement}
	     */

	  }, {
	    key: '_getBottomToolbarElement',
	    value: function _getBottomToolbarElement() {
	      return util.findChild(this, 'ons-bottom-toolbar') || internal.nullElement;
	    }

	    /**
	     * @return {HTMLElement}
	     */

	  }, {
	    key: '_getToolbarElement',
	    value: function _getToolbarElement() {
	      return util.findChild(this, 'ons-toolbar') || nullToolbarElement;
	    }

	    /**
	     * Register toolbar element to this page.
	     *
	     * @param {HTMLElement} element
	     */

	  }, {
	    key: '_registerToolbar',
	    value: function _registerToolbar(element) {
	      this.insertBefore(element, this.children[0]);
	    }

	    /**
	     * Register toolbar element to this page.
	     *
	     * @param {HTMLElement} element
	     */

	  }, {
	    key: '_registerBottomToolbar',
	    value: function _registerBottomToolbar(element) {
	      this.classList.add('page-with-bottom-toolbar');
	      this.appendChild(element);
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      var _this6 = this;

	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$12);
	      } else if (name === '_muted') {
	        this._isMuted = this.hasAttribute('_muted');
	      } else if (name === '_skipinit') {
	        this._skipInit = this.hasAttribute('_skipinit');
	      } else if (name === 'on-infinite-scroll') {
	        if (current === null) {
	          this.onInfiniteScroll = null;
	        } else {
	          this.onInfiniteScroll = function (done) {
	            var f = util.findFromPath(current);
	            _this6.onInfiniteScroll = f;
	            f(done);
	          };
	        }
	      }
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      var _this7 = this;

	      autoStyle.prepare(this);

	      if (!util.findChild(this, '.page__content')) {
	        (function () {
	          var content = util.create('.page__content');

	          util.arrayFrom(_this7.childNodes).forEach(function (node) {
	            if (!node.classList || !node.classList.contains('page__background')) {
	              content.appendChild(node);
	            }
	          });

	          _this7.appendChild(content);
	        })();
	      }

	      if (!util.findChild(this, '.page__background')) {
	        var background = util.create('.page__background');
	        this.insertBefore(background, util.findChild(this, '.page__content'));
	      }

	      ModifierUtil.initModifier(this, scheme$12);

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: '_registerExtraElement',
	    value: function _registerExtraElement(element) {
	      var extra = util.findChild(this, '.page__extra');
	      if (!extra) {
	        extra = util.create('.page__extra', { zIndex: 10001 });
	        this.appendChild(extra);
	      }

	      extra.appendChild(element);
	    }
	  }, {
	    key: '_show',
	    value: function _show() {
	      if (!this._isShown && util.isAttached(this)) {
	        this._isShown = true;

	        if (!this._isMuted) {
	          util.triggerElementEvent(this, 'show');
	        }

	        util.propagateAction(this._contentElement, '_show');
	      }
	    }
	  }, {
	    key: '_hide',
	    value: function _hide() {
	      if (this._isShown) {
	        this._isShown = false;

	        if (!this._isMuted) {
	          util.triggerElementEvent(this, 'hide');
	        }

	        util.propagateAction(this._contentElement, '_hide');
	      }
	    }
	  }, {
	    key: '_destroy',
	    value: function _destroy() {
	      this._hide();

	      if (!this._isMuted) {
	        util.triggerElementEvent(this, 'destroy');
	      }

	      if (this.onDeviceBackButton) {
	        this.onDeviceBackButton.destroy();
	      }

	      util.propagateAction(this._contentElement, '_destroy');

	      this.remove();
	    }

	    /**
	     * @property data
	     * @type {*}
	     * @description
	     *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'name',
	    set: function set(str) {
	      this.setAttribute('name', str);
	    },
	    get: function get() {
	      return this.getAttribute('name');
	    }
	  }, {
	    key: 'backButton',
	    get: function get() {
	      return this.querySelector('ons-back-button');
	    }
	  }, {
	    key: 'onInfiniteScroll',
	    set: function set(value) {
	      if (value === null) {
	        this._onInfiniteScroll = null;
	        this._contentElement.removeEventListener('scroll', this._boundOnScroll);
	        return;
	      }
	      if (!(value instanceof Function)) {
	        throw new Error('onInfiniteScroll must be a function or null');
	      }
	      if (!this._onInfiniteScroll) {
	        this._infiniteScrollLimit = 0.9;
	        this._boundOnScroll = this._onScroll.bind(this);
	        this._contentElement.addEventListener('scroll', this._boundOnScroll);
	      }
	      this._onInfiniteScroll = value;
	    },
	    get: function get() {
	      return this._onInfiniteScroll;
	    }
	  }, {
	    key: 'onDeviceBackButton',
	    get: function get() {
	      return this._backButtonHandler;
	    },
	    set: function set(callback) {
	      if (this._backButtonHandler) {
	        this._backButtonHandler.destroy();
	      }

	      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
	    }
	  }]);
	  return PageElement;
	}(BaseElement);

	window.OnsPageElement = document.registerElement('ons-page', {
	  prototype: PageElement.prototype
	});

	var PopoverAnimator = function () {

	  /**
	   * @param {Object} options
	   * @param {String} options.timing
	   * @param {Number} options.duration
	   * @param {Number} options.delay
	   */

	  function PopoverAnimator() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    babelHelpers.classCallCheck(this, PopoverAnimator);

	    this.options = util.extend({
	      timing: 'cubic-bezier(.1, .7, .4, 1)',
	      duration: 0.2,
	      delay: 0
	    }, options);
	  }

	  babelHelpers.createClass(PopoverAnimator, [{
	    key: 'show',
	    value: function show(popover, callback) {
	      callback();
	    }
	  }, {
	    key: 'hide',
	    value: function hide(popover, callback) {
	      callback();
	    }
	  }, {
	    key: '_animate',
	    value: function _animate(element, _ref) {
	      var from = _ref.from;
	      var to = _ref.to;
	      var options = _ref.options;
	      var callback = _ref.callback;
	      var _ref$restore = _ref.restore;
	      var restore = _ref$restore === undefined ? false : _ref$restore;
	      var animation = _ref.animation;

	      options = util.extend({}, this.options, options);

	      if (animation) {
	        from = animation.from;
	        to = animation.to;
	      }

	      animation = animit(element);
	      if (restore) {
	        animation = animation.saveStyle();
	      }
	      animation = animation.queue(from).wait(options.delay).queue({
	        css: to,
	        duration: options.duration,
	        timing: options.timing
	      });
	      if (restore) {
	        animation = animation.restoreStyle();
	      }
	      if (callback) {
	        animation = animation.queue(function (done) {
	          callback();
	          done();
	        });
	      }
	      return animation;
	    }
	  }, {
	    key: '_animateAll',
	    value: function _animateAll(element, animations) {
	      var _this = this;

	      Object.keys(animations).forEach(function (key) {
	        return _this._animate(element[key], animations[key]).play();
	      });
	    }
	  }]);
	  return PopoverAnimator;
	}();

	var fade = {
	  out: {
	    from: { opacity: 1.0 },
	    to: { opacity: 0 }
	  },
	  in: {
	    from: { opacity: 0 },
	    to: { opacity: 1.0 }
	  }
	};

	var MDFadePopoverAnimator = function (_PopoverAnimator) {
	  babelHelpers.inherits(MDFadePopoverAnimator, _PopoverAnimator);

	  function MDFadePopoverAnimator() {
	    babelHelpers.classCallCheck(this, MDFadePopoverAnimator);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDFadePopoverAnimator).apply(this, arguments));
	  }

	  babelHelpers.createClass(MDFadePopoverAnimator, [{
	    key: 'show',
	    value: function show(popover, callback) {
	      this._animateAll(popover, {
	        _mask: fade.in,
	        _popover: { animation: fade.in, restore: true, callback: callback }
	      });
	    }
	  }, {
	    key: 'hide',
	    value: function hide(popover, callback) {
	      this._animateAll(popover, {
	        _mask: fade.out,
	        _popover: { animation: fade.out, restore: true, callback: callback }
	      });
	    }
	  }]);
	  return MDFadePopoverAnimator;
	}(PopoverAnimator);

	var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
	  babelHelpers.inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

	  function IOSFadePopoverAnimator() {
	    babelHelpers.classCallCheck(this, IOSFadePopoverAnimator);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSFadePopoverAnimator).apply(this, arguments));
	  }

	  babelHelpers.createClass(IOSFadePopoverAnimator, [{
	    key: 'show',
	    value: function show(popover, callback) {
	      this._animateAll(popover, {
	        _mask: fade.in,
	        _popover: {
	          from: {
	            transform: 'scale3d(1.3, 1.3, 1.0)',
	            opacity: 0
	          },
	          to: {
	            transform: 'scale3d(1.0, 1.0,  1.0)',
	            opacity: 1.0
	          },
	          restore: true,
	          callback: callback
	        }
	      });
	    }
	  }]);
	  return IOSFadePopoverAnimator;
	}(MDFadePopoverAnimator);

	var animators = { PopoverAnimator: PopoverAnimator, IOSFadePopoverAnimator: IOSFadePopoverAnimator, MDFadePopoverAnimator: MDFadePopoverAnimator };

	var scheme$13 = {
	  '.popover': 'popover--*',
	  '.popover-mask': 'popover-mask--*',
	  '.popover__container': 'popover__container--*',
	  '.popover__content': 'popover__content--*',
	  '.popover__arrow': 'popover__arrow--*'
	};

	var _animatorDict$4 = {
	  'default': function _default() {
	    return platform.isAndroid() ? animators.MDFadePopoverAnimator : animators.IOSFadePopoverAnimator;
	  },
	  'none': animators.PopoverAnimator,
	  'fade-ios': animators.IOSFadePopoverAnimator,
	  'fade-md': animators.MDFadePopoverAnimator
	};

	var templateSource = util.createFragment('\n  <div class="popover-mask"></div>\n  <div class="popover__container">\n    <div class="popover__content"></div>\n    <div class="popover__arrow"></div>\n  </div>\n');

	var positions = {
	  up: 'bottom',
	  left: 'right',
	  down: 'top',
	  right: 'left'
	};

	var directions = Object.keys(positions);
	/**
	 * @element ons-popover
	 * @category popover
	 * @description
	 *  [en]
	 *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
	 *
	 *    Another common way to use the popover is to display a menu when a button on the screen is tapped.
	 *  [/en]
	 *  [ja]ある要素を対象とするポップオーバーを表示するコンポーネントです。[/ja]
	 * @codepen ZYYRKo
	 * @tutorial vanilla/Reference/popover
	 * @example
	 * <ons-button onclick="showPopover(this)">
	 *   Click me!
	 * </ons-button>
	 *
	 * <ons-popover direction="down" id="popover">
	 *   <p>This is a popover!</p>
	 * </ons-popover>
	 *
	 * <script>
	 *   var showPopover = function(element) {
	 *     var popover = document.getElementById('popover');
	 *     popover.show(element);
	 *   };
	 * </script>
	 */

	var PopoverElement = function (_BaseElement) {
	  babelHelpers.inherits(PopoverElement, _BaseElement);

	  function PopoverElement() {
	    babelHelpers.classCallCheck(this, PopoverElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PopoverElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(PopoverElement, [{
	    key: 'createdCallback',
	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        _this2._compile();
	        _this2._initAnimatorFactory();
	      });

	      this._doorLock = new DoorLock();
	      this._boundOnChange = this._onChange.bind(this);
	      this._boundCancel = this._cancel.bind(this);
	    }
	  }, {
	    key: '_initAnimatorFactory',
	    value: function _initAnimatorFactory() {
	      var factory = new AnimatorFactory({
	        animators: _animatorDict$4,
	        baseClass: animators.PopoverAnimator,
	        baseClassName: 'PopoverAnimator',
	        defaultAnimation: this.getAttribute('animation') || 'default'
	      });
	      this._animator = function (options) {
	        return factory.newAnimator(options);
	      };
	    }
	  }, {
	    key: '_positionPopover',
	    value: function _positionPopover(target) {
	      var radius = this._radius;
	      var el = this._content;
	      var margin = this._margin;

	      var pos = target.getBoundingClientRect();
	      var isMD = util.hasModifier(this, 'material');
	      var cover = isMD && this.hasAttribute('cover-target');

	      var distance = {
	        top: pos.top - margin,
	        left: pos.left - margin,
	        right: window.innerWidth - pos.right - margin,
	        bottom: window.innerHeight - pos.bottom - margin
	      };

	      var _calculateDirections2 = this._calculateDirections(distance);

	      var vertical = _calculateDirections2.vertical;
	      var primary = _calculateDirections2.primary;
	      var secondary = _calculateDirections2.secondary;

	      this._popover.classList.add('popover--' + primary);

	      var offset = cover ? 0 : (vertical ? pos.height : pos.width) + (isMD ? 0 : 14);
	      this.style[primary] = Math.max(0, distance[primary] + offset) + margin + 'px';
	      el.style[primary] = 0;

	      var l = vertical ? 'width' : 'height';
	      var sizes = function (style) {
	        return {
	          width: parseInt(style.getPropertyValue('width')),
	          height: parseInt(style.getPropertyValue('height'))
	        };
	      }(window.getComputedStyle(el));

	      el.style[secondary] = Math.max(0, distance[secondary] - (sizes[l] - pos[l]) / 2) + 'px';
	      this._arrow.style[secondary] = Math.max(radius, distance[secondary] + pos[l] / 2) + 'px';

	      this._setTransformOrigin(distance, sizes, pos, primary);

	      // Prevent animit from restoring the style.
	      el.removeAttribute('data-animit-orig-style');
	    }
	  }, {
	    key: '_setTransformOrigin',
	    value: function _setTransformOrigin(distance, sizes, pos, primary) {
	      var calc = function calc(a, o, l) {
	        return primary === a ? sizes[l] / 2 : distance[a] + (primary === o ? -sizes[l] : sizes[l] - pos[l]) / 2;
	      };
	      var x = calc('left', 'right', 'width') + 'px';
	      var y = calc('top', 'bottom', 'height') + 'px';

	      util.extend(this._popover.style, {
	        transformOrigin: x + ' ' + y,
	        webkitTransformOriginX: x,
	        webkitTransformOriginY: y
	      });
	    }
	  }, {
	    key: '_calculateDirections',
	    value: function _calculateDirections(distance) {
	      var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
	        return positions[e];
	      });
	      var primary = options.sort(function (a, b) {
	        return distance[a] - distance[b];
	      })[0];
	      var vertical = ['top', 'bottom'].indexOf(primary) !== -1;
	      var secondary = void 0;

	      if (vertical) {
	        secondary = distance.left < distance.right ? 'left' : 'right';
	      } else {
	        secondary = distance.top < distance.bottom ? 'top' : 'bottom';
	      }

	      return { vertical: vertical, primary: primary, secondary: secondary };
	    }
	  }, {
	    key: '_clearStyles',
	    value: function _clearStyles() {
	      var _this3 = this;

	      ['top', 'bottom', 'left', 'right'].forEach(function (e) {
	        _this3._arrow.style[e] = _this3._content.style[e] = _this3.style[e] = '';
	        _this3._popover.classList.remove('popover--' + e);
	      });
	    }
	  }, {
	    key: '_onChange',
	    value: function _onChange() {
	      var _this4 = this;

	      setImmediate(function () {
	        if (_this4._currentTarget) {
	          _this4._positionPopover(_this4._currentTarget);
	        }
	      });
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      if (this.classList.contains('popover')) {
	        return;
	      }

	      this.classList.add('popover');

	      var hasDefaultContainer = this._popover && this._content;

	      if (hasDefaultContainer) {

	        if (!this._mask) {
	          var mask = document.createElement('div');
	          mask.classList.add('popover-mask');
	          this.insertBefore(mask, this.firstChild);
	        }

	        if (!this._arrow) {
	          var arrow = document.createElement('div');
	          arrow.classList.add('popover__arrow');
	          this._popover.appendChild(arrow);
	        }
	      } else {

	        var template = templateSource.cloneNode(true);
	        var content = template.querySelector('.popover__content');

	        while (this.childNodes[0]) {
	          content.appendChild(this.childNodes[0]);
	        }

	        this.appendChild(template);
	      }

	      if (this.hasAttribute('style')) {
	        this._popover.setAttribute('style', this.getAttribute('style'));
	        this.removeAttribute('style');
	      }

	      if (this.hasAttribute('mask-color')) {
	        this._mask.style.backgroundColor = this.getAttribute('mask-color');
	      }

	      ModifierUtil.initModifier(this, scheme$13);
	    }
	  }, {
	    key: '_prepareAnimationOptions',
	    value: function _prepareAnimationOptions(options) {
	      if (options.animation && !(options.animation in _animatorDict$4)) {
	        throw new Error('Animator ' + options.animation + ' is not registered.');
	      }

	      options.animationOptions = util.extend(AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')), options.animationOptions || {});
	    }
	  }, {
	    key: '_executeAction',
	    value: function _executeAction(actions) {
	      var _this5 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var callback = options.callback;
	      var action = actions.action;
	      var before = actions.before;
	      var after = actions.after;


	      this._prepareAnimationOptions(options);

	      var canceled = false;
	      util.triggerElementEvent(this, 'pre' + action, { // synchronous
	        popover: this,
	        cancel: function cancel() {
	          return canceled = true;
	        }
	      });

	      if (canceled) {
	        return Promise.reject('Canceled in pre' + action + ' event.');
	      }

	      return new Promise(function (resolve) {
	        _this5._doorLock.waitUnlock(function () {
	          var unlock = _this5._doorLock.lock();

	          before && before();

	          contentReady(_this5, function () {
	            _this5._animator(options)[action](_this5, function () {
	              after && after();

	              unlock();

	              util.triggerElementEvent(_this5, 'post' + action, { popover: _this5 });

	              callback && callback();
	              resolve(_this5);
	            });
	          });
	        });
	      });
	    }

	    /**
	     * @method show
	     * @signature show(target, [options])
	     * @param {String|Event|HTMLElement} target
	     *   [en]Target element. Can be either a CSS selector, an event object or a DOM element.[/en]
	     *   [ja]ポップオーバーのターゲットとなる要素を指定します。CSSセレクタかeventオブジェクトかDOM要素のいずれかを渡せます。[/ja]
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {String} [options.animation]
	     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
	     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
	     * @param {Function} [options.callback]
	     *   [en]This function is called after the popover has been revealed.[/en]
	     *   [ja]ポップオーバーが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
	     * @description
	     *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
	     *   [ja]対象とする要素にポップオーバーを表示します。target引数には、$eventオブジェクトやDOMエレメントやCSSセレクタを渡すことが出来ます。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the displayed element[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'show',
	    value: function show(target) {
	      var _this6 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      if (typeof target === 'string') {
	        target = document.querySelector(target);
	      } else if (target instanceof Event) {
	        target = target.target;
	      }
	      if (!(target instanceof HTMLElement)) {
	        throw new Error('Invalid target');
	      }

	      return this._executeAction({
	        action: 'show',
	        before: function before() {
	          _this6.style.display = 'block';
	          _this6._currentTarget = target;
	          _this6._positionPopover(target);
	        }
	      }, options);
	    }

	    /**
	     * @method hide
	     * @signature hide([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {String} [options.animation]
	     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
	     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
	     * @param {Function} [options.callback]
	     *   [en]This functions is called after the popover has been hidden.[/en]
	     *   [ja]ポップオーバーが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
	     * @description
	     *   [en]Close the popover.[/en]
	     *   [ja]ポップオーバーを閉じます。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the hidden element[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'hide',
	    value: function hide() {
	      var _this7 = this;

	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      return this._executeAction({
	        action: 'hide',
	        after: function after() {
	          _this7.style.display = 'none';
	          _this7._clearStyles();
	        }
	      }, options);
	    }

	    /**
	     * @property visible
	     * @readonly
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is visible or not.[/en]
	     *   [ja]要素が見える場合に`true`。[/ja]
	     */

	  }, {
	    key: '_resetBackButtonHandler',
	    value: function _resetBackButtonHandler() {
	      var _this8 = this;

	      // do we need this twice?
	      this.onDeviceBackButton = function (e) {
	        return _this8.cancelable ? _this8._cancel() : e.callParentHandler();
	      };
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this9 = this;

	      this._resetBackButtonHandler();

	      contentReady(this, function () {
	        _this9._margin = _this9._margin || parseInt(window.getComputedStyle(_this9).getPropertyValue('top'));
	        _this9._radius = parseInt(window.getComputedStyle(_this9._content).getPropertyValue('border-top-left-radius'));

	        _this9._mask.addEventListener('click', _this9._boundCancel, false);

	        _this9._resetBackButtonHandler();

	        window.addEventListener('resize', _this9._boundOnChange, false);
	      });
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      var _this10 = this;

	      contentReady(this, function () {
	        _this10._mask.removeEventListener('click', _this10._boundCancel, false);

	        _this10._backButtonHandler.destroy();
	        _this10._backButtonHandler = null;

	        window.removeEventListener('resize', _this10._boundOnChange, false);
	      });
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$13);
	      }
	      if (name === 'direction') {
	        return this._boundOnChange();
	      }
	      if (name === 'animation') {
	        this._initAnimatorFactory();
	      }
	    }
	  }, {
	    key: '_cancel',
	    value: function _cancel() {
	      var _this11 = this;

	      if (this.cancelable) {
	        this.hide({
	          callback: function callback() {
	            util.triggerElementEvent(_this11, 'dialog-cancel');
	          }
	        });
	      }
	    }
	  }, {
	    key: '_mask',


	    /**
	     * @event preshow
	     * @description
	     *   [en]Fired just before the popover is displayed.[/en]
	     *   [ja]ポップオーバーが表示される直前に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.popover
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Call this function to stop the popover from being shown.[/en]
	     *   [ja]この関数を呼び出すと、ポップオーバーの表示がキャンセルされます。[/ja]
	     */

	    /**
	     * @event postshow
	     * @description
	     *   [en]Fired just after the popover is displayed.[/en]
	     *   [ja]ポップオーバーが表示された直後に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.popover
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     */

	    /**
	     * @event prehide
	     * @description
	     *   [en]Fired just before the popover is hidden.[/en]
	     *   [ja]ポップオーバーが隠れる直前に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.popover
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Call this function to stop the popover from being hidden.[/en]
	     *   [ja]この関数を呼び出すと、ポップオーバーが隠れる処理をキャンセルします。[/ja]
	     */

	    /**
	     * @event posthide
	     * @description
	     *   [en]Fired just after the popover is hidden.[/en]
	     *   [ja]ポップオーバーが隠れた後に発火します。[/ja]
	     * @param {Object} event [en]Event object.[/en]
	     * @param {Object} event.popover
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     */

	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *  [en]The appearance of the popover.[/en]
	     *  [ja]ポップオーバーの表現を指定します。[/ja]
	     */

	    /**
	     * @attribute direction
	     * @type {String}
	     * @description
	     *  [en]
	     *    A space separated list of directions. If more than one direction is specified,
	     *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
	     *  [/en]
	     *  [ja]
	     *    ポップオーバーを表示する方向を空白区切りで複数指定できます。
	     *    指定できる方向は、"up", "down", "left", "right"の4つです。空白区切りで複数指定することもできます。
	     *    複数指定された場合、対象とする要素に合わせて指定した値から自動的に選択されます。
	     *  [/ja]
	     */

	    /**
	     * @attribute cancelable
	     * @description
	     *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
	     *   [ja]この属性があると、ポップオーバーが表示された時に、背景やバックボタンをタップした時にをポップオーバー閉じます。[/ja]
	     */

	    /**
	     * @attribute cover-target
	     * @description
	     *   [en]If set the popover will cover the target on the screen.[/en]
	     *   [ja][/ja]
	     */

	    /**
	     * @attribute animation
	     * @type {String}
	     * @description
	     *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
	     *   [ja]ポップオーバーを表示する際のアニメーション名を指定します。[/ja]
	     */

	    /**
	     * @attribute animation-options
	     * @type {Expression}
	     * @description
	     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
	     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
	     */

	    /**
	     * @attribute mask-color
	     * @type {Color}
	     * @description
	     *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
	     *   [ja]背景のマスクの色を指定します。デフォルトは"rgba(0, 0, 0, 0.2)"です。[/ja]
	     */

	    get: function get() {
	      return util.findChild(this, '.popover-mask');
	    }
	  }, {
	    key: '_popover',
	    get: function get() {
	      return util.findChild(this, '.popover__container');
	    }
	  }, {
	    key: '_content',
	    get: function get() {
	      return util.findChild(this._popover, '.popover__content');
	    }
	  }, {
	    key: '_arrow',
	    get: function get() {
	      return util.findChild(this._popover, '.popover__arrow');
	    }
	  }, {
	    key: 'visible',
	    get: function get() {
	      return window.getComputedStyle(this).getPropertyValue('display') !== 'none';
	    }

	    /**
	     * @property cancelable
	     * @type {Boolean}
	     * @description
	     *   [en]
	     *     A boolean value that specifies whether the popover is cancelable or not.
	     *
	     *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
	     *   [/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'cancelable',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'cancelable', value);
	    },
	    get: function get() {
	      return this.hasAttribute('cancelable');
	    }

	    /**
	     * @property onDeviceBackButton
	     * @type {Object}
	     * @description
	     *   [en]Back-button handler.[/en]
	     *   [ja]バックボタンハンドラ。[/ja]
	     */

	  }, {
	    key: 'onDeviceBackButton',
	    get: function get() {
	      return this._backButtonHandler;
	    },
	    set: function set(callback) {
	      if (this._backButtonHandler) {
	        this._backButtonHandler.destroy();
	      }

	      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
	    }
	  }]);
	  return PopoverElement;
	}(BaseElement);

	window.OnsPopoverElement = document.registerElement('ons-popover', {
	  prototype: PopoverElement.prototype
	});

	/**
	 * @param {String} name
	 * @param {PopoverAnimator} Animator
	 */
	window.OnsPopoverElement.registerAnimator = function (name, Animator) {
	  if (!(Animator.prototype instanceof animators.PopoverAnimator)) {
	    throw new Error('"Animator" param must inherit PopoverAnimator');
	  }
	  _animatorDict$4[name] = Animator;
	};

	window.OnsPopoverElement.PopoverAnimator = animators.PopoverAnimator;

	var scheme$14 = {
	  '.progress-bar': 'progress-bar--*',
	  '.progress-bar__primary': 'progress-bar__primary--*',
	  '.progress-bar__secondary': 'progress-bar__secondary--*'
	};

	var template = util.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

	/**
	 * @element ons-progress-bar
	 * @category progress
	 * @description
	 *   [en]
	 *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen zvQbGj
	 * @tutorial vanilla/Reference/progress
	 * @seealso ons-progress-circular
	 *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
	 *   [ja][/ja]
	 * @example
	 * <ons-progress-bar
	 *  value="55"
	 *  secondary-value="87">
	 * </ons-progress-bar>
	 *
	 * <ons-progress-bar
	 *  indeterminate>
	 * </ons-progress-bar>
	 */

	var ProgressBarElement = function (_BaseElement) {
	  babelHelpers.inherits(ProgressBarElement, _BaseElement);

	  function ProgressBarElement() {
	    babelHelpers.classCallCheck(this, ProgressBarElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ProgressBarElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(ProgressBarElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *   [en]Change the appearance of the progress indicator.[/en]
	     *   [ja]プログレスインジケータの見た目を変更します。[/ja]
	     */

	    /**
	     * @attribute value
	     * @type {Number}
	     * @description
	     *   [en]Current progress. Should be a value between 0 and 100.[/en]
	     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
	     */

	    /**
	     * @attribute secondary-value
	     * @type {Number}
	     * @description
	     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
	     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
	     */

	    /**
	     * @attribute indeterminate
	     * @description
	     *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
	     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
	     */

	    value: function createdCallback() {
	      if (!this.hasAttribute('_compiled')) {
	        this._compile();
	      }
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$14);
	      } else if (name === 'value' || name === 'secondary-value') {
	        this._updateValue();
	      } else if (name === 'indeterminate') {
	        this._updateDeterminate();
	      }
	    }
	  }, {
	    key: '_updateDeterminate',
	    value: function _updateDeterminate() {
	      if (this.hasAttribute('indeterminate')) {
	        this._template.classList.add('progress-bar--indeterminate');
	        this._template.classList.remove('progress-bar--determinate');
	      } else {
	        this._template.classList.add('progress-bar--determinate');
	        this._template.classList.remove('progress-bar--indeterminate');
	      }
	    }
	  }, {
	    key: '_updateValue',
	    value: function _updateValue() {
	      this._primary.style.width = this.hasAttribute('value') ? this.getAttribute('value') + '%' : '0%';
	      this._secondary.style.width = this.hasAttribute('secondary-value') ? this.getAttribute('secondary-value') + '%' : '0%';
	    }

	    /**
	     * @property value
	     * @type {Number}
	     * @description
	     *   [en]Current progress. Should be a value between 0 and 100.[/en]
	     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
	     */

	  }, {
	    key: '_compile',
	    value: function _compile() {
	      this._template = template.cloneNode(true);

	      this._primary = this._template.childNodes[3];
	      this._secondary = this._template.childNodes[1];

	      this._updateDeterminate();
	      this._updateValue();

	      this.appendChild(this._template);

	      ModifierUtil.initModifier(this, scheme$14);

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: 'value',
	    set: function set(value) {
	      if (typeof value !== 'number' || value < 0 || value > 100) {
	        throw new Error('Invalid value');
	      }

	      this.setAttribute('value', Math.floor(value));
	    },
	    get: function get() {
	      return parseInt(this.getAttribute('value') || '0');
	    }

	    /**
	     * @property secondaryValue
	     * @type {Number}
	     * @description
	     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
	     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
	     */

	  }, {
	    key: 'secondaryValue',
	    set: function set(value) {
	      if (typeof value !== 'number' || value < 0 || value > 100) {
	        throw new Error('Invalid value');
	      }

	      this.setAttribute('secondary-value', Math.floor(value));
	    },
	    get: function get() {
	      return parseInt(this.getAttribute('secondary-value') || '0');
	    }

	    /**
	     * @property indeterminate
	     * @type {Boolean}
	     * @description
	     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
	     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
	     */

	  }, {
	    key: 'indeterminate',
	    set: function set(value) {
	      if (value) {
	        this.setAttribute('indeterminate', '');
	      } else {
	        this.removeAttribute('indeterminate');
	      }
	    },
	    get: function get() {
	      return this.hasAttribute('indeterminate');
	    }
	  }]);
	  return ProgressBarElement;
	}(BaseElement);

	window.OnsProgressBarElement = document.registerElement('ons-progress-bar', {
	  prototype: ProgressBarElement.prototype
	});

	var scheme$15 = {
	  '.progress-circular': 'progress-circular--*',
	  '.progress-circular__primary': 'progress-circular__primary--*',
	  '.progress-circular__secondary': 'progress-circular__secondary--*'
	};

	var template$1 = util.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n  </svg>\n');

	/**
	 * @element ons-progress-circular
	 * @category progress
	 * @description
	 *   [en]
	 *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen EVzMjR
	 * @tutorial vanilla/Reference/progress
	 * @example
	 * <ons-progress-circular
	 *  value="55"
	 *  secondary-value="87">
	 * </ons-progress-circular>
	 *
	 * <ons-progress-circular
	 *  indeterminate>
	 * </ons-progress-circular>
	 */

	var ProgressCircularElement = function (_BaseElement) {
	  babelHelpers.inherits(ProgressCircularElement, _BaseElement);

	  function ProgressCircularElement() {
	    babelHelpers.classCallCheck(this, ProgressCircularElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ProgressCircularElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(ProgressCircularElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *   [en]Change the appearance of the progress indicator.[/en]
	     *   [ja]プログレスインジケータの見た目を変更します。[/ja]
	     */

	    /**
	     * @attribute value
	     * @type {Number}
	     * @description
	     *   [en]Current progress. Should be a value between 0 and 100.[/en]
	     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
	     */

	    /**
	     * @attribute secondary-value
	     * @type {Number}
	     * @description
	     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
	     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
	     */

	    /**
	     * @attribute indeterminate
	     * @description
	     *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
	     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
	     */

	    value: function createdCallback() {
	      if (!this.hasAttribute('_compiled')) {
	        this._compile();
	      }
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$15);
	      } else if (name === 'value' || name === 'secondary-value') {
	        this._updateValue();
	      } else if (name === 'indeterminate') {
	        this._updateDeterminate();
	      }
	    }
	  }, {
	    key: '_updateDeterminate',
	    value: function _updateDeterminate() {
	      if (this.hasAttribute('indeterminate')) {
	        this._template.classList.add('progress-circular--indeterminate');
	        this._template.classList.remove('progress-circular--determinate');
	      } else {
	        this._template.classList.add('progress-circular--determinate');
	        this._template.classList.remove('progress-circular--indeterminate');
	      }
	    }
	  }, {
	    key: '_updateValue',
	    value: function _updateValue() {
	      if (this.hasAttribute('value')) {
	        var per = Math.ceil(this.getAttribute('value') * 251.32 * 0.01);
	        this._primary.style['stroke-dasharray'] = per + '%, 251.32%';
	      }
	      if (this.hasAttribute('secondary-value')) {
	        var _per = Math.ceil(this.getAttribute('secondary-value') * 251.32 * 0.01);
	        this._secondary.style['stroke-dasharray'] = _per + '%, 251.32%';
	      }
	    }

	    /**
	     * @property value
	     * @type {Number}
	     * @description
	     *   [en]Current progress. Should be a value between 0 and 100.[/en]
	     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
	     */

	  }, {
	    key: '_compile',
	    value: function _compile() {
	      this._template = template$1.cloneNode(true);

	      this._primary = this._template.childNodes[3];
	      this._secondary = this._template.childNodes[1];

	      this._updateDeterminate();
	      this._updateValue();

	      this.appendChild(this._template);

	      ModifierUtil.initModifier(this, scheme$15);

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: 'value',
	    set: function set(value) {
	      if (typeof value !== 'number' || value < 0 || value > 100) {
	        throw new Error('Invalid value');
	      }

	      this.setAttribute('value', Math.floor(value));
	    },
	    get: function get() {
	      return parseInt(this.getAttribute('value') || '0');
	    }

	    /**
	     * @property secondaryValue
	     * @type {Number}
	     * @description
	     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
	     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
	     */

	  }, {
	    key: 'secondaryValue',
	    set: function set(value) {
	      if (typeof value !== 'number' || value < 0 || value > 100) {
	        throw new Error('Invalid value');
	      }

	      this.setAttribute('secondary-value', Math.floor(value));
	    },
	    get: function get() {
	      return parseInt(this.getAttribute('secondary-value') || '0');
	    }

	    /**
	     * @property indeterminate
	     * @type {Boolean}
	     * @description
	     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
	     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
	     */

	  }, {
	    key: 'indeterminate',
	    set: function set(value) {
	      if (value) {
	        this.setAttribute('indeterminate', '');
	      } else {
	        this.removeAttribute('indeterminate');
	      }
	    },
	    get: function get() {
	      return this.hasAttribute('indeterminate');
	    }
	  }]);
	  return ProgressCircularElement;
	}(BaseElement);

	window.OnsProgressCircularElement = document.registerElement('ons-progress-circular', {
	  prototype: ProgressCircularElement.prototype
	});

	var STATE_INITIAL = 'initial';
	var STATE_PREACTION = 'preaction';
	var STATE_ACTION = 'action';

	/**
	 * @element ons-pull-hook
	 * @category pull-hook
	 * @description
	 *   [en]
	 *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
	 *
	 *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen WbJogM
	 * @tutorial vanilla/Reference/pull-hook
	 * @guide UsingPullHook
	 *   [en]How to use Pull Hook[/en]
	 *   [ja]プルフックを使う[/ja]
	 * @example
	 * <ons-page>
	 *   <ons-pull-hook>
	 *     Release to refresh
	 *   </ons-pull-hook>
	 * </ons-page>
	 *
	 * <script>
	 *   document.querySelector('ons-pull-hook').onAction = function(done) {
	 *     setTimeout(done, 1000);
	 *   };
	 * </script>
	 */

	var PullHookElement = function (_BaseElement) {
	  babelHelpers.inherits(PullHookElement, _BaseElement);

	  function PullHookElement() {
	    babelHelpers.classCallCheck(this, PullHookElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PullHookElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(PullHookElement, [{
	    key: 'createdCallback',


	    /**
	     * @event changestate
	     * @description
	     *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
	     *   [ja]コンポーネントの状態が変わった場合に発火します。状態は、"initial", "preaction", "action"のいずれかです。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクト。[/ja]
	     * @param {Object} event.pullHook
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {String} event.state
	     *   [en]Current state.[/en]
	     *   [ja]現在の状態名を参照できます。[/ja]
	     */

	    /**
	     * @attribute disabled
	     * @description
	     *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
	     *   [ja]この属性がある時、disabled状態になりアクションが実行されなくなります[/ja]
	     */

	    /**
	     * @attribute height
	     * @type {String}
	     * @description
	     *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
	     *   [ja]コンポーネントの高さを指定します。この高さ以上にpull downすると"preaction"状態に移行します。デフォルトの値は"64px"です。[/ja]
	     */

	    /**
	     * @attribute threshold-height
	     * @type {String}
	     * @description
	     *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value or a value less than the height will disable this property.[/en]
	     *   [ja]閾値となる高さを指定します。この値で指定した高さよりもpull downすると、このコンポーネントは自動的に"action"状態に移行します。[/ja]
	     */

	    /**
	     * @attribute fixed-content
	     * @description
	     *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
	     *   [ja]この属性がある時、プルフックが引き出されている時にもコンテンツは動きません。[/ja]
	     */

	    value: function createdCallback() {
	      this._boundOnDrag = this._onDrag.bind(this);
	      this._boundOnDragStart = this._onDragStart.bind(this);
	      this._boundOnDragEnd = this._onDragEnd.bind(this);
	      this._boundOnScroll = this._onScroll.bind(this);

	      this._currentTranslation = 0;

	      this._ensureScrollElement();

	      this._setState(STATE_INITIAL, true);
	      this._setStyle();
	    }
	  }, {
	    key: '_createScrollElement',
	    value: function _createScrollElement() {
	      if (this.parentElement.classList.contains('scroll')) {
	        return this.parentElement;
	      }

	      var scrollElement = util.createElement('<div class="scroll"><div>');

	      var pageElement = this.parentElement;

	      scrollElement.appendChild(this);
	      while (pageElement.firstChild) {
	        scrollElement.appendChild(pageElement.firstChild);
	      }
	      pageElement.appendChild(scrollElement);

	      return scrollElement;
	    }
	  }, {
	    key: '_ensureScrollElement',
	    value: function _ensureScrollElement() {
	      if (this.parentElement && !this._scrollElement) {
	        this._scrollElement = this._createScrollElement();
	      }
	    }
	  }, {
	    key: '_setStyle',
	    value: function _setStyle() {
	      var height = this.height;

	      this.style.top = '-' + height + 'px';
	      this.style.height = height + 'px';
	      this.style.lineHeight = height + 'px';
	    }
	  }, {
	    key: '_onScroll',
	    value: function _onScroll(event) {
	      var element = this._pageElement;

	      if (element.scrollTop < 0) {
	        element.scrollTop = 0;
	      }
	    }
	  }, {
	    key: '_generateTranslationTransform',
	    value: function _generateTranslationTransform(scroll) {
	      return 'translate3d(0px, ' + scroll + 'px, 0px)';
	    }
	  }, {
	    key: '_onDrag',
	    value: function _onDrag(event) {
	      var _this2 = this;

	      if (this.disabled) {
	        return;
	      }

	      // Ignore when dragging left and right.
	      if (event.gesture.direction === 'left' || event.gesture.direction === 'right') {
	        return;
	      }

	      // Hack to make it work on Android 4.4 WebView. Scrolls manually near the top of the page so
	      // there will be no inertial scroll when scrolling down. Allowing default scrolling will
	      // kill all 'touchmove' events.
	      var element = this._pageElement;
	      element.scrollTop = this._startScroll - event.gesture.deltaY;
	      if (element.scrollTop < window.innerHeight && event.gesture.direction !== 'up') {
	        event.gesture.preventDefault();
	      }

	      if (this._currentTranslation === 0 && this._getCurrentScroll() === 0) {
	        this._transitionDragLength = event.gesture.deltaY;

	        var direction = event.gesture.interimDirection;
	        if (direction === 'down') {
	          this._transitionDragLength -= 1;
	        } else {
	          this._transitionDragLength += 1;
	        }
	      }

	      var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);

	      if (this._thresholdHeightEnabled() && scroll >= this.thresholdHeight) {
	        event.gesture.stopDetect();

	        setImmediate(function () {
	          return _this2._finish();
	        });
	      } else if (scroll >= this.height) {
	        this._setState(STATE_PREACTION);
	      } else {
	        this._setState(STATE_INITIAL);
	      }

	      event.stopPropagation();
	      this._translateTo(scroll);
	    }
	  }, {
	    key: '_onDragStart',
	    value: function _onDragStart(event) {
	      if (this.disabled) {
	        return;
	      }

	      this._startScroll = this._getCurrentScroll();
	    }
	  }, {
	    key: '_onDragEnd',
	    value: function _onDragEnd(event) {
	      if (this.disabled) {
	        return;
	      }

	      if (this._currentTranslation > 0) {
	        var scroll = this._currentTranslation;

	        if (scroll > this.height) {
	          this._finish();
	        } else {
	          this._translateTo(0, { animate: true });
	        }
	      }
	    }

	    /**
	     * @property onAction
	     * @type {Function}
	     * @description
	     *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: '_finish',
	    value: function _finish() {
	      var _this3 = this;

	      this._setState(STATE_ACTION);
	      this._translateTo(this.height, { animate: true });
	      var action = this.onAction || function (done) {
	        return done();
	      };
	      action(function () {
	        _this3._translateTo(0, { animate: true });
	        _this3._setState(STATE_INITIAL);
	      });
	    }

	    /**
	     * @property height
	     * @type {Number}
	     * @description
	     *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: '_thresholdHeightEnabled',
	    value: function _thresholdHeightEnabled() {
	      var th = this.thresholdHeight;
	      return th > 0 && th >= this.height;
	    }
	  }, {
	    key: '_setState',
	    value: function _setState(state, noEvent) {
	      var lastState = this._getState();

	      this.setAttribute('state', state);

	      if (!noEvent && lastState !== this._getState()) {
	        util.triggerElementEvent(this, 'changestate', {
	          pullHook: this,
	          state: state,
	          lastState: lastState
	        });
	      }
	    }
	  }, {
	    key: '_getState',
	    value: function _getState() {
	      return this.getAttribute('state');
	    }

	    /**
	     * @property state
	     * @readonly
	     * @type {String}
	     * @description
	     *   [en]Current state of the element.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: '_getCurrentScroll',
	    value: function _getCurrentScroll() {
	      return this._pageElement.scrollTop;
	    }

	    /**
	     * @property pullDistance
	     * @readonly
	     * @type {Number}
	     * @description
	     *   [en]The current number of pixels the pull hook has moved.[/en]
	     *   [ja]現在のプルフックが引き出された距離をピクセル数。[/ja]
	     */

	  }, {
	    key: '_isContentFixed',
	    value: function _isContentFixed() {
	      return this.hasAttribute('fixed-content');
	    }
	  }, {
	    key: '_getScrollableElement',
	    value: function _getScrollableElement() {
	      if (this._isContentFixed()) {
	        return this;
	      } else {
	        return this._scrollElement;
	      }
	    }

	    /**
	     * @param {Number} scroll
	     * @param {Object} options
	     * @param {Function} [options.callback]
	     */

	  }, {
	    key: '_translateTo',
	    value: function _translateTo(scroll) {
	      var _this4 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      if (this._currentTranslation == 0 && scroll == 0) {
	        return;
	      }

	      var done = function done() {
	        if (scroll === 0 && !_this4._isContentFixed()) {
	          _this4._getScrollableElement().removeAttribute('style');
	        }

	        if (options.callback) {
	          options.callback();
	        }
	      };

	      this._currentTranslation = scroll;

	      if (options.animate) {
	        animit(this._getScrollableElement()).queue({
	          transform: this._generateTranslationTransform(scroll)
	        }, {
	          duration: 0.3,
	          timing: 'cubic-bezier(.1, .7, .1, 1)'
	        }).play(done);
	      } else {
	        animit(this._getScrollableElement()).queue({
	          transform: this._generateTranslationTransform(scroll)
	        }).play(done);
	      }
	    }
	  }, {
	    key: '_getMinimumScroll',
	    value: function _getMinimumScroll() {
	      var scrollHeight = this._scrollElement.getBoundingClientRect().height;
	      var pageHeight = this._pageElement.getBoundingClientRect().height;

	      return scrollHeight > pageHeight ? -(scrollHeight - pageHeight) : 0;
	    }
	  }, {
	    key: '_createEventListeners',
	    value: function _createEventListeners() {
	      this._gestureDetector = new GestureDetector(this._pageElement, {
	        dragMinDistance: 1,
	        dragDistanceCorrection: false
	      });

	      // Bind listeners
	      this._gestureDetector.on('drag', this._boundOnDrag);
	      this._gestureDetector.on('dragstart', this._boundOnDragStart);
	      this._gestureDetector.on('dragend', this._boundOnDragEnd);

	      this._scrollElement.parentElement.addEventListener('scroll', this._boundOnScroll, false);
	    }
	  }, {
	    key: '_destroyEventListeners',
	    value: function _destroyEventListeners() {
	      if (this._gestureDetector) {
	        this._gestureDetector.off('drag', this._boundOnDrag);
	        this._gestureDetector.off('dragstart', this._boundOnDragStart);
	        this._gestureDetector.off('dragend', this._boundOnDragEnd);

	        this._gestureDetector.dispose();
	        this._gestureDetector = null;
	      }

	      if (this._scrollElement && this._scrollElement.parentElement) {
	        this._scrollElement.parentElement.removeEventListener('scroll', this._boundOnScroll, false);
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      this._ensureScrollElement();

	      this._pageElement = this._scrollElement.parentElement;

	      if (!this._pageElement.classList.contains('page__content')) {
	        throw new Error('<ons-pull-hook> must be a direct descendant of an <ons-page> element.');
	      }

	      this._createEventListeners();
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this._destroyEventListeners();
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {}
	  }, {
	    key: 'height',
	    set: function set(value) {
	      if (!util.isInteger(value)) {
	        throw new Error('The height must be an integer');
	      }

	      this.setAttribute('height', value + 'px');
	    },
	    get: function get() {
	      return parseInt(this.getAttribute('height') || '64', 10);
	    }

	    /**
	     * @property thresholdHeight
	     * @type {Number}
	     * @description
	     *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'thresholdHeight',
	    set: function set(value) {
	      if (!util.isInteger(value)) {
	        throw new Error('The threshold height must be an integer');
	      }

	      this.setAttribute('threshold-height', value + 'px');
	    },
	    get: function get() {
	      return parseInt(this.getAttribute('threshold-height') || '96', 10);
	    }
	  }, {
	    key: 'state',
	    get: function get() {
	      return this._getState();
	    }
	  }, {
	    key: 'pullDistance',
	    get: function get() {
	      return this._currentTranslation;
	    }

	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: 'disabled',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'disabled', value);
	    },
	    get: function get() {
	      return this.hasAttribute('disabled');
	    }
	  }]);
	  return PullHookElement;
	}(BaseElement);

	window.OnsPullHookElement = document.registerElement('ons-pull-hook', {
	  prototype: PullHookElement.prototype
	});

	window.OnsPullHookElement.STATE_ACTION = STATE_ACTION;
	window.OnsPullHookElement.STATE_INITIAL = STATE_INITIAL;
	window.OnsPullHookElement.STATE_PREACTION = STATE_PREACTION;

	/**
	 * @class AnimatorCSS - implementation of Animator class using css transitions
	 */

	var AnimatorCSS = function () {
	  babelHelpers.createClass(AnimatorCSS, [{
	    key: 'animate',


	    /**
	     * @method animate
	     * @desc main animation function
	     * @param {Element} element
	     * @param {Object} finalCSS
	     * @param {number} [duration=200] - duration in milliseconds
	     * @return {Object} result
	     * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
	     * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
	     * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
	     * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
	     * @example
	     * ````
	     *  var result = animator.animate(el, {opacity: 0.5}, 1000);
	     *
	     *  el.addEventListener('click', function(e){
	     *    result.speed(200).then(function(){
	     *      console.log('done');
	     *    });
	     *  }, 300);
	     * ````
	     */
	    value: function animate(el, final) {
	      var duration = arguments.length <= 2 || arguments[2] === undefined ? 200 : arguments[2];

	      var start = new Date().getTime(),
	          initial = {},
	          stopped = false,
	          next = false,
	          timeout = false,
	          properties = Object.keys(final);

	      var updateStyles = function updateStyles() {
	        var s = window.getComputedStyle(el);
	        properties.forEach(s.getPropertyValue.bind(s));
	        s = el.offsetHeight;
	      };

	      var result = {
	        stop: function stop() {
	          var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	          timeout && clearTimeout(timeout);
	          var k = Math.min(1, (new Date().getTime() - start) / duration);
	          properties.forEach(function (i) {
	            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
	          });
	          el.style.transitionDuration = '0s';

	          if (options.stopNext) {
	            next = false;
	          } else if (!stopped) {
	            stopped = true;
	            next && next();
	          }
	          return result;
	        },
	        then: function then(cb) {
	          next = cb;
	          if (stopped) {
	            next && next();
	          }
	          return result;
	        },
	        speed: function speed(newDuration) {
	          if (internal.config.animationsDisabled) {
	            newDuration = 0;
	          }
	          if (!stopped) {
	            (function () {
	              timeout && clearTimeout(timeout);

	              var passed = new Date().getTime() - start;
	              var k = passed / duration;
	              var remaining = newDuration * (1 - k);

	              properties.forEach(function (i) {
	                el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
	              });

	              updateStyles();

	              start = el.speedUpTime;
	              duration = remaining;

	              el.style.transitionDuration = duration / 1000 + 's';

	              properties.forEach(function (i) {
	                el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
	              });

	              timeout = setTimeout(result.stop, remaining);
	            })();
	          }
	          return result;
	        },
	        finish: function finish() {
	          var milliseconds = arguments.length <= 0 || arguments[0] === undefined ? 50 : arguments[0];

	          var k = (new Date().getTime() - start) / duration;

	          result.speed(milliseconds / (1 - k));
	          return result;
	        }
	      };

	      if (el.hasAttribute('disabled') || stopped || internal.config.animationsDisabled) {
	        return result;
	      }

	      var style = window.getComputedStyle(el);
	      properties.forEach(function (e) {
	        var v = parseFloat(style.getPropertyValue(e));
	        initial[e] = isNaN(v) ? 0 : v;
	      });

	      if (!stopped) {
	        el.style.transitionProperty = properties.join(',');
	        el.style.transitionDuration = duration / 1000 + 's';

	        properties.forEach(function (e) {
	          el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
	        });
	      }

	      timeout = setTimeout(result.stop, duration);
	      this._onStopAnimations(el, result.stop);

	      return result;
	    }
	  }]);

	  function AnimatorCSS() {
	    babelHelpers.classCallCheck(this, AnimatorCSS);

	    this._queue = [];
	    this._index = 0;
	  }

	  babelHelpers.createClass(AnimatorCSS, [{
	    key: '_onStopAnimations',
	    value: function _onStopAnimations(el, listener) {
	      var queue = this._queue;
	      var i = this._index++;
	      queue[el] = queue[el] || [];
	      queue[el][i] = function (options) {
	        delete queue[el][i];
	        if (queue[el] && queue[el].length == 0) {
	          delete queue[el];
	        }
	        return listener(options);
	      };
	    }

	    /**
	    * @method stopAnimations
	    * @desc stops active animations on a specified element
	    * @param {Element|Array} element - element or array of elements
	    * @param {Object} [options={}]
	    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
	    */

	  }, {
	    key: 'stopAnimations',
	    value: function stopAnimations(el) {
	      var _this = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      if (Array.isArray(el)) {
	        return el.forEach(function (el) {
	          _this.stopAnimations(el, options);
	        });
	      }

	      (this._queue[el] || []).forEach(function (e) {
	        e(options || {});
	      });
	    }

	    /**
	    * @method stopAll
	    * @desc stops all active animations
	    * @param {Object} [options={}]
	    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
	    */

	  }, {
	    key: 'stopAll',
	    value: function stopAll() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      this.stopAnimations(Object.keys(this._queue), options);
	    }

	    /**
	    * @method fade
	    * @desc fades the element (short version for animate(el, {opacity: 0}))
	    * @param {Element} element
	    * @param {number} [duration=200]
	    */

	  }, {
	    key: 'fade',
	    value: function fade(el) {
	      var duration = arguments.length <= 1 || arguments[1] === undefined ? 200 : arguments[1];

	      return this.animate(el, { opacity: 0 }, duration);
	    }
	  }]);
	  return AnimatorCSS;
	}();

	/**
	 * @element ons-ripple
	 * @category ripple
	 * @description
	 *   [en]
	 *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
	 *
	 *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
	 *   [/en]
	 *   [ja]マテリアルデザインのリップル効果をDOM要素に追加します。[/ja]
	 * @codepen wKQWdZ
	 * @tutorial vanilla/Reference/ripple
	 * @example
	 * <div class="my-div">
	 *  <ons-ripple></ons-ripple>
	 * </div>
	 *
	 * <ons-button ripple>Click me!</ons-button>
	 */

	var RippleElement = function (_BaseElement) {
	  babelHelpers.inherits(RippleElement, _BaseElement);

	  function RippleElement() {
	    babelHelpers.classCallCheck(this, RippleElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(RippleElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(RippleElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute color
	     * @type {String}
	     * @description
	     *   [en]Color of the ripple effect.[/en]
	     *   [ja]リップルエフェクトの色を指定します。[/ja]
	     */

	    /**
	     * @attribute background
	     * @type {String}
	     * @description
	     *   [en]Color of the background.[/en]
	     *   [ja]背景の色を設定します。[/ja]
	     */

	    /**
	     * @attribute disabled
	     * @description
	     *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
	     *   [ja]この属性が設定された場合、リップルエフェクトは無効になります。[/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      this.classList.add('ripple');
	      if (!this.hasAttribute('_compiled')) {
	        this._compile();
	      } else {
	        this._background = this.getElementsByClassName('ripple__background')[0];
	        this._wave = this.getElementsByClassName('ripple__wave')[0];
	      }

	      this._animator = new AnimatorCSS();

	      ['color', 'center', 'start-radius', 'background'].forEach(function (e) {
	        _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
	      });
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      var _this3 = this;

	      ['_wave', '_background'].forEach(function (e) {
	        _this3[e] = document.createElement('div');
	        _this3[e].classList.add('ripple_' + e);
	        _this3.appendChild(_this3[e]);
	      });
	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: '_calculateCoords',
	    value: function _calculateCoords(e) {
	      var x, y, h, w, r;
	      var b = this.getBoundingClientRect();
	      if (this._center) {
	        x = b.width / 2;
	        y = b.height / 2;
	        r = Math.sqrt(x * x + y * y);
	      } else {
	        x = (e.clientX || e.changedTouches[0].clientX) - b.left;
	        y = (e.clientY || e.changedTouches[0].clientY) - b.top;
	        h = Math.max(y, b.height - y);
	        w = Math.max(x, b.width - x);
	        r = Math.sqrt(h * h + w * w);
	      }
	      return { x: x, y: y, r: r };
	    }
	  }, {
	    key: '_rippleAnimation',
	    value: function _rippleAnimation(e) {
	      var duration = arguments.length <= 1 || arguments[1] === undefined ? 300 : arguments[1];
	      var _animator = this._animator;
	      var _wave = this._wave;
	      var _background = this._background;

	      var _minR = this._minR;

	      var _calculateCoords2 = this._calculateCoords(e);

	      var x = _calculateCoords2.x;
	      var y = _calculateCoords2.y;
	      var r = _calculateCoords2.r;


	      _animator.stopAll({ stopNext: 1 });
	      _animator.animate(_background, { opacity: 1 }, duration);

	      util.extend(_wave.style, {
	        opacity: 1,
	        top: y - _minR + 'px',
	        left: x - _minR + 'px',
	        width: 2 * _minR + 'px',
	        height: 2 * _minR + 'px'
	      });

	      return _animator.animate(_wave, {
	        top: y - r,
	        left: x - r,
	        height: 2 * r,
	        width: 2 * r
	      }, duration);
	    }
	  }, {
	    key: '_updateParent',
	    value: function _updateParent() {
	      if (!this._parentUpdated && this.parentNode) {
	        var computedStyle = window.getComputedStyle(this.parentNode);
	        if (computedStyle.getPropertyValue('position') === 'static') {
	          this.parentNode.style.position = 'relative';
	        }
	        this._parentUpdated = true;
	      }
	    }
	  }, {
	    key: '_onTap',
	    value: function _onTap(e) {
	      var _this4 = this;

	      if (!this.disabled) {
	        this._updateParent();
	        this._rippleAnimation(e.gesture.srcEvent).then(function () {
	          _this4._animator.fade(_this4._wave);
	          _this4._animator.fade(_this4._background);
	        });
	      }
	    }
	  }, {
	    key: '_onHold',
	    value: function _onHold(e) {
	      if (!this.disabled) {
	        this._updateParent();
	        this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
	        document.addEventListener('release', this._boundOnRelease);
	      }
	    }
	  }, {
	    key: '_onRelease',
	    value: function _onRelease(e) {
	      var _this5 = this;

	      if (this._holding) {
	        this._holding.speed(300).then(function () {
	          _this5._animator.stopAll({ stopNext: true });
	          _this5._animator.fade(_this5._wave);
	          _this5._animator.fade(_this5._background);
	        });

	        this._holding = false;
	      }

	      document.removeEventListener('release', this._boundOnRelease);
	    }
	  }, {
	    key: '_onDragStart',
	    value: function _onDragStart(e) {
	      if (this._holding) {
	        return this._onRelease(e);
	      }
	      if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
	        this._onTap(e);
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      this._parentNode = this.parentNode;
	      this._boundOnTap = this._onTap.bind(this);
	      this._boundOnHold = this._onHold.bind(this);
	      this._boundOnDragStart = this._onDragStart.bind(this);
	      this._boundOnRelease = this._onRelease.bind(this);

	      if (internal.config.animationsDisabled) {
	        this.disabled = true;
	      } else {
	        this._parentNode.addEventListener('tap', this._boundOnTap);
	        this._parentNode.addEventListener('hold', this._boundOnHold);
	        this._parentNode.addEventListener('dragstart', this._boundOnDragStart);
	      }
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this._parentNode.removeEventListener('tap', this._boundOnTap);
	      this._parentNode.removeEventListener('hold', this._boundOnHold);
	      this._parentNode.removeEventListener('dragstart', this._boundOnDragStart);
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'start-radius') {
	        this._minR = Math.max(0, parseFloat(current) || 0);
	      }
	      if (name === 'color' && current) {
	        this._wave.style.background = current;
	        if (!this.hasAttribute('background')) {
	          this._background.style.background = current;
	        }
	      }
	      if (name === 'background' && (current || last)) {
	        if (current === 'none') {
	          this._background.setAttribute('disabled', 'disabled');
	          this._background.style.background = 'transparent';
	        } else {
	          if (this._background.hasAttribute('disabled')) {
	            this._background.removeAttribute('disabled');
	          }
	          this._background.style.background = current;
	        }
	      }
	      if (name === 'center') {
	        this._center = current != null && current != 'false';
	      }
	    }

	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: 'disabled',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'disabled', value);
	    },
	    get: function get() {
	      return this.hasAttribute('disabled');
	    }
	  }]);
	  return RippleElement;
	}(BaseElement);

	window.OnsRippleElement = document.registerElement('ons-ripple', {
	  prototype: RippleElement.prototype
	});

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	/**
	 * @element ons-row
	 * @category grid
	 * @description
	 *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
	 *   [ja]グリッドシステムにて行を定義します。ons-colとともに使用し、コンポーネントの配置に使用します。[/ja]
	 * @codepen GgujC {wide}
	 * @guide Layouting
	 *   [en]Layouting guide[/en]
	 *   [ja]レイアウト調整[/ja]
	 * @seealso ons-col
	 *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
	 *   [ja]ons-colコンポーネント[/ja]
	 * @note
	 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
	 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-colを組み合わせてそれぞれのons-col要素のvertical-align属性の値に別々の値を指定すると、描画が崩れる場合があります。vertical-align属性の値には一つの値だけを指定できます。[/ja]
	 * @example
	 * <ons-row>
	 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
	 *   <ons-col>Text</ons-col>
	 * </ons-row>
	 */

	/**
	 * @attribute vertical-align
	 * @type {String}
	 * @description
	 *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
	 *   [ja]縦に整列するために指定します。top、bottom、centerのいずれかを指定できます。[/ja]
	 */
	window.OnsRowElement = window.OnsRowElement ? window.OnsRowElement : document.registerElement('ons-row');

	var scheme$16 = {
	  '': 'speed-dial__item--*'
	};

	/**
	 * @element ons-speed-dial-item
	 * @category speed-dial
	 * @description
	 *   [en]
	 *     This component displays the child elements of the Material Design Speed dial component.
	 *   [/en]
	 *   [ja]
	 *     Material DesignのSpeed dialの子要素を表現する要素です。
	 *   [/ja]
	 * @codepen dYQYLg
	 * @tutorial vanilla/Reference/speed-dial
	 * @seealso ons-speed-dial
	 *   [en]The `<ons-speed-dial>` component.[/en]
	 *   [ja]ons-speed-dialコンポーネント[/ja]
	 * @example
	 * <ons-speed-dial position="left bottom">
	 *   <ons-fab>
	 *     <ons-icon icon="fa-twitter"></ons-icon>
	 *   </ons-fab>
	 *   <ons-speed-dial-item>A</ons-speed-dial-item>
	 *   <ons-speed-dial-item>B</ons-speed-dial-item>
	 *   <ons-speed-dial-item>C</ons-speed-dial-item>
	 * </ons-speed-dial>
	 */

	var SpeedDialItemElement = function (_BaseElement) {
	  babelHelpers.inherits(SpeedDialItemElement, _BaseElement);

	  function SpeedDialItemElement() {
	    babelHelpers.classCallCheck(this, SpeedDialItemElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SpeedDialItemElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(SpeedDialItemElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *   [en]The appearance of the component.[/en]
	     *   [ja]このコンポーネントの表現を指定します。[/ja]
	     */

	    value: function createdCallback() {
	      this._compile();

	      this._boundOnClick = this._onClick.bind(this);
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      switch (name) {
	        case 'modifier':
	          ModifierUtil.onModifierChanged(last, current, this, scheme$16);
	          break;
	        case 'ripple':
	          this._updateRipple();
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      this.addEventListener('click', this._boundOnClick, false);
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this.removeEventListener('click', this._boundOnClick, false);
	    }
	  }, {
	    key: '_updateRipple',
	    value: function _updateRipple() {
	      util.updateRipple(this);
	    }
	  }, {
	    key: '_onClick',
	    value: function _onClick(e) {
	      e.stopPropagation();
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      this.classList.add('fab');
	      this.classList.add('fab--mini');
	      this.classList.add('speed-dial__item');

	      this._updateRipple();

	      ModifierUtil.initModifier(this, scheme$16);
	    }
	  }]);
	  return SpeedDialItemElement;
	}(BaseElement);

	window.OnsSpeedDialItemElement = document.registerElement('ons-speed-dial-item', {
	  prototype: SpeedDialItemElement.prototype
	});

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	/**
	 * Minimal utility library for manipulating element's style.
	 */
	var styler = function styler(element, style) {
	  return styler.css.apply(styler, arguments);
	};

	/**
	 * Set element's style.
	 *
	 * @param {Element} element
	 * @param {Object} styles
	 * @return {Element}
	 */
	styler.css = function (element, styles) {
	  var keys = Object.keys(styles);
	  keys.forEach(function (key) {
	    if (key in element.style) {
	      element.style[key] = styles[key];
	    } else if (styler._prefix(key) in element.style) {
	      element.style[styler._prefix(key)] = styles[key];
	    } else {
	      console.warn('No such style property: ' + key);
	    }
	  });
	  return element;
	};

	/**
	 * Add vendor prefix.
	 *
	 * @param {String} name
	 * @return {String}
	 */
	styler._prefix = function () {
	  var styles = window.getComputedStyle(document.documentElement, '');
	  var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

	  return function (name) {
	    return prefix + name.substr(0, 1).toUpperCase() + name.substr(1);
	  };
	}();

	/**
	 * @param {Element} element
	 */
	styler.clear = function (element) {
	  styler._clear(element);
	};

	/**
	 * @param {Element} element
	 */
	styler._clear = function (element) {
	  var len = element.style.length;
	  var style = element.style;
	  var keys = [];
	  for (var i = 0; i < len; i++) {
	    keys.push(style[i]);
	  }

	  keys.forEach(function (key) {
	    style[key] = '';
	  });
	};

	var scheme$17 = {
	  '': 'speed-dial--*'
	};

	/**
	 * @element ons-speed-dial
	 * @category speed-dial
	 * @description
	 *   [en]
	 *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
	 *
	 *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen dYQYLg
	 * @tutorial vanilla/Reference/speed-dial
	 * @seealso ons-speed-dial-item
	 *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
	 *   [ja]ons-speed-dial-itemコンポーネント[/ja]
	 * @example
	 * <ons-speed-dial position="left bottom">
	 *   <ons-fab>
	 *     <ons-icon icon="fa-twitter"></ons-icon>
	 *   </ons-fab>
	 *   <ons-speed-dial-item>A</ons-speed-dial-item>
	 *   <ons-speed-dial-item>B</ons-speed-dial-item>
	 *   <ons-speed-dial-item>C</ons-speed-dial-item>
	 * </ons-speed-dial>
	 */

	var SpeedDialElement = function (_BaseElement) {
	  babelHelpers.inherits(SpeedDialElement, _BaseElement);

	  function SpeedDialElement() {
	    babelHelpers.classCallCheck(this, SpeedDialElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SpeedDialElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(SpeedDialElement, [{
	    key: 'createdCallback',


	    /**
	     * @event open
	     * @description
	     *   [en]Fired when the menu items are shown.[/en]
	     *   [ja][/ja]
	     */

	    /**
	     * @event close
	     * @description
	     *   [en]Fired when the menu items are hidden.[/en]
	     *   [ja][/ja]
	     */

	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *   [en]The appearance of the component.[/en]
	     *   [ja]このコンポーネントの表現を指定します。[/ja]
	     */

	    /**
	     * @attribute position
	     * @type {String}
	     * @description
	     *   [en]
	     *     Specify the vertical and horizontal position of the component.
	     *     I.e. to display it in the top right corner specify "right top".
	     *     Choose from "right", "left", "top" and "bottom".
	     *   [/en]
	     *   [ja]
	     *     この要素を表示する左右と上下の位置を指定します。
	     *     例えば、右上に表示する場合には"right top"を指定します。
	     *     左右と上下の位置の指定には、rightとleft、topとbottomがそれぞれ指定できます。
	     *   [/ja]
	     */

	    /**
	     * @attribute direction
	     * @type {String}
	     * @description
	     *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
	     *   [ja]
	     *     要素が表示する方向を指定します。up, down, left, rightが指定できます。
	     *   [/ja]
	     */

	    /**
	     * @attribute disabled
	     * @description
	     *   [en]Specify if button should be disabled.[/en]
	     *   [ja]無効化する場合に指定します。[/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        _this2._compile();
	      });

	      this._shown = true;
	      this._itemShown = false;
	      this._boundOnClick = this._onClick.bind(this);
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      if (!this.classList.contains('speed__dial')) {
	        this.classList.add('speed__dial');
	        autoStyle.prepare(this);
	        this._updateRipple();
	        ModifierUtil.initModifier(this, scheme$17);

	        if (this.hasAttribute('direction')) {
	          this._updateDirection(this.getAttribute('direction'));
	        } else {
	          this._updateDirection('up');
	        }
	      }

	      this._updatePosition();
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      var _this3 = this;

	      switch (name) {
	        case 'modifier':
	          ModifierUtil.onModifierChanged(last, current, this, scheme$17);
	          break;
	        case 'ripple':
	          contentReady(this, function () {
	            return _this3._updateRipple();
	          });
	          break;
	        case 'direction':
	          contentReady(this, function () {
	            return _this3._updateDirection(current);
	          });
	          break;
	        case 'position':
	          contentReady(this, function () {
	            return _this3._updatePosition();
	          });
	          break;
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      this.addEventListener('click', this._boundOnClick, false);
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this.removeEventListener('click', this._boundOnClick, false);
	    }
	  }, {
	    key: '_onClick',
	    value: function _onClick(e) {
	      if (!this.disabled && this._shown) {
	        this.toggleItems();
	      }
	    }
	  }, {
	    key: '_show',
	    value: function _show() {
	      if (!this.inline) {
	        this.show();
	      }
	    }
	  }, {
	    key: '_hide',
	    value: function _hide() {
	      if (!this.inline) {
	        this.hide();
	      }
	    }
	  }, {
	    key: '_updateRipple',
	    value: function _updateRipple() {
	      var fab = util.findChild(this, 'ons-fab');

	      if (fab) {
	        this.hasAttribute('ripple') ? fab.setAttribute('ripple', '') : fab.removeAttribute('ripple');
	      }
	    }
	  }, {
	    key: '_updateDirection',
	    value: function _updateDirection(direction) {
	      var children = this.items;
	      for (var i = 0; i < children.length; i++) {
	        styler(children[i], {
	          transitionDelay: 25 * i + 'ms',
	          bottom: 'auto',
	          right: 'auto',
	          top: 'auto',
	          left: 'auto'
	        });
	      }
	      switch (direction) {
	        case 'up':
	          for (var _i = 0; _i < children.length; _i++) {
	            children[_i].style.bottom = 72 + 56 * _i + 'px';
	            children[_i].style.right = '8px';
	          }
	          break;
	        case 'down':
	          for (var _i2 = 0; _i2 < children.length; _i2++) {
	            children[_i2].style.top = 72 + 56 * _i2 + 'px';
	            children[_i2].style.left = '8px';
	          }
	          break;
	        case 'left':
	          for (var _i3 = 0; _i3 < children.length; _i3++) {
	            children[_i3].style.top = '8px';
	            children[_i3].style.right = 72 + 56 * _i3 + 'px';
	          }
	          break;
	        case 'right':
	          for (var _i4 = 0; _i4 < children.length; _i4++) {
	            children[_i4].style.top = '8px';
	            children[_i4].style.left = 72 + 56 * _i4 + 'px';
	          }
	          break;
	        default:
	          throw new Error('Argument must be one of up, down, left or right.');
	      }
	    }
	  }, {
	    key: '_updatePosition',
	    value: function _updatePosition() {
	      var position = this.getAttribute('position');
	      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
	      switch (position) {
	        case 'top right':
	        case 'right top':
	          this.classList.add('fab--top__right');
	          break;
	        case 'top left':
	        case 'left top':
	          this.classList.add('fab--top__left');
	          break;
	        case 'bottom right':
	        case 'right bottom':
	          this.classList.add('fab--bottom__right');
	          break;
	        case 'bottom left':
	        case 'left bottom':
	          this.classList.add('fab--bottom__left');
	          break;
	        case 'center top':
	        case 'top center':
	          this.classList.add('fab--top__center');
	          break;
	        case 'center bottom':
	        case 'bottom center':
	          this.classList.add('fab--bottom__center');
	          break;
	        default:
	          break;
	      }
	    }

	    /**
	     * @method show
	     * @signature show()
	     * @description
	     *   [en]Show the speed dial.[/en]
	     *   [ja]Speed dialを表示します。[/ja]
	     */

	  }, {
	    key: 'show',
	    value: function show() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      this.querySelector('ons-fab').show();
	      this._shown = true;
	    }

	    /**
	     * @method hide
	     * @signature hide()
	     * @description
	     *   [en]Hide the speed dial.[/en]
	     *   [ja]Speed dialを非表示にします。[/ja]
	     */

	  }, {
	    key: 'hide',
	    value: function hide() {
	      var _this4 = this;

	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      this.hideItems();
	      setTimeout(function () {
	        _this4.querySelector('ons-fab').hide();
	      }, 200);
	      this._shown = false;
	    }

	    /**
	     * @method showItems
	     * @signature showItems()
	     * @description
	     *   [en]Show the speed dial items.[/en]
	     *   [ja]Speed dialの子要素を表示します。[/ja]
	     */

	  }, {
	    key: 'showItems',
	    value: function showItems() {

	      if (this.hasAttribute('direction')) {
	        this._updateDirection(this.getAttribute('direction'));
	      } else {
	        this._updateDirection('up');
	      }

	      if (!this._itemShown) {
	        var children = this.items;
	        for (var i = 0; i < children.length; i++) {
	          styler(children[i], {
	            transform: 'scale(1)',
	            transitionDelay: 25 * i + 'ms'
	          });
	        }
	      }
	      this._itemShown = true;

	      util.triggerElementEvent(this, 'open');
	    }

	    /**
	     * @method hideItems
	     * @signature hideItems()
	     * @description
	     *   [en]Hide the speed dial items.[/en]
	     *   [ja]Speed dialの子要素を非表示にします。[/ja]
	     */

	  }, {
	    key: 'hideItems',
	    value: function hideItems() {
	      if (this._itemShown) {
	        var children = this.items;
	        for (var i = 0; i < children.length; i++) {
	          styler(children[i], {
	            transform: 'scale(0)',
	            transitionDelay: 25 * (children.length - i) + 'ms'
	          });
	        }
	      }
	      this._itemShown = false;
	      util.triggerElementEvent(this, 'close');
	    }

	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: 'isOpen',


	    /**
	     * @method isOpen
	     * @signature isOpen()
	     * @description
	     *   [en]Returns whether the menu is open or not.[/en]
	     *   [ja][/ja]
	     */
	    value: function isOpen() {
	      return this._itemShown;
	    }

	    /**
	     * @method toggle
	     * @signature toggle()
	     * @description
	     *   [en]Toggle visibility.[/en]
	     *   [ja]Speed dialの表示非表示を切り替えます。[/ja]
	     */

	  }, {
	    key: 'toggle',
	    value: function toggle() {
	      this.visible ? this.hide() : this.show();
	    }

	    /**
	     * @method toggleItems
	     * @signature toggleItems()
	     * @description
	     *   [en]Toggle item visibility.[/en]
	     *   [ja]Speed dialの子要素の表示非表示を切り替えます。[/ja]
	     */

	  }, {
	    key: 'toggleItems',
	    value: function toggleItems() {
	      if (this.isOpen()) {
	        this.hideItems();
	      } else {
	        this.showItems();
	      }
	    }
	  }, {
	    key: 'items',
	    get: function get() {
	      return util.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
	    }
	  }, {
	    key: 'disabled',
	    set: function set(value) {
	      if (value) {
	        this.hideItems();
	      }
	      util.arrayFrom(this.children).forEach(function (e) {
	        util.match(e, '.fab') && util.toggleAttribute(e, 'disabled', value);
	      });

	      return util.toggleAttribute(this, 'disabled', value);
	    },
	    get: function get() {
	      return this.hasAttribute('disabled');
	    }

	    /**
	     * @property inline
	     * @readonly
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is inline or not.[/en]
	     *   [ja]インライン要素の場合に`true`。[/ja]
	     */

	  }, {
	    key: 'inline',
	    get: function get() {
	      return this.hasAttribute('inline');
	    }

	    /**
	     * @property visible
	     * @readonly
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is visible or not.[/en]
	     *   [ja]要素が見える場合に`true`。[/ja]
	     */

	  }, {
	    key: 'visible',
	    get: function get() {
	      return this._shown && this.style.display !== 'none';
	    }
	  }]);
	  return SpeedDialElement;
	}(BaseElement);

	window.OnsSpeedDialElement = document.registerElement('ons-speed-dial', {
	  prototype: SpeedDialElement.prototype
	});

	var rewritables$1 = {
	  /**
	   * @param {Element} element
	   * @param {Function} callback
	   */

	  ready: function ready(element, callback) {
	    setImmediate(callback);
	  },


	  /**
	   * @param {Element} element
	   * @param {HTMLFragment} target
	   * @param {Object} options
	   * @param {Function} callback
	   */
	  link: function link(element, target, options, callback) {
	    callback(target);
	  }
	};

	/**
	 * @element ons-splitter-content
	 * @category splitter
	 * @description
	 *  [en]
	 *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
	 *
	 *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
	 *  [/en]
	 *  [ja]ons-splitter-content要素は、ons-splitter要素の子要素として利用します。[/ja]
	 * @codepen rOQOML
	 * @tutorial vanilla/Reference/splitter
	 * @seealso ons-splitter
	 *  [en]The `<ons-splitter>` component is the parent element.[/en]
	 *  [ja]ons-splitterコンポーネント[/ja]
	 * @seealso ons-splitter-side
	 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
	 *  [ja]ons-splitter-sideコンポーネント[/ja]
	 * @example
	 * <ons-splitter>
	 *   <ons-splitter-content>
	 *     ...
	 *   </ons-splitter-content>
	 *
	 *   <ons-splitter-side side="left" width="80%" collapse>
	 *     ...
	 *   </ons-splitter-side>
	 * </ons-splitter>
	 */

	var SplitterContentElement = function (_BaseElement) {
	  babelHelpers.inherits(SplitterContentElement, _BaseElement);

	  function SplitterContentElement() {
	    babelHelpers.classCallCheck(this, SplitterContentElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterContentElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(SplitterContentElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute page
	     * @type {String}
	     * @description
	     *   [en]
	     *     The url of the content page. If this attribute is used the content will be loaded from a `<ons-template>` tag or a remote file.
	     *
	     *     It is also possible to put `<ons-page>` element as a child of the element.
	     *   [/en]
	     *   [ja]ons-splitter-content要素に表示するページのURLを指定します。[/ja]
	     */
	    value: function createdCallback() {
	      this._page = null;
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      if (!util.match(this.parentNode, 'ons-splitter')) {
	        throw new Error('"ons-splitter-content" must have "ons-splitter" as parentNode.');
	      }
	      this.attributeChangedCallback('page', null, this.getAttribute('page'));
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {}
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      var _this2 = this;

	      if (name === 'page' && current !== null) {
	        rewritables$1.ready(this, function () {
	          return _this2.load(current);
	        });
	      }
	    }

	    /**
	     * @property page
	     * @readonly
	     * @type {HTMLElement}
	     * @description
	     *   [en]Page element loaded in the splitter content.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'load',


	    /**
	     * @method load
	     * @signature load(page, [options])
	     * @param {String} page, [options]
	     *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
	     *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
	     * @param {Object} [options]
	     * @param {Function} [options.callback]
	     * @description
	     *   [en]Show the page specified in `page` in the content.[/en]
	     *   [ja]指定したURLをメインページを読み込みます。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the new `<ons-page>` element[/en]
	     *   [ja][/ja]
	     */
	    value: function load(page) {
	      var _this3 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      this._page = page;
	      var callback = options.callback;

	      return internal.getPageHTMLAsync(page).then(function (html) {
	        return new Promise(function (resolve) {
	          rewritables$1.link(_this3, util.createFragment(html), options, function (fragment) {
	            _this3._hide();
	            _this3.innerHTML = '';

	            _this3.appendChild(fragment);

	            _this3._show();
	            callback && callback();
	            resolve(_this3.firstChild);
	          });
	        });
	      });
	    }
	  }, {
	    key: '_show',
	    value: function _show() {
	      util.propagateAction(this, '_show');
	    }
	  }, {
	    key: '_hide',
	    value: function _hide() {
	      util.propagateAction(this, '_hide');
	    }
	  }, {
	    key: '_destroy',
	    value: function _destroy() {
	      util.propagateAction(this, '_destroy');
	      this.remove();
	    }
	  }, {
	    key: 'page',
	    get: function get() {
	      return this._page;
	    }
	  }]);
	  return SplitterContentElement;
	}(BaseElement);

	window.OnsSplitterContentElement = document.registerElement('ons-splitter-content', {
	  prototype: SplitterContentElement.prototype
	});

	window.OnsSplitterContentElement.rewritables = rewritables$1;

	var SplitterMaskElement = function (_BaseElement) {
	  babelHelpers.inherits(SplitterMaskElement, _BaseElement);

	  function SplitterMaskElement() {
	    babelHelpers.classCallCheck(this, SplitterMaskElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterMaskElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(SplitterMaskElement, [{
	    key: 'createdCallback',
	    value: function createdCallback() {
	      this._boundOnClick = this._onClick.bind(this);
	    }
	  }, {
	    key: '_onClick',
	    value: function _onClick(event) {
	      if (util.match(this.parentNode, 'ons-splitter')) {
	        this.parentNode._sides.forEach(function (side) {
	          return side.close('left').catch(function () {});
	        });
	      }
	      event.stopPropagation();
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {}
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      this.addEventListener('click', this._boundOnClick);
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this.removeEventListener('click', this._boundOnClick);
	    }
	  }]);
	  return SplitterMaskElement;
	}(BaseElement);

	window.OnsSplitterMaskElement = document.registerElement('ons-splitter-mask', {
	  prototype: SplitterMaskElement.prototype
	});

	var SplitterAnimator = function () {
	  function SplitterAnimator() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    babelHelpers.classCallCheck(this, SplitterAnimator);

	    this._options = {
	      timing: 'cubic-bezier(.1, .7, .1, 1)',
	      duration: '0.3',
	      delay: '0'
	    };
	    this.updateOptions(options);
	  }

	  babelHelpers.createClass(SplitterAnimator, [{
	    key: 'updateOptions',
	    value: function updateOptions() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      util.extend(this._options, options);
	      this._timing = this._options.timing;
	      this._duration = this._options.duration;
	      this._delay = this._options.delay;
	    }

	    /**
	     * @param {Element} sideElement
	     */

	  }, {
	    key: 'activate',
	    value: function activate(sideElement) {
	      var _this = this;

	      var splitter = sideElement.parentNode;

	      contentReady(splitter, function () {
	        _this._side = sideElement;
	        _this._content = splitter.content;
	        _this._mask = splitter.mask;
	      });
	    }
	  }, {
	    key: 'inactivate',
	    value: function inactivate() {
	      this._content = this._side = this._mask = null;
	    }
	  }, {
	    key: 'translate',
	    value: function translate(distance) {
	      animit(this._side).queue({
	        transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'
	      }).play();
	    }

	    /**
	     * @param {Function} done
	     */

	  }, {
	    key: 'open',
	    value: function open(done) {
	      animit.runAll(animit(this._side).wait(this._delay).queue({
	        transform: 'translate3d(' + this.minus + '100%, 0px, 0px)'
	      }, {
	        duration: this._duration,
	        timing: this._timing
	      }).queue(function (callback) {
	        callback();
	        done && done();
	      }), animit(this._mask).wait(this._delay).queue({
	        display: 'block'
	      }).queue({
	        opacity: '1'
	      }, {
	        duration: this._duration,
	        timing: 'linear'
	      }));
	    }

	    /**
	     * @param {Function} done
	     */

	  }, {
	    key: 'close',
	    value: function close(done) {
	      var _this2 = this;

	      animit.runAll(animit(this._side).wait(this._delay).queue({
	        transform: 'translate3d(0px, 0px, 0px)'
	      }, {
	        duration: this._duration,
	        timing: this._timing
	      }).queue(function (callback) {
	        _this2._side.style.webkitTransition = '';
	        done && done();
	        callback();
	      }), animit(this._mask).wait(this._delay).queue({
	        opacity: '0'
	      }, {
	        duration: this._duration,
	        timing: 'linear'
	      }).queue({
	        display: 'none'
	      }));
	    }
	  }, {
	    key: 'minus',
	    get: function get() {
	      return this._side._side === 'right' ? '-' : '';
	    }
	  }]);
	  return SplitterAnimator;
	}();

	/**
	 * @element ons-splitter
	 * @category splitter
	 * @description
	 *  [en]
	 *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
	 *
	 *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
	 *  [/en]
	 *  [ja][/ja]
	 * @codepen rOQOML
	 * @tutorial vanilla/Reference/splitter
	 * @seealso ons-splitter-content
	 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
	 *  [ja]ons-splitter-contentコンポーネント[/ja]
	 * @seealso ons-splitter-side
	 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
	 *  [ja]ons-splitter-sideコンポーネント[/ja]
	 * @guide CallingComponentAPIsfromJavaScript
	 *   [en]Using components from JavaScript[/en]
	 *   [ja]JavaScriptからコンポーネントを呼び出す[/ja]
	 * @example
	 * <ons-splitter id="splitter">
	 *   <ons-splitter-content>
	 *     ...
	 *   </ons-splitter-content>
	 *
	 *   <ons-splitter-side side="left" width="80%" collapse swipeable>
	 *     ...
	 *   </ons-splitter-side>
	 * </ons-splitter>
	 *
	 * <script>
	 *   var splitter = document.getElementById('splitter');
	 *   splitter.left.open();
	 * </script>
	 */

	var SplitterElement = function (_BaseElement) {
	  babelHelpers.inherits(SplitterElement, _BaseElement);

	  function SplitterElement() {
	    babelHelpers.classCallCheck(this, SplitterElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(SplitterElement, [{
	    key: '_getSide',
	    value: function _getSide(side) {
	      var element = util.findChild(this, function (e) {
	        return util.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
	      });
	      element && CustomElements.upgrade(element);
	      return element;
	    }

	    /**
	     * @property left
	     * @readonly
	     * @type {HTMLElement}
	     * @description
	     *   [en]Left `<ons-splitter-side>` element.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: '_onDeviceBackButton',
	    value: function _onDeviceBackButton(event) {
	      this._sides.some(function (s) {
	        return s.isOpen ? s.close() : false;
	      }) || event.callParentHandler();
	    }
	  }, {
	    key: '_onModeChange',
	    value: function _onModeChange(e) {
	      var _this2 = this;

	      if (e.target.parentNode) {
	        contentReady(this, function () {
	          _this2._layout();
	        });
	      }
	    }
	  }, {
	    key: '_layout',
	    value: function _layout() {
	      var _this3 = this;

	      this._sides.forEach(function (side) {
	        _this3.content.style[side._side] = side.mode === 'split' ? side._width : 0;
	      });
	    }
	  }, {
	    key: 'createdCallback',
	    value: function createdCallback() {
	      var _this4 = this;

	      this._boundOnModeChange = this._onModeChange.bind(this);

	      contentReady(this, function () {
	        _this4._compile();
	        _this4._layout();
	      });
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      if (!this.mask) {
	        this.appendChild(document.createElement('ons-splitter-mask'));
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
	      this.addEventListener('modechange', this._boundOnModeChange, false);
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this._backButtonHandler.destroy();
	      this._backButtonHandler = null;
	      this.removeEventListener('modechange', this._boundOnModeChange, false);
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {}
	  }, {
	    key: '_show',
	    value: function _show() {
	      util.propagateAction(this, '_show');
	    }
	  }, {
	    key: '_hide',
	    value: function _hide() {
	      util.propagateAction(this, '_hide');
	    }
	  }, {
	    key: '_destroy',
	    value: function _destroy() {
	      util.propagateAction(this, '_destroy');
	      this.remove();
	    }
	  }, {
	    key: 'left',
	    get: function get() {
	      return this._getSide('left');
	    }
	    /**
	     * @property right
	     * @readonly
	     * @type {HTMLElement}
	     * @description
	     *   [en]Right `<ons-splitter-side>` element.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'right',
	    get: function get() {
	      return this._getSide('right');
	    }
	  }, {
	    key: '_sides',
	    get: function get() {
	      return [this.left, this.right].filter(function (e) {
	        return e;
	      });
	    }
	    /**
	     * @property content
	     * @readonly
	     * @type {HTMLElement}
	     * @description
	     *   [en]The `<ons-splitter-content>` element.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'content',
	    get: function get() {
	      return util.findChild(this, 'ons-splitter-content');
	    }
	  }, {
	    key: 'mask',
	    get: function get() {
	      return util.findChild(this, 'ons-splitter-mask');
	    }

	    /**
	     * @property onDeviceBackButton
	     * @type {Object}
	     * @description
	     *   [en]Back-button handler.[/en]
	     *   [ja]バックボタンハンドラ。[/ja]
	     */

	  }, {
	    key: 'onDeviceBackButton',
	    get: function get() {
	      return this._backButtonHandler;
	    },
	    set: function set(callback) {
	      if (this._backButtonHandler) {
	        this._backButtonHandler.destroy();
	      }

	      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
	    }
	  }]);
	  return SplitterElement;
	}(BaseElement);

	window.OnsSplitterElement = document.registerElement('ons-splitter', {
	  prototype: SplitterElement.prototype
	});

	window.OnsSplitterElement._animatorDict = {
	  default: SplitterAnimator,
	  overlay: SplitterAnimator
	};

	window.OnsSplitterElement.registerAnimator = function (name, Animator) {
	  if (!(Animator instanceof SplitterAnimator)) {
	    throw new Error('Animator parameter must be an instance of SplitterAnimator.');
	  }
	  window.OnsSplitterElement._animatorDict[name] = Animator;
	};

	window.OnsSplitterElement.SplitterAnimator = SplitterAnimator;

	var OnsSplitterElement$1 = OnsSplitterElement;

	var SPLIT_MODE = 'split';
	var COLLAPSE_MODE = 'collapse';
	var CLOSED_STATE = 'closed';
	var OPEN_STATE = 'open';
	var CHANGING_STATE = 'changing';

	var rewritables$2 = {
	  /**
	   * @param {Element} splitterSideElement
	   * @param {Function} callback
	   */

	  ready: function ready(splitterSideElement, callback) {
	    setImmediate(callback);
	  },


	  /**
	   * @param {Element} splitterSideElement
	   * @param {HTMLFragment} target
	   * @param {Object} options
	   * @param {Function} callback
	   */
	  link: function link(splitterSideElement, target, options, callback) {
	    callback(target);
	  }
	};

	var CollapseDetection = function () {
	  function CollapseDetection(element, target) {
	    babelHelpers.classCallCheck(this, CollapseDetection);

	    this._element = element;
	    this._boundOnChange = this._onChange.bind(this);
	    target && this.changeTarget(target);
	  }

	  babelHelpers.createClass(CollapseDetection, [{
	    key: 'changeTarget',
	    value: function changeTarget(target) {
	      this.disable();
	      this._target = target;
	      if (target) {
	        this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
	        this.activate();
	      }
	    }
	  }, {
	    key: '_match',
	    value: function _match(value) {
	      if (this._orientation) {
	        return this._target === (value.isPortrait ? 'portrait' : 'landscape');
	      }
	      return value.matches;
	    }
	  }, {
	    key: '_onChange',
	    value: function _onChange(value) {
	      this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
	    }
	  }, {
	    key: 'activate',
	    value: function activate() {
	      if (this._orientation) {
	        orientation.on('change', this._boundOnChange);
	        this._onChange({ isPortrait: orientation.isPortrait() });
	      } else {
	        this._queryResult = window.matchMedia(this._target);
	        this._queryResult.addListener(this._boundOnChange);
	        this._onChange(this._queryResult);
	      }
	    }
	  }, {
	    key: 'disable',
	    value: function disable() {
	      if (this._orientation) {
	        orientation.off('change', this._boundOnChange);
	      } else if (this._queryResult) {
	        this._queryResult.removeListener(this._boundOnChange);
	        this._queryResult = null;
	      }
	    }
	  }]);
	  return CollapseDetection;
	}();

	var widthToPx = function widthToPx(width, parent) {
	  var value = parseInt(width, 10);
	  var px = /px/.test(width);

	  return px ? value : Math.round(parent.offsetWidth * value / 100);
	};

	var CollapseMode = function () {
	  babelHelpers.createClass(CollapseMode, [{
	    key: '_animator',
	    get: function get() {
	      return this._element._animator;
	    }
	  }]);

	  function CollapseMode(element) {
	    babelHelpers.classCallCheck(this, CollapseMode);

	    this._active = false;
	    this._state = CLOSED_STATE;
	    this._element = element;
	    this._lock = new DoorLock();
	  }

	  babelHelpers.createClass(CollapseMode, [{
	    key: 'isOpen',
	    value: function isOpen() {
	      return this._active && this._state !== CLOSED_STATE;
	    }
	  }, {
	    key: 'handleGesture',
	    value: function handleGesture(e) {
	      if (!this._active || this._lock.isLocked() || this._isOpenOtherSideMenu()) {
	        return;
	      }
	      if (e.type === 'dragstart') {
	        this._onDragStart(e);
	      } else if (!this._ignoreDrag) {
	        e.type === 'dragend' ? this._onDragEnd(e) : this._onDrag(e);
	      }
	    }
	  }, {
	    key: '_onDragStart',
	    value: function _onDragStart(event) {
	      var scrolling = !/left|right/.test(event.gesture.direction);
	      var distance = this._element._side === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
	      var area = this._element._swipeTargetWidth;
	      var isOpen = this.isOpen();
	      this._ignoreDrag = scrolling || area && distance > area && !isOpen;

	      this._width = widthToPx(this._element._width, this._element.parentNode);
	      this._startDistance = this._distance = isOpen ? this._width : 0;
	    }
	  }, {
	    key: '_onDrag',
	    value: function _onDrag(event) {
	      event.gesture.preventDefault();
	      var delta = this._element._side === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
	      var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
	      if (distance !== this._distance) {
	        this._animator.translate(distance);
	        this._distance = distance;
	        this._state = CHANGING_STATE;
	      }
	    }
	  }, {
	    key: '_onDragEnd',
	    value: function _onDragEnd(event) {
	      var distance = this._distance;
	      var width = this._width;
	      var el = this._element;

	      var direction = event.gesture.interimDirection;
	      var shouldOpen = el._side !== direction && distance > width * el._threshold;
	      this.executeAction(shouldOpen ? 'open' : 'close');
	      this._ignoreDrag = true;
	    }
	  }, {
	    key: 'layout',
	    value: function layout() {
	      if (this._active && this._state === OPEN_STATE) {
	        this._animator.open();
	      }
	    }

	    // enter collapse mode

	  }, {
	    key: 'enterMode',
	    value: function enterMode() {
	      if (!this._active) {
	        this._active = true;
	        this.layout();
	      }
	    }

	    // exit collapse mode

	  }, {
	    key: 'exitMode',
	    value: function exitMode() {
	      this._active = false;
	    }
	  }, {
	    key: '_isOpenOtherSideMenu',
	    value: function _isOpenOtherSideMenu() {
	      var _this = this;

	      return util.arrayFrom(this._element.parentElement.children).some(function (e) {
	        return util.match(e, 'ons-splitter-side') && e !== _this._element && e.isOpen;
	      });
	    }

	    /**
	     * @param {String} name - 'open' or 'close'
	     * @param {Object} [options]
	     * @param {Function} [options.callback]
	     * @param {Boolean} [options.withoutAnimation]
	     * @return {Promise} Resolves to the splitter side element or false if not in collapse mode
	     */

	  }, {
	    key: 'executeAction',
	    value: function executeAction(name) {
	      var _this2 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var FINAL_STATE = name === 'open' ? OPEN_STATE : CLOSED_STATE;

	      if (!this._active) {
	        return Promise.resolve(false);
	      }

	      if (this._state === FINAL_STATE) {
	        return Promise.resolve(this._element);
	      }
	      if (this._lock.isLocked()) {
	        return Promise.reject('Splitter side is locked.');
	      }
	      if (name === 'open' && this._isOpenOtherSideMenu()) {
	        return Promise.reject('Another menu is already open.');
	      }
	      if (this._element._emitEvent('pre' + name)) {
	        return Promise.reject('Canceled in pre' + name + ' event.');
	      }

	      var callback = options.callback;
	      var unlock = this._lock.lock();
	      var done = function done() {
	        _this2._state = FINAL_STATE;
	        _this2.layout();
	        unlock();
	        _this2._element._emitEvent('post' + name);
	        callback && callback();
	      };

	      if (options.withoutAnimation) {
	        done();
	        return Promise.resolve(this._element);
	      }
	      this._state = CHANGING_STATE;
	      return new Promise(function (resolve) {
	        _this2._animator[name](function () {
	          done();
	          resolve(_this2._element);
	        });
	      });
	    }
	  }]);
	  return CollapseMode;
	}();

	/**
	 * @element ons-splitter-side
	 * @category splitter
	 * @description
	 *  [en]
	 *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
	 *
	 *    It will be displayed on either the left or right side of the `<ons-splitte-content>` element.
	 *
	 *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
	 *  [/en]
	 *  [ja]ons-splitter-side要素は、ons-splitter要素の子要素として利用します。[/ja]
	 * @codepen rOQOML
	 * @tutorial vanilla/Reference/splitter
	 * @seealso ons-splitter
	 *  [en]The `<ons-splitter>` is the parent component.[/en]
	 *  [ja]ons-splitterコンポーネント[/ja]
	 * @seealso ons-splitter-content
	 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
	 *  [ja]ons-splitter-contentコンポーネント[/ja]
	 * @example
	 * <ons-splitter>
	 *   <ons-splitter-content>
	 *     ...
	 *   </ons-splitter-content>
	 *
	 *   <ons-splitter-side side="left" width="80%" collapse>
	 *     ...
	 *   </ons-splitter-side>
	 * </ons-splitter>
	 */


	var SplitterSideElement = function (_BaseElement) {
	  babelHelpers.inherits(SplitterSideElement, _BaseElement);

	  function SplitterSideElement() {
	    babelHelpers.classCallCheck(this, SplitterSideElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterSideElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(SplitterSideElement, [{
	    key: 'createdCallback',


	    /**
	     * @event modechange
	     * @description
	     *   [en]Fired just after the component's mode changes.[/en]
	     *   [ja]この要素のモードが変化した際に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクトです。[/ja]
	     * @param {Object} event.side
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {String} event.mode
	     *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
	     *   [ja]現在のモードを返します。[/ja]
	     */

	    /**
	     * @event preopen
	     * @description
	     *   [en]Fired just before the sliding menu is opened.[/en]
	     *   [ja]スライディングメニューが開く前に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクトです。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Call to cancel opening sliding menu.[/en]
	     *   [ja]スライディングメニューが開くのをキャンセルします。[/ja]
	     * @param {Object} event.side
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     */

	    /**
	     * @event postopen
	     * @description
	     *   [en]Fired just after the sliding menu is opened.[/en]
	     *   [ja]スライディングメニューが開いた後に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクトです。[/ja]
	     * @param {Object} event.side
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     */

	    /**
	     * @event preclose
	     * @description
	     *   [en]Fired just before the sliding menu is closed.[/en]
	     *   [ja]スライディングメニューが閉じる前に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクトです。[/ja]
	     * @param {Object} event.side
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Call to cancel opening sliding-menu.[/en]
	     *   [ja]スライディングメニューが閉じるのをキャンセルします。[/ja]
	     */

	    /**
	     * @event postclose
	     * @description
	     *   [en]Fired just after the sliding menu is closed.[/en]
	     *   [ja]スライディングメニューが閉じた後に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクトです。[/ja]
	     * @param {Object} event.side
	     *   [en]Component object.[/en]
	     *   [ja]コンポーネントのオブジェクト。[/ja]
	     */

	    /**
	     * @attribute animation
	     * @type {String}
	     * @default  default
	     * @description
	     *  [en]Specify the animation. Use one of `"overlay"`, and `"default"`.[/en]
	     *  [ja]アニメーションを指定します。"overlay", "default"のいずれかを指定できます。[/ja]
	     */

	    /**
	     * @attribute animation-options
	     * @type {Expression}
	     * @description
	     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
	     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
	     */

	    /**
	     * @attribute open-threshold
	     * @type {Number}
	     * @default  0.3
	     * @description
	     *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
	     *  [ja]どのくらいスワイプすればスライディングメニューを開くかどうかの割合を指定します。0から1の間の数値を指定します。スワイプの距離がここで指定した数値掛けるこの要素の幅よりも大きければ、スワイプが終わった時にこの要素を開きます。デフォルトは0.3です。[/ja]
	     */

	    /**
	     * @attribute collapse
	     * @type {String}
	     * @description
	     *   [en]
	     *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
	     *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
	     *     If the value is a media query, the view will collapse when the media query resolves to `true`.
	     *     If the value is not defined, the view always be in `"collapse"` mode.
	     *   [/en]
	     *   [ja]
	     *     左側のページを非表示にする条件を指定します。portrait, landscape、width #pxもしくはメディアクエリの指定が可能です。
	     *     portraitもしくはlandscapeを指定すると、デバイスの画面が縦向きもしくは横向きになった時に適用されます。
	     *     メディアクエリを指定すると、指定したクエリに適合している場合に適用されます。
	     *     値に何も指定しない場合には、常にcollapseモードになります。
	     *   [/ja]
	     */

	    /**
	     * @attribute swipe-target-width
	     * @type {String}
	     * @description
	     *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
	     *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
	     */

	    /**
	     * @attribute width
	     * @type {String}
	     * @description
	     *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
	     *   [ja]この要素の横幅を指定します。pxと%での指定が可能です。eg. 90%, 200px[/ja]
	     */

	    /**
	     * @attribute side
	     * @type {String}
	     * @default left
	     * @description
	     *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
	     *   [ja]この要素が左か右かを指定します。指定できる値は"left"か"right"のみです。[/ja]
	     */

	    /**
	     * @attribute mode
	     * @type {String}
	     * @description
	     *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
	     *   [ja]現在のモードが設定されます。"collapse"もしくは"split"が指定されます。この属性は読み込み専用です。[/ja]
	     */

	    /**
	     * @attribute page
	     * @initonly
	     * @type {String}
	     * @description
	     *   [en]The URL of the menu page.[/en]
	     *   [ja]ons-splitter-side要素に表示するページのURLを指定します。[/ja]
	     */

	    /**
	     * @attribute swipeable
	     * @type {Boolean}
	     * @description
	     *   [en]Whether to enable swipe interaction on collapse mode.[/en]
	     *   [ja]collapseモード時にスワイプ操作を有効にする場合に指定します。[/ja]
	     */

	    value: function createdCallback() {
	      var _this4 = this;

	      this._collapseMode = new CollapseMode(this);
	      this._collapseDetection = new CollapseDetection(this);

	      this._animatorFactory = new AnimatorFactory({
	        animators: OnsSplitterElement$1._animatorDict,
	        baseClass: SplitterAnimator,
	        baseClassName: 'SplitterAnimator',
	        defaultAnimation: this.getAttribute('animation')
	      });
	      this._boundHandleGesture = function (e) {
	        return _this4._collapseMode.handleGesture(e);
	      };
	      this._watchedAttributes = ['animation', 'width', 'side', 'collapse', 'swipeable', 'swipe-target-width', 'animation-options', 'open-threshold', 'page'];
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this5 = this;

	      if (!util.match(this.parentNode, 'ons-splitter')) {
	        throw new Error('Parent must be an ons-splitter element.');
	      }

	      this._gestureDetector = new GestureDetector(this.parentElement, { dragMinDistance: 1 });

	      if (!this.hasAttribute('side')) {
	        this.setAttribute('side', 'left');
	      }

	      contentReady(this, function () {
	        _this5._watchedAttributes.forEach(function (e) {
	          return _this5._update(e);
	        });
	      });
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this._collapseDetection.disable();
	      this._gestureDetector.dispose();
	      this._gestureDetector = null;
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (this._watchedAttributes.indexOf(name) !== -1) {
	        this._update(name, current);
	      }
	    }
	  }, {
	    key: '_update',
	    value: function _update(name, value) {
	      name = '_update' + name.split('-').map(function (e) {
	        return e[0].toUpperCase() + e.slice(1);
	      }).join('');
	      return this[name](value);
	    }
	  }, {
	    key: '_emitEvent',
	    value: function _emitEvent(name) {
	      if (name.slice(0, 3) !== 'pre') {
	        return util.triggerElementEvent(this, name, { side: this });
	      }
	      var isCanceled = false;

	      util.triggerElementEvent(this, name, {
	        side: this,
	        cancel: function cancel() {
	          return isCanceled = true;
	        }
	      });

	      return isCanceled;
	    }
	  }, {
	    key: '_updateCollapse',
	    value: function _updateCollapse() {
	      var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('collapse') : arguments[0];

	      if (value === null || value === 'split') {
	        this._collapseDetection.disable();
	        return this._updateMode(SPLIT_MODE);
	      }
	      if (value === '' || value === 'collapse') {
	        this._collapseDetection.disable();
	        return this._updateMode(COLLAPSE_MODE);
	      }

	      this._collapseDetection.changeTarget(value);
	    }

	    // readonly attribute for the users

	  }, {
	    key: '_updateMode',
	    value: function _updateMode(mode) {
	      if (mode !== this._mode) {
	        this._mode = mode;
	        this._collapseMode[mode === COLLAPSE_MODE ? 'enterMode' : 'exitMode']();
	        this.setAttribute('mode', mode);

	        util.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
	      }
	    }
	  }, {
	    key: '_updatePage',
	    value: function _updatePage() {
	      var _this6 = this;

	      var page = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('page') : arguments[0];

	      if (page !== null) {
	        rewritables$2.ready(this, function () {
	          return _this6.load(page);
	        });
	      }
	    }
	  }, {
	    key: '_updateOpenThreshold',
	    value: function _updateOpenThreshold() {
	      var threshold = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('open-threshold') : arguments[0];

	      this._threshold = Math.max(0, Math.min(1, parseFloat(threshold) || 0.3));
	    }
	  }, {
	    key: '_updateSwipeable',
	    value: function _updateSwipeable() {
	      var swipeable = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('swipeable') : arguments[0];

	      var action = swipeable === null ? 'off' : 'on';

	      if (this._gestureDetector) {
	        this._gestureDetector[action]('dragstart dragleft dragright dragend', this._boundHandleGesture);
	      }
	    }
	  }, {
	    key: '_updateSwipeTargetWidth',
	    value: function _updateSwipeTargetWidth() {
	      var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('swipe-target-width') : arguments[0];

	      this._swipeTargetWidth = Math.max(0, parseInt(value) || 0);
	    }
	  }, {
	    key: '_updateWidth',
	    value: function _updateWidth() {
	      this.style.width = this._width;
	    }
	  }, {
	    key: '_updateSide',
	    value: function _updateSide() {
	      var side = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('side') : arguments[0];

	      this._side = side === 'right' ? side : 'left';
	    }
	  }, {
	    key: '_updateAnimation',
	    value: function _updateAnimation() {
	      var animation = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('animation') : arguments[0];

	      this._animator = this._animatorFactory.newAnimator({ animation: animation });
	      this._animator.activate(this);
	    }
	  }, {
	    key: '_updateAnimationOptions',
	    value: function _updateAnimationOptions() {
	      var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('animation-options') : arguments[0];

	      this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
	    }

	    /**
	     * @property page
	     * @readonly
	     * @type {HTMLElement}
	     * @description
	     *   [en]Page element loaded in the splitter side.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'open',


	    /**
	     * @method open
	     * @signature open([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {Function} [options.callback]
	     *   [en]This function will be called after the menu has been opened.[/en]
	     *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]
	     * @description
	     *   [en]Open menu in collapse mode.[/en]
	     *   [ja]collapseモードになっているons-splitter-side要素を開きます。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
	     *   [ja][/ja]
	     */
	    value: function open() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      return this._collapseMode.executeAction('open', options);
	    }

	    /**
	     * @method close
	     * @signature close([options])
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {Function} [options.callback]
	     *   [en]This function will be called after the menu has been closed.[/en]
	     *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]
	     * @description
	     *   [en]Close menu in collapse mode.[/en]
	     *   [ja]collapseモードになっているons-splitter-side要素を閉じます。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'close',
	    value: function close() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      return this._collapseMode.executeAction('close', options);
	    }

	    /**
	     * @method toggle
	     * @signature toggle([options])
	     * @param {Object} [options]
	     * @description
	     *   [en]Opens if it's closed. Closes if it's open.[/en]
	     *   [ja]開けている場合は要素を閉じますそして開けている場合は要素を開きます。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'toggle',
	    value: function toggle() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      return this.isOpen ? this.close(options) : this.open(options);
	    }

	    /**
	     * @method load
	     * @signature load(page, [options])
	     * @param {String} page
	     *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]
	     *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
	     * @param {Object} [options]
	     * @param {Function} [options.callback]
	     * @description
	     *   [en]Show the page specified in pageUrl in the right section[/en]
	     *   [ja]指定したURLをメインページを読み込みます。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the new page element[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'load',
	    value: function load(page) {
	      var _this7 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      this._page = page;
	      var callback = options.callback;

	      return internal.getPageHTMLAsync(page).then(function (html) {
	        return new Promise(function (resolve) {
	          rewritables$2.link(_this7, util.createFragment(html), options, function (fragment) {
	            _this7._hide();

	            _this7.innerHTML = '';
	            _this7.appendChild(fragment);

	            _this7._show();
	            callback && callback();
	            resolve(_this7.firstChild);
	          });
	        });
	      });
	    }
	  }, {
	    key: '_show',
	    value: function _show() {
	      util.propagateAction(this, '_show');
	    }
	  }, {
	    key: '_hide',
	    value: function _hide() {
	      util.propagateAction(this, '_hide');
	    }
	  }, {
	    key: '_destroy',
	    value: function _destroy() {
	      util.propagateAction(this, '_destroy');
	      this.remove();
	    }
	  }, {
	    key: '_width',
	    get: function get() {
	      var width = this.getAttribute('width');
	      return (/^\d+(px|%)$/.test(width) ? width : '80%'
	      );
	    },
	    set: function set(value) {
	      this.setAttribute('width', value);
	    }
	  }, {
	    key: 'page',
	    get: function get() {
	      return this._page;
	    }

	    /**
	     * @property mode
	     * @readonly
	     * @type {String}
	     * @description
	     *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'mode',
	    get: function get() {
	      return this._mode;
	    }

	    /**
	     * @property isOpen
	     * @type {Boolean}
	     * @readonly
	     * @description
	     *   [en]This value is `true` when the menu is open..[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'isOpen',
	    get: function get() {
	      return this._collapseMode.isOpen();
	    }
	  }]);
	  return SplitterSideElement;
	}(BaseElement);

	window.OnsSplitterSideElement = document.registerElement('ons-splitter-side', {
	  prototype: SplitterSideElement.prototype
	});

	window.OnsSplitterSideElement.rewritables = rewritables$2;

	var scheme$18 = {
	  '': 'switch--*',
	  '.switch__input': 'switch--*__input',
	  '.switch__handle': 'switch--*__handle',
	  '.switch__toggle': 'switch--*__toggle'
	};

	var template$2 = util.createFragment('\n  <input type="checkbox" class="switch__input">\n  <div class="switch__toggle">\n    <div class="switch__handle">\n      <div class="switch__touch"></div>\n    </div>\n  </div>\n');

	var locations = {
	  ios: [1, 21],
	  material: [0, 16]
	};

	/**
	 * @element ons-switch
	 * @category switch
	 * @description
	 *   [en]
	 *     Switch component. The switch can be toggled both by dragging and tapping.
	 *
	 *     Will automatically displays a Material Design switch on Android devices.
	 *   [/en]
	 *   [ja]スイッチを表示するコンポーネントです。[/ja]
	 * @modifier material
	 *   [en]Material Design switch[/en]
	 *   [ja][/ja]
	 * @codepen LpXZQQ
	 * @tutorial vanilla/Reference/switch
	 * @guide UsingFormComponents
	 *   [en]Using form components[/en]
	 *   [ja]フォームを使う[/ja]
	 * @guide EventHandling
	 *   [en]Event handling descriptions[/en]
	 *   [ja]イベント処理の使い方[/ja]
	 * @example
	 * <ons-switch checked></ons-switch>
	 * <ons-switch disabled></ons-switch>
	 * <ons-switch modifier="material"></ons-switch>
	 */

	var SwitchElement = function (_BaseElement) {
	  babelHelpers.inherits(SwitchElement, _BaseElement);

	  function SwitchElement() {
	    babelHelpers.classCallCheck(this, SwitchElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SwitchElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(SwitchElement, [{
	    key: 'createdCallback',
	    value: function createdCallback() {
	      var _this2 = this;

	      if (!this.hasAttribute('_compiled')) {
	        this._compile();
	      }

	      this._checkbox = this.querySelector('.switch__input');
	      this._handle = this.querySelector('.switch__handle');

	      ['checked', 'disabled', 'modifier', 'name', 'input-id'].forEach(function (e) {
	        _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
	      });
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      this.classList.add('switch');

	      this.appendChild(template$2.cloneNode(true));

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this._checkbox.removeEventListener('change', this._onChange);
	      this.removeEventListener('dragstart', this._onDragStart);
	      this.removeEventListener('hold', this._onHold);
	      this.removeEventListener('tap', this.click);
	      this.removeEventListener('click', this._onClick);
	      this._gestureDetector.dispose();
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      this._checkbox.addEventListener('change', this._onChange);
	      this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1, holdTimeout: 251 });
	      this.addEventListener('dragstart', this._onDragStart);
	      this.addEventListener('hold', this._onHold);
	      this.addEventListener('tap', this.click);
	      this._boundOnRelease = this._onRelease.bind(this);
	      this.addEventListener('click', this._onClick);
	    }
	  }, {
	    key: '_onChange',
	    value: function _onChange() {
	      if (this.checked) {
	        this.parentNode.setAttribute('checked', '');
	      } else {
	        this.parentNode.removeAttribute('checked');
	      }
	    }
	  }, {
	    key: '_onClick',
	    value: function _onClick(ev) {
	      if (ev.target.classList.contains('switch__touch')) {
	        ev.preventDefault();
	      }
	    }
	  }, {
	    key: 'click',
	    value: function click() {
	      if (!this.disabled) {
	        this.checked = !this.checked;
	      }
	    }
	  }, {
	    key: '_getPosition',
	    value: function _getPosition(e) {
	      var l = this._locations;
	      return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
	    }
	  }, {
	    key: '_onHold',
	    value: function _onHold(e) {
	      if (!this.disabled) {
	        this.classList.add('switch--active');
	        document.addEventListener('release', this._boundOnRelease);
	      }
	    }
	  }, {
	    key: '_onDragStart',
	    value: function _onDragStart(e) {
	      if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
	        this.classList.remove('switch--active');
	        return;
	      }

	      e.stopPropagation();

	      this.classList.add('switch--active');
	      this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

	      this.addEventListener('drag', this._onDrag);
	      document.addEventListener('release', this._boundOnRelease);
	    }
	  }, {
	    key: '_onDrag',
	    value: function _onDrag(e) {
	      e.gesture.srcEvent.preventDefault();
	      this._handle.style.left = this._getPosition(e) + 'px';
	    }
	  }, {
	    key: '_onRelease',
	    value: function _onRelease(e) {
	      var l = this._locations;
	      var position = this._getPosition(e);

	      this.checked = position >= (l[0] + l[1]) / 2;

	      this.removeEventListener('drag', this._onDrag);
	      document.removeEventListener('release', this._boundOnRelease);

	      this._handle.style.left = '';
	      this.classList.remove('switch--active');
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      switch (name) {
	        case 'modifier':
	          this._isMaterial = (current || '').indexOf('material') !== -1;
	          this._locations = locations[this._isMaterial ? 'material' : 'ios'];
	          ModifierUtil.onModifierChanged(last, current, this, scheme$18);
	          break;
	        case 'input-id':
	          this._checkbox.id = current;
	          break;
	        case 'checked':
	          this._checkbox.checked = current !== null;
	          util.toggleAttribute(this._checkbox, name, current !== null);
	          break;
	        case 'disabled':
	          util.toggleAttribute(this._checkbox, name, current !== null);
	      }
	    }
	  }, {
	    key: 'checked',


	    /**
	     * @event change
	     * @description
	     *   [en]Fired when the switch is toggled.[/en]
	     *   [ja]ON/OFFが変わった時に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクト。[/ja]
	     * @param {Object} event.switch
	     *   [en]Switch object.[/en]
	     *   [ja]イベントが発火したSwitchオブジェクトを返します。[/ja]
	     * @param {Boolean} event.value
	     *   [en]Current value.[/en]
	     *   [ja]現在の値を返します。[/ja]
	     * @param {Boolean} event.isInteractive
	     *   [en]True if the change was triggered by the user clicking on the switch.[/en]
	     *   [ja]タップやクリックなどのユーザの操作によって変わった場合にはtrueを返します。[/ja]
	     */

	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *  [en]The appearance of the switch.[/en]
	     *  [ja]スイッチの表現を指定します。[/ja]
	     */

	    /**
	     * @attribute disabled
	     * @description
	     *   [en]Whether the switch is be disabled.[/en]
	     *   [ja]スイッチを無効の状態にする場合に指定します。[/ja]
	     */

	    /**
	     * @attribute checked
	     * @description
	     *   [en]Whether the switch is checked.[/en]
	     *   [ja]スイッチがONの状態にするときに指定します。[/ja]
	     */

	    /**
	     * @attribute input-id
	     * @type {String}
	     * @description
	     *  [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
	     *  [ja][/ja]
	     */

	    /**
	     * @property checked
	     * @type {Boolean}
	     * @description
	     *   [en]This value is `true` if the switch is checked.[/en]
	     *   [ja]スイッチがONの場合に`true`。[/ja]
	     */

	    get: function get() {
	      return this._checkbox.checked;
	    },
	    set: function set(value) {
	      if (!!value !== this._checkbox.checked) {
	        this._checkbox.click();
	        this._checkbox.checked = !!value;
	        return util.toggleAttribute(this, 'checked', this.checked);
	      }
	    }

	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: 'disabled',
	    get: function get() {
	      return this._checkbox.disabled;
	    },
	    set: function set(value) {
	      this._checkbox.disabled = value;
	      return util.toggleAttribute(this, 'disabled', this.disabled);
	    }

	    /**
	     * @property checkbox
	     * @readonly
	     * @type {HTMLElement}
	     * @description
	     *   [en]The underlying checkbox element.[/en]
	     *   [ja]コンポーネント内部のcheckbox要素になります。[/ja]
	     */

	  }, {
	    key: 'checkbox',
	    get: function get() {
	      return this._checkbox;
	    }
	  }]);
	  return SwitchElement;
	}(BaseElement);

	window.OnsSwitchElement = document.registerElement('ons-switch', {
	  prototype: SwitchElement.prototype
	});

	/*
	Copyright 2013-2015 ASIAL CORPORATION

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	*/

	var TabbarAnimator = function () {

	  /**
	   * @param {Object} options
	   * @param {String} options.timing
	   * @param {Number} options.duration
	   * @param {Number} options.delay
	   */

	  function TabbarAnimator() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    babelHelpers.classCallCheck(this, TabbarAnimator);

	    this.timing = options.timing || 'linear';
	    this.duration = options.duration !== undefined ? options.duration : '0.4';
	    this.delay = options.delay !== undefined ? options.delay : '0';
	  }

	  /**
	   * @param {Element} enterPage ons-page element
	   * @param {Element} leavePage ons-page element
	   * @param {Number} enterPageIndex
	   * @param {Number} leavePageIndex
	   * @param {Function} done
	   */


	  babelHelpers.createClass(TabbarAnimator, [{
	    key: 'apply',
	    value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
	      throw new Error('This method must be implemented.');
	    }
	  }]);
	  return TabbarAnimator;
	}();

	var TabbarNoneAnimator = function (_TabbarAnimator) {
	  babelHelpers.inherits(TabbarNoneAnimator, _TabbarAnimator);

	  function TabbarNoneAnimator() {
	    babelHelpers.classCallCheck(this, TabbarNoneAnimator);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarNoneAnimator).apply(this, arguments));
	  }

	  babelHelpers.createClass(TabbarNoneAnimator, [{
	    key: 'apply',
	    value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
	      setTimeout(done, 1000 / 60);
	    }
	  }]);
	  return TabbarNoneAnimator;
	}(TabbarAnimator);

	var TabbarFadeAnimator = function (_TabbarAnimator2) {
	  babelHelpers.inherits(TabbarFadeAnimator, _TabbarAnimator2);

	  function TabbarFadeAnimator(options) {
	    babelHelpers.classCallCheck(this, TabbarFadeAnimator);

	    options.timing = options.timing !== undefined ? options.timing : 'linear';
	    options.duration = options.duration !== undefined ? options.duration : '0.4';
	    options.delay = options.delay !== undefined ? options.delay : '0';

	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarFadeAnimator).call(this, options));
	  }

	  babelHelpers.createClass(TabbarFadeAnimator, [{
	    key: 'apply',
	    value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
	      animit.runAll(animit(enterPage).saveStyle().queue({
	        transform: 'translate3D(0, 0, 0)',
	        opacity: 0
	      }).wait(this.delay).queue({
	        transform: 'translate3D(0, 0, 0)',
	        opacity: 1
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (callback) {
	        done();
	        callback();
	      }), animit(leavePage).queue({
	        transform: 'translate3D(0, 0, 0)',
	        opacity: 1
	      }).wait(this.delay).queue({
	        transform: 'translate3D(0, 0, 0)',
	        opacity: 0
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }));
	    }
	  }]);
	  return TabbarFadeAnimator;
	}(TabbarAnimator);

	var TabbarSlideAnimator = function (_TabbarAnimator3) {
	  babelHelpers.inherits(TabbarSlideAnimator, _TabbarAnimator3);

	  function TabbarSlideAnimator(options) {
	    babelHelpers.classCallCheck(this, TabbarSlideAnimator);

	    options.timing = options.timing !== undefined ? options.timing : 'ease-in';
	    options.duration = options.duration !== undefined ? options.duration : '0.15';
	    options.delay = options.delay !== undefined ? options.delay : '0';

	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarSlideAnimator).call(this, options));
	  }

	  /**
	   * @param {jqLite} enterPage
	   * @param {jqLite} leavePage
	   */


	  babelHelpers.createClass(TabbarSlideAnimator, [{
	    key: 'apply',
	    value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
	      var sgn = enterIndex > leaveIndex;

	      animit.runAll(animit(enterPage).saveStyle().queue({
	        transform: 'translate3D(' + (sgn ? '' : '-') + '100%, 0, 0)'
	      }).wait(this.delay).queue({
	        transform: 'translate3D(0, 0, 0)'
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }).restoreStyle().queue(function (callback) {
	        done();
	        callback();
	      }), animit(leavePage).queue({
	        transform: 'translate3D(0, 0, 0)'
	      }).wait(this.delay).queue({
	        transform: 'translate3D(' + (sgn ? '-' : '') + '100%, 0, 0)'
	      }, {
	        duration: this.duration,
	        timing: this.timing
	      }));
	    }
	  }]);
	  return TabbarSlideAnimator;
	}(TabbarAnimator);

	var scheme$20 = {
	  '.tab-bar__content': 'tab-bar--*__content',
	  '.tab-bar': 'tab-bar--*'
	};

	var _animatorDict$5 = {
	  'default': TabbarNoneAnimator,
	  'fade': TabbarFadeAnimator,
	  'slide': TabbarSlideAnimator,
	  'none': TabbarNoneAnimator
	};

	var rewritables$3 = {
	  /**
	   * @param {Element} tabbarElement
	   * @param {Function} callback
	   */

	  ready: function ready(tabbarElement, callback) {
	    callback();
	  },


	  /**
	   * @param {Element} tabbarElement
	   * @param {Element} target
	   * @param {Object} options
	   * @param {Function} callback
	   */
	  link: function link(tabbarElement, target, options, callback) {
	    callback(target);
	  },


	  /**
	   * @param {Element} tabbarElement
	   * @param {Element} target
	   * @param {Function} callback
	   */
	  unlink: function unlink(tabbarElement, target, callback) {
	    callback(target);
	  }
	};

	var generateId$1 = function () {
	  var i = 0;
	  return function () {
	    return 'ons-tabbar-gen-' + i++;
	  };
	}();

	/**
	 * @element ons-tabbar
	 * @category tabbar
	 * @description
	 *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
	 *   [ja]タブバーをページ下部に表示するためのコンポーネントです。ons-tabと組み合わせて使うことで、ページを管理できます。[/ja]
	 * @codepen pGuDL
	 * @tutorial vanilla/Reference/tabbar
	 * @guide UsingTabBar
	 *   [en]Using tab bar[/en]
	 *   [ja]タブバーを使う[/ja]
	 * @guide EventHandling
	 *   [en]Event handling descriptions[/en]
	 *   [ja]イベント処理の使い方[/ja]
	 * @guide CallingComponentAPIsfromJavaScript
	 *   [en]Using navigator from JavaScript[/en]
	 *   [ja]JavaScriptからコンポーネントを呼び出す[/ja]
	 * @guide DefiningMultiplePagesinSingleHTML
	 *   [en]Defining multiple pages in single html[/en]
	 *   [ja]複数のページを1つのHTMLに記述する[/ja]
	 * @seealso ons-tab
	 *   [en]The `<ons-tab>` component.[/en]
	 *   [ja]ons-tabコンポーネント[/ja]
	 * @seealso ons-page
	 *   [en]The `<ons-page>` component.[/en]
	 *   [ja]ons-pageコンポーネント[/ja]
	 * @example
	 * <ons-tabbar>
	 *   <ons-tab
	 *     page="home.html"
	 *     label="Home"
	 *     active>
	 *   </ons-tab>
	 *   <ons-tab
	 *     page="settings.html"
	 *     label="Settings"
	 *     active>
	 *   </ons-tab>
	 * </ons-tabbar>
	 *
	 * <ons-template id="home.html">
	 *   ...
	 * </ons-template>
	 *
	 * <ons-template id="settings.html">
	 *   ...
	 * </ons-template>
	 */

	var TabbarElement = function (_BaseElement) {
	  babelHelpers.inherits(TabbarElement, _BaseElement);

	  function TabbarElement() {
	    babelHelpers.classCallCheck(this, TabbarElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(TabbarElement, [{
	    key: 'createdCallback',


	    /**
	     * @event prechange
	     * @description
	     *   [en]Fires just before the tab is changed.[/en]
	     *   [ja]アクティブなタブが変わる前に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクト。[/ja]
	     * @param {Number} event.index
	     *   [en]Current index.[/en]
	     *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
	     * @param {Object} event.tabItem
	     *   [en]Tab item object.[/en]
	     *   [ja]tabItemオブジェクト。[/ja]
	     * @param {Function} event.cancel
	     *   [en]Call this function to cancel the change event.[/en]
	     *   [ja]この関数を呼び出すと、アクティブなタブの変更がキャンセルされます。[/ja]
	     */

	    /**
	     * @event postchange
	     * @description
	     *   [en]Fires just after the tab is changed.[/en]
	     *   [ja]アクティブなタブが変わった後に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクト。[/ja]
	     * @param {Number} event.index
	     *   [en]Current index.[/en]
	     *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
	     * @param {Object} event.tabItem
	     *   [en]Tab item object.[/en]
	     *   [ja]tabItemオブジェクト。[/ja]
	     */

	    /**
	     * @event reactive
	     * @description
	     *   [en]Fires if the already open tab is tapped again.[/en]
	     *   [ja]すでにアクティブになっているタブがもう一度タップやクリックされた場合に発火します。[/ja]
	     * @param {Object} event
	     *   [en]Event object.[/en]
	     *   [ja]イベントオブジェクト。[/ja]
	     * @param {Number} event.index
	     *   [en]Current index.[/en]
	     *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
	     * @param {Object} event.tabItem
	     *   [en]Tab item object.[/en]
	     *   [ja]tabItemオブジェクト。[/ja]
	     */

	    /**
	     * @attribute animation
	     * @type {String}
	     * @default none
	     * @description
	     *   [en]Animation name. Available values are `"none"`, `"slide"` and `"fade"`. Default is `"none"`.[/en]
	     *   [ja]ページ読み込み時のアニメーションを指定します。"none"、"fade"、"slide"のいずれかを選択できます。デフォルトは"none"です。[/ja]
	     */

	    /**
	     * @attribute animation-options
	     * @type {Expression}
	     * @description
	     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
	     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
	     */

	    /**
	     * @attribute position
	     * @initonly
	     * @type {String}
	     * @default bottom
	     * @description
	     *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (iOS bottom, Android top).[/en]
	     *   [ja]タブバーの位置を指定します。"bottom"もしくは"top"を選択できます。デフォルトは"bottom"です。[/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      this._tabbarId = generateId$1();

	      contentReady(this, function () {
	        if (!_this2.hasAttribute('_compiled')) {
	          _this2._compile();
	        }

	        for (var i = 0; i < _this2.firstChild.children.length; i++) {
	          _this2.firstChild.children[i].style.display = 'none';
	        }

	        var activeIndex = _this2.getAttribute('activeIndex');

	        if (activeIndex && _this2.children[1].children.length > activeIndex) {
	          _this2.children[1].children[activeIndex].setAttribute('active', 'true');
	        }

	        autoStyle.prepare(_this2);
	        ModifierUtil.initModifier(_this2, scheme$20);

	        _this2._animatorFactory = new AnimatorFactory({
	          animators: _animatorDict$5,
	          baseClass: TabbarAnimator,
	          baseClassName: 'TabbarAnimator',
	          defaultAnimation: _this2.getAttribute('animation')
	        });
	      });
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      var content = util.create('.ons-tab-bar__content.tab-bar__content');
	      var tabbar = util.create('.tab-bar.ons-tab-bar__footer.ons-tabbar-inner');

	      while (this.firstChild) {
	        tabbar.appendChild(this.firstChild);
	      }

	      this.appendChild(content);
	      this.appendChild(tabbar);

	      this._updatePosition();

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: '_updatePosition',
	    value: function _updatePosition() {
	      var _this3 = this;

	      var position = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('position') : arguments[0];

	      var top = this._top = position === 'top' || position === 'auto' && platform.isAndroid();
	      var action = top ? util.addModifier : util.removeModifier;

	      action(this, 'top');

	      var page = util.findParent(this, 'ons-page');
	      if (page) {
	        this.style.top = top ? window.getComputedStyle(page._getContentElement(), null).getPropertyValue('padding-top') : '';

	        if (util.match(page.firstChild, 'ons-toolbar')) {
	          action(page.firstChild, 'noshadow');
	        }
	      }

	      internal.autoStatusBarFill(function () {
	        var filled = util.findParent(_this3, function (e) {
	          return e.hasAttribute('status-bar-fill');
	        });
	        util.toggleAttribute(_this3, 'status-bar-fill', top && !filled);
	      });
	    }
	  }, {
	    key: '_getTabbarElement',
	    value: function _getTabbarElement() {
	      return util.findChild(this, '.tab-bar');
	    }

	    /**
	     * @method loadPage
	     * @signature loadPage(url, [options])
	     * @param {String} url
	     *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
	     *   [ja]pageのURLか、もしくはons-templateで宣言したid属性の値を利用できます。[/ja]
	     * @description
	     *   [en]Displays a new page without changing the active index.[/en]
	     *   [ja]現在のアクティブなインデックスを変更せずに、新しいページを表示します。[/ja]
	     * @param {Object} [options]
	     *   [en][/en]
	     *   [ja][/ja]
	     * @param {Object} [options.animation]
	     *   [en][/en]
	     *   [ja][/ja]
	     * @param {Object} [options.callback]
	     *   [en][/en]
	     *   [ja][/ja]
	     * @return {Promise}
	     *   [en]Resolves to the new page element.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'loadPage',
	    value: function loadPage(page) {
	      var _this4 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      return new Promise(function (resolve) {
	        OnsTabElement.prototype._createPageElement(page, function (pageElement) {
	          resolve(_this4._loadPageDOMAsync(pageElement, options));
	        });
	      });
	    }

	    /**
	     * @param {Element} pageElement
	     * @param {Object} [options]
	     * @param {Object} [options.animation]
	     * @param {Object} [options.callback]
	     * @return {Promise} Resolves to the new page element.
	     */

	  }, {
	    key: '_loadPageDOMAsync',
	    value: function _loadPageDOMAsync(pageElement) {
	      var _this5 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      return new Promise(function (resolve) {
	        rewritables$3.link(_this5, pageElement, options, function (pageElement) {
	          _this5._contentElement.appendChild(pageElement);

	          if (_this5.getActiveTabIndex() !== -1) {
	            resolve(_this5._switchPage(pageElement, options));
	          } else {
	            if (options.callback instanceof Function) {
	              options.callback();
	            }

	            _this5._oldPageElement = pageElement;
	            resolve(pageElement);
	          }
	        });
	      });
	    }

	    /**
	     * @return {String}
	     */

	  }, {
	    key: 'getTabbarId',
	    value: function getTabbarId() {
	      return this._tabbarId;
	    }

	    /**
	     * @return {Element/null}
	     */

	  }, {
	    key: '_getCurrentPageElement',
	    value: function _getCurrentPageElement() {
	      var pages = this._contentElement.children;
	      var page = null;
	      for (var i = 0; i < pages.length; i++) {
	        if (pages[i].style.display !== 'none') {
	          page = pages[i];
	          break;
	        }
	      }

	      if (page && page.nodeName.toLowerCase() !== 'ons-page') {
	        throw new Error('Invalid state: page element must be a "ons-page" element.');
	      }

	      return page;
	    }
	  }, {
	    key: '_switchPage',


	    /**
	     * @param {Element} element
	     * @param {Object} options
	     * @param {String} [options.animation]
	     * @param {Function} [options.callback]
	     * @param {Object} [options.animationOptions]
	     * @param {Number} options.selectedTabIndex
	     * @param {Number} options.previousTabIndex
	     * @return {Promise} Resolves to the new page element.
	     */
	    value: function _switchPage(element, options) {
	      var oldPageElement = this._oldPageElement || internal.nullElement;
	      this._oldPageElement = element;
	      var animator = this._animatorFactory.newAnimator(options);

	      return new Promise(function (resolve) {
	        if (oldPageElement !== internal.nullElement) {
	          oldPageElement._hide();
	        }

	        animator.apply(element, oldPageElement, options.selectedTabIndex, options.previousTabIndex, function () {
	          if (oldPageElement !== internal.nullElement) {
	            oldPageElement.style.display = 'none';
	          }

	          element.style.display = 'block';
	          element._show();

	          if (options.callback instanceof Function) {
	            options.callback();
	          }

	          resolve(element);
	        });
	      });
	    }

	    /**
	     * @method setActiveTab
	     * @signature setActiveTab(index, [options])
	     * @param {Number} index
	     *   [en]Tab index.[/en]
	     *   [ja]タブのインデックスを指定します。[/ja]
	     * @param {Object} [options]
	     *   [en]Parameter object.[/en]
	     *   [ja]オプションを指定するオブジェクト。[/ja]
	     * @param {Boolean} [options.keepPage]
	     *   [en]If true the page will not be changed.[/en]
	     *   [ja]タブバーが現在表示しているpageを変えない場合にはtrueを指定します。[/ja]
	     * @param {String} [options.animation]
	     *   [en]Animation name. Available animations are `"fade"`, `"slide"` and `"none"`.[/en]
	     *   [ja]アニメーション名を指定します。`"fade"`、`"slide"`、`"none"`のいずれかを指定できます。[/ja]
	     * @param {String} [options.animationOptions]
	     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
	     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
	     * @description
	     *   [en]Show specified tab page. Animations and other options can be specified by the second parameter.[/en]
	     *   [ja]指定したインデックスのタブを表示します。アニメーションなどのオプションを指定できます。[/ja]
	     * @return {Promise}
	     *   [en]Resolves to the new page element.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'setActiveTab',
	    value: function setActiveTab(index) {
	      var _this6 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
	        throw new Error('options must be an object. You supplied ' + options);
	      }

	      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

	      if (!options.animation && this.hasAttribute('animation')) {
	        options.animation = this.getAttribute('animation');
	      }

	      var previousTab = this._getActiveTabElement(),
	          selectedTab = this._getTabElement(index),
	          previousTabIndex = this.getActiveTabIndex(),
	          selectedTabIndex = index,
	          previousPageElement = this._getCurrentPageElement();

	      if (!selectedTab) {
	        return Promise.reject('Specified index does not match any tab.');
	      }

	      if (selectedTabIndex === previousTabIndex) {
	        util.triggerElementEvent(this, 'reactive', {
	          index: selectedTabIndex,
	          tabItem: selectedTab
	        });

	        return Promise.resolve(previousPageElement);
	      }

	      var canceled = false;

	      util.triggerElementEvent(this, 'prechange', {
	        index: selectedTabIndex,
	        tabItem: selectedTab,
	        cancel: function cancel() {
	          return canceled = true;
	        }
	      });

	      if (canceled) {
	        selectedTab.setInactive();
	        if (previousTab) {
	          previousTab.setActive();
	        }
	        return Promise.reject('Canceled in prechange event.');
	      }

	      selectedTab.setActive();

	      var needLoad = !selectedTab.isLoaded() && !options.keepPage;

	      util.arrayFrom(this._getTabbarElement().children).forEach(function (tab) {
	        if (tab != selectedTab) {
	          tab.setInactive();
	        } else {
	          if (!needLoad) {
	            util.triggerElementEvent(_this6, 'postchange', {
	              index: selectedTabIndex,
	              tabItem: selectedTab
	            });
	          }
	        }
	      });

	      if (needLoad) {
	        var removeElement;
	        var params;

	        var _ret = function () {
	          removeElement = false;


	          if (!previousTab && previousPageElement || previousTab && previousTab._pageElement !== previousPageElement) {
	            removeElement = true;
	          }

	          params = {
	            callback: function callback() {
	              util.triggerElementEvent(_this6, 'postchange', {
	                index: selectedTabIndex,
	                tabItem: selectedTab
	              });

	              if (options.callback instanceof Function) {
	                options.callback();
	              }
	            },
	            previousTabIndex: previousTabIndex,
	            selectedTabIndex: selectedTabIndex
	          };


	          if (options.animation) {
	            params.animation = options.animation;
	          }

	          params.animationOptions = options.animationOptions || {};

	          var link = function link(element, callback) {
	            rewritables$3.link(_this6, element, options, callback);
	          };

	          return {
	            v: new Promise(function (resolve) {
	              selectedTab._loadPageElement(function (pageElement) {
	                resolve(_this6._loadPersistentPageDOM(pageElement, params));
	              }, link);
	            })
	          };
	        }();

	        if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
	      }

	      return Promise.resolve(previousPageElement);
	    }

	    /**
	     * @param {Element} element
	     * @param {Object} options
	     * @param {Object} options.animation
	     */

	  }, {
	    key: '_loadPersistentPageDOM',
	    value: function _loadPersistentPageDOM(element) {
	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


	      if (!util.isAttached(element)) {
	        this._contentElement.appendChild(element);
	      }

	      element.removeAttribute('style');
	      return this._switchPage(element, options);
	    }

	    /**
	     * @method setTabbarVisibility
	     * @signature setTabbarVisibility(visible)
	     * @param {Boolean} visible
	     * @description
	     *   [en]Used to hide or show the tab bar.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'setTabbarVisibility',
	    value: function setTabbarVisibility(visible) {
	      this._contentElement.style[this._top ? 'top' : 'bottom'] = visible ? '' : '0px';
	      this._getTabbarElement().style.display = visible ? '' : 'none';
	    }

	    /**
	     * @method getActiveTabIndex
	     * @signature getActiveTabIndex()
	     * @return {Number}
	     *   [en]The index of the currently active tab.[/en]
	     *   [ja]現在アクティブになっているタブのインデックスを返します。[/ja]
	     * @description
	     *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
	     *   [ja]現在アクティブになっているタブのインデックスを返します。現在アクティブなタブがない場合には-1を返します。[/ja]
	     */

	  }, {
	    key: 'getActiveTabIndex',
	    value: function getActiveTabIndex() {
	      var tabs = this._getTabbarElement().children;

	      for (var i = 0; i < tabs.length; i++) {
	        if (tabs[i] instanceof window.OnsTabElement && tabs[i].isActive && tabs[i].isActive()) {
	          return i;
	        }
	      }

	      return -1;
	    }

	    /**
	     * @return {Number} When active tab is not found, returns -1.
	     */

	  }, {
	    key: '_getActiveTabElement',
	    value: function _getActiveTabElement() {
	      return this._getTabElement(this.getActiveTabIndex());
	    }

	    /**
	     * @return {Element}
	     */

	  }, {
	    key: '_getTabElement',
	    value: function _getTabElement(index) {
	      return this._getTabbarElement().children[index];
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {}
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {}
	  }, {
	    key: '_show',
	    value: function _show() {
	      var currentPageElement = this._getCurrentPageElement();
	      if (currentPageElement) {
	        currentPageElement._show();
	      }
	    }
	  }, {
	    key: '_hide',
	    value: function _hide() {
	      var currentPageElement = this._getCurrentPageElement();
	      if (currentPageElement) {
	        currentPageElement._hide();
	      }
	    }
	  }, {
	    key: '_destroy',
	    value: function _destroy() {
	      var pages = this._contentElement.children;
	      for (var i = pages.length - 1; i >= 0; i--) {
	        pages[i]._destroy();
	      }
	      this.remove();
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$20);
	      }
	    }
	  }, {
	    key: '_contentElement',
	    get: function get() {
	      return util.findChild(this, '.tab-bar__content');
	    }
	  }, {
	    key: 'pages',
	    get: function get() {
	      return util.arrayFrom(this._contentElement.children);
	    }
	  }]);
	  return TabbarElement;
	}(BaseElement);

	window.OnsTabbarElement = document.registerElement('ons-tabbar', {
	  prototype: TabbarElement.prototype
	});

	/**
	 * @param {String} name
	 * @param {Function} Animator
	 */
	window.OnsTabbarElement.registerAnimator = function (name, Animator) {
	  if (!(Animator.prototype instanceof TabbarAnimator)) {
	    throw new Error('"Animator" param must inherit OnsTabbarElement.TabbarAnimator');
	  }
	  _animatorDict$5[name] = Animator;
	};

	window.OnsTabbarElement.rewritables = rewritables$3;
	window.OnsTabbarElement.TabbarAnimator = TabbarAnimator;

	var OnsTabbarElement$1 = OnsTabbarElement;

	var scheme$19 = {
	  '': 'tab-bar--*__item',
	  '.tab-bar__button': 'tab-bar--*__button'
	};
	var templateSource$1 = util.createElement('\n  <div>\n    <input type="radio" style="display: none">\n    <button class="tab-bar__button tab-bar-inner"></button>\n  </div>\n');
	var defaultInnerTemplateSource = util.createElement('\n  <div>\n    <div class="tab-bar__icon">\n      <ons-icon icon="ion-cloud"></ons-icon>\n    </div>\n    <div class="tab-bar__label">label</div>\n  </div>\n');

	/**
	 * @element ons-tab
	 * @category tabbar
	 * @description
	 *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
	 *   [ja]
	 *     タブバーに配置される各アイテムのコンポーネントです。それぞれのons-tabはページを表します。
	 *     ons-tab要素の中には、タブに表示されるコンテンツを直接記述することが出来ます。
	 *   [/ja]
	 * @codepen pGuDL
	 * @tutorial vanilla/Reference/tabbar
	 * @guide UsingTabBar
	 *   [en]Using tab bar[/en]
	 *   [ja]タブバーを使う[/ja]
	 * @guide DefiningMultiplePagesinSingleHTML
	 *   [en]Defining multiple pages in single html[/en]
	 *   [ja]複数のページを1つのHTMLに記述する[/ja]
	 * @seealso ons-tabbar
	 *   [en]ons-tabbar component[/en]
	 *   [ja]ons-tabbarコンポーネント[/ja]
	 * @seealso ons-page
	 *   [en]ons-page component[/en]
	 *   [ja]ons-pageコンポーネント[/ja]
	 * @seealso ons-icon
	 *   [en]ons-icon component[/en]
	 *   [ja]ons-iconコンポーネント[/ja]
	 * @example
	 * <ons-tabbar>
	 *   <ons-tab
	 *     page="home.html"
	 *     label="Home"
	 *     active>
	 *   </ons-tab>
	 *   <ons-tab
	 *     page="settings.html"
	 *     label="Settings"
	 *     active>
	 *   </ons-tab>
	 * </ons-tabbar>
	 *
	 * <ons-template id="home.html">
	 *   ...
	 * </ons-template>
	 *
	 * <ons-template id="settings.html">
	 *   ...
	 * </ons-template>

	 */

	var TabElement = function (_BaseElement) {
	  babelHelpers.inherits(TabElement, _BaseElement);

	  function TabElement() {
	    babelHelpers.classCallCheck(this, TabElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(TabElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute page
	     * @initonly
	     * @type {String}
	     * @description
	     *   [en]The page that is displayed when the tab is tapped.[/en]
	     *   [ja]ons-tabが参照するページへのURLを指定します。[/ja]
	     */

	    /**
	     * @attribute icon
	     * @type {String}
	     * @description
	     *   [en]
	     *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`.
	     *     If you need to use your own icon, create a CSS class with `background-image` or any CSS properties and specify the name of your CSS class here.
	     *   [/en]
	     *   [ja]
	     *     アイコン名を指定します。ons-iconと同じアイコン名を指定できます。
	     *     個別にアイコンをカスタマイズする場合は、background-imageなどのCSSスタイルを用いて指定できます。
	     *   [/ja]
	     */

	    /**
	     * @attribute active-icon
	     * @type {String}
	     * @description
	     *   [en]The name of the icon when the tab is active.[/en]
	     *   [ja]アクティブの際のアイコン名を指定します。[/ja]
	     */

	    /**
	     * @attribute label
	     * @type {String}
	     * @description
	     *   [en]The label of the tab item.[/en]
	     *   [ja]アイコン下に表示されるラベルを指定します。[/ja]
	     */

	    /**
	     * @attribute active
	     * @description
	     *   [en]This attribute should be set to the tab that is active by default.[/en]
	     *   [ja][/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      if (this.hasAttribute('label') || this.hasAttribute('icon')) {
	        if (!this.hasAttribute('_compiled')) {
	          this._compile();
	        }
	      } else {
	        contentReady(this, function () {
	          if (!_this2.hasAttribute('_compiled')) {
	            _this2._compile();
	          }
	        });
	      }

	      this._boundOnClick = this._onClick.bind(this);
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      var fragment = document.createDocumentFragment();
	      var hasChildren = false;

	      while (this.childNodes[0]) {
	        var node = this.childNodes[0];
	        this.removeChild(node);
	        fragment.appendChild(node);

	        if (node.nodeType == Node.ELEMENT_NODE) {
	          hasChildren = true;
	        }
	      }

	      var template = templateSource$1.cloneNode(true);
	      while (template.children[0]) {
	        this.appendChild(template.children[0]);
	      }
	      this.classList.add('tab-bar__item');

	      var button = util.findChild(this, '.tab-bar__button');

	      if (hasChildren) {
	        button.appendChild(fragment);
	        this._hasDefaultTemplate = false;
	      } else {
	        this._hasDefaultTemplate = true;
	        this._updateDefaultTemplate();
	      }

	      ModifierUtil.initModifier(this, scheme$19);
	      this._updateRipple();

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: '_updateRipple',
	    value: function _updateRipple() {
	      // util.updateRipple(this.querySelector('.tab-bar__button'), this);
	    }
	  }, {
	    key: '_updateDefaultTemplate',
	    value: function _updateDefaultTemplate() {
	      if (!this._hasDefaultTemplate) {
	        return;
	      }

	      var button = util.findChild(this, '.tab-bar__button');

	      if (button.children.length == 0) {
	        var template = defaultInnerTemplateSource.cloneNode(true);
	        while (template.children[0]) {
	          button.appendChild(template.children[0]);
	        }

	        if (!button.querySelector('.tab-bar__icon')) {
	          button.insertBefore(template.querySelector('.tab-bar__icon'), button.firstChild);
	        }

	        if (!button.querySelector('.tab-bar__label')) {
	          button.appendChild(template.querySelector('.tab-bar__label'));
	        }
	      }

	      var self = this;
	      var icon = this.getAttribute('icon');
	      var label = this.getAttribute('label');

	      if (typeof icon === 'string') {
	        getIconElement().setAttribute('icon', icon);
	      } else {
	        var wrapper = button.querySelector('.tab-bar__icon');
	        if (wrapper) {
	          wrapper.remove();
	        }
	      }

	      if (typeof label === 'string') {
	        getLabelElement().textContent = label;
	      } else {
	        var _label = getLabelElement();
	        if (_label) {
	          _label.remove();
	        }
	      }

	      function getLabelElement() {
	        return self.querySelector('.tab-bar__label');
	      }

	      function getIconElement() {
	        return self.querySelector('ons-icon');
	      }
	    }
	  }, {
	    key: '_onClick',
	    value: function _onClick() {
	      var tabbar = this._findTabbarElement();
	      if (tabbar) {
	        tabbar.setActiveTab(this._findTabIndex());
	      }
	    }
	  }, {
	    key: 'setActive',
	    value: function setActive() {
	      var radio = util.findChild(this, 'input');
	      radio.checked = true;
	      this.classList.add('active');

	      util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
	        return element.style.display = 'none';
	      });
	      util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
	        return element.style.display = 'inherit';
	      });
	    }
	  }, {
	    key: 'setInactive',
	    value: function setInactive() {
	      var radio = util.findChild(this, 'input');
	      radio.checked = false;
	      this.classList.remove('active');

	      util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
	        return element.style.display = 'inherit';
	      });
	      util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
	        return element.style.display = 'none';
	      });
	    }

	    /**
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isLoaded',
	    value: function isLoaded() {
	      return false;
	    }

	    /**
	     * @param {Function} callback
	     * @param {Function} link
	     */

	  }, {
	    key: '_loadPageElement',
	    value: function _loadPageElement(callback, link) {
	      var _this3 = this;

	      if (!this.pageElement) {
	        this._createPageElement(this.getAttribute('page'), function (element) {
	          link(element, function (element) {
	            _this3.pageElement = element;
	            callback(element);
	          });
	        });
	      } else {
	        callback(this.pageElement);
	      }
	    }
	  }, {
	    key: '_createPageElement',


	    /**
	     * @param {String} page
	     * @param {Function} callback
	     */
	    value: function _createPageElement(page, callback) {
	      internal.getPageHTMLAsync(page).then(function (html) {
	        callback(util.createElement(html.trim()));
	      });
	    }

	    /**
	     * @return {Boolean}
	     */

	  }, {
	    key: 'isActive',
	    value: function isActive() {
	      return this.classList.contains('active');
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this.removeEventListener('click', this._boundOnClick, false);
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this4 = this;

	      contentReady(this, function () {
	        _this4._ensureElementPosition();

	        var tabbar = _this4._findTabbarElement();

	        if (tabbar.hasAttribute('modifier')) {
	          var prefix = _this4.hasAttribute('modifier') ? _this4.getAttribute('modifier') + ' ' : '';
	          _this4.setAttribute('modifier', prefix + tabbar.getAttribute('modifier'));
	        }

	        if (_this4.hasAttribute('active')) {
	          (function () {
	            var tabIndex = _this4._findTabIndex();

	            OnsTabbarElement$1.rewritables.ready(tabbar, function () {
	              setImmediate(function () {
	                return tabbar.setActiveTab(tabIndex, { animation: 'none' });
	              });
	            });
	          })();
	        } else {
	          OnsTabbarElement$1.rewritables.ready(tabbar, function () {
	            setImmediate(function () {
	              if (_this4.hasAttribute('page')) {
	                _this4._createPageElement(_this4.getAttribute('page'), function (pageElement) {
	                  OnsTabbarElement$1.rewritables.link(tabbar, pageElement, {}, function (pageElement) {
	                    _this4.pageElement = pageElement;
	                    _this4.pageElement.style.display = 'none';
	                    tabbar._contentElement.appendChild(_this4.pageElement);
	                  });
	                });
	              }
	            });
	          });
	        }

	        _this4.addEventListener('click', _this4._boundOnClick, false);
	      });
	    }
	  }, {
	    key: '_findTabbarElement',
	    value: function _findTabbarElement() {
	      if (this.parentNode && this.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
	        return this.parentNode;
	      }

	      if (this.parentNode.parentNode && this.parentNode.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
	        return this.parentNode.parentNode;
	      }

	      return null;
	    }
	  }, {
	    key: '_findTabIndex',
	    value: function _findTabIndex() {
	      var elements = this.parentNode.children;
	      for (var i = 0; i < elements.length; i++) {
	        if (this === elements[i]) {
	          return i;
	        }
	      }
	    }
	  }, {
	    key: '_ensureElementPosition',
	    value: function _ensureElementPosition() {
	      if (!this._findTabbarElement()) {
	        throw new Error('This ons-tab element is must be child of ons-tabbar element.');
	      }
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      var _this5 = this;

	      switch (name) {
	        case 'modifier':
	          contentReady(this, function () {
	            return ModifierUtil.onModifierChanged(last, current, _this5, scheme$19);
	          });
	          break;
	        case 'ripple':
	          contentReady(this, function () {
	            return _this5._updateRipple();
	          });
	          break;
	        case 'icon':
	        case 'label':
	          contentReady(this, function () {
	            return _this5._updateDefaultTemplate();
	          });
	          break;
	      }
	    }
	  }, {
	    key: 'pageElement',
	    set: function set(el) {
	      this._pageElement = el;
	    },
	    get: function get() {
	      if (typeof this._pageElement !== 'undefined') {
	        return this._pageElement;
	      }

	      var tabbar = this._findTabbarElement();
	      var index = this._findTabIndex();

	      return tabbar._contentElement.children[index];
	    }
	  }]);
	  return TabElement;
	}(BaseElement);

	window.OnsTabElement = document.registerElement('ons-tab', {
	  prototype: TabElement.prototype
	});

	document.registerElement('ons-tabbar-item', {
	  prototype: Object.create(TabElement.prototype)
	});

	var scheme$21 = { '': 'toolbar-button--*' };

	/**
	 * @element ons-toolbar-button
	 * @category toolbar
	 * @modifier material
	 *   [en]Material Design toolbar button.[/en]
	 *   [ja][/ja]
	 * @modifier outline
	 *   [en]A button with an outline.[/en]
	 *   [ja]アウトラインをもったボタンを表示します。[/ja]
	 * @description
	 *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
	 *   [ja]ons-toolbarあるいはons-bottom-toolbarに設置できるボタン用コンポーネントです。[/ja]
	 * @codepen aHmGL
	 * @tutorial vanilla/Reference/button
	 * @guide Addingatoolbar
	 *   [en]Adding a toolbar[/en]
	 *   [ja]ツールバーの追加[/ja]
	 * @seealso ons-toolbar
	 *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
	 *   [ja]ons-toolbarコンポーネント[/ja]
	 * @seealso ons-back-button
	 *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
	 *   [ja]ons-back-buttonコンポーネント[/ja]
	 * @example
	 * <ons-toolbar>
	 *   <div class="left">
	 *     <ons-toolbar-button>
	 *       Button
	 *     </ons-toolbar-button>
	 *   </div>
	 *   <div class="center">
	 *     Title
	 *   </div>
	 *   <div class="right">
	 *     <ons-toolbar-button>
	 *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
	 *     </ons-toolbar-button>
	 *   </div>
	 * </ons-toolbar>
	 */

	var ToolbarButtonElement = function (_BaseElement) {
	  babelHelpers.inherits(ToolbarButtonElement, _BaseElement);

	  function ToolbarButtonElement() {
	    babelHelpers.classCallCheck(this, ToolbarButtonElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarButtonElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(ToolbarButtonElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute modifier
	     * @type {String}
	     * @description
	     *   [en]The appearance of the button.[/en]
	     *   [ja]ボタンの表現を指定します。[/ja]
	     */

	    /**
	     * @attribute disabled
	     * @description
	     *   [en]Specify if button should be disabled.[/en]
	     *   [ja]ボタンを無効化する場合は指定してください。[/ja]
	     */

	    value: function createdCallback() {
	      if (!this.hasAttribute('_compiled')) {
	        this._compile();
	      }
	    }

	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      this.classList.add('toolbar-button');

	      ModifierUtil.initModifier(this, scheme$21);

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$21);
	      }
	    }
	  }, {
	    key: 'disabled',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'disabled', value);
	    },
	    get: function get() {
	      return this.hasAttribute('disabled');
	    }
	  }]);
	  return ToolbarButtonElement;
	}(BaseElement);

	window.OnsToolbarButton = document.registerElement('ons-toolbar-button', {
	  prototype: ToolbarButtonElement.prototype
	});

	var scheme$22 = {
	  '': 'navigation-bar--*',
	  '.navigation-bar__left': 'navigation-bar--*__left',
	  '.navigation-bar__center': 'navigation-bar--*__center',
	  '.navigation-bar__right': 'navigation-bar--*__right'
	};

	/**
	 * @element ons-toolbar
	 * @category toolbar
	 * @modifier material
	 *   [en]Material Design toolbar.[/en]
	 *   [ja][/ja]
	 * @modifier transparent
	 *   [en]Transparent toolbar[/en]
	 *   [ja]透明な背景を持つツールバーを表示します。[/ja]
	 * @description
	 *   [en]
	 *     Toolbar component that can be used with navigation.
	 *
	 *     Left, center and right container can be specified by class names.
	 *
	 *     This component will automatically displays as a Material Design toolbar when running on Android devices.
	 *   [/en]
	 *   [ja]ナビゲーションで使用するツールバー用コンポーネントです。クラス名により、左、中央、右のコンテナを指定できます。[/ja]
	 * @codepen aHmGL
	 * @tutorial vanilla/Reference/button
	 * @guide Addingatoolbar [en]Adding a toolbar[/en][ja]ツールバーの追加[/ja]
	 * @seealso ons-bottom-toolbar
	 *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
	 *   [ja]ons-bottom-toolbarコンポーネント[/ja]
	 * @seealso ons-back-button
	 *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
	 *   [ja]ons-back-buttonコンポーネント[/ja]
	 * @seealso ons-toolbar-button
	 *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
	 *   [ja]ons-toolbar-buttonコンポーネント[/ja]
	 * @example
	 * <ons-page>
	 *   <ons-toolbar>
	 *     <div class="left">
	 *       <ons-back-button>
	 *         Back
	 *       </ons-back-button>
	 *     </div>
	 *     <div class="center">
	 *       Title
	 *     </div>
	 *     <div class="right">
	 *       <ons-toolbar-button>
	 *         <ons-icon icon="md-menu"></ons-icon>
	 *       </ons-toolbar-button>
	 *     </div>
	 *   </ons-toolbar>
	 * </ons-page>
	 */

	var ToolbarElement = function (_BaseElement) {
	  babelHelpers.inherits(ToolbarElement, _BaseElement);

	  function ToolbarElement() {
	    babelHelpers.classCallCheck(this, ToolbarElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(ToolbarElement, [{
	    key: 'createdCallback',


	    /**
	     * @attribute inline
	     * @initonly
	     * @description
	     *   [en]Display the toolbar as an inline element.[/en]
	     *   [ja]ツールバーをインラインに置きます。スクロール領域内にそのまま表示されます。[/ja]
	     */

	    /**
	     * @attribute modifier
	     * @description
	     *   [en]The appearance of the toolbar.[/en]
	     *   [ja]ツールバーの表現を指定します。[/ja]
	     */

	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        if (!_this2.hasAttribute('_compiled')) {
	          _this2._compile();
	        }
	      });

	      this._tryToEnsureNodePosition();
	      setImmediate(function () {
	        return _this2._tryToEnsureNodePosition();
	      });
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      if (name === 'modifier') {
	        return ModifierUtil.onModifierChanged(last, current, this, scheme$22);
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      var _this3 = this;

	      this._tryToEnsureNodePosition();
	      setImmediate(function () {
	        return _this3._tryToEnsureNodePosition();
	      });
	    }
	  }, {
	    key: '_tryToEnsureNodePosition',
	    value: function _tryToEnsureNodePosition() {
	      if (!this.parentNode || this.hasAttribute('inline')) {
	        return;
	      }
	      var page = util.findParent(this, 'ons-page');

	      if (page && page !== this.parentNode) {
	        page._registerToolbar(this);
	      }
	    }

	    /**
	     * @return {HTMLElement}
	     */

	  }, {
	    key: '_getToolbarLeftItemsElement',
	    value: function _getToolbarLeftItemsElement() {
	      return this.querySelector('.left') || internal.nullElement;
	    }

	    /**
	     * @return {HTMLElement}
	     */

	  }, {
	    key: '_getToolbarCenterItemsElement',
	    value: function _getToolbarCenterItemsElement() {
	      return this.querySelector('.center') || internal.nullElement;
	    }

	    /**
	     * @return {HTMLElement}
	     */

	  }, {
	    key: '_getToolbarRightItemsElement',
	    value: function _getToolbarRightItemsElement() {
	      return this.querySelector('.right') || internal.nullElement;
	    }

	    /**
	     * @return {HTMLElement}
	     */

	  }, {
	    key: '_getToolbarBackButtonLabelElement',
	    value: function _getToolbarBackButtonLabelElement() {
	      return this.querySelector('ons-back-button .back-button__label') || internal.nullElement;
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);
	      this.classList.add('navigation-bar');
	      this._ensureToolbarItemElements();
	      ModifierUtil.initModifier(this, scheme$22);
	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: '_ensureToolbarItemElements',
	    value: function _ensureToolbarItemElements() {
	      for (var i = this.childNodes.length - 1; i >= 0; i--) {
	        // case of not element
	        if (this.childNodes[i].nodeType != 1) {
	          this.removeChild(this.childNodes[i]);
	        }
	      }

	      var center = this._ensureToolbarElement('center');
	      center.classList.add('navigation-bar__title');

	      if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
	        var left = this._ensureToolbarElement('left');
	        var right = this._ensureToolbarElement('right');

	        if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
	          this.appendChild(left);
	          this.appendChild(center);
	          this.appendChild(right);
	        }
	      }
	    }
	  }, {
	    key: '_ensureToolbarElement',
	    value: function _ensureToolbarElement(name) {
	      var element = util.findChild(this, '.' + name) || util.create('.' + name);

	      element.classList.add('navigation-bar__' + name);

	      return element;
	    }
	  }]);
	  return ToolbarElement;
	}(BaseElement);

	window.OnsToolbarElement = document.registerElement('ons-toolbar', {
	  prototype: ToolbarElement.prototype
	});

	var scheme$23 = {
	  '.range': 'range--*',
	  '.range__left': 'range--*__left'
	};

	var templateSource$2 = util.createElement('<div>\n  <div class="range__left"></div>\n  <input type="range" class="range">\n</div>');

	var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'inputmode', 'max', 'min', 'name', 'placeholder', 'readonly', 'size', 'step', 'validator', 'value'];

	/**
	 * @element ons-range
	 * @category range
	 * @modifier material
	 *   [en]Material Design slider[/en]
	 *   [ja][/ja]
	 * @description
	 *   [en]
	 *     Range input component. Used to display a draggable slider.
	 *
	 *     Works very similar to the `<input type="range">` element.
	 *   [/en]
	 *   [ja][/ja]
	 * @codepen xZQomM
	 * @tutorial vanilla/Reference/range
	 * @guide UsingFormComponents
	 *   [en]Using form components[/en]
	 *   [ja]フォームを使う[/ja]
	 * @guide EventHandling
	 *   [en]Event handling descriptions[/en]
	 *   [ja]イベント処理の使い方[/ja]
	 * @seealso ons-input
	 *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
	 *   [ja][/ja]
	 * @example
	 * <ons-range value="20"></ons-range>
	 * <ons-range modifier="material" value="10"></range>
	 */

	var RangeElement = function (_BaseElement) {
	  babelHelpers.inherits(RangeElement, _BaseElement);

	  function RangeElement() {
	    babelHelpers.classCallCheck(this, RangeElement);
	    return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(RangeElement).apply(this, arguments));
	  }

	  babelHelpers.createClass(RangeElement, [{
	    key: 'createdCallback',
	    value: function createdCallback() {
	      var _this2 = this;

	      contentReady(this, function () {
	        if (!_this2.hasAttribute('_compiled')) {
	          _this2._compile();
	        }

	        _this2._updateBoundAttributes();
	        _this2._onChange();
	      });
	    }
	  }, {
	    key: '_compile',
	    value: function _compile() {
	      autoStyle.prepare(this);

	      if (!(util.findChild(this, '.range__left') && util.findChild(this, 'input'))) {
	        var template = templateSource$2.cloneNode(true);
	        while (template.children[0]) {
	          this.appendChild(template.children[0]);
	        }
	      }

	      ModifierUtil.initModifier(this, scheme$23);

	      this.setAttribute('_compiled', '');
	    }
	  }, {
	    key: '_onChange',
	    value: function _onChange() {
	      this._left.style.width = 100 * this._ratio + '%';
	    }
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback(name, last, current) {
	      var _this3 = this;

	      if (name === 'modifier') {
	        ModifierUtil.onModifierChanged(last, current, this, scheme$23);
	      } else if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
	        contentReady(this, function () {
	          _this3._updateBoundAttributes();

	          if (name === 'min' || name === 'max') {
	            _this3._onChange();
	          }
	        });
	      }
	    }
	  }, {
	    key: 'attachedCallback',
	    value: function attachedCallback() {
	      this.addEventListener('input', this._onChange);
	    }
	  }, {
	    key: 'detachedCallback',
	    value: function detachedCallback() {
	      this.removeEventListener('input', this._onChange);
	    }
	  }, {
	    key: '_updateBoundAttributes',
	    value: function _updateBoundAttributes() {
	      var _this4 = this;

	      INPUT_ATTRIBUTES$1.forEach(function (attr) {
	        if (_this4.hasAttribute(attr)) {
	          _this4._input.setAttribute(attr, _this4.getAttribute(attr));
	        } else {
	          _this4._input.removeAttribute(attr);
	        }
	      });
	    }
	  }, {
	    key: '_ratio',
	    get: function get() {
	      // Returns the current ratio.
	      var min = this._input.min === '' ? 0 : parseInt(this._input.min);
	      var max = this._input.max === '' ? 100 : parseInt(this._input.max);

	      return (this.value - min) / (max - min);
	    }
	  }, {
	    key: '_input',
	    get: function get() {
	      return this.querySelector('input');
	    }
	  }, {
	    key: '_left',
	    get: function get() {
	      return this.querySelector('.range__left');
	    }

	    /**
	     * @property disabled
	     * @type {Boolean}
	     * @description
	     *   [en]Whether the element is disabled or not.[/en]
	     *   [ja]無効化されている場合に`true`。[/ja]
	     */

	  }, {
	    key: 'disabled',
	    set: function set(value) {
	      return util.toggleAttribute(this, 'disabled', value);
	    },
	    get: function get() {
	      return this.hasAttribute('disabled');
	    }

	    /**
	     * @property value
	     * @type {Number}
	     * @description
	     *   [en]Current value.[/en]
	     *   [ja][/ja]
	     */

	  }, {
	    key: 'value',
	    get: function get() {
	      return this._input.value;
	    },
	    set: function set(val) {
	      var _this5 = this;

	      contentReady(this, function () {
	        _this5._input.value = val;
	        _this5._onChange();
	      });
	    }
	  }]);
	  return RangeElement;
	}(BaseElement);

	window.OnsRangeElement = document.registerElement('ons-range', {
	  prototype: RangeElement.prototype
	});

	var space = {
	    //该组件的根样式名
	    rootClassName: 'bh-stepping',
	    value: 1,
	    //缓存标签对象
	    rootObj: null
	};

	/**
	 * 步进组件
	 * @example <bh-stepping></bh-stepping>
	 * @example <bh-stepping value="设定初始值"></bh-stepping>
	 */

	var BhSteppingElement = function (_BaseElement) {
	    babelHelpers.inherits(BhSteppingElement, _BaseElement);

	    function BhSteppingElement() {
	        babelHelpers.classCallCheck(this, BhSteppingElement);
	        return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BhSteppingElement).apply(this, arguments));
	    }

	    babelHelpers.createClass(BhSteppingElement, [{
	        key: 'setStep',


	        //定义设置input值的方法
	        value: function setStep(value) {
	            this.inputDom.value = value;
	        }

	        //获取input的当前值

	    }, {
	        key: '_add',


	        //步进加1
	        value: function _add() {
	            var num = space.rootObj.currentStep;
	            num++;
	            space.rootObj.setStep(num);

	            /**
	             * 点击加号或减号时触发的事件
	             * @event BhSteppingElement#BhSteppingElement change
	             * @property {number} value 当前的值
	             * @property {string} flag "add"点击加号, "down"点击减号
	             */
	            util.triggerElementEvent(util.findParent(this, space.rootClassName), 'change', {
	                value: num,
	                flag: 'add'
	            });
	        }

	        //步进减一

	    }, {
	        key: '_down',
	        value: function _down() {
	            var num = space.rootObj.currentStep;
	            num--;
	            //最小值是1
	            if (num < 1) {
	                num = 1;
	            }
	            space.rootObj.setStep(num);
	            util.triggerElementEvent(util.findParent(this, space.rootClassName), 'change', {
	                value: num,
	                flag: 'down'
	            });
	        }
	    }, {
	        key: '_iconActiveHandle',
	        value: function _iconActiveHandle(event) {
	            this.classList.toggle('bh-active');
	        }

	        //组件加载完毕的回调,相当于该组件的入口方法

	    }, {
	        key: 'createdCallback',
	        value: function createdCallback() {
	            var _this2 = this;

	            contentReady(this, function () {
	                return _this2._compile();
	            });
	        }

	        //监听属性变化处理

	    }, {
	        key: 'attributeChangedCallback',
	        value: function attributeChangedCallback(name, last, current) {
	            //text 变化时的处理
	            if (name === 'value') {
	                this.querySelector('input').value = current;
	            }
	        }

	        //初始化方法

	    }, {
	        key: '_compile',
	        value: function _compile() {
	            space.rootObj = this;
	            autoStyle.prepare(this);
	            //添加样式
	            this.classList.add(space.rootClassName);

	            var initValue = this.getAttribute('value');
	            if (initValue) {
	                space.value = initValue;
	            }

	            var stepHtml = '\n            <div class="' + space.rootClassName + '-icon bh-left"><i class="iconfont icon-remove"></i></div>\n            <input class="' + space.rootClassName + '-input" value="' + space.value + '" type="number" />\n            <div class="' + space.rootClassName + '-icon bh-right"><i class="iconfont icon-add"></i></div>\n        ';

	            this.innerHTML = stepHtml;

	            //监听该组件的事件
	            var leftIcon = util.findChild(this, '.bh-left');
	            var rightIcon = util.findChild(this, '.bh-right');
	            leftIcon.addEventListener('click', this._down, false);
	            leftIcon.addEventListener('touchstart', this._iconActiveHandle, false);
	            leftIcon.addEventListener('touchend', this._iconActiveHandle, false);

	            rightIcon.addEventListener('click', this._add, false);
	            rightIcon.addEventListener('touchstart', this._iconActiveHandle, false);
	            rightIcon.addEventListener('touchend', this._iconActiveHandle, false);
	        }
	    }, {
	        key: 'inputDom',


	        //定义获取input元素的方法
	        get: function get() {
	            return util.findChild(this, 'input');
	        }
	    }, {
	        key: 'currentStep',
	        get: function get() {
	            var num = parseInt(this.inputDom.value, 10);
	            if (!num) {
	                num = 0;
	            }
	            return num;
	        }
	    }]);
	    return BhSteppingElement;
	}(BaseElement);

	//注册该标签(用于浏览器不支持自定义标签的处理)


	window.BhSteppingElement = document.registerElement('bh-stepping', {
	    prototype: BhSteppingElement.prototype
	});

	var space$1 = {
	    //该组件的根样式名
	    rootClassName: 'bh-input',
	    value: ''
	};

	/**
	 * 输入框
	 *
	 * @example <bh-input label="label值" value="输入框的值"></bh-input>
	 */

	var BhInputElement = function (_BaseElement) {
	    babelHelpers.inherits(BhInputElement, _BaseElement);

	    function BhInputElement() {
	        babelHelpers.classCallCheck(this, BhInputElement);
	        return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BhInputElement).apply(this, arguments));
	    }

	    babelHelpers.createClass(BhInputElement, [{
	        key: 'value',

	        /**
	         * 获取输入框的值
	         * @returns {string}
	         */
	        value: function value() {
	            return util.findChild(this, 'input').value;
	        }

	        //组件加载完毕的回调,相当于该组件的入口方法

	    }, {
	        key: 'createdCallback',
	        value: function createdCallback() {
	            var _this2 = this;

	            contentReady(this, function () {
	                return _this2._compile();
	            });
	        }

	        //初始化方法

	    }, {
	        key: '_compile',
	        value: function _compile() {
	            var initValue = this.getAttribute('value');
	            if (initValue) {
	                space$1.value = initValue;
	            }

	            var label = this.getAttribute('label');

	            var stepHtml = '\n            <div class="' + space$1.rootClassName + '-label">' + label + '</div>\n            <input class="' + space$1.rootClassName + '" value="' + space$1.value + '" type="text" />\n        ';

	            this.innerHTML = stepHtml;
	        }
	    }]);
	    return BhInputElement;
	}(BaseElement);

	//注册该标签(用于浏览器不支持自定义标签的处理)


	window.BhInputElement = document.registerElement('bh-input', {
	    prototype: BhInputElement.prototype
	});

	var space$2 = {
	    //该组件的根样式名
	    rootClassName: 'bh-search',
	    value: ''
	};

	/**
	 * 搜索框
	 *
	 * @example <bh-search></bh-search>
	 */

	var BhSearchElement = function (_BaseElement) {
	    babelHelpers.inherits(BhSearchElement, _BaseElement);

	    function BhSearchElement() {
	        babelHelpers.classCallCheck(this, BhSearchElement);
	        return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BhSearchElement).apply(this, arguments));
	    }

	    babelHelpers.createClass(BhSearchElement, [{
	        key: 'value',

	        /**
	         * 获取或设置搜索框的值
	         * @param {string} text 传入text则为设值,否则为获取值
	         * @returns {string}
	         */
	        value: function value(text) {
	            if (typeof text === 'undefined') {
	                return this.querySelector('.bh-search-input').value;
	            } else {
	                this.querySelector('.bh-search-input').value = text + '';
	                this._showClose();
	            }
	        }
	    }, {
	        key: '_clearValue',
	        value: function _clearValue() {
	            var parentObj = util.findParent(this, 'bh-search');
	            var input = parentObj.querySelector('.bh-search-input');
	            var clas = this.getAttribute('class');
	            if (input.value != '') {

	                if (clas == 'iconfont icon-cancel') {
	                    this.style.display = 'none';
	                } else {
	                    this.previousSibling.parentNode.querySelector('.icon-cancel').style.display = 'none';
	                }
	                input.value = '';
	                input.focus();
	            }

	            /**
	             * 点击取消按钮时触发的事件
	             * @event BhSearchElement#BhSearchElement cancel
	             */
	            if (util.hasClass(this, 'bh-search-cancel')) {
	                util.triggerElementEvent(this, 'cancel');
	            }
	        }
	    }, {
	        key: '_showClose',
	        value: function _showClose() {
	            var value = this.value;
	            var cancel = this.parentNode.querySelector('.icon-cancel');
	            if (value != '') {
	                cancel.style.display = 'inline-block';
	            } else {
	                cancel.style.display = 'none';
	            }
	        }

	        //组件加载完毕的回调,相当于该组件的入口方法

	    }, {
	        key: 'createdCallback',
	        value: function createdCallback() {
	            var _this2 = this;

	            contentReady(this, function () {
	                return _this2._compile();
	            });
	        }

	        //初始化方法

	    }, {
	        key: '_compile',
	        value: function _compile() {
	            var contentHtml = '\n            <div class="' + space$2.rootClassName + '-wrap">\n                <div class="' + space$2.rootClassName + '-box">\n                    <i class ="iconfont icon-search"></i>\n                    <input class="' + space$2.rootClassName + '-input" value="' + space$2.value + '" type="text" />\n                    <i class = "iconfont icon-cancel"></i>\n                </div>\n                <a href="javascript:;" class="bh-search-cancel">取消</a>\n            </div>\n        ';

	            this.innerHTML = contentHtml;

	            var cancel = this.querySelector('.bh-search-cancel');
	            var close = this.querySelector('.icon-cancel');
	            var Input = this.querySelector('.bh-search-input');
	            cancel.addEventListener('click', this._clearValue, false);
	            close.addEventListener('click', this._clearValue, false);
	            Input.addEventListener('keyup', this._showClose, false);
	        }
	    }]);
	    return BhSearchElement;
	}(BaseElement);

	//注册该标签(用于浏览器不支持自定义标签的处理)


	window.BhSearchElement = document.registerElement('bh-search', {
	    prototype: BhSearchElement.prototype
	});

	var space$3 = {
	    //该组件的根样式名
	    rootClassName: 'bh-search-bar'
	};

	/**
	 * 搜索条
	 * @example <bh-search-bar></bh-search-bar>
	 * @example <bh-search-bar text="内容"></bh-search-bar>
	 */

	var BhSearchBarElement = function (_BaseElement) {
	    babelHelpers.inherits(BhSearchBarElement, _BaseElement);

	    function BhSearchBarElement() {
	        babelHelpers.classCallCheck(this, BhSearchBarElement);
	        return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BhSearchBarElement).apply(this, arguments));
	    }

	    babelHelpers.createClass(BhSearchBarElement, [{
	        key: 'createdCallback',


	        //组件加载完毕的回调,相当于该组件的入口方法
	        value: function createdCallback() {
	            var _this2 = this;

	            contentReady(this, function () {
	                return _this2._compile();
	            });
	        }

	        //监听属性变化处理

	    }, {
	        key: 'attributeChangedCallback',
	        value: function attributeChangedCallback(name, last, current) {
	            //text 变化时的处理
	            if (name === 'text') {
	                this.querySelector('span').innerHTML = current;
	            }
	        }

	        //初始化方法

	    }, {
	        key: '_compile',
	        value: function _compile() {
	            var value = this.getAttribute('text') || '';
	            var contentHtml = '\n            <div class="' + space$3.rootClassName + '">\n                <i class="iconfont icon-search"></i>\n                <span>' + value + '</span>\n            </div>\n        ';

	            this.innerHTML = contentHtml;
	        }
	    }]);
	    return BhSearchBarElement;
	}(BaseElement);

	//注册该标签(用于浏览器不支持自定义标签的处理)


	window.BhSearchBarElement = document.registerElement('bh-search-bar', {
	    prototype: BhSearchBarElement.prototype
	});

	var space$4 = {
	    //该组件的根样式名
	    rootClassName: 'bh-input-select'
	};

	var BhInputSelectElement = function (_BaseElement) {
	    babelHelpers.inherits(BhInputSelectElement, _BaseElement);

	    function BhInputSelectElement() {
	        babelHelpers.classCallCheck(this, BhInputSelectElement);
	        return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BhInputSelectElement).apply(this, arguments));
	    }

	    babelHelpers.createClass(BhInputSelectElement, [{
	        key: 'createdCallback',


	        //组件加载完毕的回调,相当于该组件的入口方法
	        value: function createdCallback() {
	            var _this2 = this;

	            contentReady(this, function () {
	                return _this2._compile();
	            });
	        }

	        //初始化方法

	    }, {
	        key: '_compile',
	        value: function _compile() {
	            this.classList.add('bh-clearfix-child');
	            var label = this.getAttribute('label');
	            var caption = this.getAttribute('caption');
	            var icon = this.getAttribute('icon');
	            var iconClass = icon ? icon : 'keyboardarrowright';
	            iconClass = iconClass.replace(/^icon-/, '');

	            var contentHtml = '\n            <div class="' + space$4.rootClassName + '-label">' + label + '</div>\n            <div class="' + space$4.rootClassName + '-caption">\n                <span class="' + space$4.rootClassName + '-caption-text">' + caption + '</span>\n                <i class="iconfont icon-' + iconClass + '"></i>\n            </div>\n        ';

	            this.innerHTML = contentHtml;
	        }
	    }]);
	    return BhInputSelectElement;
	}(BaseElement);

	//注册该标签(用于浏览器不支持自定义标签的处理)


	window.BhInputSelectElement = document.registerElement('bh-input-select', {
	    prototype: BhInputSelectElement.prototype
	});

	var space$5 = {
	    //该组件的根样式名
	    rootClassName: 'bh-carousel-btns'
	};

	/**
	 * 轮播高亮按钮组
	 *
	 * @example <bh-carousel-btns count="要显示的按钮个数" active-index="要高亮的按钮index,起始数是0"></bh-carousel-btns>
	 */

	var BhCarouselBtnsElement = function (_BaseElement) {
	    babelHelpers.inherits(BhCarouselBtnsElement, _BaseElement);

	    function BhCarouselBtnsElement() {
	        babelHelpers.classCallCheck(this, BhCarouselBtnsElement);
	        return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BhCarouselBtnsElement).apply(this, arguments));
	    }

	    babelHelpers.createClass(BhCarouselBtnsElement, [{
	        key: 'setActiveIndex',

	        /**
	         * 设置高亮位置
	         * @param {number} index 要高亮的按钮index,起始数是0
	         */
	        value: function setActiveIndex(index) {
	            var btns = this.querySelectorAll('div');
	            var btnsLen = btns.length;
	            for (var i = 0; i < btnsLen; i++) {
	                var item = btns[i];
	                item.classList.remove('bh-active');
	                if (index === i) {
	                    item.classList.add('bh-active');
	                }
	            }
	        }

	        //组件加载完毕的回调,相当于该组件的入口方法

	    }, {
	        key: 'createdCallback',
	        value: function createdCallback() {
	            var _this2 = this;

	            contentReady(this, function () {
	                return _this2._compile();
	            });
	        }

	        //初始化方法

	    }, {
	        key: '_compile',
	        value: function _compile() {
	            var count = parseInt(this.getAttribute('count'), 10);
	            if (!count) {
	                return;
	            }

	            var activeIndex = parseInt(this.getAttribute('active-index'), 10);
	            activeIndex = activeIndex ? activeIndex : 1;

	            var btnHtml = '\n            <div class="' + space$5.rootClassName + '-item @activeClass"></div>\n        ';

	            var contentHtml = '';

	            for (var i = 0; i < count; i++) {
	                var activeClass = '';
	                if (i + 1 === activeIndex) {
	                    activeClass = 'bh-active';
	                }
	                contentHtml += btnHtml.replace('@activeClass', activeClass);
	            }

	            this.innerHTML = contentHtml;
	        }
	    }]);
	    return BhCarouselBtnsElement;
	}(BaseElement);

	//注册该标签(用于浏览器不支持自定义标签的处理)


	window.BhCarouselBtnsElement = document.registerElement('bh-carousel-btns', {
	    prototype: BhCarouselBtnsElement.prototype
	});

	var space$6 = {
	    //该组件的根样式名
	    rootClassName: 'bh-modal-bottom',
	    animateTime: 450
	};

	/**
	 * 底部弹框
	 *
	 * @example <bh-modal-bottom></bh-modal-bottom>
	 * @example <bh-modal-bottom cover></bh-modal-bottom> 带遮罩层的弹框
	 * @example <bh-modal-bottom close-icon></bh-modal-bottom> 带关闭按钮的弹框
	 */

	var BhModalBottomElement = function (_BaseElement) {
	    babelHelpers.inherits(BhModalBottomElement, _BaseElement);

	    function BhModalBottomElement() {
	        babelHelpers.classCallCheck(this, BhModalBottomElement);
	        return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BhModalBottomElement).apply(this, arguments));
	    }

	    babelHelpers.createClass(BhModalBottomElement, [{
	        key: 'show',

	        /**
	         * 打开弹框
	         * @param {Object} options
	         * @param {function} options.callback 打开弹框后的回调
	         */
	        value: function show() {
	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            options = util.extend(options || {});

	            var content = this.querySelector('.' + space$6.rootClassName + '-content');
	            var cover = util.findChild(this, '.' + space$6.rootClassName + '-cover');

	            if (cover) {
	                cover.classList.add('bh-animate-fadeIn-lv1');
	                cover.classList.remove('bh-animate-fadeOut-lv1');
	            }

	            content.classList.remove('bh-animate-out-bottom');
	            content.classList.add('bh-animate-into-bottom');
	            this.style.display = 'block';

	            if (typeof options.callback != 'undefined' && options.callback instanceof Function) {
	                //执行的回调
	                options.callback();
	            }
	        }

	        /**
	         * 关闭弹框
	         * @param {Object} options
	         * @param {function} options.callback 关闭弹框后的回调
	         */

	    }, {
	        key: 'hide',
	        value: function hide() {
	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            options = util.extend(options || {});

	            var root = this;
	            if (this.localName !== space$6.rootClassName) {
	                root = util.findParent(this, space$6.rootClassName);
	            }
	            var content = util.findChild(root, '.' + space$6.rootClassName + '-content');
	            var cover = util.findChild(root, '.' + space$6.rootClassName + '-cover');

	            if (cover) {
	                cover.classList.remove('bh-animate-fadeIn-lv1');
	                cover.classList.add('bh-animate-fadeOut-lv1');
	            }

	            content.classList.remove('bh-animate-into-bottom');
	            content.classList.add('bh-animate-out-bottom');

	            setTimeout(function () {
	                root.style.display = 'none';
	            }, space$6.animateTime);
	            if (typeof options.callback != 'undefined' && options.callback instanceof Function) {
	                //执行的回调
	                options.callback();
	            }
	        }

	        //点击底部弹框的非内容区域,将弹框隐藏

	    }, {
	        key: '_clickAllHandle',
	        value: function _clickAllHandle(event) {
	            this.hide();
	        }
	        //点击弹框的内容区域将事件冒泡阻止,防止误隐藏操作

	    }, {
	        key: '_contentClickAllHandle',
	        value: function _contentClickAllHandle(event) {
	            event.preventDefault();
	            event.stopPropagation();
	        }

	        //组件加载完毕的回调,相当于该组件的入口方法

	    }, {
	        key: 'createdCallback',
	        value: function createdCallback() {
	            var _this2 = this;

	            contentReady(this, function () {
	                return _this2._compile();
	            });
	        }

	        //初始化方法

	    }, {
	        key: '_compile',
	        value: function _compile() {
	            var selectContent = this.querySelector('.' + space$6.rootClassName + '-content');
	            if (selectContent) {
	                var selectCloseIcon = util.findChild(selectContent, '.icon-close');
	                if (selectCloseIcon) {
	                    selectCloseIcon.removeEventListener('click', this.hide, false);
	                    selectCloseIcon.addEventListener('click', this.hide, false);
	                }
	                return;
	            }
	            var content = util.create('.' + space$6.rootClassName + '-content');

	            var isHaveClose = false;
	            var closeIcon = null;
	            if (this.hasAttribute('close-icon')) {
	                closeIcon = util.create('i');
	                closeIcon.classList.add('iconfont');
	                closeIcon.classList.add('icon-close');
	                content.appendChild(closeIcon);
	                isHaveClose = true;
	            }

	            while (this.firstChild) {
	                content.appendChild(this.firstChild);
	            }

	            if (this.hasAttribute('cover')) {
	                var cover = util.create('.' + space$6.rootClassName + '-cover');
	                //给遮罩层添加动画
	                cover.classList.add('bh-animated');
	                this.appendChild(cover);
	            }

	            this.appendChild(content);

	            this.style.display = 'none';
	            content.classList.add('bh-animated');

	            var bottom = this.getAttribute('bottom');
	            if (bottom) {
	                this.style.bottom = util.pxToRem(bottom);
	            }

	            if (isHaveClose) {
	                //给关闭按钮添加点击事件
	                closeIcon.addEventListener('click', this.hide, false);
	            }

	            //给内容去添加事件监听
	            this.querySelector('.' + space$6.rootClassName + '-content').addEventListener('click', this._contentClickAllHandle, false);
	            //给整个底部弹框添加点击事件监听
	            this.addEventListener('click', this._clickAllHandle, false);
	        }
	    }]);
	    return BhModalBottomElement;
	}(BaseElement);

	//注册该标签(用于浏览器不支持自定义标签的处理)


	window.BhModalBottomElement = document.registerElement('bh-modal-bottom', {
	    prototype: BhModalBottomElement.prototype
	});

	var space$7 = {
	    //该组件的根样式名
	    rootClassName: 'bh-modal-bottom',
	    animateTime: 450
	};

	//继承组件开发所需的类

	var BhModalBottom = function () {
	    function BhModalBottom() {
	        babelHelpers.classCallCheck(this, BhModalBottom);
	    }

	    babelHelpers.createClass(BhModalBottom, [{
	        key: 'show',

	        //初始化并显示弹框
	        value: function show() {
	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            var defaultOptions = {
	                cover: true, //是否显示遮罩层,默认true显示, false不显示
	                closeIcon: true //是否显示关闭按钮, 默认true显示, false不显示
	            };
	            //合并参数
	            options = util.extend({}, defaultOptions, options);
	            //初始化处理
	            this._compile(options);
	        }
	    }, {
	        key: 'hide',
	        value: function hide() {
	            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            options = util.extend(options || {});

	            var rootObj = document.querySelector('.' + space$7.rootClassName);
	            var contentObj = util.findChild(rootObj, '.' + space$7.rootClassName + '-content');
	            var coverObj = util.findChild(rootObj, '.' + space$7.rootClassName + '-cover');

	            if (coverObj) {
	                coverObj.classList.remove('bh-animate-fadeIn');
	                coverObj.classList.add('bh-animate-out-fadeOut');
	            }
	            contentObj.classList.remove('bh-animate-into-bottom');
	            contentObj.classList.add('bh-animate-out-bottom');

	            setTimeout(function () {
	                rootObj.remove();
	            }, space$7.animateTime);

	            if (typeof options.close != 'undefined' && options.close instanceof Function) {
	                //执行的回调
	                options.close();
	            }
	        }

	        //初始化方法

	    }, {
	        key: '_compile',
	        value: function _compile(options) {
	            var self = this;
	            //创建根节点
	            var rootObj = util.create('.' + space$7.rootClassName);
	            //对根节点设置上下左右值,默认使用rem单位,否则会将px或数字转换成rem
	            var offset = options.offset;
	            if (offset) {
	                if (offset.top) {
	                    rootObj.style.top = util.pxToRem(offset.top);
	                }
	                if (offset.bottom) {
	                    rootObj.style.bottom = util.pxToRem(offset.bottom);
	                }
	                if (offset.left) {
	                    rootObj.style.left = util.pxToRem(offset.left);
	                }
	                if (offset.right) {
	                    rootObj.style.right = util.pxToRem(offset.right);
	                }
	            }

	            //创建内容块
	            var contentObj = util.create('.' + space$7.rootClassName + '-content');
	            //添加动画类
	            contentObj.classList.add('bh-animated');
	            contentObj.classList.add('bh-animate-into-bottom');

	            //插入内容
	            var content = options.content;
	            contentObj.innerHTML = content;

	            //判断显示关闭按钮
	            if (options.closeIcon) {
	                var closeIcon = util.create('i');
	                closeIcon.classList.add('iconfont');
	                closeIcon.classList.add('icon-close');
	                contentObj.appendChild(closeIcon);

	                //监听关闭按钮事件
	                closeIcon.addEventListener('click', function () {
	                    //执行关闭回调
	                    self.hide({ 'close': options.close });
	                }, false);
	            }

	            //判断显示遮罩层
	            if (options.cover) {
	                var cover = util.create('.' + space$7.rootClassName + '-cover');
	                //给遮罩层添加动画
	                cover.classList.add('bh-animated');
	                cover.classList.add('bh-animate-fadeIn');
	                rootObj.appendChild(cover);
	            }

	            //将创建的节点加入页面
	            rootObj.appendChild(contentObj);
	            document.querySelector('body').appendChild(rootObj);

	            //初始化并显示完成后,执行回调
	            if (typeof options.ready != 'undefined' && options.ready instanceof Function) {
	                //执行的回调
	                setTimeout(function () {
	                    options.ready();
	                }, space$7.animateTime);
	            }
	        }
	    }]);
	    return BhModalBottom;
	}();

	//注册组件


	(function (BH, undefined) {
	    BH.bhModalBottom = BhModalBottom.prototype;
	})(window.BH = window.BH || {});

	var SPACE = {
	    //该组件的根样式名
	    rootClassName: 'bh-select-roll',
	    touchStartData: {},
	    dataCount: 0,
	    rotateXstep: 20,
	    activeIndex: 0,
	    //当触摸事件结束后会将标签上的selected属性值修改,
	    // 由于同时监听了该属性的变化做动态设置处理,所以会触发两次change事件,
	    // 该属性是为了屏蔽第二次触发change事件
	    selfToSetSelected: false
	};

	/**
	 * 滚轮选择组件
	 * @example <bh-select-roll date="列表数据的json字符串 [{key:"", value:""}]"></bh-select-roll>
	 * @example <bh-select-roll date="列表数据的json字符串" selected="设定选中项{key:"",value:""}"></bh-select-roll>
	 */

	var BhSelectRollElement = function (_BaseElement) {
	    babelHelpers.inherits(BhSelectRollElement, _BaseElement);

	    function BhSelectRollElement() {
	        babelHelpers.classCallCheck(this, BhSelectRollElement);
	        return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BhSelectRollElement).apply(this, arguments));
	    }

	    babelHelpers.createClass(BhSelectRollElement, [{
	        key: 'getValue',

	        /**
	         * 获取当前选中数据
	         * @returns {{key: string, value: string}}
	         */
	        value: function getValue() {
	            var activeItem = this.querySelector('.bh-active');
	            return { "key": activeItem.getAttribute('key'), "value": activeItem.getAttribute('value') };
	        }

	        /***
	         * 开始触摸
	         * 记录当前的y轴位置,存入SPACE.touchStartData.pageY中
	         * 将高亮节点的高亮去掉
	         * @param event
	         * @private
	         */

	    }, {
	        key: '_touchStartHandle',
	        value: function _touchStartHandle(event) {
	            SPACE.touchStartData.timeStamp = event.timeStamp;
	            SPACE.touchStartData.pageY = event.touches[0].pageY;
	            this._resetItemActive('hide');
	        }

	        /***
	         * 滑动处理
	         * 获取当前的y轴值,计算滑动距离与应滑动到的节点位置
	         * 设置ul的transform
	         * 更新SPACE.touchStartData.pageY为当前节点位置
	         * 更新SPACE.activeIndex为当前节点index
	         * @param event
	         * @private
	         */

	    }, {
	        key: '_touchMoveHandle',
	        value: function _touchMoveHandle(event) {
	            var pageY = event.touches[0].pageY;
	            var diff = SPACE.touchStartData.pageY - pageY;
	            var ulObj = this.querySelector('ul');
	            var ulTransform = ulObj.style.transform;
	            var rotateX = ulTransform.match(/rotateX\(\-?\d*\.+\d*deg\)|rotateX\(\-?\d*deg\)/);
	            if (!rotateX) {
	                return;
	            }
	            var rotateXNum = Number(rotateX[0].replace(/[^\-\.0-9]*/g, ''));
	            var newRotateXNum = rotateXNum + diff;
	            var newTransform = ulTransform.replace(/rotateX\(.+deg\)/, 'rotateX(' + newRotateXNum + 'deg)');
	            var index = Math.round(newRotateXNum / SPACE.rotateXstep);

	            if (index >= 0 && index < SPACE.dataCount) {
	                SPACE.activeIndex = index;
	            } else {
	                //当滑动到顶时或底部时,最多可偏移一个节点的距离
	                if (index < 0) {
	                    SPACE.activeIndex = 0;
	                    if (index < -1) {
	                        return;
	                    }
	                } else {
	                    SPACE.activeIndex = SPACE.dataCount - 1;
	                    if (index > SPACE.dataCount) {
	                        return;
	                    }
	                }
	            }

	            ulObj.style.transform = newTransform;
	            SPACE.touchStartData.pageY = pageY;

	            //根据当前位置index设置节点的显示隐藏
	            this._resetItemVisible(index);
	        }

	        /***
	         * 根据当前位置index设置节点的显示隐藏
	         * @param index
	         * @private
	         */

	    }, {
	        key: '_resetItemVisible',
	        value: function _resetItemVisible(index) {
	            var liList = this.querySelectorAll('li');
	            var liLen = liList.length;
	            for (var i = 0; i < liLen; i++) {
	                if (i > index - 5 && i < index + 5) {
	                    liList[i].classList.add('bh-visible');
	                } else {
	                    liList[i].classList.remove('bh-visible');
	                }
	            }
	        }

	        /***
	         * 触摸结束
	         * 对当前选中节点设置高亮
	         * 当节点不在正中间,移动节点居中
	         * trigger一个change事件,把key和value值返回
	         * @param event
	         * @private
	         */

	    }, {
	        key: '_touchEndHandle',
	        value: function _touchEndHandle(event) {
	            SPACE.touchStartData = {};
	            this._resetItemActive('show');
	            var ulObj = this.querySelector('ul');
	            ulObj.style.transform = this._getUlTransform(SPACE.activeIndex * SPACE.rotateXstep);

	            var selectData = this.getValue();
	            /**
	             * 数据切换时触发的事件
	             * @event BhSelectRollElement#BhSelectRollElement change
	             */
	            util.triggerElementEvent(this, 'change', selectData);
	            //触摸结束后,同步设置selected值,设置selfToSetSelected为true避免多次触发事件
	            SPACE.selfToSetSelected = true;
	            this.setAttribute('selected', JSON.stringify(selectData));
	        }

	        /***
	         * 当动态设置selected属性时的处理
	         * 可传入json字符串或则key值
	         * 根据传入的值设置高亮节点,并触发change事件
	         * @param newValue
	         * @private
	         */

	    }, {
	        key: '_resetSelectItem',
	        value: function _resetSelectItem(newValue) {
	            //selfToSetSelected为true表示是组件自己动态设置的,不对selected做同步处理
	            if (SPACE.selfToSetSelected) {
	                //将selfToSetSelected置为false
	                SPACE.selfToSetSelected = false;
	                return;
	            }
	            var toSelectKey = null;
	            try {
	                toSelectKey = JSON.parse(this._formateJsonStr(newValue)).key;
	            } catch (e) {
	                toSelectKey = newValue;
	            }

	            var selectItem = this.querySelector('li[key=\'' + toSelectKey + '\']');
	            if (selectItem) {
	                this._resetItemActive('hide');
	                SPACE.activeIndex = util.getElementIndex(selectItem);
	                this._resetItemVisible(SPACE.activeIndex);
	                this._touchEndHandle();
	            }
	        }

	        /***
	         * 设置节点高亮class
	         * @param type show对当前节点设置高亮,hide移除当前节点的高亮
	         * @private
	         */

	    }, {
	        key: '_resetItemActive',
	        value: function _resetItemActive(type) {
	            var ulObj = this.querySelector('ul');
	            var liList = ulObj.querySelectorAll('li');
	            if (type === 'hide') {
	                liList[SPACE.activeIndex].classList.remove('bh-active');
	            } else {
	                liList[SPACE.activeIndex].classList.add('bh-active');
	            }
	        }

	        /***
	         * ul的transform值
	         * @param rotateX
	         * @returns {string}
	         * @private
	         */

	    }, {
	        key: '_getUlTransform',
	        value: function _getUlTransform(rotateX) {
	            return 'perspective(500rem) rotateY(0deg) rotateX(' + rotateX + 'deg)';
	        }

	        //组件加载完毕的回调,相当于该组件的入口方法

	    }, {
	        key: 'createdCallback',
	        value: function createdCallback() {
	            var _this2 = this;

	            contentReady(this, function () {
	                return _this2._compile();
	            });
	        }

	        //属性变更的回调，vue集成时，会被多次触发

	    }, {
	        key: 'attributeChangedCallback',
	        value: function attributeChangedCallback(propName, oldValue, newValue) {
	            switch (propName) {
	                //该组件的数据,必须是json字符串
	                //修改data数据的处理
	                case 'data':
	                    if (!newValue) {
	                        return;
	                    }
	                    //渲染数据
	                    this._renderItems(newValue);
	                    break;
	                //设置选中节点的处理
	                case 'selected':
	                    this._resetSelectItem(newValue);
	                    break;
	                default:
	                    break;
	            }
	        }

	        /***
	         * 渲染节点列表
	         * @param items 节点数据,是json字符串
	         * @param type init是初始化时以字符串返回,否则直接添加到HTML中
	         * @returns {string}
	         * @private
	         */

	    }, {
	        key: '_renderItems',
	        value: function _renderItems(items, type) {
	            var listHtml = '';
	            if (items) {
	                try {
	                    items = JSON.parse(items);
	                } catch (e) {
	                    //当数据是静态的直接写在HTML标签上的处理,将其转换成json可解析的格式
	                    items = JSON.parse(this._formateJsonStr(items));
	                }
	                var selectDatas = items;
	                var selectDataLen = selectDatas.length;

	                SPACE.dataCount = selectDataLen;

	                var itemStyle = 'transform-origin: center center -7rem; transform: translateZ(7rem) rotateX(@rotateXNumdeg);';
	                for (var i = 0; i < selectDataLen; i++) {
	                    var itemClass = '';
	                    //前4条数据让其为显示状态
	                    if (i < 4) {
	                        if (i !== 0) {
	                            itemClass = 'bh-visible';
	                        } else {
	                            itemClass = 'bh-active bh-visible';
	                        }
	                    }
	                    var selectItem = selectDatas[i];
	                    var selectKey = selectItem.key ? selectItem.key : selectItem.KEY;
	                    var selectValue = selectItem.value ? selectItem.value : selectItem.VALUE;

	                    listHtml += '<li class="' + itemClass + '" value="' + selectValue + '" key="' + selectKey + '" style="' + itemStyle.replace('@rotateXNum', -(i * SPACE.rotateXstep)) + '">' + selectValue + '</li>';
	                }
	            }

	            if (type === 'init') {
	                return listHtml;
	            } else {
	                this.querySelector('.bh-select-roll-list').innerHTML = listHtml;
	            }
	        }
	    }, {
	        key: '_formateJsonStr',
	        value: function _formateJsonStr(jsonStr) {
	            return jsonStr.replace(/{ *' *key *'/ig, '{"key"').replace(/{ *' *value *'/ig, '{"value"').replace(/' *key *' *:/ig, '"key":').replace(/' *value *' *:/ig, '"value":').replace(/{ *key *:/ig, '{"key":').replace(/{ *value *:/ig, '{"value":').replace(/, *key *:/ig, ',"key":').replace(/, *value *:/ig, ',"value":').replace(/: *' */g, ':"').replace(/ *' *}/g, '"}').replace(/' *,/g, '",');
	        }

	        //初始化方法

	    }, {
	        key: '_compile',
	        value: function _compile() {
	            //当这个组件已经初始化过,则不再进行初始化处理
	            if (this.querySelector('.' + SPACE.rootClassName + '-body')) {
	                this.removeEventListener('touchstart', this._touchStartHandle, false);
	                this.addEventListener('touchstart', this._touchStartHandle, false);

	                this.removeEventListener('touchmove', this._touchMoveHandle, false);
	                this.addEventListener('touchmove', this._touchMoveHandle, false);

	                this.removeEventListener('touchend', this._touchEndHandle, false);
	                this.addEventListener('touchend', this._touchEndHandle, false);
	                return;
	            }

	            //当该组件是嵌在底部弹框组件里,则设置底部弹框的高度
	            var modalBottomContentObj = util.findParent(this, '.bh-modal-bottom-content');
	            if (modalBottomContentObj) {
	                modalBottomContentObj.style.height = '17rem';
	            }

	            var mobileOs = platform.getMobileOS();
	            var ultransformOrigin = '';
	            //当该组件是在iOS中,则给其加入动画定位点,以确保动画的正确
	            if (mobileOs === 'ios') {
	                ultransformOrigin = 'transform-origin: center center 7rem;';
	            }

	            var data = this.getAttribute('data');
	            var listHtml = this._renderItems(data, 'init');

	            //拼接内容串
	            var contentHtml = '\n            <div class="' + SPACE.rootClassName + '-body">\n                <div class="' + SPACE.rootClassName + '-box"></div>\n                <ul class="bh-select-roll-list" style="' + ultransformOrigin + ' transform: ' + this._getUlTransform(0) + '">\n                    ' + listHtml + '\n                </ul>\n            </div>\n        ';

	            this.innerHTML = contentHtml;

	            //初始化时若设置了默认选择项,则使其选中
	            var selected = this.getAttribute('selected');
	            if (selected) {
	                this._resetSelectItem(selected);
	            }

	            //监听该组件的事件
	            this.addEventListener('touchstart', this._touchStartHandle, false);
	            this.addEventListener('touchmove', this._touchMoveHandle, false);
	            this.addEventListener('touchend', this._touchEndHandle, false);
	        }
	    }]);
	    return BhSelectRollElement;
	}(BaseElement);

	//注册该标签(用于浏览器不支持自定义标签的处理)


	window.BhSelectRollElement = document.registerElement('bh-select-roll', {
	    prototype: BhSelectRollElement.prototype
	});

	// fastclick
	window.addEventListener('load', function () {
		ons.fastClick = FastClick.attach(document.body);
	}, false);

	// ons._defaultDeviceBackButtonHandler
	window.addEventListener('DOMContentLoaded', function () {
		ons._deviceBackButtonDispatcher.enable();
		ons._defaultDeviceBackButtonHandler = ons._deviceBackButtonDispatcher.createHandler(window.document.body, function () {
			navigator.app.exitApp();
		});
		document.body._gestureDetector = new ons.GestureDetector(document.body);
	}, false);

	// setup loading placeholder
	ons.ready(function () {
		ons._setupLoadingPlaceHolders();
	});

	// viewport.js
	new Viewport().setup();

	return ons;

}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkN1c3RvbUVsZW1lbnRzLmpzIiwiQ3VzdG9tRXZlbnQuanMiLCJNdXRhdGlvbk9ic2VydmVyLmpzIiwiYW5pbWl0LmpzIiwiY2hpbGROb2RlUmVtb3ZlLmpzIiwiY2xhc3NMaXN0LmpzIiwiZmFzdGNsaWNrLXBhdGNoZWQuanMiLCJtaWNyb2V2ZW50LmpzIiwicHJvbWlzZS03LjAuNC5taW4uanMiLCJzZXRJbW1lZGlhdGUuanMiLCJ2aWV3cG9ydC5qcyIsIndpbnN0b3JlLWpzY29tcGF0LmpzIiwib25zL2FuaW1hdGlvbi1vcHRpb25zLXBhcnNlci5qcyIsIm9ucy91dGlsLmpzIiwib25zL2dlc3R1cmUtZGV0ZWN0b3IuanMiLCJvbnMvcGxhdGZvcm0uanMiLCJvbnMvbm90aWZpY2F0aW9uLmpzIiwib25zL3BhZ2UtYXR0cmlidXRlLWV4cHJlc3Npb24uanMiLCJvbnMvaW50ZXJuYWwvaW50ZXJuYWwuanMiLCJvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeS5qcyIsIm9ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsLmpzIiwib25zL2ludGVybmFsL2xhenktcmVwZWF0LmpzIiwib25zL2ludGVybmFsL2luZGV4LmpzIiwib25zL29yaWVudGF0aW9uLmpzIiwib25zL3NvZnR3YXJlLWtleWJvYXJkLmpzIiwib25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyLmpzIiwib25zL2F1dG9zdHlsZS5qcyIsIm9ucy9kb29ybG9jay5qcyIsIm9ucy9jb250ZW50LXJlYWR5LmpzIiwib25zL29ucy5qcyIsIm9ucy9iYXNlLWVsZW1lbnQuanMiLCJlbGVtZW50cy9vbnMtdGVtcGxhdGUuanMiLCJlbGVtZW50cy9vbnMtaWYuanMiLCJlbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1iYWNrLWJ1dHRvbi5qcyIsImVsZW1lbnRzL29ucy1ib3R0b20tdG9vbGJhci5qcyIsImVsZW1lbnRzL29ucy1idXR0b24uanMiLCJlbGVtZW50cy9vbnMtY2Fyb3VzZWwtaXRlbS5qcyIsImVsZW1lbnRzL29ucy1jYXJvdXNlbC5qcyIsImVsZW1lbnRzL29ucy1jb2wuanMiLCJlbGVtZW50cy9vbnMtZGlhbG9nL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLWRpYWxvZy9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1mYWIuanMiLCJlbGVtZW50cy9vbnMtZ2VzdHVyZS1kZXRlY3Rvci5qcyIsImVsZW1lbnRzL29ucy1pY29uLmpzIiwiZWxlbWVudHMvb25zLWxhenktcmVwZWF0LmpzIiwiZWxlbWVudHMvb25zLWxpc3QtaGVhZGVyLmpzIiwiZWxlbWVudHMvb25zLWxpc3QtaXRlbS5qcyIsImVsZW1lbnRzL29ucy1saXN0LmpzIiwiZWxlbWVudHMvb25zLWlucHV0LmpzIiwiZWxlbWVudHMvb25zLW1vZGFsL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW1vZGFsL2ZhZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbW9kYWwvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3Mtc2xpZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1saWZ0LWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3MtZmFkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtc2xpZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL21kLWxpZnQtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL21kLWZhZGUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL25vbmUtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXBhZ2UuanMiLCJlbGVtZW50cy9vbnMtcG9wb3Zlci9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1wb3BvdmVyL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXByb2dyZXNzLWJhci5qcyIsImVsZW1lbnRzL29ucy1wcm9ncmVzcy1jaXJjdWxhci5qcyIsImVsZW1lbnRzL29ucy1wdWxsLWhvb2suanMiLCJlbGVtZW50cy9vbnMtcmlwcGxlL2FuaW1hdG9yLWNzcy5qcyIsImVsZW1lbnRzL29ucy1yaXBwbGUvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtcm93LmpzIiwiZWxlbWVudHMvb25zLXNwZWVkLWRpYWwtaXRlbS5qcyIsImxpYi9zdHlsZXIuanMiLCJlbGVtZW50cy9vbnMtc3BlZWQtZGlhbC5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci1jb250ZW50LmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyLW1hc2suanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXIvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXIvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXItc2lkZS5qcyIsImVsZW1lbnRzL29ucy1zd2l0Y2guanMiLCJlbGVtZW50cy9vbnMtdGFiYmFyL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLXRhYmJhci9pbmRleC5qcyIsImVsZW1lbnRzL29ucy10YWIuanMiLCJlbGVtZW50cy9vbnMtdG9vbGJhci1idXR0b24uanMiLCJlbGVtZW50cy9vbnMtdG9vbGJhci5qcyIsImVsZW1lbnRzL29ucy1yYW5nZS5qcyIsImVsZW1lbnRzL2JoL2JoLXN0ZXAvaW5kZXguanMiLCJlbGVtZW50cy9iaC9iaC1pbnB1dC9pbmRleC5qcyIsImVsZW1lbnRzL2JoL2JoLXNlYXJjaC9pbmRleC5qcyIsImVsZW1lbnRzL2JoL2JoLXNlYXJjaC1iYXIvaW5kZXguanMiLCJlbGVtZW50cy9iaC9iaC1pbnB1dC1zZWxlY3QvaW5kZXguanMiLCJlbGVtZW50cy9iaC9iaC1jYXJvdXNlbC1idG5zL2luZGV4LmpzIiwiZWxlbWVudHMvYmgvYmgtbW9kYWwtYm90dG9tL2luZGV4LmpzIiwiZWxlbWVudHMvYmgvYmgtbW9kYWwtYm90dG9tLWNvbW1hbmQuanMiLCJlbGVtZW50cy9iaC9iaC1zZWxlY3Qtcm9sbC9pbmRleC5qcyIsInNldHVwLmpzIl0sIm5hbWVzIjpbImFuaW1hdGlvbk9wdGlvbnNQYXJzZSIsIkV2ZW50IiwidXRpbCIsIm9uc1BsYXRmb3JtIiwiUGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24iLCJhbmltYXRpb25PcHRpb25zUGFyc2VyIiwic2NoZW1lIiwiX2FuaW1hdG9yRGljdCIsInRlbXBsYXRlIiwiQW5pbWF0b3IiLCJyZXdyaXRhYmxlcyIsIk9uc1NwbGl0dGVyRWxlbWVudCIsImdlbmVyYXRlSWQiLCJ0ZW1wbGF0ZVNvdXJjZSIsIklOUFVUX0FUVFJJQlVURVMiLCJzcGFjZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzU3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xFQTtBQUNBO0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFKO0FBQ0EsQ0FBQSxDQUZEOzs7QUFLQSxDQUFBLElBQUksUUFBSixHQUFlLEtBQWYiLCJmaWxlIjoiYmguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8vIEB2ZXJzaW9uIDAuNy4zXG5pZiAodHlwZW9mIFdlYWtNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICB2YXIgY291bnRlciA9IERhdGUubm93KCkgJSAxZTk7XG4gICAgdmFyIFdlYWtNYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiX19zdFwiICsgKE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApICsgKGNvdW50ZXIrKyArIFwiX19cIik7XG4gICAgfTtcbiAgICBXZWFrTWFwLnByb3RvdHlwZSA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkpIGVudHJ5WzFdID0gdmFsdWU7IGVsc2UgZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgcmV0dXJuIChlbnRyeSA9IGtleVt0aGlzLm5hbWVdKSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZW50cnlbMF0gPSBlbnRyeVsxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICghZW50cnkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5WzBdID09PSBrZXk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuV2Vha01hcCA9IFdlYWtNYXA7XG4gIH0pKCk7XG59XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbnNUYWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBzZXRJbW1lZGlhdGU7XG4gIGlmICgvVHJpZGVudHxFZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dDtcbiAgfSBlbHNlIGlmICh3aW5kb3cuc2V0SW1tZWRpYXRlKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gd2luZG93LnNldEltbWVkaWF0ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2V0SW1tZWRpYXRlUXVldWUgPSBbXTtcbiAgICB2YXIgc2VudGluZWwgPSBTdHJpbmcoTWF0aC5yYW5kb20oKSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmRhdGEgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHNldEltbWVkaWF0ZVF1ZXVlO1xuICAgICAgICBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICBmdW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHNldEltbWVkaWF0ZVF1ZXVlLnB1c2goZnVuYyk7XG4gICAgICB3aW5kb3cucG9zdE1lc3NhZ2Uoc2VudGluZWwsIFwiKlwiKTtcbiAgICB9O1xuICB9XG4gIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2sob2JzZXJ2ZXIpIHtcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0SW1tZWRpYXRlKGRpc3BhdGNoQ2FsbGJhY2tzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gd3JhcElmTmVlZGVkKG5vZGUpIHtcbiAgICByZXR1cm4gd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQobm9kZSkgfHwgbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaENhbGxiYWNrcygpIHtcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBvYnNlcnZlcnMgPSBzY2hlZHVsZWRPYnNlcnZlcnM7XG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gICAgb2JzZXJ2ZXJzLnNvcnQoZnVuY3Rpb24obzEsIG8yKSB7XG4gICAgICByZXR1cm4gbzEudWlkXyAtIG8yLnVpZF87XG4gICAgfSk7XG4gICAgdmFyIGFueU5vbkVtcHR5ID0gZmFsc2U7XG4gICAgb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBxdWV1ZSA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpO1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFja18ocXVldWUsIG9ic2VydmVyKTtcbiAgICAgICAgYW55Tm9uRW1wdHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChhbnlOb25FbXB0eSkgZGlzcGF0Y2hDYWxsYmFja3MoKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJldHVybjtcbiAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gb2JzZXJ2ZXIpIHJlZ2lzdHJhdGlvbi5yZW1vdmVUcmFuc2llbnRPYnNlcnZlcnMoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgbm9kZSA9IHRhcmdldDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbal07XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSByZWdpc3RyYXRpb24ub3B0aW9ucztcbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0ICYmICFvcHRpb25zLnN1YnRyZWUpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciByZWNvcmQgPSBjYWxsYmFjayhvcHRpb25zKTtcbiAgICAgICAgICBpZiAocmVjb3JkKSByZWdpc3RyYXRpb24uZW5xdWV1ZShyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciB1aWRDb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gSnNNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICB0aGlzLm5vZGVzXyA9IFtdO1xuICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB0aGlzLnVpZF8gPSArK3VpZENvdW50ZXI7XG4gIH1cbiAgSnNNdXRhdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgICBvYnNlcnZlOiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRhcmdldCA9IHdyYXBJZk5lZWRlZCh0YXJnZXQpO1xuICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEgfHwgb3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQodGFyZ2V0KTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldCh0YXJnZXQsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tpXTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbikge1xuICAgICAgICByZWdpc3RyYXRpb24gPSBuZXcgUmVnaXN0cmF0aW9uKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaChyZWdpc3RyYXRpb24pO1xuICAgICAgICB0aGlzLm5vZGVzXy5wdXNoKHRhcmdldCk7XG4gICAgICB9XG4gICAgICByZWdpc3RyYXRpb24uYWRkTGlzdGVuZXJzKCk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb24ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB9LFxuICAgIHRha2VSZWNvcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3B5T2ZSZWNvcmRzID0gdGhpcy5yZWNvcmRzXztcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICAgIHJldHVybiBjb3B5T2ZSZWNvcmRzO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcbiAgICB0aGlzLnJlbW92ZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gbnVsbDtcbiAgICB0aGlzLm9sZFZhbHVlID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjb3B5TXV0YXRpb25SZWNvcmQob3JpZ2luYWwpIHtcbiAgICB2YXIgcmVjb3JkID0gbmV3IE11dGF0aW9uUmVjb3JkKG9yaWdpbmFsLnR5cGUsIG9yaWdpbmFsLnRhcmdldCk7XG4gICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBvcmlnaW5hbC5hZGRlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IG9yaWdpbmFsLnJlbW92ZWROb2Rlcy5zbGljZSgpO1xuICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBvcmlnaW5hbC5wcmV2aW91c1NpYmxpbmc7XG4gICAgcmVjb3JkLm5leHRTaWJsaW5nID0gb3JpZ2luYWwubmV4dFNpYmxpbmc7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgcmVjb3JkLm9sZFZhbHVlID0gb3JpZ2luYWwub2xkVmFsdWU7XG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfVxuICB2YXIgY3VycmVudFJlY29yZCwgcmVjb3JkV2l0aE9sZFZhbHVlO1xuICBmdW5jdGlvbiBnZXRSZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRSZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpIHtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZSA9IGNvcHlNdXRhdGlvblJlY29yZChjdXJyZW50UmVjb3JkKTtcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUmVjb3JkcygpIHtcbiAgICBjdXJyZW50UmVjb3JkID0gcmVjb3JkV2l0aE9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24ocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZCA9PT0gcmVjb3JkV2l0aE9sZFZhbHVlIHx8IHJlY29yZCA9PT0gY3VycmVudFJlY29yZDtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgbmV3UmVjb3JkKSB7XG4gICAgaWYgKGxhc3RSZWNvcmQgPT09IG5ld1JlY29yZCkgcmV0dXJuIGxhc3RSZWNvcmQ7XG4gICAgaWYgKHJlY29yZFdpdGhPbGRWYWx1ZSAmJiByZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uKGxhc3RSZWNvcmQpKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIFJlZ2lzdHJhdGlvbihvYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gIH1cbiAgUmVnaXN0cmF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBlbnF1ZXVlOiBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgIHZhciByZWNvcmRzID0gdGhpcy5vYnNlcnZlci5yZWNvcmRzXztcbiAgICAgIHZhciBsZW5ndGggPSByZWNvcmRzLmxlbmd0aDtcbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxhc3RSZWNvcmQgPSByZWNvcmRzW2xlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVjb3JkVG9SZXBsYWNlTGFzdCA9IHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCByZWNvcmQpO1xuICAgICAgICBpZiAocmVjb3JkVG9SZXBsYWNlTGFzdCkge1xuICAgICAgICAgIHJlY29yZHNbbGVuZ3RoIC0gMV0gPSByZWNvcmRUb1JlcGxhY2VMYXN0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayh0aGlzLm9ic2VydmVyKTtcbiAgICAgIH1cbiAgICAgIHJlY29yZHNbbGVuZ3RoXSA9IHJlY29yZDtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01BdHRyTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVSZW1vdmVkXCIsIHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBhZGRUcmFuc2llbnRPYnNlcnZlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0KSByZXR1cm47XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18obm9kZSk7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldChub2RlLCByZWdpc3RyYXRpb25zID0gW10pO1xuICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHRoaXMpO1xuICAgIH0sXG4gICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzO1xuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gICAgICB0cmFuc2llbnRPYnNlcnZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18obm9kZSk7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICBjYXNlIFwiRE9NQXR0ck1vZGlmaWVkXCI6XG4gICAgICAgIHZhciBuYW1lID0gZS5hdHRyTmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGUucmVsYXRlZE5vZGUubmFtZXNwYWNlVVJJO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciByZWNvcmQgPSBuZXcgZ2V0UmVjb3JkKFwiYXR0cmlidXRlc1wiLCB0YXJnZXQpO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG5hbWU7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGUuYXR0ckNoYW5nZSA9PT0gTXV0YXRpb25FdmVudC5BRERJVElPTiA/IG51bGwgOiBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWUpID09PSAtMSAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWVzcGFjZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCI6XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoYXJhY3RlckRhdGFcIiwgdGFyZ2V0KTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5wcmV2VmFsdWU7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVSZW1vdmVkXCI6XG4gICAgICAgIHRoaXMuYWRkVHJhbnNpZW50T2JzZXJ2ZXIoZS50YXJnZXQpO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVJbnNlcnRlZFwiOlxuICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGFkZGVkTm9kZXMsIHJlbW92ZWROb2RlcztcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJET01Ob2RlSW5zZXJ0ZWRcIikge1xuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFtdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gY2hhbmdlZE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjaGFuZ2VkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoaWxkTGlzdFwiLCBlLnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBhZGRlZE5vZGVzO1xuICAgICAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzO1xuICAgICAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKGUucmVsYXRlZE5vZGUsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0KSByZXR1cm47XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjbGVhclJlY29yZHMoKTtcbiAgICB9XG4gIH07XG4gIGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmICghZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIpIGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyID0gSnNNdXRhdGlvbk9ic2VydmVyO1xufSkodGhpcyk7XG5cbndpbmRvdy5DdXN0b21FbGVtZW50cyA9IHdpbmRvdy5DdXN0b21FbGVtZW50cyB8fCB7XG4gIGZsYWdzOiB7fVxufTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHZhciBmbGFncyA9IHNjb3BlLmZsYWdzO1xuICB2YXIgbW9kdWxlcyA9IFtdO1xuICB2YXIgYWRkTW9kdWxlID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgbW9kdWxlcy5wdXNoKG1vZHVsZSk7XG4gIH07XG4gIHZhciBpbml0aWFsaXplTW9kdWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgIG1vZHVsZShzY29wZSk7XG4gICAgfSk7XG4gIH07XG4gIHNjb3BlLmFkZE1vZHVsZSA9IGFkZE1vZHVsZTtcbiAgc2NvcGUuaW5pdGlhbGl6ZU1vZHVsZXMgPSBpbml0aWFsaXplTW9kdWxlcztcbiAgc2NvcGUuaGFzTmF0aXZlID0gQm9vbGVhbihkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQpO1xuICBzY29wZS51c2VOYXRpdmUgPSAhZmxhZ3MucmVnaXN0ZXIgJiYgc2NvcGUuaGFzTmF0aXZlICYmICF3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgKCF3aW5kb3cuSFRNTEltcG9ydHMgfHwgSFRNTEltcG9ydHMudXNlTmF0aXZlKTtcbn0pKHdpbmRvdy5DdXN0b21FbGVtZW50cyk7XG5cbndpbmRvdy5DdXN0b21FbGVtZW50cy5hZGRNb2R1bGUoZnVuY3Rpb24oc2NvcGUpIHtcbiAgdmFyIElNUE9SVF9MSU5LX1RZUEUgPSB3aW5kb3cuSFRNTEltcG9ydHMgPyBIVE1MSW1wb3J0cy5JTVBPUlRfTElOS19UWVBFIDogXCJub25lXCI7XG4gIGZ1bmN0aW9uIGZvclN1YnRyZWUobm9kZSwgY2IpIHtcbiAgICBmaW5kQWxsRWxlbWVudHMobm9kZSwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGNiKGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yUm9vdHMoZSwgY2IpO1xuICAgIH0pO1xuICAgIGZvclJvb3RzKG5vZGUsIGNiKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kQWxsRWxlbWVudHMobm9kZSwgZmluZCwgZGF0YSkge1xuICAgIHZhciBlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICBpZiAoIWUpIHtcbiAgICAgIGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZSAmJiBlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBlID0gZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGUpIHtcbiAgICAgIGlmIChmaW5kKGUsIGRhdGEpICE9PSB0cnVlKSB7XG4gICAgICAgIGZpbmRBbGxFbGVtZW50cyhlLCBmaW5kLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGUgPSBlLm5leHRFbGVtZW50U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZm9yUm9vdHMobm9kZSwgY2IpIHtcbiAgICB2YXIgcm9vdCA9IG5vZGUuc2hhZG93Um9vdDtcbiAgICB3aGlsZSAocm9vdCkge1xuICAgICAgZm9yU3VidHJlZShyb290LCBjYik7XG4gICAgICByb290ID0gcm9vdC5vbGRlclNoYWRvd1Jvb3Q7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZvckRvY3VtZW50VHJlZShkb2MsIGNiKSB7XG4gICAgX2ZvckRvY3VtZW50VHJlZShkb2MsIGNiLCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gX2ZvckRvY3VtZW50VHJlZShkb2MsIGNiLCBwcm9jZXNzaW5nRG9jdW1lbnRzKSB7XG4gICAgZG9jID0gd3JhcChkb2MpO1xuICAgIGlmIChwcm9jZXNzaW5nRG9jdW1lbnRzLmluZGV4T2YoZG9jKSA+PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb2Nlc3NpbmdEb2N1bWVudHMucHVzaChkb2MpO1xuICAgIHZhciBpbXBvcnRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3JlbD1cIiArIElNUE9SVF9MSU5LX1RZUEUgKyBcIl1cIik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbXBvcnRzLmxlbmd0aCwgbjsgaSA8IGwgJiYgKG4gPSBpbXBvcnRzW2ldKTsgaSsrKSB7XG4gICAgICBpZiAobi5pbXBvcnQpIHtcbiAgICAgICAgX2ZvckRvY3VtZW50VHJlZShuLmltcG9ydCwgY2IsIHByb2Nlc3NpbmdEb2N1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYihkb2MpO1xuICB9XG4gIHNjb3BlLmZvckRvY3VtZW50VHJlZSA9IGZvckRvY3VtZW50VHJlZTtcbiAgc2NvcGUuZm9yU3VidHJlZSA9IGZvclN1YnRyZWU7XG59KTtcblxud2luZG93LkN1c3RvbUVsZW1lbnRzLmFkZE1vZHVsZShmdW5jdGlvbihzY29wZSkge1xuICB2YXIgZmxhZ3MgPSBzY29wZS5mbGFncztcbiAgdmFyIGZvclN1YnRyZWUgPSBzY29wZS5mb3JTdWJ0cmVlO1xuICB2YXIgZm9yRG9jdW1lbnRUcmVlID0gc2NvcGUuZm9yRG9jdW1lbnRUcmVlO1xuICBmdW5jdGlvbiBhZGRlZE5vZGUobm9kZSkge1xuICAgIHJldHVybiBhZGRlZChub2RlKSB8fCBhZGRlZFN1YnRyZWUobm9kZSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkZWQobm9kZSkge1xuICAgIGlmIChzY29wZS51cGdyYWRlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXR0YWNoZWQobm9kZSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkZWRTdWJ0cmVlKG5vZGUpIHtcbiAgICBmb3JTdWJ0cmVlKG5vZGUsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChhZGRlZChlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhdHRhY2hlZE5vZGUobm9kZSkge1xuICAgIGF0dGFjaGVkKG5vZGUpO1xuICAgIGlmIChpbkRvY3VtZW50KG5vZGUpKSB7XG4gICAgICBmb3JTdWJ0cmVlKG5vZGUsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgYXR0YWNoZWQoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdmFyIGhhc1BvbHlmaWxsTXV0YXRpb25zID0gIXdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyID09PSB3aW5kb3cuSnNNdXRhdGlvbk9ic2VydmVyO1xuICBzY29wZS5oYXNQb2x5ZmlsbE11dGF0aW9ucyA9IGhhc1BvbHlmaWxsTXV0YXRpb25zO1xuICB2YXIgaXNQZW5kaW5nTXV0YXRpb25zID0gZmFsc2U7XG4gIHZhciBwZW5kaW5nTXV0YXRpb25zID0gW107XG4gIGZ1bmN0aW9uIGRlZmVyTXV0YXRpb24oZm4pIHtcbiAgICBwZW5kaW5nTXV0YXRpb25zLnB1c2goZm4pO1xuICAgIGlmICghaXNQZW5kaW5nTXV0YXRpb25zKSB7XG4gICAgICBpc1BlbmRpbmdNdXRhdGlvbnMgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCh0YWtlTXV0YXRpb25zKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdGFrZU11dGF0aW9ucygpIHtcbiAgICBpc1BlbmRpbmdNdXRhdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgJHAgPSBwZW5kaW5nTXV0YXRpb25zO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gJHAubGVuZ3RoLCBwOyBpIDwgbCAmJiAocCA9ICRwW2ldKTsgaSsrKSB7XG4gICAgICBwKCk7XG4gICAgfVxuICAgIHBlbmRpbmdNdXRhdGlvbnMgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiBhdHRhY2hlZChlbGVtZW50KSB7XG4gICAgaWYgKGhhc1BvbHlmaWxsTXV0YXRpb25zKSB7XG4gICAgICBkZWZlck11dGF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICBfYXR0YWNoZWQoZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2F0dGFjaGVkKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfYXR0YWNoZWQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Ll9fdXBncmFkZWRfXyAmJiAoZWxlbWVudC5hdHRhY2hlZENhbGxiYWNrIHx8IGVsZW1lbnQuZGV0YWNoZWRDYWxsYmFjaykpIHtcbiAgICAgIGlmICghZWxlbWVudC5fX2F0dGFjaGVkICYmIGluRG9jdW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudC5fX2F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVsZW1lbnQuYXR0YWNoZWRDYWxsYmFjaykge1xuICAgICAgICAgIGVsZW1lbnQuYXR0YWNoZWRDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRldGFjaGVkTm9kZShub2RlKSB7XG4gICAgZGV0YWNoZWQobm9kZSk7XG4gICAgZm9yU3VidHJlZShub2RlLCBmdW5jdGlvbihlKSB7XG4gICAgICBkZXRhY2hlZChlKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZXRhY2hlZChlbGVtZW50KSB7XG4gICAgaWYgKGhhc1BvbHlmaWxsTXV0YXRpb25zKSB7XG4gICAgICBkZWZlck11dGF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICBfZGV0YWNoZWQoZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2RldGFjaGVkKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfZGV0YWNoZWQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Ll9fdXBncmFkZWRfXyAmJiAoZWxlbWVudC5hdHRhY2hlZENhbGxiYWNrIHx8IGVsZW1lbnQuZGV0YWNoZWRDYWxsYmFjaykpIHtcbiAgICAgIGlmIChlbGVtZW50Ll9fYXR0YWNoZWQgJiYgIWluRG9jdW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudC5fX2F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChlbGVtZW50LmRldGFjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICBlbGVtZW50LmRldGFjaGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbkRvY3VtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgcCA9IGVsZW1lbnQ7XG4gICAgdmFyIGRvYyA9IHdyYXAoZG9jdW1lbnQpO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBpZiAocCA9PSBkb2MpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwID0gcC5wYXJlbnROb2RlIHx8IHAubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJiBwLmhvc3Q7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHdhdGNoU2hhZG93KG5vZGUpIHtcbiAgICBpZiAobm9kZS5zaGFkb3dSb290ICYmICFub2RlLnNoYWRvd1Jvb3QuX193YXRjaGVkKSB7XG4gICAgICBmbGFncy5kb20gJiYgY29uc29sZS5sb2coXCJ3YXRjaGluZyBzaGFkb3ctcm9vdCBmb3I6IFwiLCBub2RlLmxvY2FsTmFtZSk7XG4gICAgICB2YXIgcm9vdCA9IG5vZGUuc2hhZG93Um9vdDtcbiAgICAgIHdoaWxlIChyb290KSB7XG4gICAgICAgIG9ic2VydmUocm9vdCk7XG4gICAgICAgIHJvb3QgPSByb290Lm9sZGVyU2hhZG93Um9vdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlcihtdXRhdGlvbnMpIHtcbiAgICBpZiAoZmxhZ3MuZG9tKSB7XG4gICAgICB2YXIgbXggPSBtdXRhdGlvbnNbMF07XG4gICAgICBpZiAobXggJiYgbXgudHlwZSA9PT0gXCJjaGlsZExpc3RcIiAmJiBteC5hZGRlZE5vZGVzKSB7XG4gICAgICAgIGlmIChteC5hZGRlZE5vZGVzKSB7XG4gICAgICAgICAgdmFyIGQgPSBteC5hZGRlZE5vZGVzWzBdO1xuICAgICAgICAgIHdoaWxlIChkICYmIGQgIT09IGRvY3VtZW50ICYmICFkLmhvc3QpIHtcbiAgICAgICAgICAgIGQgPSBkLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB1ID0gZCAmJiAoZC5VUkwgfHwgZC5fVVJMIHx8IGQuaG9zdCAmJiBkLmhvc3QubG9jYWxOYW1lKSB8fCBcIlwiO1xuICAgICAgICAgIHUgPSB1LnNwbGl0KFwiLz9cIikuc2hpZnQoKS5zcGxpdChcIi9cIikucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnNvbGUuZ3JvdXAoXCJtdXRhdGlvbnMgKCVkKSBbJXNdXCIsIG11dGF0aW9ucy5sZW5ndGgsIHUgfHwgXCJcIik7XG4gICAgfVxuICAgIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG14KSB7XG4gICAgICBpZiAobXgudHlwZSA9PT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICBmb3JFYWNoKG14LmFkZGVkTm9kZXMsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICBpZiAoIW4ubG9jYWxOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkTm9kZShuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvckVhY2gobXgucmVtb3ZlZE5vZGVzLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgaWYgKCFuLmxvY2FsTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXRhY2hlZE5vZGUobik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZsYWdzLmRvbSAmJiBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbiAgZnVuY3Rpb24gdGFrZVJlY29yZHMobm9kZSkge1xuICAgIG5vZGUgPSB3cmFwKG5vZGUpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgbm9kZSA9IHdyYXAoZG9jdW1lbnQpO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB2YXIgb2JzZXJ2ZXIgPSBub2RlLl9fb2JzZXJ2ZXI7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBoYW5kbGVyKG9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgdGFrZU11dGF0aW9ucygpO1xuICAgIH1cbiAgfVxuICB2YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUuZm9yRWFjaCk7XG4gIGZ1bmN0aW9uIG9ic2VydmUoaW5Sb290KSB7XG4gICAgaWYgKGluUm9vdC5fX29ic2VydmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGhhbmRsZXIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoaW5Sb290LCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSk7XG4gICAgaW5Sb290Ll9fb2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgfVxuICBmdW5jdGlvbiB1cGdyYWRlRG9jdW1lbnQoZG9jKSB7XG4gICAgZG9jID0gd3JhcChkb2MpO1xuICAgIGZsYWdzLmRvbSAmJiBjb25zb2xlLmdyb3VwKFwidXBncmFkZURvY3VtZW50OiBcIiwgZG9jLmJhc2VVUkkuc3BsaXQoXCIvXCIpLnBvcCgpKTtcbiAgICBhZGRlZE5vZGUoZG9jKTtcbiAgICBvYnNlcnZlKGRvYyk7XG4gICAgZmxhZ3MuZG9tICYmIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgfVxuICBmdW5jdGlvbiB1cGdyYWRlRG9jdW1lbnRUcmVlKGRvYykge1xuICAgIGZvckRvY3VtZW50VHJlZShkb2MsIHVwZ3JhZGVEb2N1bWVudCk7XG4gIH1cbiAgdmFyIG9yaWdpbmFsQ3JlYXRlU2hhZG93Um9vdCA9IEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1Jvb3Q7XG4gIGlmIChvcmlnaW5hbENyZWF0ZVNoYWRvd1Jvb3QpIHtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcm9vdCA9IG9yaWdpbmFsQ3JlYXRlU2hhZG93Um9vdC5jYWxsKHRoaXMpO1xuICAgICAgQ3VzdG9tRWxlbWVudHMud2F0Y2hTaGFkb3codGhpcyk7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICB9XG4gIHNjb3BlLndhdGNoU2hhZG93ID0gd2F0Y2hTaGFkb3c7XG4gIHNjb3BlLnVwZ3JhZGVEb2N1bWVudFRyZWUgPSB1cGdyYWRlRG9jdW1lbnRUcmVlO1xuICBzY29wZS51cGdyYWRlU3VidHJlZSA9IGFkZGVkU3VidHJlZTtcbiAgc2NvcGUudXBncmFkZUFsbCA9IGFkZGVkTm9kZTtcbiAgc2NvcGUuYXR0YWNoZWROb2RlID0gYXR0YWNoZWROb2RlO1xuICBzY29wZS50YWtlUmVjb3JkcyA9IHRha2VSZWNvcmRzO1xufSk7XG5cbndpbmRvdy5DdXN0b21FbGVtZW50cy5hZGRNb2R1bGUoZnVuY3Rpb24oc2NvcGUpIHtcbiAgdmFyIGZsYWdzID0gc2NvcGUuZmxhZ3M7XG4gIGZ1bmN0aW9uIHVwZ3JhZGUobm9kZSkge1xuICAgIGlmICghbm9kZS5fX3VwZ3JhZGVkX18gJiYgbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHZhciBpcyA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiaXNcIik7XG4gICAgICB2YXIgZGVmaW5pdGlvbiA9IHNjb3BlLmdldFJlZ2lzdGVyZWREZWZpbml0aW9uKGlzIHx8IG5vZGUubG9jYWxOYW1lKTtcbiAgICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgIGlmIChpcyAmJiBkZWZpbml0aW9uLnRhZyA9PSBub2RlLmxvY2FsTmFtZSkge1xuICAgICAgICAgIHJldHVybiB1cGdyYWRlV2l0aERlZmluaXRpb24obm9kZSwgZGVmaW5pdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzICYmICFkZWZpbml0aW9uLmV4dGVuZHMpIHtcbiAgICAgICAgICByZXR1cm4gdXBncmFkZVdpdGhEZWZpbml0aW9uKG5vZGUsIGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZ3JhZGVXaXRoRGVmaW5pdGlvbihlbGVtZW50LCBkZWZpbml0aW9uKSB7XG4gICAgZmxhZ3MudXBncmFkZSAmJiBjb25zb2xlLmdyb3VwKFwidXBncmFkZTpcIiwgZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIGlmIChkZWZpbml0aW9uLmlzKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImlzXCIsIGRlZmluaXRpb24uaXMpO1xuICAgIH1cbiAgICBpbXBsZW1lbnRQcm90b3R5cGUoZWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgZWxlbWVudC5fX3VwZ3JhZGVkX18gPSB0cnVlO1xuICAgIGNyZWF0ZWQoZWxlbWVudCk7XG4gICAgc2NvcGUuYXR0YWNoZWROb2RlKGVsZW1lbnQpO1xuICAgIHNjb3BlLnVwZ3JhZGVTdWJ0cmVlKGVsZW1lbnQpO1xuICAgIGZsYWdzLnVwZ3JhZGUgJiYgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIGZ1bmN0aW9uIGltcGxlbWVudFByb3RvdHlwZShlbGVtZW50LCBkZWZpbml0aW9uKSB7XG4gICAgaWYgKE9iamVjdC5fX3Byb3RvX18pIHtcbiAgICAgIGVsZW1lbnQuX19wcm90b19fID0gZGVmaW5pdGlvbi5wcm90b3R5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1c3RvbU1peGluKGVsZW1lbnQsIGRlZmluaXRpb24ucHJvdG90eXBlLCBkZWZpbml0aW9uLm5hdGl2ZSk7XG4gICAgICBlbGVtZW50Ll9fcHJvdG9fXyA9IGRlZmluaXRpb24ucHJvdG90eXBlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjdXN0b21NaXhpbihpblRhcmdldCwgaW5TcmMsIGluTmF0aXZlKSB7XG4gICAgdmFyIHVzZWQgPSB7fTtcbiAgICB2YXIgcCA9IGluU3JjO1xuICAgIHdoaWxlIChwICE9PSBpbk5hdGl2ZSAmJiBwICE9PSBIVE1MRWxlbWVudC5wcm90b3R5cGUpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgazsgayA9IGtleXNbaV07IGkrKykge1xuICAgICAgICBpZiAoIXVzZWRba10pIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5UYXJnZXQsIGssIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgaykpO1xuICAgICAgICAgIHVzZWRba10gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVkKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5jcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIGVsZW1lbnQuY3JlYXRlZENhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIHNjb3BlLnVwZ3JhZGUgPSB1cGdyYWRlO1xuICBzY29wZS51cGdyYWRlV2l0aERlZmluaXRpb24gPSB1cGdyYWRlV2l0aERlZmluaXRpb247XG4gIHNjb3BlLmltcGxlbWVudFByb3RvdHlwZSA9IGltcGxlbWVudFByb3RvdHlwZTtcbn0pO1xuXG53aW5kb3cuQ3VzdG9tRWxlbWVudHMuYWRkTW9kdWxlKGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHZhciBpc0lFMTFPck9sZGVyID0gc2NvcGUuaXNJRTExT3JPbGRlcjtcbiAgdmFyIHVwZ3JhZGVEb2N1bWVudFRyZWUgPSBzY29wZS51cGdyYWRlRG9jdW1lbnRUcmVlO1xuICB2YXIgdXBncmFkZUFsbCA9IHNjb3BlLnVwZ3JhZGVBbGw7XG4gIHZhciB1cGdyYWRlV2l0aERlZmluaXRpb24gPSBzY29wZS51cGdyYWRlV2l0aERlZmluaXRpb247XG4gIHZhciBpbXBsZW1lbnRQcm90b3R5cGUgPSBzY29wZS5pbXBsZW1lbnRQcm90b3R5cGU7XG4gIHZhciB1c2VOYXRpdmUgPSBzY29wZS51c2VOYXRpdmU7XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGVmaW5pdGlvbiA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQ6IGZpcnN0IGFyZ3VtZW50IGBuYW1lYCBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgaWYgKG5hbWUuaW5kZXhPZihcIi1cIikgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQ6IGZpcnN0IGFyZ3VtZW50ICgnbmFtZScpIG11c3QgY29udGFpbiBhIGRhc2ggKCctJykuIEFyZ3VtZW50IHByb3ZpZGVkIHdhcyAnXCIgKyBTdHJpbmcobmFtZSkgKyBcIicuXCIpO1xuICAgIH1cbiAgICBpZiAoaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ3JlZ2lzdGVyRWxlbWVudCcgb24gJ0RvY3VtZW50JzogUmVnaXN0cmF0aW9uIGZhaWxlZCBmb3IgdHlwZSAnXCIgKyBTdHJpbmcobmFtZSkgKyBcIicuIFRoZSB0eXBlIG5hbWUgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuICAgIGlmIChnZXRSZWdpc3RlcmVkRGVmaW5pdGlvbihuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlRGVmaW5pdGlvbkVycm9yOiBhIHR5cGUgd2l0aCBuYW1lICdcIiArIFN0cmluZyhuYW1lKSArIFwiJyBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7XG4gICAgfVxuICAgIGlmICghZGVmaW5pdGlvbi5wcm90b3R5cGUpIHtcbiAgICAgIGRlZmluaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xuICAgIH1cbiAgICBkZWZpbml0aW9uLl9fbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBkZWZpbml0aW9uLmxpZmVjeWNsZSA9IGRlZmluaXRpb24ubGlmZWN5Y2xlIHx8IHt9O1xuICAgIGRlZmluaXRpb24uYW5jZXN0cnkgPSBhbmNlc3RyeShkZWZpbml0aW9uLmV4dGVuZHMpO1xuICAgIHJlc29sdmVUYWdOYW1lKGRlZmluaXRpb24pO1xuICAgIHJlc29sdmVQcm90b3R5cGVDaGFpbihkZWZpbml0aW9uKTtcbiAgICBvdmVycmlkZUF0dHJpYnV0ZUFwaShkZWZpbml0aW9uLnByb3RvdHlwZSk7XG4gICAgcmVnaXN0ZXJEZWZpbml0aW9uKGRlZmluaXRpb24uX19uYW1lLCBkZWZpbml0aW9uKTtcbiAgICBkZWZpbml0aW9uLmN0b3IgPSBnZW5lcmF0ZUNvbnN0cnVjdG9yKGRlZmluaXRpb24pO1xuICAgIGRlZmluaXRpb24uY3Rvci5wcm90b3R5cGUgPSBkZWZpbml0aW9uLnByb3RvdHlwZTtcbiAgICBkZWZpbml0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGRlZmluaXRpb24uY3RvcjtcbiAgICBpZiAoc2NvcGUucmVhZHkpIHtcbiAgICAgIHVwZ3JhZGVEb2N1bWVudFRyZWUoZG9jdW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmaW5pdGlvbi5jdG9yO1xuICB9XG4gIGZ1bmN0aW9uIG92ZXJyaWRlQXR0cmlidXRlQXBpKHByb3RvdHlwZSkge1xuICAgIGlmIChwcm90b3R5cGUuc2V0QXR0cmlidXRlLl9wb2x5ZmlsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZXRBdHRyaWJ1dGUgPSBwcm90b3R5cGUuc2V0QXR0cmlidXRlO1xuICAgIHByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgY2hhbmdlQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgdmFsdWUsIHNldEF0dHJpYnV0ZSk7XG4gICAgfTtcbiAgICB2YXIgcmVtb3ZlQXR0cmlidXRlID0gcHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZTtcbiAgICBwcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgY2hhbmdlQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgbnVsbCwgcmVtb3ZlQXR0cmlidXRlKTtcbiAgICB9O1xuICAgIHByb3RvdHlwZS5zZXRBdHRyaWJ1dGUuX3BvbHlmaWxsZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGNoYW5nZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgb3BlcmF0aW9uKSB7XG4gICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBvcGVyYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgJiYgbmV3VmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1Jlc2VydmVkVGFnKG5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkVGFnTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG5hbWUgPT09IHJlc2VydmVkVGFnTGlzdFtpXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJlc2VydmVkVGFnTGlzdCA9IFsgXCJhbm5vdGF0aW9uLXhtbFwiLCBcImNvbG9yLXByb2ZpbGVcIiwgXCJmb250LWZhY2VcIiwgXCJmb250LWZhY2Utc3JjXCIsIFwiZm9udC1mYWNlLXVyaVwiLCBcImZvbnQtZmFjZS1mb3JtYXRcIiwgXCJmb250LWZhY2UtbmFtZVwiLCBcIm1pc3NpbmctZ2x5cGhcIiBdO1xuICBmdW5jdGlvbiBhbmNlc3RyeShleHRuZHMpIHtcbiAgICB2YXIgZXh0ZW5kZWUgPSBnZXRSZWdpc3RlcmVkRGVmaW5pdGlvbihleHRuZHMpO1xuICAgIGlmIChleHRlbmRlZSkge1xuICAgICAgcmV0dXJuIGFuY2VzdHJ5KGV4dGVuZGVlLmV4dGVuZHMpLmNvbmNhdChbIGV4dGVuZGVlIF0pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgZnVuY3Rpb24gcmVzb2x2ZVRhZ05hbWUoZGVmaW5pdGlvbikge1xuICAgIHZhciBiYXNlVGFnID0gZGVmaW5pdGlvbi5leHRlbmRzO1xuICAgIGZvciAodmFyIGkgPSAwLCBhOyBhID0gZGVmaW5pdGlvbi5hbmNlc3RyeVtpXTsgaSsrKSB7XG4gICAgICBiYXNlVGFnID0gYS5pcyAmJiBhLnRhZztcbiAgICB9XG4gICAgZGVmaW5pdGlvbi50YWcgPSBiYXNlVGFnIHx8IGRlZmluaXRpb24uX19uYW1lO1xuICAgIGlmIChiYXNlVGFnKSB7XG4gICAgICBkZWZpbml0aW9uLmlzID0gZGVmaW5pdGlvbi5fX25hbWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVQcm90b3R5cGVDaGFpbihkZWZpbml0aW9uKSB7XG4gICAgaWYgKCFPYmplY3QuX19wcm90b19fKSB7XG4gICAgICB2YXIgbmF0aXZlUHJvdG90eXBlID0gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuICAgICAgaWYgKGRlZmluaXRpb24uaXMpIHtcbiAgICAgICAgdmFyIGluc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGRlZmluaXRpb24udGFnKTtcbiAgICAgICAgdmFyIGV4cGVjdGVkUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGluc3QpO1xuICAgICAgICBpZiAoZXhwZWN0ZWRQcm90b3R5cGUgPT09IGRlZmluaXRpb24ucHJvdG90eXBlKSB7XG4gICAgICAgICAgbmF0aXZlUHJvdG90eXBlID0gZXhwZWN0ZWRQcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IGRlZmluaXRpb24ucHJvdG90eXBlLCBhbmNlc3RvcjtcbiAgICAgIHdoaWxlIChwcm90byAmJiBwcm90byAhPT0gbmF0aXZlUHJvdG90eXBlKSB7XG4gICAgICAgIGFuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgICAgcHJvdG8uX19wcm90b19fID0gYW5jZXN0b3I7XG4gICAgICAgIHByb3RvID0gYW5jZXN0b3I7XG4gICAgICB9XG4gICAgICBkZWZpbml0aW9uLm5hdGl2ZSA9IG5hdGl2ZVByb3RvdHlwZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5zdGFudGlhdGUoZGVmaW5pdGlvbikge1xuICAgIHJldHVybiB1cGdyYWRlV2l0aERlZmluaXRpb24oZG9tQ3JlYXRlRWxlbWVudChkZWZpbml0aW9uLnRhZyksIGRlZmluaXRpb24pO1xuICB9XG4gIHZhciByZWdpc3RyeSA9IHt9O1xuICBmdW5jdGlvbiBnZXRSZWdpc3RlcmVkRGVmaW5pdGlvbihuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiByZWdpc3RyeVtuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlckRlZmluaXRpb24obmFtZSwgZGVmaW5pdGlvbikge1xuICAgIHJlZ2lzdHJ5W25hbWVdID0gZGVmaW5pdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZUNvbnN0cnVjdG9yKGRlZmluaXRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaW5zdGFudGlhdGUoZGVmaW5pdGlvbik7XG4gICAgfTtcbiAgfVxuICB2YXIgSFRNTF9OQU1FU1BBQ0UgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnLCB0eXBlRXh0ZW5zaW9uKSB7XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZywgdHlwZUV4dGVuc2lvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkb21DcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCB0YWcpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgdHlwZUV4dGVuc2lvbikge1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZUV4dGVuc2lvbikge1xuICAgICAgdHlwZUV4dGVuc2lvbiA9IHR5cGVFeHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgdmFyIGRlZmluaXRpb24gPSBnZXRSZWdpc3RlcmVkRGVmaW5pdGlvbih0eXBlRXh0ZW5zaW9uIHx8IHRhZyk7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgIGlmICh0YWcgPT0gZGVmaW5pdGlvbi50YWcgJiYgdHlwZUV4dGVuc2lvbiA9PSBkZWZpbml0aW9uLmlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgZGVmaW5pdGlvbi5jdG9yKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXR5cGVFeHRlbnNpb24gJiYgIWRlZmluaXRpb24uaXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkZWZpbml0aW9uLmN0b3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGVsZW1lbnQ7XG4gICAgaWYgKHR5cGVFeHRlbnNpb24pIHtcbiAgICAgIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImlzXCIsIHR5cGVFeHRlbnNpb24pO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGVsZW1lbnQgPSBkb21DcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRhZy5pbmRleE9mKFwiLVwiKSA+PSAwKSB7XG4gICAgICBpbXBsZW1lbnRQcm90b3R5cGUoZWxlbWVudCwgSFRNTEVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB2YXIgZG9tQ3JlYXRlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChkb2N1bWVudCk7XG4gIHZhciBkb21DcmVhdGVFbGVtZW50TlMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMuYmluZChkb2N1bWVudCk7XG4gIHZhciBpc0luc3RhbmNlO1xuICBpZiAoIU9iamVjdC5fX3Byb3RvX18gJiYgIXVzZU5hdGl2ZSkge1xuICAgIGlzSW5zdGFuY2UgPSBmdW5jdGlvbihvYmosIGN0b3IpIHtcbiAgICAgIHZhciBwID0gb2JqO1xuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgaWYgKHAgPT09IGN0b3IucHJvdG90eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAuX19wcm90b19fO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaXNJbnN0YW5jZSA9IGZ1bmN0aW9uKG9iaiwgYmFzZSkge1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIGJhc2U7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB3cmFwRG9tTWV0aG9kVG9Gb3JjZVVwZ3JhZGUob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgdmFyIG9yaWcgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgb2JqW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbiA9IG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHVwZ3JhZGVBbGwobik7XG4gICAgICByZXR1cm4gbjtcbiAgICB9O1xuICB9XG4gIHdyYXBEb21NZXRob2RUb0ZvcmNlVXBncmFkZShOb2RlLnByb3RvdHlwZSwgXCJjbG9uZU5vZGVcIik7XG4gIHdyYXBEb21NZXRob2RUb0ZvcmNlVXBncmFkZShkb2N1bWVudCwgXCJpbXBvcnROb2RlXCIpO1xuICBpZiAoaXNJRTExT3JPbGRlcikge1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbXBvcnROb2RlID0gZG9jdW1lbnQuaW1wb3J0Tm9kZTtcbiAgICAgIGRvY3VtZW50LmltcG9ydE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG4gPSBpbXBvcnROb2RlLmFwcGx5KGRvY3VtZW50LCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAobi5ub2RlVHlwZSA9PSBuLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICB2YXIgZiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICBmLmFwcGVuZENoaWxkKG4pO1xuICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gIH1cbiAgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50ID0gcmVnaXN0ZXI7XG4gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgPSBjcmVhdGVFbGVtZW50TlM7XG4gIHNjb3BlLnJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gIHNjb3BlLmluc3RhbmNlb2YgPSBpc0luc3RhbmNlO1xuICBzY29wZS5yZXNlcnZlZFRhZ0xpc3QgPSByZXNlcnZlZFRhZ0xpc3Q7XG4gIHNjb3BlLmdldFJlZ2lzdGVyZWREZWZpbml0aW9uID0gZ2V0UmVnaXN0ZXJlZERlZmluaXRpb247XG4gIGRvY3VtZW50LnJlZ2lzdGVyID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50O1xufSk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICB2YXIgdXNlTmF0aXZlID0gc2NvcGUudXNlTmF0aXZlO1xuICB2YXIgaW5pdGlhbGl6ZU1vZHVsZXMgPSBzY29wZS5pbml0aWFsaXplTW9kdWxlcztcbiAgdmFyIGlzSUUxMU9yT2xkZXIgPSAvVHJpZGVudC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgaWYgKHVzZU5hdGl2ZSkge1xuICAgIHZhciBub3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHNjb3BlLndhdGNoU2hhZG93ID0gbm9wO1xuICAgIHNjb3BlLnVwZ3JhZGUgPSBub3A7XG4gICAgc2NvcGUudXBncmFkZUFsbCA9IG5vcDtcbiAgICBzY29wZS51cGdyYWRlRG9jdW1lbnRUcmVlID0gbm9wO1xuICAgIHNjb3BlLnVwZ3JhZGVTdWJ0cmVlID0gbm9wO1xuICAgIHNjb3BlLnRha2VSZWNvcmRzID0gbm9wO1xuICAgIHNjb3BlLmluc3RhbmNlb2YgPSBmdW5jdGlvbihvYmosIGJhc2UpIHtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBiYXNlO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW5pdGlhbGl6ZU1vZHVsZXMoKTtcbiAgfVxuICB2YXIgdXBncmFkZURvY3VtZW50VHJlZSA9IHNjb3BlLnVwZ3JhZGVEb2N1bWVudFRyZWU7XG4gIGlmICghd2luZG93LndyYXApIHtcbiAgICBpZiAod2luZG93LlNoYWRvd0RPTVBvbHlmaWxsKSB7XG4gICAgICB3aW5kb3cud3JhcCA9IFNoYWRvd0RPTVBvbHlmaWxsLndyYXBJZk5lZWRlZDtcbiAgICAgIHdpbmRvdy51bndyYXAgPSBTaGFkb3dET01Qb2x5ZmlsbC51bndyYXBJZk5lZWRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LndyYXAgPSB3aW5kb3cudW53cmFwID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJvb3RzdHJhcCgpIHtcbiAgICB1cGdyYWRlRG9jdW1lbnRUcmVlKHdyYXAoZG9jdW1lbnQpKTtcbiAgICBpZiAod2luZG93LkhUTUxJbXBvcnRzKSB7XG4gICAgICBIVE1MSW1wb3J0cy5fX2ltcG9ydHNQYXJzaW5nSG9vayA9IGZ1bmN0aW9uKGVsdCkge1xuICAgICAgICB1cGdyYWRlRG9jdW1lbnRUcmVlKHdyYXAoZWx0LmltcG9ydCkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgQ3VzdG9tRWxlbWVudHMucmVhZHkgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBDdXN0b21FbGVtZW50cy5yZWFkeVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKHdpbmRvdy5IVE1MSW1wb3J0cykge1xuICAgICAgICBDdXN0b21FbGVtZW50cy5lbGFwc2VkID0gQ3VzdG9tRWxlbWVudHMucmVhZHlUaW1lIC0gSFRNTEltcG9ydHMucmVhZHlUaW1lO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJXZWJDb21wb25lbnRzUmVhZHlcIiwge1xuICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzSUUxMU9yT2xkZXIgJiYgdHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgd2luZG93LkN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oaW5UeXBlLCBwYXJhbXMpIHtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgIGUuaW5pdEN1c3RvbUV2ZW50KGluVHlwZSwgQm9vbGVhbihwYXJhbXMuYnViYmxlcyksIEJvb2xlYW4ocGFyYW1zLmNhbmNlbGFibGUpLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgd2luZG93LkN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fCBzY29wZS5mbGFncy5lYWdlcikge1xuICAgIGJvb3RzdHJhcCgpO1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcIiAmJiAhd2luZG93LmF0dGFjaEV2ZW50ICYmICghd2luZG93LkhUTUxJbXBvcnRzIHx8IHdpbmRvdy5IVE1MSW1wb3J0cy5yZWFkeSkpIHtcbiAgICBib290c3RyYXAoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbG9hZEV2ZW50ID0gd2luZG93LkhUTUxJbXBvcnRzICYmICFIVE1MSW1wb3J0cy5yZWFkeSA/IFwiSFRNTEltcG9ydHNMb2FkZWRcIiA6IFwiRE9NQ29udGVudExvYWRlZFwiO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGxvYWRFdmVudCwgYm9vdHN0cmFwKTtcbiAgfVxuICBzY29wZS5pc0lFMTFPck9sZGVyID0gaXNJRTExT3JPbGRlcjtcbn0pKHdpbmRvdy5DdXN0b21FbGVtZW50cyk7XG4iLCJpZiAoIXdpbmRvdy5DdXN0b21FdmVudCkge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIEN1c3RvbUV2ZW50O1xuXG4gICAgQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbihldmVudCwgcGFyYW1zKSB7XG4gICAgICB2YXIgZXZ0O1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtcbiAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICBkZXRhaWw6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgcmV0dXJuIGV2dDtcbiAgICB9O1xuXG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcblxuICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuICB9KSgpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vLyBAdmVyc2lvbiAwLjcuMjJcbmlmICh0eXBlb2YgV2Vha01hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcbiAgICB2YXIgV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5uYW1lID0gXCJfX3N0XCIgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkgKyAoY291bnRlcisrICsgXCJfX1wiKTtcbiAgICB9O1xuICAgIFdlYWtNYXAucHJvdG90eXBlID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSkgZW50cnlbMV0gPSB2YWx1ZTsgZWxzZSBkZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMubmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBbIGtleSwgdmFsdWUgXSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICByZXR1cm4gKGVudHJ5ID0ga2V5W3RoaXMubmFtZV0pICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA6IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICghZW50cnkgfHwgZW50cnlbMF0gIT09IGtleSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbnRyeVswXSA9IGVudHJ5WzFdID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKCFlbnRyeSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZW50cnlbMF0gPT09IGtleTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5XZWFrTWFwID0gV2Vha01hcDtcbiAgfSkoKTtcbn1cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBpZiAoZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlcikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVnaXN0cmF0aW9uc1RhYmxlID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHNldEltbWVkaWF0ZTtcbiAgaWYgKC9UcmlkZW50fEVkZ2UvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSBzZXRUaW1lb3V0O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5zZXRJbW1lZGlhdGUpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgIHZhciBzZW50aW5lbCA9IFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuZGF0YSA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gc2V0SW1tZWRpYXRlUXVldWU7XG4gICAgICAgIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgc2V0SW1tZWRpYXRlUXVldWUucHVzaChmdW5jKTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShzZW50aW5lbCwgXCIqXCIpO1xuICAgIH07XG4gIH1cbiAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhvYnNlcnZlcikge1xuICAgIHNjaGVkdWxlZE9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRJbW1lZGlhdGUoZGlzcGF0Y2hDYWxsYmFja3MpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3cmFwSWZOZWVkZWQobm9kZSkge1xuICAgIHJldHVybiB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsLndyYXBJZk5lZWRlZChub2RlKSB8fCBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoQ2FsbGJhY2tzKCkge1xuICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIG9ic2VydmVycyA9IHNjaGVkdWxlZE9ic2VydmVycztcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgICBvYnNlcnZlcnMuc29ydChmdW5jdGlvbihvMSwgbzIpIHtcbiAgICAgIHJldHVybiBvMS51aWRfIC0gbzIudWlkXztcbiAgICB9KTtcbiAgICB2YXIgYW55Tm9uRW1wdHkgPSBmYWxzZTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgdmFyIHF1ZXVlID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcik7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrXyhxdWV1ZSwgb2JzZXJ2ZXIpO1xuICAgICAgICBhbnlOb25FbXB0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGFueU5vbkVtcHR5KSBkaXNwYXRjaENhbGxiYWNrcygpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLm5vZGVzXy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmV0dXJuO1xuICAgICAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSBvYnNlcnZlcikgcmVnaXN0cmF0aW9uLnJlbW92ZVRyYW5zaWVudE9ic2VydmVycygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBub2RlID0gdGFyZ2V0OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAocmVnaXN0cmF0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tqXTtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHJlZ2lzdHJhdGlvbi5vcHRpb25zO1xuICAgICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQgJiYgIW9wdGlvbnMuc3VidHJlZSkgY29udGludWU7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGNhbGxiYWNrKG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChyZWNvcmQpIHJlZ2lzdHJhdGlvbi5lbnF1ZXVlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHVpZENvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBKc011dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIHRoaXMubm9kZXNfID0gW107XG4gICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIHRoaXMudWlkXyA9ICsrdWlkQ291bnRlcjtcbiAgfVxuICBKc011dGF0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICAgIG9ic2VydmU6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdGFyZ2V0ID0gd3JhcElmTmVlZGVkKHRhcmdldCk7XG4gICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0ICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSB8fCBvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldCh0YXJnZXQpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KHRhcmdldCwgcmVnaXN0cmF0aW9ucyA9IFtdKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb247XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvbiA9IG5ldyBSZWdpc3RyYXRpb24odGhpcywgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHJlZ2lzdHJhdGlvbik7XG4gICAgICAgIHRoaXMubm9kZXNfLnB1c2godGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJhdGlvbi5hZGRMaXN0ZW5lcnMoKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIH0sXG4gICAgdGFrZVJlY29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHlPZlJlY29yZHMgPSB0aGlzLnJlY29yZHNfO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgICAgcmV0dXJuIGNvcHlPZlJlY29yZHM7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBudWxsO1xuICAgIHRoaXMub2xkVmFsdWUgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNvcHlNdXRhdGlvblJlY29yZChvcmlnaW5hbCkge1xuICAgIHZhciByZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQob3JpZ2luYWwudHlwZSwgb3JpZ2luYWwudGFyZ2V0KTtcbiAgICByZWNvcmQuYWRkZWROb2RlcyA9IG9yaWdpbmFsLmFkZGVkTm9kZXMuc2xpY2UoKTtcbiAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gb3JpZ2luYWwucmVtb3ZlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IG9yaWdpbmFsLnByZXZpb3VzU2libGluZztcbiAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBvcmlnaW5hbC5uZXh0U2libGluZztcbiAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWU7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICByZWNvcmQub2xkVmFsdWUgPSBvcmlnaW5hbC5vbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG4gIHZhciBjdXJyZW50UmVjb3JkLCByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIGZ1bmN0aW9uIGdldFJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gY3VycmVudFJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSkge1xuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmVjb3JkV2l0aE9sZFZhbHVlID0gY29weU11dGF0aW9uUmVjb3JkKGN1cnJlbnRSZWNvcmQpO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZS5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJSZWNvcmRzKCkge1xuICAgIGN1cnJlbnRSZWNvcmQgPSByZWNvcmRXaXRoT2xkVmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkID09PSByZWNvcmRXaXRoT2xkVmFsdWUgfHwgcmVjb3JkID09PSBjdXJyZW50UmVjb3JkO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCBuZXdSZWNvcmQpIHtcbiAgICBpZiAobGFzdFJlY29yZCA9PT0gbmV3UmVjb3JkKSByZXR1cm4gbGFzdFJlY29yZDtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlICYmIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24obGFzdFJlY29yZCkpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gUmVnaXN0cmF0aW9uKG9ic2VydmVyLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgfVxuICBSZWdpc3RyYXRpb24ucHJvdG90eXBlID0ge1xuICAgIGVucXVldWU6IGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLm9ic2VydmVyLnJlY29yZHNfO1xuICAgICAgdmFyIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoO1xuICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbGFzdFJlY29yZCA9IHJlY29yZHNbbGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciByZWNvcmRUb1JlcGxhY2VMYXN0ID0gc2VsZWN0UmVjb3JkKGxhc3RSZWNvcmQsIHJlY29yZCk7XG4gICAgICAgIGlmIChyZWNvcmRUb1JlcGxhY2VMYXN0KSB7XG4gICAgICAgICAgcmVjb3Jkc1tsZW5ndGggLSAxXSA9IHJlY29yZFRvUmVwbGFjZUxhc3Q7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgICAgcmVjb3Jkc1tsZW5ndGhdID0gcmVjb3JkO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKHRoaXMudGFyZ2V0KTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlSW5zZXJ0ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZFRyYW5zaWVudE9ic2VydmVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy50YXJnZXQpIHJldHVybjtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KG5vZGUsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICByZWdpc3RyYXRpb25zLnB1c2godGhpcyk7XG4gICAgfSxcbiAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXM7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgICAgIHRyYW5zaWVudE9ic2VydmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXSA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gICAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgIGNhc2UgXCJET01BdHRyTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIG5hbWUgPSBlLmF0dHJOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gZS5yZWxhdGVkTm9kZS5uYW1lc3BhY2VVUkk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IG5ldyBnZXRSZWNvcmQoXCJhdHRyaWJ1dGVzXCIsIHRhcmdldCk7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5hdHRyQ2hhbmdlID09PSBNdXRhdGlvbkV2ZW50LkFERElUSU9OID8gbnVsbCA6IGUucHJldlZhbHVlO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMpIHJldHVybjtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZSkgPT09IC0xICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZXNwYWNlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hhcmFjdGVyRGF0YVwiLCB0YXJnZXQpO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZVJlbW92ZWRcIjpcbiAgICAgICAgdGhpcy5hZGRUcmFuc2llbnRPYnNlcnZlcihlLnRhcmdldCk7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZUluc2VydGVkXCI6XG4gICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzO1xuICAgICAgICBpZiAoZS50eXBlID09PSBcIkRPTU5vZGVJbnNlcnRlZFwiKSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlZE5vZGVzID0gW107XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBjaGFuZ2VkTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGNoYW5nZWROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hpbGRMaXN0XCIsIGUudGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgICByZWNvcmQuYWRkZWROb2RlcyA9IGFkZGVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSByZW1vdmVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHJlY29yZC5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQoZS5yZWxhdGVkTm9kZSwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QpIHJldHVybjtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNsZWFyUmVjb3JkcygpO1xuICAgIH1cbiAgfTtcbiAgZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgaWYgKCFnbG9iYWwuTXV0YXRpb25PYnNlcnZlcikge1xuICAgIGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyID0gSnNNdXRhdGlvbk9ic2VydmVyO1xuICAgIEpzTXV0YXRpb25PYnNlcnZlci5faXNQb2x5ZmlsbGVkID0gdHJ1ZTtcbiAgfVxufSkoc2VsZik7IiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuXG4vKipcbiAqIE1pbmltYWwgYW5pbWF0aW9uIGxpYnJhcnkgZm9yIG1hbmFnaW5nIGNzcyB0cmFuc2l0aW9uIG9uIG1vYmlsZSBicm93c2Vycy5cbiAqL1xud2luZG93LmFuaW1pdCA9IChmdW5jdGlvbigpe1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFRJTUVPVVRfUkFUSU8gPSAxLjQ7XG5cbiAgdmFyIHV0aWwgPSB7XG4gIH07XG5cbiAgLy8gY2FwaXRhbGl6ZSBzdHJpbmdcbiAgdXRpbC5jYXBpdGFsaXplID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgfTtcblxuICAvKipcbiAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5wcm9wZXJ0eVxuICAqIEBwYXJhbSB7RmxvYXR9IHBhcmFtcy5kdXJhdGlvblxuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudGltaW5nXG4gICovXG4gIHV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBwYXJhbXMucHJvcGVydHkgPSBwYXJhbXMucHJvcGVydHkgfHwgJ2FsbCc7XG4gICAgcGFyYW1zLmR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uIHx8IDAuNDtcbiAgICBwYXJhbXMudGltaW5nID0gcGFyYW1zLnRpbWluZyB8fCAnbGluZWFyJztcblxuICAgIHZhciBwcm9wcyA9IHBhcmFtcy5wcm9wZXJ0eS5zcGxpdCgvICsvKTtcblxuICAgIHJldHVybiBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnICcgKyBwYXJhbXMuZHVyYXRpb24gKyAncyAnICsgcGFyYW1zLnRpbWluZztcbiAgICB9KS5qb2luKCcsICcpO1xuICB9O1xuXG4gIC8qKlxuICAqIEFkZCBhbiBldmVudCBoYW5kbGVyIG9uIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50LlxuICAqL1xuICB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuXG4gICAgdmFyIGZuID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChlbGVtZW50ID09IGV2ZW50LnRhcmdldCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXJzO1xuICB9O1xuXG4gIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoJ29udHJhbnNpdGlvbmVuZCcgaW4gd2luZG93KSB7XG4gICAgICByZXR1cm4gWyd0cmFuc2l0aW9uZW5kJ107XG4gICAgfVxuXG4gICAgaWYgKCdvbndlYmtpdHRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykge1xuICAgICAgcmV0dXJuIFsnd2Via2l0VHJhbnNpdGlvbkVuZCddO1xuICAgIH1cblxuICAgIGlmICh1dGlsLnZlbmRvclByZWZpeCA9PT0gJ3dlYmtpdCcgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdvJyB8fCB1dGlsLnZlbmRvclByZWZpeCA9PT0gJ21veicgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtcycpIHtcbiAgICAgIHJldHVybiBbdXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkVuZCcsICd0cmFuc2l0aW9uZW5kJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9KSgpO1xuXG4gIHV0aWwuX2Nzc1Byb3BlcnR5RGljdCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyk7XG4gICAgdmFyIGRpY3QgPSB7fTtcbiAgICB2YXIgYSA9ICdBJy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB6ID0gJ3onLmNoYXJDb2RlQXQoMCk7XG5cbiAgICB2YXIgdXBwZXIgPSBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gcy5zdWJzdHIoMSkudG9VcHBlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgdmFyIGtleSA9IHN0eWxlc1tpXVxuICAgICAgICAucmVwbGFjZSgvXltcXC1dKy8sICcnKVxuICAgICAgICAucmVwbGFjZSgvW1xcLV1bYS16XS9nLCB1cHBlcilcbiAgICAgICAgLnJlcGxhY2UoL15tb3ovLCAnTW96Jyk7XG5cbiAgICAgIGlmIChhIDw9IGtleS5jaGFyQ29kZUF0KDApICYmIHogPj0ga2V5LmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ2Nzc1RleHQnICYmIGtleSAhPT0gJ3BhcmVudFRleHQnKSB7XG4gICAgICAgICAgZGljdFtrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWN0O1xuICB9KSgpO1xuXG4gIHV0aWwuaGFzQ3NzUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gdXRpbC5fY3NzUHJvcGVydHlEaWN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZW5kb3IgcHJlZml4IGZvciBjc3MgcHJvcGVydHkuXG4gICAqL1xuICB1dGlsLnZlbmRvclByZWZpeCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyksXG4gICAgcHJlID0gKEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgLmNhbGwoc3R5bGVzKVxuICAgICAgLmpvaW4oJycpXG4gICAgICAubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuICAgIClbMV07XG4gICAgcmV0dXJuIHByZTtcbiAgfSkoKTtcblxuICB1dGlsLmZvcmNlTGF5b3V0QXRPbmNlID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYXRjaEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAvLyBmb3JjZSBsYXlvdXRcbiAgICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICB9KTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdXRpbC5iYXRjaEltbWVkaWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY29uY3JlYXRlQ2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcblxuICAgIHZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJhZihmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY29uY3JlYXRlQ2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgICAgcmV0dXJuICd0cmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSh1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgICAgcmV0dXJuIHV0aWwudmVuZG9yUHJlZml4ICsgJ1RyYW5zaXRpb24nO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9KSgpO1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHZhciBBbmltaXQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFuaW1pdCkpIHtcbiAgICAgIHJldHVybiBuZXcgQW5pbWl0KGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBbZWxlbWVudF07XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSBvciBhbiBpbnN0YW5jZSBvZiBIVE1MRWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZSA9IFtdO1xuICAgIHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdCA9IFtdO1xuICB9O1xuXG4gIEFuaW1pdC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fVxuICAgICAqL1xuICAgIHRyYW5zaXRpb25RdWV1ZTogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICAgKi9cbiAgICBlbGVtZW50czogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlIHdpdGggcGFzc2VkIGFuaW1hdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHBsYXk6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbigpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zIG9yIG90aGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y29sb3I6ICdyZWQnfSlcbiAgICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjb2xvcjogJ3JlZCd9LCB7ZHVyYXRpb246IDAuNH0pXG4gICAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y3NzOiB7Y29sb3I6ICdyZWQnfSwgZHVyYXRpb246IDAuMn0pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBbmltaXQuVHJhbnNpdGlvbnxGdW5jdGlvbn0gdHJhbnNpdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBxdWV1ZTogZnVuY3Rpb24odHJhbnNpdGlvbiwgb3B0aW9ucykge1xuICAgICAgdmFyIHF1ZXVlID0gdGhpcy50cmFuc2l0aW9uUXVldWU7XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uICYmIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy5jc3MgPSB0cmFuc2l0aW9uO1xuICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoISh0cmFuc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgdHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbi5jc3MpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24oe1xuICAgICAgICAgICAgY3NzOiB0cmFuc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICBxdWV1ZS5wdXNoKHRyYW5zaXRpb24pO1xuICAgICAgfSBlbHNlIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgQW5pbWl0LlRyYW5zaXRpb24pIHtcbiAgICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uLmJ1aWxkKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdH0gc2Vjb25kc1xuICAgICAqL1xuICAgIHdhaXQ6IGZ1bmN0aW9uKHNlY29uZHMpIHtcbiAgICAgIGlmIChzZWNvbmRzID4gMCkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDAgKiBzZWNvbmRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzYXZlU3R5bGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGNzcyA9IHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gZWxlbWVudC5zdHlsZVtlbGVtZW50LnN0eWxlW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIGVsZW1lbnQncyBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kdXJhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50cmFuc2l0aW9uXVxuICAgICAqL1xuICAgIHJlc3RvcmVTdHlsZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gJiYgIW9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm9wdGlvbnMuZHVyYXRpb25cIiBpcyByZXF1aXJlZCB3aGVuIFwib3B0aW9ucy50cmFuc2l0aW9uXCIgaXMgZW5hYmxlZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zaXRpb25OYW1lID0gdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lO1xuXG4gICAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uIHx8IChvcHRpb25zLmR1cmF0aW9uICYmIG9wdGlvbnMuZHVyYXRpb24gPiAwKSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvblZhbHVlID0gb3B0aW9ucy50cmFuc2l0aW9uIHx8ICgnYWxsICcgKyBvcHRpb25zLmR1cmF0aW9uICsgJ3MgJyArIChvcHRpb25zLnRpbWluZyB8fCAnbGluZWFyJykpO1xuXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgICAgdmFyIHRpbWVvdXRJZDtcblxuICAgICAgICAgIHZhciBjbGVhclRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9ICcnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGFkZCBcInRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyXG4gICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIGNsZWFyVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gZm9yIGZhaWwgc2FmZS5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9LCBvcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU8pO1xuXG4gICAgICAgICAgLy8gdHJhbnNpdGlvbiBhbmQgc3R5bGUgc2V0dGluZ3NcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cbiAgICAgICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAoIWNzcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBlbGVtZW50LnN0eWxlW2ldO1xuICAgICAgICAgICAgICBpZiAoY3NzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjc3NbbmFtZV0gPSAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICBpZiAoa2V5ICE9PSB0cmFuc2l0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IGNzc1trZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIC8vIENsZWFyIHRyYW5zaXRpb24gYW5pbWF0aW9uIHNldHRpbmdzLlxuICAgICAgICBzZWxmLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9ICdub25lJztcblxuICAgICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzdG9yZVN0eWxlKCk6IFRoZSBzdHlsZSBpcyBub3Qgc2F2ZWQuIEludm9rZSBzYXZlU3R5bGUoKSBiZWZvcmUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuYW1lID0gJyc7IGkgPCBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBjc3NbZWxlbWVudC5zdHlsZVtpXV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIHN0YXJ0QW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZGVxdWV1ZVRyYW5zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudCB0cmFuc2l0aW9uIGV4aXN0cy4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHNlbGYuX2N1cnJlbnRUcmFuc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGYuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlOiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB0d2ljZS4nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdHJhbnNpdGlvbi5jYWxsKHRoaXMsIGRvbmUpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FuaW1pdH0gYXJndW1lbnRzXG4gICAqL1xuICBBbmltaXQucnVuQWxsID0gZnVuY3Rpb24oLyogYXJndW1lbnRzLi4uICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3VtZW50c1tpXS5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmR1cmF0aW9uXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvcGVydHldXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aW1pbmddXG4gICAqL1xuICBBbmltaXQuVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA9IHRoaXMub3B0aW9ucy5kdXJhdGlvbiB8fCAwO1xuICAgIHRoaXMub3B0aW9ucy50aW1pbmcgPSB0aGlzLm9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICAgIHRoaXMub3B0aW9ucy5jc3MgPSB0aGlzLm9wdGlvbnMuY3NzIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5wcm9wZXJ0eSA9IHRoaXMub3B0aW9ucy5wcm9wZXJ0eSB8fCAnYWxsJztcbiAgfTtcblxuICBBbmltaXQuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmNzcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5jc3MgaXMgcmVxdWlyZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjc3MgPSBjcmVhdGVBY3R1YWxDc3NQcm9wcyh0aGlzLm9wdGlvbnMuY3NzKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IHV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUodGhpcy5vcHRpb25zKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgICAgdmFyIHRpbWVvdXQgPSBzZWxmLm9wdGlvbnMuZHVyYXRpb24gKiAxMDAwICogVElNRU9VVF9SQVRJTztcbiAgICAgICAgICB2YXIgdGltZW91dElkO1xuXG4gICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3V0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBjc3NbbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWVdID0gJyc7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBjc3NbbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB1dGlsLmZvcmNlTGF5b3V0QXRPbmNlKGVsZW1lbnRzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlQWN0dWFsQ3NzUHJvcHMoY3NzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNzc1tuYW1lXTtcblxuICAgICAgICAgIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcHJlZml4ZWQgPSB1dGlsLnZlbmRvclByZWZpeCArIHV0aWwuY2FwaXRhbGl6ZShuYW1lKTtcbiAgICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShwcmVmaXhlZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVmaXhlZF0gPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgfVxuICB9O1xuXG5cbiAgcmV0dXJuIEFuaW1pdDtcbn0pKCk7XG4iLCIvKlxyXG4gKiBjaGlsZE5vZGUucmVtb3ZlIG1ldGhvZCBwb2x5ZmlsbCBmb3IgSUUuXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DaGlsZE5vZGUvcmVtb3ZlXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdGlmICghKCdyZW1vdmUnIGluIEVsZW1lbnQucHJvdG90eXBlKSkge1xyXG5cdCAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0ICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcclxuXHQgICAgXHR0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XHJcblx0ICAgIH1cclxuXHQgIH07XHJcblx0fVxyXG59KSgpO1xyXG4iLCIvKlxyXG4gKiBjbGFzc0xpc3QuanM6IENyb3NzLWJyb3dzZXIgZnVsbCBlbGVtZW50LmNsYXNzTGlzdCBpbXBsZW1lbnRhdGlvbi5cclxuICogMS4xLjIwMTUwMzEyXHJcbiAqXHJcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cclxuICogTGljZW5zZTogRGVkaWNhdGVkIHRvIHRoZSBwdWJsaWMgZG9tYWluLlxyXG4gKiAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxyXG4gKi9cclxuXHJcbi8qZ2xvYmFsIHNlbGYsIGRvY3VtZW50LCBET01FeGNlcHRpb24gKi9cclxuXHJcbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvY2xhc3NMaXN0LmpzICovXHJcblxyXG5pZiAoXCJkb2N1bWVudFwiIGluIHNlbGYpIHtcclxuXHJcbi8vIEZ1bGwgcG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcclxuLy8gSW5jbHVkaW5nIElFIDwgRWRnZSBtaXNzaW5nIFNWR0VsZW1lbnQuY2xhc3NMaXN0XHJcbmlmICghKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIikpXHJcbiAgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmICEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwiZ1wiKSkpIHtcclxuXHJcbihmdW5jdGlvbiAodmlldykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pZiAoISgnRWxlbWVudCcgaW4gdmlldykpIHJldHVybjtcclxuXHJcbnZhclxyXG4gICAgY2xhc3NMaXN0UHJvcCA9IFwiY2xhc3NMaXN0XCJcclxuICAsIHByb3RvUHJvcCA9IFwicHJvdG90eXBlXCJcclxuICAsIGVsZW1DdHJQcm90byA9IHZpZXcuRWxlbWVudFtwcm90b1Byb3BdXHJcbiAgLCBvYmpDdHIgPSBPYmplY3RcclxuICAsIHN0clRyaW0gPSBTdHJpbmdbcHJvdG9Qcm9wXS50cmltIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xyXG4gIH1cclxuICAsIGFyckluZGV4T2YgPSBBcnJheVtwcm90b1Byb3BdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIHZhclxyXG4gICAgICAgIGkgPSAwXHJcbiAgICAgICwgbGVuID0gdGhpcy5sZW5ndGhcclxuICAgIDtcclxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcbiAgLy8gVmVuZG9yczogcGxlYXNlIGFsbG93IGNvbnRlbnQgY29kZSB0byBpbnN0YW50aWF0ZSBET01FeGNlcHRpb25zXHJcbiAgLCBET01FeCA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XHJcbiAgICB0aGlzLm5hbWUgPSB0eXBlO1xyXG4gICAgdGhpcy5jb2RlID0gRE9NRXhjZXB0aW9uW3R5cGVdO1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICB9XHJcbiAgLCBjaGVja1Rva2VuQW5kR2V0SW5kZXggPSBmdW5jdGlvbiAoY2xhc3NMaXN0LCB0b2tlbikge1xyXG4gICAgaWYgKHRva2VuID09PSBcIlwiKSB7XHJcbiAgICAgIHRocm93IG5ldyBET01FeChcclxuICAgICAgICAgIFwiU1lOVEFYX0VSUlwiXHJcbiAgICAgICAgLCBcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZFwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAoL1xccy8udGVzdCh0b2tlbikpIHtcclxuICAgICAgdGhyb3cgbmV3IERPTUV4KFxyXG4gICAgICAgICAgXCJJTlZBTElEX0NIQVJBQ1RFUl9FUlJcIlxyXG4gICAgICAgICwgXCJTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXJcIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyckluZGV4T2YuY2FsbChjbGFzc0xpc3QsIHRva2VuKTtcclxuICB9XHJcbiAgLCBDbGFzc0xpc3QgPSBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgdmFyXHJcbiAgICAgICAgdHJpbW1lZENsYXNzZXMgPSBzdHJUcmltLmNhbGwoZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKVxyXG4gICAgICAsIGNsYXNzZXMgPSB0cmltbWVkQ2xhc3NlcyA/IHRyaW1tZWRDbGFzc2VzLnNwbGl0KC9cXHMrLykgOiBbXVxyXG4gICAgICAsIGkgPSAwXHJcbiAgICAgICwgbGVuID0gY2xhc3Nlcy5sZW5ndGhcclxuICAgIDtcclxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgdGhpcy5wdXNoKGNsYXNzZXNbaV0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMudG9TdHJpbmcoKSk7XHJcbiAgICB9O1xyXG4gIH1cclxuICAsIGNsYXNzTGlzdFByb3RvID0gQ2xhc3NMaXN0W3Byb3RvUHJvcF0gPSBbXVxyXG4gICwgY2xhc3NMaXN0R2V0dGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBDbGFzc0xpc3QodGhpcyk7XHJcbiAgfVxyXG47XHJcbi8vIE1vc3QgRE9NRXhjZXB0aW9uIGltcGxlbWVudGF0aW9ucyBkb24ndCBhbGxvdyBjYWxsaW5nIERPTUV4Y2VwdGlvbidzIHRvU3RyaW5nKClcclxuLy8gb24gbm9uLURPTUV4Y2VwdGlvbnMuIEVycm9yJ3MgdG9TdHJpbmcoKSBpcyBzdWZmaWNpZW50IGhlcmUuXHJcbkRPTUV4W3Byb3RvUHJvcF0gPSBFcnJvcltwcm90b1Byb3BdO1xyXG5jbGFzc0xpc3RQcm90by5pdGVtID0gZnVuY3Rpb24gKGkpIHtcclxuICByZXR1cm4gdGhpc1tpXSB8fCBudWxsO1xyXG59O1xyXG5jbGFzc0xpc3RQcm90by5jb250YWlucyA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gIHRva2VuICs9IFwiXCI7XHJcbiAgcmV0dXJuIGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgIT09IC0xO1xyXG59O1xyXG5jbGFzc0xpc3RQcm90by5hZGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyXHJcbiAgICAgIHRva2VucyA9IGFyZ3VtZW50c1xyXG4gICAgLCBpID0gMFxyXG4gICAgLCBsID0gdG9rZW5zLmxlbmd0aFxyXG4gICAgLCB0b2tlblxyXG4gICAgLCB1cGRhdGVkID0gZmFsc2VcclxuICA7XHJcbiAgZG8ge1xyXG4gICAgdG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xyXG4gICAgaWYgKGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgPT09IC0xKSB7XHJcbiAgICAgIHRoaXMucHVzaCh0b2tlbik7XHJcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICB3aGlsZSAoKytpIDwgbCk7XHJcblxyXG4gIGlmICh1cGRhdGVkKSB7XHJcbiAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcclxuICB9XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXJcclxuICAgICAgdG9rZW5zID0gYXJndW1lbnRzXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIGwgPSB0b2tlbnMubGVuZ3RoXHJcbiAgICAsIHRva2VuXHJcbiAgICAsIHVwZGF0ZWQgPSBmYWxzZVxyXG4gICAgLCBpbmRleFxyXG4gIDtcclxuICBkbyB7XHJcbiAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XHJcbiAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XHJcbiAgICB3aGlsZSAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgICAgIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcclxuICAgIH1cclxuICB9XHJcbiAgd2hpbGUgKCsraSA8IGwpO1xyXG5cclxuICBpZiAodXBkYXRlZCkge1xyXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XHJcbiAgfVxyXG59O1xyXG5jbGFzc0xpc3RQcm90by50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XHJcbiAgdG9rZW4gKz0gXCJcIjtcclxuXHJcbiAgdmFyXHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuY29udGFpbnModG9rZW4pXHJcbiAgICAsIG1ldGhvZCA9IHJlc3VsdCA/XHJcbiAgICAgIGZvcmNlICE9PSB0cnVlICYmIFwicmVtb3ZlXCJcclxuICAgIDpcclxuICAgICAgZm9yY2UgIT09IGZhbHNlICYmIFwiYWRkXCJcclxuICA7XHJcblxyXG4gIGlmIChtZXRob2QpIHtcclxuICAgIHRoaXNbbWV0aG9kXSh0b2tlbik7XHJcbiAgfVxyXG5cclxuICBpZiAoZm9yY2UgPT09IHRydWUgfHwgZm9yY2UgPT09IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZm9yY2U7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiAhcmVzdWx0O1xyXG4gIH1cclxufTtcclxuY2xhc3NMaXN0UHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuam9pbihcIiBcIik7XHJcbn07XHJcblxyXG5pZiAob2JqQ3RyLmRlZmluZVByb3BlcnR5KSB7XHJcbiAgdmFyIGNsYXNzTGlzdFByb3BEZXNjID0ge1xyXG4gICAgICBnZXQ6IGNsYXNzTGlzdEdldHRlclxyXG4gICAgLCBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gIH07XHJcbiAgdHJ5IHtcclxuICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcclxuICB9IGNhdGNoIChleCkgeyAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBlbnVtZXJhYmxlOnRydWVcclxuICAgIGlmIChleC5udW1iZXIgPT09IC0weDdGRjVFQzU0KSB7XHJcbiAgICAgIGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcclxuICAgICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xyXG4gICAgfVxyXG4gIH1cclxufSBlbHNlIGlmIChvYmpDdHJbcHJvdG9Qcm9wXS5fX2RlZmluZUdldHRlcl9fKSB7XHJcbiAgZWxlbUN0clByb3RvLl9fZGVmaW5lR2V0dGVyX18oY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0R2V0dGVyKTtcclxufVxyXG5cclxufShzZWxmKSk7XHJcblxyXG59IGVsc2Uge1xyXG4vLyBUaGVyZSBpcyBmdWxsIG9yIHBhcnRpYWwgbmF0aXZlIGNsYXNzTGlzdCBzdXBwb3J0LCBzbyBqdXN0IGNoZWNrIGlmIHdlIG5lZWRcclxuLy8gdG8gbm9ybWFsaXplIHRoZSBhZGQvcmVtb3ZlIGFuZCB0b2dnbGUgQVBJcy5cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpO1xyXG5cclxuICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiYzFcIiwgXCJjMlwiKTtcclxuXHJcbiAgLy8gUG9seWZpbGwgZm9yIElFIDEwLzExIGFuZCBGaXJlZm94IDwyNiwgd2hlcmUgY2xhc3NMaXN0LmFkZCBhbmRcclxuICAvLyBjbGFzc0xpc3QucmVtb3ZlIGV4aXN0IGJ1dCBzdXBwb3J0IG9ubHkgb25lIGFyZ3VtZW50IGF0IGEgdGltZS5cclxuICBpZiAoIXRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImMyXCIpKSB7XHJcbiAgICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kKSB7XHJcbiAgICAgIHZhciBvcmlnaW5hbCA9IERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXTtcclxuXHJcbiAgICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHRva2VuKSB7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgdG9rZW4gPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICBvcmlnaW5hbC5jYWxsKHRoaXMsIHRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgY3JlYXRlTWV0aG9kKCdhZGQnKTtcclxuICAgIGNyZWF0ZU1ldGhvZCgncmVtb3ZlJyk7XHJcbiAgfVxyXG5cclxuICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwiYzNcIiwgZmFsc2UpO1xyXG5cclxuICAvLyBQb2x5ZmlsbCBmb3IgSUUgMTAgYW5kIEZpcmVmb3ggPDI0LCB3aGVyZSBjbGFzc0xpc3QudG9nZ2xlIGRvZXMgbm90XHJcbiAgLy8gc3VwcG9ydCB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gIGlmICh0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjM1wiKSkge1xyXG4gICAgdmFyIF90b2dnbGUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZTtcclxuXHJcbiAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKHRva2VuLCBmb3JjZSkge1xyXG4gICAgICBpZiAoMSBpbiBhcmd1bWVudHMgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcclxuICAgICAgICByZXR1cm4gZm9yY2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gIH1cclxuXHJcbiAgdGVzdEVsZW1lbnQgPSBudWxsO1xyXG59KCkpO1xyXG5cclxufVxyXG5cclxufVxyXG5cclxuIiwiOyhmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvKipcblx0ICogQHByZXNlcnZlIEZhc3RDbGljazogcG9seWZpbGwgdG8gcmVtb3ZlIGNsaWNrIGRlbGF5cyBvbiBicm93c2VycyB3aXRoIHRvdWNoIFVJcy5cblx0ICpcblx0ICogQGNvZGluZ3N0YW5kYXJkIGZ0bGFicy1qc3YyXG5cdCAqIEBjb3B5cmlnaHQgVGhlIEZpbmFuY2lhbCBUaW1lcyBMaW1pdGVkIFtBbGwgUmlnaHRzIFJlc2VydmVkXVxuXHQgKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoc2VlIExJQ0VOU0UudHh0KVxuXHQgKi9cblxuXHQvKmpzbGludCBicm93c2VyOnRydWUsIG5vZGU6dHJ1ZSovXG5cdC8qZ2xvYmFsIGRlZmluZSwgRXZlbnQsIE5vZGUqL1xuXG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlIGZhc3QtY2xpY2tpbmcgbGlzdGVuZXJzIG9uIHRoZSBzcGVjaWZpZWQgbGF5ZXIuXG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGxheWVyIFRoZSBsYXllciB0byBsaXN0ZW4gb25cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHNcblx0ICovXG5cdGZ1bmN0aW9uIEZhc3RDbGljayhsYXllciwgb3B0aW9ucykge1xuXHRcdHZhciBvbGRPbkNsaWNrO1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIGEgY2xpY2sgaXMgY3VycmVudGx5IGJlaW5nIHRyYWNrZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBib29sZWFuXG5cdFx0ICovXG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRpbWVzdGFtcCBmb3Igd2hlbiBjbGljayB0cmFja2luZyBzdGFydGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50cmFja2luZ0NsaWNrU3RhcnQgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZWxlbWVudCBiZWluZyB0cmFja2VkIGZvciBhIGNsaWNrLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgRXZlbnRUYXJnZXRcblx0XHQgKi9cblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXG5cblx0XHQvKipcblx0XHQgKiBYLWNvb3JkaW5hdGUgb2YgdG91Y2ggc3RhcnQgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoU3RhcnRYID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWS1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WSA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIElEIG9mIHRoZSBsYXN0IHRvdWNoLCByZXRyaWV2ZWQgZnJvbSBUb3VjaC5pZGVudGlmaWVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVG91Y2htb3ZlIGJvdW5kYXJ5LCBiZXlvbmQgd2hpY2ggYSBjbGljayB3aWxsIGJlIGNhbmNlbGxlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hCb3VuZGFyeSA9IG9wdGlvbnMudG91Y2hCb3VuZGFyeSB8fCAxMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIEZhc3RDbGljayBsYXllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEVsZW1lbnRcblx0XHQgKi9cblx0XHR0aGlzLmxheWVyID0gbGF5ZXI7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWluaW11bSB0aW1lIGJldHdlZW4gdGFwKHRvdWNoc3RhcnQgYW5kIHRvdWNoZW5kKSBldmVudHNcblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudGFwRGVsYXkgPSBvcHRpb25zLnRhcERlbGF5IHx8IDIwMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIHRpbWUgZm9yIGEgdGFwXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcFRpbWVvdXQgPSBvcHRpb25zLnRhcFRpbWVvdXQgfHwgNzAwO1xuXG5cdFx0aWYgKEZhc3RDbGljay5ub3ROZWVkZWQobGF5ZXIpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gU29tZSBvbGQgdmVyc2lvbnMgb2YgQW5kcm9pZCBkb24ndCBoYXZlIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5cdFx0ZnVuY3Rpb24gYmluZChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpOyB9O1xuXHRcdH1cblxuXG5cdFx0dmFyIG1ldGhvZHMgPSBbJ29uTW91c2UnLCAnb25DbGljaycsICdvblRvdWNoU3RhcnQnLCAnb25Ub3VjaE1vdmUnLCAnb25Ub3VjaEVuZCcsICdvblRvdWNoQ2FuY2VsJ107XG5cdFx0dmFyIGNvbnRleHQgPSB0aGlzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvbnRleHRbbWV0aG9kc1tpXV0gPSBiaW5kKGNvbnRleHRbbWV0aG9kc1tpXV0sIGNvbnRleHQpO1xuXHRcdH1cblxuXHRcdC8vIFNldCB1cCBldmVudCBoYW5kbGVycyBhcyByZXF1aXJlZFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQpIHtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRydWUpO1xuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZCwgZmFsc2UpO1xuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5vblRvdWNoQ2FuY2VsLCBmYWxzZSk7XG5cblx0XHQvLyBIYWNrIGlzIHJlcXVpcmVkIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgRXZlbnQjc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIChlLmcuIEFuZHJvaWQgMilcblx0XHQvLyB3aGljaCBpcyBob3cgRmFzdENsaWNrIG5vcm1hbGx5IHN0b3BzIGNsaWNrIGV2ZW50cyBidWJibGluZyB0byBjYWxsYmFja3MgcmVnaXN0ZXJlZCBvbiB0aGUgRmFzdENsaWNrXG5cdFx0Ly8gbGF5ZXIgd2hlbiB0aGV5IGFyZSBjYW5jZWxsZWQuXG5cdFx0aWYgKCFFdmVudC5wcm90b3R5cGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpIHtcblx0XHRcdFx0dmFyIHJtdiA9IE5vZGUucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLmhpamFja2VkIHx8IGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRybXYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpIHtcblx0XHRcdFx0dmFyIGFkdiA9IE5vZGUucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRcdFx0YWR2LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLmhpamFja2VkIHx8IChjYWxsYmFjay5oaWphY2tlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRpZiAoIWV2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZCkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhldmVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSksIGNhcHR1cmUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSWYgYSBoYW5kbGVyIGlzIGFscmVhZHkgZGVjbGFyZWQgaW4gdGhlIGVsZW1lbnQncyBvbmNsaWNrIGF0dHJpYnV0ZSwgaXQgd2lsbCBiZSBmaXJlZCBiZWZvcmVcblx0XHQvLyBGYXN0Q2xpY2sncyBvbkNsaWNrIGhhbmRsZXIuIEZpeCB0aGlzIGJ5IHB1bGxpbmcgb3V0IHRoZSB1c2VyLWRlZmluZWQgaGFuZGxlciBmdW5jdGlvbiBhbmRcblx0XHQvLyBhZGRpbmcgaXQgYXMgbGlzdGVuZXIuXG5cdFx0aWYgKHR5cGVvZiBsYXllci5vbmNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG5cblx0XHRcdC8vIEFuZHJvaWQgYnJvd3NlciBvbiBhdCBsZWFzdCAzLjIgcmVxdWlyZXMgYSBuZXcgcmVmZXJlbmNlIHRvIHRoZSBmdW5jdGlvbiBpbiBsYXllci5vbmNsaWNrXG5cdFx0XHQvLyAtIHRoZSBvbGQgb25lIHdvbid0IHdvcmsgaWYgcGFzc2VkIHRvIGFkZEV2ZW50TGlzdGVuZXIgZGlyZWN0bHkuXG5cdFx0XHRvbGRPbkNsaWNrID0gbGF5ZXIub25jbGljaztcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0b2xkT25DbGljayhldmVudCk7XG5cdFx0XHR9LCBmYWxzZSk7XG5cdFx0XHRsYXllci5vbmNsaWNrID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBXaW5kb3dzIFBob25lIDguMSBmYWtlcyB1c2VyIGFnZW50IHN0cmluZyB0byBsb29rIGxpa2UgQW5kcm9pZCBhbmQgaVBob25lLlxuXHQqXG5cdCogQHR5cGUgYm9vbGVhblxuXHQqL1xuXHR2YXIgZGV2aWNlSXNXaW5kb3dzUGhvbmUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJXaW5kb3dzIFBob25lXCIpID49IDA7XG5cblx0LyoqXG5cdCAqIEFuZHJvaWQgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQW5kcm9pZCcpID4gMCAmJiAhZGV2aWNlSXNXaW5kb3dzUGhvbmU7XG5cblxuXHQvKipcblx0ICogaU9TIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPUyA9IC9pUChhZHxob25lfG9kKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhZGV2aWNlSXNXaW5kb3dzUGhvbmU7XG5cblxuXHQvKipcblx0ICogaU9TIDQgcmVxdWlyZXMgYW4gZXhjZXB0aW9uIGZvciBzZWxlY3QgZWxlbWVudHMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPUzQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIDRfXFxkKF9cXGQpPy8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblxuXHQvKipcblx0ICogaU9TIDYuMC03LiogcmVxdWlyZXMgdGhlIHRhcmdldCBlbGVtZW50IHRvIGJlIG1hbnVhbGx5IGRlcml2ZWRcblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzSU9TV2l0aEJhZFRhcmdldCA9IGRldmljZUlzSU9TICYmICgvT1MgWzYtN11fXFxkLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuXHQvKipcblx0ICogQmxhY2tCZXJyeSByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNCbGFja0JlcnJ5MTAgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0JCMTAnKSA+IDA7XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gZWxlbWVudCByZXF1aXJlcyBhIG5hdGl2ZSBjbGljay5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXQgVGFyZ2V0IERPTSBlbGVtZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGVsZW1lbnQgbmVlZHMgYSBuYXRpdmUgY2xpY2tcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUubmVlZHNDbGljayA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHN3aXRjaCAodGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcblxuXHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgdG8gZGlzYWJsZWQgaW5wdXRzIChpc3N1ZSAjNjIpXG5cdFx0Y2FzZSAnYnV0dG9uJzpcblx0XHRjYXNlICdzZWxlY3QnOlxuXHRcdGNhc2UgJ3RleHRhcmVhJzpcblx0XHRcdGlmICh0YXJnZXQuZGlzYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2lucHV0JzpcblxuXHRcdFx0Ly8gRmlsZSBpbnB1dHMgbmVlZCByZWFsIGNsaWNrcyBvbiBpT1MgNiBkdWUgdG8gYSBicm93c2VyIGJ1ZyAoaXNzdWUgIzY4KVxuXHRcdFx0aWYgKChkZXZpY2VJc0lPUyAmJiB0YXJnZXQudHlwZSA9PT0gJ2ZpbGUnKSB8fCB0YXJnZXQuZGlzYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2xhYmVsJzpcblx0XHRjYXNlICdpZnJhbWUnOiAvLyBpT1M4IGhvbWVzY3JlZW4gYXBwcyBjYW4gcHJldmVudCBldmVudHMgYnViYmxpbmcgaW50byBmcmFtZXNcblx0XHRjYXNlICd2aWRlbyc6XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKC9cXGJuZWVkc2NsaWNrXFxiLykudGVzdCh0YXJnZXQuY2xhc3NOYW1lKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBjYWxsIHRvIGZvY3VzIHRvIHNpbXVsYXRlIGNsaWNrIGludG8gZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXQgVGFyZ2V0IERPTSBlbGVtZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGVsZW1lbnQgcmVxdWlyZXMgYSBjYWxsIHRvIGZvY3VzIHRvIHNpbXVsYXRlIG5hdGl2ZSBjbGljay5cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUubmVlZHNGb2N1cyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHN3aXRjaCAodGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRjYXNlICdzZWxlY3QnOlxuXHRcdFx0cmV0dXJuICFkZXZpY2VJc0FuZHJvaWQ7XG5cdFx0Y2FzZSAnaW5wdXQnOlxuXHRcdFx0c3dpdGNoICh0YXJnZXQudHlwZSkge1xuXHRcdFx0Y2FzZSAnYnV0dG9uJzpcblx0XHRcdGNhc2UgJ2NoZWNrYm94Jzpcblx0XHRcdGNhc2UgJ2ZpbGUnOlxuXHRcdFx0Y2FzZSAnaW1hZ2UnOlxuXHRcdFx0Y2FzZSAncmFkaW8nOlxuXHRcdFx0Y2FzZSAnc3VibWl0Jzpcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBObyBwb2ludCBpbiBhdHRlbXB0aW5nIHRvIGZvY3VzIGRpc2FibGVkIGlucHV0c1xuXHRcdFx0cmV0dXJuICF0YXJnZXQuZGlzYWJsZWQgJiYgIXRhcmdldC5yZWFkT25seTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuICgvXFxibmVlZHNmb2N1c1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFNlbmQgYSBjbGljayBldmVudCB0byB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5zZW5kQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXRFbGVtZW50LCBldmVudCkge1xuXHRcdHZhciBjbGlja0V2ZW50LCB0b3VjaDtcblxuXHRcdC8vIE9uIHNvbWUgQW5kcm9pZCBkZXZpY2VzIGFjdGl2ZUVsZW1lbnQgbmVlZHMgdG8gYmUgYmx1cnJlZCBvdGhlcndpc2UgdGhlIHN5bnRoZXRpYyBjbGljayB3aWxsIGhhdmUgbm8gZWZmZWN0ICgjMjQpXG5cdFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0ZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG5cdFx0fVxuXG5cdFx0dG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcblxuXHRcdC8vIFN5bnRoZXNpemUgYSBjbGljayBldmVudCwgd2l0aCBhbiBleHRyYSBhdHRyaWJ1dGUgc28gaXQgY2FuIGJlIHRyYWNrZWRcblx0XHRjbGlja0V2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cdFx0Y2xpY2tFdmVudC5pbml0TW91c2VFdmVudCh0aGlzLmRldGVybWluZUV2ZW50VHlwZSh0YXJnZXRFbGVtZW50KSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLCB0b3VjaC5zY3JlZW5YLCB0b3VjaC5zY3JlZW5ZLCB0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cdFx0Y2xpY2tFdmVudC5mb3J3YXJkZWRUb3VjaEV2ZW50ID0gdHJ1ZTtcblx0XHR0YXJnZXRFbGVtZW50LmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG5cdH07XG5cblx0RmFzdENsaWNrLnByb3RvdHlwZS5kZXRlcm1pbmVFdmVudFR5cGUgPSBmdW5jdGlvbih0YXJnZXRFbGVtZW50KSB7XG5cblx0XHQvL0lzc3VlICMxNTk6IEFuZHJvaWQgQ2hyb21lIFNlbGVjdCBCb3ggZG9lcyBub3Qgb3BlbiB3aXRoIGEgc3ludGhldGljIGNsaWNrIGV2ZW50XG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCAmJiB0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCcpIHtcblx0XHRcdHJldHVybiAnbW91c2Vkb3duJztcblx0XHR9XG5cblx0XHRyZXR1cm4gJ2NsaWNrJztcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbih0YXJnZXRFbGVtZW50KSB7XG5cdFx0dmFyIGxlbmd0aDtcblxuXHRcdC8vIElzc3VlICMxNjA6IG9uIGlPUyA3LCBzb21lIGlucHV0IGVsZW1lbnRzIChlLmcuIGRhdGUgZGF0ZXRpbWUgbW9udGgpIHRocm93IGEgdmFndWUgVHlwZUVycm9yIG9uIHNldFNlbGVjdGlvblJhbmdlLiBUaGVzZSBlbGVtZW50cyBkb24ndCBoYXZlIGFuIGludGVnZXIgdmFsdWUgZm9yIHRoZSBzZWxlY3Rpb25TdGFydCBhbmQgc2VsZWN0aW9uRW5kIHByb3BlcnRpZXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IHRoYXQgY2FuJ3QgYmUgdXNlZCBmb3IgZGV0ZWN0aW9uIGJlY2F1c2UgYWNjZXNzaW5nIHRoZSBwcm9wZXJ0aWVzIGFsc28gdGhyb3dzIGEgVHlwZUVycm9yLiBKdXN0IGNoZWNrIHRoZSB0eXBlIGluc3RlYWQuIEZpbGVkIGFzIEFwcGxlIGJ1ZyAjMTUxMjI3MjQuXG5cdFx0aWYgKGRldmljZUlzSU9TICYmIHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UgJiYgdGFyZ2V0RWxlbWVudC50eXBlLmluZGV4T2YoJ2RhdGUnKSAhPT0gMCAmJiB0YXJnZXRFbGVtZW50LnR5cGUgIT09ICd0aW1lJyAmJiB0YXJnZXRFbGVtZW50LnR5cGUgIT09ICdtb250aCcpIHtcblx0XHRcdGxlbmd0aCA9IHRhcmdldEVsZW1lbnQudmFsdWUubGVuZ3RoO1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShsZW5ndGgsIGxlbmd0aCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldEVsZW1lbnQuZm9jdXMoKTtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiBhIHNjcm9sbGFibGUgbGF5ZXIgYW5kIGlmIHNvLCBzZXQgYSBmbGFnIG9uIGl0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUudXBkYXRlU2Nyb2xsUGFyZW50ID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBzY3JvbGxQYXJlbnQsIHBhcmVudEVsZW1lbnQ7XG5cblx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblxuXHRcdC8vIEF0dGVtcHQgdG8gZGlzY292ZXIgd2hldGhlciB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgY29udGFpbmVkIHdpdGhpbiBhIHNjcm9sbGFibGUgbGF5ZXIuIFJlLWNoZWNrIGlmIHRoZVxuXHRcdC8vIHRhcmdldCBlbGVtZW50IHdhcyBtb3ZlZCB0byBhbm90aGVyIHBhcmVudC5cblx0XHRpZiAoIXNjcm9sbFBhcmVudCB8fCAhc2Nyb2xsUGFyZW50LmNvbnRhaW5zKHRhcmdldEVsZW1lbnQpKSB7XG5cdFx0XHRwYXJlbnRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudDtcblx0XHRcdGRvIHtcblx0XHRcdFx0aWYgKHBhcmVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gcGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQpIHtcblx0XHRcdFx0XHRzY3JvbGxQYXJlbnQgPSBwYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRcdHRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHR9IHdoaWxlIChwYXJlbnRFbGVtZW50KTtcblx0XHR9XG5cblx0XHQvLyBBbHdheXMgdXBkYXRlIHRoZSBzY3JvbGwgdG9wIHRyYWNrZXIgaWYgcG9zc2libGUuXG5cdFx0aWYgKHNjcm9sbFBhcmVudCkge1xuXHRcdFx0c2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRFbGVtZW50XG5cdCAqIEByZXR1cm5zIHtFbGVtZW50fEV2ZW50VGFyZ2V0fVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5nZXRUYXJnZXRFbGVtZW50RnJvbUV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24oZXZlbnRUYXJnZXQpIHtcblxuXHRcdC8vIE9uIHNvbWUgb2xkZXIgYnJvd3NlcnMgKG5vdGFibHkgU2FmYXJpIG9uIGlPUyA0LjEgLSBzZWUgaXNzdWUgIzU2KSB0aGUgZXZlbnQgdGFyZ2V0IG1heSBiZSBhIHRleHQgbm9kZS5cblx0XHRpZiAoZXZlbnRUYXJnZXQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnRUYXJnZXQucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRUYXJnZXQ7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggc3RhcnQsIHJlY29yZCB0aGUgcG9zaXRpb24gYW5kIHNjcm9sbCBvZmZzZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB0YXJnZXRFbGVtZW50LCB0b3VjaCwgc2VsZWN0aW9uO1xuXG5cdFx0Ly8gSWdub3JlIG11bHRpcGxlIHRvdWNoZXMsIG90aGVyd2lzZSBwaW5jaC10by16b29tIGlzIHByZXZlbnRlZCBpZiBib3RoIGZpbmdlcnMgYXJlIG9uIHRoZSBGYXN0Q2xpY2sgZWxlbWVudCAoaXNzdWUgIzExMSkuXG5cdFx0aWYgKGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldChldmVudC50YXJnZXQpO1xuXHRcdHRvdWNoID0gZXZlbnQudGFyZ2V0VG91Y2hlc1swXTtcblxuXHRcdGlmIChkZXZpY2VJc0lPUykge1xuXG5cdFx0XHQvLyBPbmx5IHRydXN0ZWQgZXZlbnRzIHdpbGwgZGVzZWxlY3QgdGV4dCBvbiBpT1MgKGlzc3VlICM0OSlcblx0XHRcdHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCAmJiAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRldmljZUlzSU9TNCkge1xuXG5cdFx0XHRcdC8vIFdlaXJkIHRoaW5ncyBoYXBwZW4gb24gaU9TIHdoZW4gYW4gYWxlcnQgb3IgY29uZmlybSBkaWFsb2cgaXMgb3BlbmVkIGZyb20gYSBjbGljayBldmVudCBjYWxsYmFjayAoaXNzdWUgIzIzKTpcblx0XHRcdFx0Ly8gd2hlbiB0aGUgdXNlciBuZXh0IHRhcHMgYW55d2hlcmUgZWxzZSBvbiB0aGUgcGFnZSwgbmV3IHRvdWNoc3RhcnQgYW5kIHRvdWNoZW5kIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZFxuXHRcdFx0XHQvLyB3aXRoIHRoZSBzYW1lIGlkZW50aWZpZXIgYXMgdGhlIHRvdWNoIGV2ZW50IHRoYXQgcHJldmlvdXNseSB0cmlnZ2VyZWQgdGhlIGNsaWNrIHRoYXQgdHJpZ2dlcmVkIHRoZSBhbGVydC5cblx0XHRcdFx0Ly8gU2FkbHksIHRoZXJlIGlzIGFuIGlzc3VlIG9uIGlPUyA0IHRoYXQgY2F1c2VzIHNvbWUgbm9ybWFsIHRvdWNoIGV2ZW50cyB0byBoYXZlIHRoZSBzYW1lIGlkZW50aWZpZXIgYXMgYW5cblx0XHRcdFx0Ly8gaW1tZWRpYXRlbHkgcHJlY2VkaW5nIHRvdWNoIGV2ZW50IChpc3N1ZSAjNTIpLCBzbyB0aGlzIGZpeCBpcyB1bmF2YWlsYWJsZSBvbiB0aGF0IHBsYXRmb3JtLlxuXHRcdFx0XHQvLyBJc3N1ZSAxMjA6IHRvdWNoLmlkZW50aWZpZXIgaXMgMCB3aGVuIENocm9tZSBkZXYgdG9vbHMgJ0VtdWxhdGUgdG91Y2ggZXZlbnRzJyBpcyBzZXQgd2l0aCBhbiBpT1MgZGV2aWNlIFVBIHN0cmluZyxcblx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGFsbCB0b3VjaCBldmVudHMgdG8gYmUgaWdub3JlZC4gQXMgdGhpcyBibG9jayBvbmx5IGFwcGxpZXMgdG8gaU9TLCBhbmQgaU9TIGlkZW50aWZpZXJzIGFyZSBhbHdheXMgbG9uZyxcblx0XHRcdFx0Ly8gcmFuZG9tIGludGVnZXJzLCBpdCdzIHNhZmUgdG8gdG8gY29udGludWUgaWYgdGhlIGlkZW50aWZpZXIgaXMgMCBoZXJlLlxuXHRcdFx0XHRpZiAodG91Y2guaWRlbnRpZmllciAmJiB0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIpIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyICh1c2luZyAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2gpIGFuZDpcblx0XHRcdFx0Ly8gMSkgdGhlIHVzZXIgZG9lcyBhIGZsaW5nIHNjcm9sbCBvbiB0aGUgc2Nyb2xsYWJsZSBsYXllclxuXHRcdFx0XHQvLyAyKSB0aGUgdXNlciBzdG9wcyB0aGUgZmxpbmcgc2Nyb2xsIHdpdGggYW5vdGhlciB0YXBcblx0XHRcdFx0Ly8gdGhlbiB0aGUgZXZlbnQudGFyZ2V0IG9mIHRoZSBsYXN0ICd0b3VjaGVuZCcgZXZlbnQgd2lsbCBiZSB0aGUgZWxlbWVudCB0aGF0IHdhcyB1bmRlciB0aGUgdXNlcidzIGZpbmdlclxuXHRcdFx0XHQvLyB3aGVuIHRoZSBmbGluZyBzY3JvbGwgd2FzIHN0YXJ0ZWQsIGNhdXNpbmcgRmFzdENsaWNrIHRvIHNlbmQgYSBjbGljayBldmVudCB0byB0aGF0IGxheWVyIC0gdW5sZXNzIGEgY2hlY2tcblx0XHRcdFx0Ly8gaXMgbWFkZSB0byBlbnN1cmUgdGhhdCBhIHBhcmVudCBsYXllciB3YXMgbm90IHNjcm9sbGVkIGJlZm9yZSBzZW5kaW5nIGEgc3ludGhldGljIGNsaWNrIChpc3N1ZSAjNDIpLlxuXHRcdFx0XHR0aGlzLnVwZGF0ZVNjcm9sbFBhcmVudCh0YXJnZXRFbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSB0cnVlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gZXZlbnQudGltZVN0YW1wO1xuXHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cblx0XHR0aGlzLnRvdWNoU3RhcnRYID0gdG91Y2gucGFnZVg7XG5cdFx0dGhpcy50b3VjaFN0YXJ0WSA9IHRvdWNoLnBhZ2VZO1xuXG5cdFx0Ly8gUHJldmVudCBwaGFudG9tIGNsaWNrcyBvbiBmYXN0IGRvdWJsZS10YXAgKGlzc3VlICMzNilcblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPCB0aGlzLnRhcERlbGF5ICYmIChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpID4gLTEpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQmFzZWQgb24gYSB0b3VjaG1vdmUgZXZlbnQgb2JqZWN0LCBjaGVjayB3aGV0aGVyIHRoZSB0b3VjaCBoYXMgbW92ZWQgcGFzdCBhIGJvdW5kYXJ5IHNpbmNlIGl0IHN0YXJ0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS50b3VjaEhhc01vdmVkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSwgYm91bmRhcnkgPSB0aGlzLnRvdWNoQm91bmRhcnk7XG5cblx0XHRpZiAoTWF0aC5hYnModG91Y2gucGFnZVggLSB0aGlzLnRvdWNoU3RhcnRYKSA+IGJvdW5kYXJ5IHx8IE1hdGguYWJzKHRvdWNoLnBhZ2VZIC0gdGhpcy50b3VjaFN0YXJ0WSkgPiBib3VuZGFyeSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgbGFzdCBwb3NpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIHRvdWNoIGhhcyBtb3ZlZCwgY2FuY2VsIHRoZSBjbGljayB0cmFja2luZ1xuXHRcdGlmICh0aGlzLnRhcmdldEVsZW1lbnQgIT09IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldChldmVudC50YXJnZXQpIHx8IHRoaXMudG91Y2hIYXNNb3ZlZChldmVudCkpIHtcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGZpbmQgdGhlIGxhYmVsbGVkIGNvbnRyb2wgZm9yIHRoZSBnaXZlbiBsYWJlbCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEhUTUxMYWJlbEVsZW1lbnR9IGxhYmVsRWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxudWxsfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5maW5kQ29udHJvbCA9IGZ1bmN0aW9uKGxhYmVsRWxlbWVudCkge1xuXG5cdFx0Ly8gRmFzdCBwYXRoIGZvciBuZXdlciBicm93c2VycyBzdXBwb3J0aW5nIHRoZSBIVE1MNSBjb250cm9sIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuY29udHJvbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LmNvbnRyb2w7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGJyb3dzZXJzIHVuZGVyIHRlc3QgdGhhdCBzdXBwb3J0IHRvdWNoIGV2ZW50cyBhbHNvIHN1cHBvcnQgdGhlIEhUTUw1IGh0bWxGb3IgYXR0cmlidXRlXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5odG1sRm9yKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobGFiZWxFbGVtZW50Lmh0bWxGb3IpO1xuXHRcdH1cblxuXHRcdC8vIElmIG5vIGZvciBhdHRyaWJ1dGUgZXhpc3RzLCBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBmaXJzdCBsYWJlbGxhYmxlIGRlc2NlbmRhbnQgZWxlbWVudFxuXHRcdC8vIHRoZSBsaXN0IG9mIHdoaWNoIGlzIGRlZmluZWQgaGVyZTogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNjYXRlZ29yeS1sYWJlbFxuXHRcdHJldHVybiBsYWJlbEVsZW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSksIGtleWdlbiwgbWV0ZXIsIG91dHB1dCwgcHJvZ3Jlc3MsIHNlbGVjdCwgdGV4dGFyZWEnKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiB0b3VjaCBlbmQsIGRldGVybWluZSB3aGV0aGVyIHRvIHNlbmQgYSBjbGljayBldmVudCBhdCBvbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaEVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGZvckVsZW1lbnQsIHRyYWNraW5nQ2xpY2tTdGFydCwgdGFyZ2V0VGFnTmFtZSwgc2Nyb2xsUGFyZW50LCB0b3VjaCwgdGFyZ2V0RWxlbWVudCA9IHRoaXMudGFyZ2V0RWxlbWVudDtcblxuXHRcdGlmICghdGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkgJiYgKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPiAtMSkge1xuXHRcdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCkgPiB0aGlzLnRhcFRpbWVvdXQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHRvIHByZXZlbnQgd3JvbmcgY2xpY2sgY2FuY2VsIG9uIGlucHV0IChpc3N1ZSAjMTU2KS5cblx0XHR0aGlzLmNhbmNlbE5leHRDbGljayA9IGZhbHNlO1xuXG5cdFx0dGhpcy5sYXN0Q2xpY2tUaW1lID0gZXZlbnQudGltZVN0YW1wO1xuXG5cdFx0dHJhY2tpbmdDbGlja1N0YXJ0ID0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQ7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrU3RhcnQgPSAwO1xuXG5cdFx0Ly8gT24gc29tZSBpT1MgZGV2aWNlcywgdGhlIHRhcmdldEVsZW1lbnQgc3VwcGxpZWQgd2l0aCB0aGUgZXZlbnQgaXMgaW52YWxpZCBpZiB0aGUgbGF5ZXJcblx0XHQvLyBpcyBwZXJmb3JtaW5nIGEgdHJhbnNpdGlvbiBvciBzY3JvbGwsIGFuZCBoYXMgdG8gYmUgcmUtZGV0ZWN0ZWQgbWFudWFsbHkuIE5vdGUgdGhhdFxuXHRcdC8vIGZvciB0aGlzIHRvIGZ1bmN0aW9uIGNvcnJlY3RseSwgaXQgbXVzdCBiZSBjYWxsZWQgKmFmdGVyKiB0aGUgZXZlbnQgdGFyZ2V0IGlzIGNoZWNrZWQhXG5cdFx0Ly8gU2VlIGlzc3VlICM1NzsgYWxzbyBmaWxlZCBhcyByZGFyOi8vMTMwNDg1ODkgLlxuXHRcdGlmIChkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQpIHtcblx0XHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHRcdC8vIEluIGNlcnRhaW4gY2FzZXMgYXJndW1lbnRzIG9mIGVsZW1lbnRGcm9tUG9pbnQgY2FuIGJlIG5lZ2F0aXZlLCBzbyBwcmV2ZW50IHNldHRpbmcgdGFyZ2V0RWxlbWVudCB0byBudWxsXG5cdFx0XHR0YXJnZXRFbGVtZW50ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgdG91Y2gucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpIHx8IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHRoaXMudGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0VGFnTmFtZSA9IHRhcmdldEVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmICh0YXJnZXRUYWdOYW1lID09PSAnbGFiZWwnKSB7XG5cdFx0XHRmb3JFbGVtZW50ID0gdGhpcy5maW5kQ29udHJvbCh0YXJnZXRFbGVtZW50KTtcblx0XHRcdGlmIChmb3JFbGVtZW50KSB7XG5cdFx0XHRcdHRoaXMuZm9jdXModGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRcdGlmIChkZXZpY2VJc0FuZHJvaWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRFbGVtZW50ID0gZm9yRWxlbWVudDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMubmVlZHNGb2N1cyh0YXJnZXRFbGVtZW50KSkge1xuXG5cdFx0XHQvLyBDYXNlIDE6IElmIHRoZSB0b3VjaCBzdGFydGVkIGEgd2hpbGUgYWdvIChiZXN0IGd1ZXNzIGlzIDEwMG1zIGJhc2VkIG9uIHRlc3RzIGZvciBpc3N1ZSAjMzYpIHRoZW4gZm9jdXMgd2lsbCBiZSB0cmlnZ2VyZWQgYW55d2F5LiBSZXR1cm4gZWFybHkgYW5kIHVuc2V0IHRoZSB0YXJnZXQgZWxlbWVudCByZWZlcmVuY2Ugc28gdGhhdCB0aGUgc3Vic2VxdWVudCBjbGljayB3aWxsIGJlIGFsbG93ZWQgdGhyb3VnaC5cblx0XHRcdC8vIENhc2UgMjogV2l0aG91dCB0aGlzIGV4Y2VwdGlvbiBmb3IgaW5wdXQgZWxlbWVudHMgdGFwcGVkIHdoZW4gdGhlIGRvY3VtZW50IGlzIGNvbnRhaW5lZCBpbiBhbiBpZnJhbWUsIHRoZW4gYW55IGlucHV0dGVkIHRleHQgd29uJ3QgYmUgdmlzaWJsZSBldmVuIHRob3VnaCB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIHVwZGF0ZWQgYXMgdGhlIHVzZXIgdHlwZXMgKGlzc3VlICMzNykuXG5cdFx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRyYWNraW5nQ2xpY2tTdGFydCkgPiAxMDAgfHwgKGRldmljZUlzSU9TICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyAmJiB0YXJnZXRUYWdOYW1lID09PSAnaW5wdXQnKSkge1xuXHRcdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZm9jdXModGFyZ2V0RWxlbWVudCk7XG5cdFx0XHR0aGlzLnNlbmRDbGljayh0YXJnZXRFbGVtZW50LCBldmVudCk7XG5cblx0XHRcdC8vIFNlbGVjdCBlbGVtZW50cyBuZWVkIHRoZSBldmVudCB0byBnbyB0aHJvdWdoIG9uIGlPUyA0LCBvdGhlcndpc2UgdGhlIHNlbGVjdG9yIG1lbnUgd29uJ3Qgb3Blbi5cblx0XHRcdC8vIEFsc28gdGhpcyBicmVha3Mgb3BlbmluZyBzZWxlY3RzIHdoZW4gVm9pY2VPdmVyIGlzIGFjdGl2ZSBvbiBpT1M2LCBpT1M3IChhbmQgcG9zc2libHkgb3RoZXJzKVxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUyB8fCB0YXJnZXRUYWdOYW1lICE9PSAnc2VsZWN0Jykge1xuXHRcdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGRldmljZUlzSU9TICYmICFkZXZpY2VJc0lPUzQpIHtcblxuXHRcdFx0Ly8gRG9uJ3Qgc2VuZCBhIHN5bnRoZXRpYyBjbGljayBldmVudCBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgY29udGFpbmVkIHdpdGhpbiBhIHBhcmVudCBsYXllciB0aGF0IHdhcyBzY3JvbGxlZFxuXHRcdFx0Ly8gYW5kIHRoaXMgdGFwIGlzIGJlaW5nIHVzZWQgdG8gc3RvcCB0aGUgc2Nyb2xsaW5nICh1c3VhbGx5IGluaXRpYXRlZCBieSBhIGZsaW5nIC0gaXNzdWUgIzQyKS5cblx0XHRcdHNjcm9sbFBhcmVudCA9IHRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXHRcdFx0aWYgKHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQuZmFzdENsaWNrTGFzdFNjcm9sbFRvcCAhPT0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmV2ZW50IHRoZSBhY3R1YWwgY2xpY2sgZnJvbSBnb2luZyB0aG91Z2ggLSB1bmxlc3MgdGhlIHRhcmdldCBub2RlIGlzIG1hcmtlZCBhcyByZXF1aXJpbmdcblx0XHQvLyByZWFsIGNsaWNrcyBvciBpZiBpdCBpcyBpbiB0aGUgd2hpdGVsaXN0IGluIHdoaWNoIGNhc2Ugb25seSBub24tcHJvZ3JhbW1hdGljIGNsaWNrcyBhcmUgcGVybWl0dGVkLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRhcmdldEVsZW1lbnQpKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5zZW5kQ2xpY2sodGFyZ2V0RWxlbWVudCwgZXZlbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiB0b3VjaCBjYW5jZWwsIHN0b3AgdHJhY2tpbmcgdGhlIGNsaWNrLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaENhbmNlbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIG1vdXNlIGV2ZW50cyB3aGljaCBzaG91bGQgYmUgcGVybWl0dGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Nb3VzZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHQvLyBJZiBhIHRhcmdldCBlbGVtZW50IHdhcyBuZXZlciBzZXQgKGJlY2F1c2UgYSB0b3VjaCBldmVudCB3YXMgbmV2ZXIgZmlyZWQpIGFsbG93IHRoZSBldmVudFxuXHRcdGlmICghdGhpcy50YXJnZXRFbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUHJvZ3JhbW1hdGljYWxseSBnZW5lcmF0ZWQgZXZlbnRzIHRhcmdldGluZyBhIHNwZWNpZmljIGVsZW1lbnQgc2hvdWxkIGJlIHBlcm1pdHRlZFxuXHRcdGlmICghZXZlbnQuY2FuY2VsYWJsZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRGVyaXZlIGFuZCBjaGVjayB0aGUgdGFyZ2V0IGVsZW1lbnQgdG8gc2VlIHdoZXRoZXIgdGhlIG1vdXNlIGV2ZW50IG5lZWRzIHRvIGJlIHBlcm1pdHRlZDtcblx0XHQvLyB1bmxlc3MgZXhwbGljaXRseSBlbmFibGVkLCBwcmV2ZW50IG5vbi10b3VjaCBjbGljayBldmVudHMgZnJvbSB0cmlnZ2VyaW5nIGFjdGlvbnMsXG5cdFx0Ly8gdG8gcHJldmVudCBnaG9zdC9kb3VibGVjbGlja3MuXG5cdFx0aWYgKCF0aGlzLm5lZWRzQ2xpY2sodGhpcy50YXJnZXRFbGVtZW50KSB8fCB0aGlzLmNhbmNlbE5leHRDbGljaykge1xuXG5cdFx0XHQvLyBQcmV2ZW50IGFueSB1c2VyLWFkZGVkIGxpc3RlbmVycyBkZWNsYXJlZCBvbiBGYXN0Q2xpY2sgZWxlbWVudCBmcm9tIGJlaW5nIGZpcmVkLlxuXHRcdFx0aWYgKGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUGFydCBvZiB0aGUgaGFjayBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0XHRcdGV2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbmNlbCB0aGUgZXZlbnRcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBtb3VzZSBldmVudCBpcyBwZXJtaXR0ZWQsIHJldHVybiB0cnVlIGZvciB0aGUgYWN0aW9uIHRvIGdvIHRocm91Z2guXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gYWN0dWFsIGNsaWNrcywgZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHRvdWNoLWdlbmVyYXRlZCBjbGljaywgYSBjbGljayBhY3Rpb24gb2NjdXJyaW5nXG5cdCAqIG5hdHVyYWxseSBhZnRlciBhIGRlbGF5IGFmdGVyIGEgdG91Y2ggKHdoaWNoIG5lZWRzIHRvIGJlIGNhbmNlbGxlZCB0byBhdm9pZCBkdXBsaWNhdGlvbiksIG9yXG5cdCAqIGFuIGFjdHVhbCBjbGljayB3aGljaCBzaG91bGQgYmUgcGVybWl0dGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHBlcm1pdHRlZDtcblxuXHRcdC8vIEl0J3MgcG9zc2libGUgZm9yIGFub3RoZXIgRmFzdENsaWNrLWxpa2UgbGlicmFyeSBkZWxpdmVyZWQgd2l0aCB0aGlyZC1wYXJ0eSBjb2RlIHRvIGZpcmUgYSBjbGljayBldmVudCBiZWZvcmUgRmFzdENsaWNrIGRvZXMgKGlzc3VlICM0NCkuIEluIHRoYXQgY2FzZSwgc2V0IHRoZSBjbGljay10cmFja2luZyBmbGFnIGJhY2sgdG8gZmFsc2UgYW5kIHJldHVybiBlYXJseS4gVGhpcyB3aWxsIGNhdXNlIG9uVG91Y2hFbmQgdG8gcmV0dXJuIGVhcmx5LlxuXHRcdGlmICh0aGlzLnRyYWNraW5nQ2xpY2spIHtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFZlcnkgb2RkIGJlaGF2aW9yIG9uIGlPUyAoaXNzdWUgIzE4KTogaWYgYSBzdWJtaXQgZWxlbWVudCBpcyBwcmVzZW50IGluc2lkZSBhIGZvcm0gYW5kIHRoZSB1c2VyIGhpdHMgZW50ZXIgaW4gdGhlIGlPUyBzaW11bGF0b3Igb3IgY2xpY2tzIHRoZSBHbyBidXR0b24gb24gdGhlIHBvcC11cCBPUyBrZXlib2FyZCB0aGUgYSBraW5kIG9mICdmYWtlJyBjbGljayBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCB3aXRoIHRoZSBzdWJtaXQtdHlwZSBpbnB1dCBlbGVtZW50IGFzIHRoZSB0YXJnZXQuXG5cdFx0aWYgKGV2ZW50LnRhcmdldC50eXBlID09PSAnc3VibWl0JyAmJiBldmVudC5kZXRhaWwgPT09IDApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHBlcm1pdHRlZCA9IHRoaXMub25Nb3VzZShldmVudCk7XG5cblx0XHQvLyBPbmx5IHVuc2V0IHRhcmdldEVsZW1lbnQgaWYgdGhlIGNsaWNrIGlzIG5vdCBwZXJtaXR0ZWQuIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCB0aGUgY2hlY2sgZm9yICF0YXJnZXRFbGVtZW50IGluIG9uTW91c2UgZmFpbHMgYW5kIHRoZSBicm93c2VyJ3MgY2xpY2sgZG9lc24ndCBnbyB0aHJvdWdoLlxuXHRcdGlmICghcGVybWl0dGVkKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8vIElmIGNsaWNrcyBhcmUgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiBwZXJtaXR0ZWQ7XG5cdH07XG5cblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBGYXN0Q2xpY2sncyBldmVudCBsaXN0ZW5lcnMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5sYXllcjtcblxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQpIHtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRydWUpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZCwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5vblRvdWNoQ2FuY2VsLCBmYWxzZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogQ2hlY2sgd2hldGhlciBGYXN0Q2xpY2sgaXMgbmVlZGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGxheWVyIFRoZSBsYXllciB0byBsaXN0ZW4gb25cblx0ICovXG5cdEZhc3RDbGljay5ub3ROZWVkZWQgPSBmdW5jdGlvbihsYXllcikge1xuXHRcdHZhciBtZXRhVmlld3BvcnQ7XG5cdFx0dmFyIGNocm9tZVZlcnNpb247XG5cdFx0dmFyIGJsYWNrYmVycnlWZXJzaW9uO1xuXHRcdHZhciBmaXJlZm94VmVyc2lvbjtcblxuXHRcdC8vIERldmljZXMgdGhhdCBkb24ndCBzdXBwb3J0IHRvdWNoIGRvbid0IG5lZWQgRmFzdENsaWNrXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hyb21lIHZlcnNpb24gLSB6ZXJvIGZvciBvdGhlciBicm93c2Vyc1xuXHRcdGNocm9tZVZlcnNpb24gPSArKC9DaHJvbWVcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcblxuXHRcdGlmIChjaHJvbWVWZXJzaW9uKSB7XG5cblx0XHRcdGlmIChkZXZpY2VJc0FuZHJvaWQpIHtcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG5cdFx0XHRcdGlmIChtZXRhVmlld3BvcnQpIHtcblx0XHRcdFx0XHQvLyBDaHJvbWUgb24gQW5kcm9pZCB3aXRoIHVzZXItc2NhbGFibGU9XCJub1wiIGRvZXNuJ3QgbmVlZCBGYXN0Q2xpY2sgKGlzc3VlICM4OSlcblx0XHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIENocm9tZSAzMiBhbmQgYWJvdmUgd2l0aCB3aWR0aD1kZXZpY2Utd2lkdGggb3IgbGVzcyBkb24ndCBuZWVkIEZhc3RDbGlja1xuXHRcdFx0XHRcdGlmIChjaHJvbWVWZXJzaW9uID4gMzEgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hyb21lIGRlc2t0b3AgZG9lc24ndCBuZWVkIEZhc3RDbGljayAoaXNzdWUgIzE1KVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGRldmljZUlzQmxhY2tCZXJyeTEwKSB7XG5cdFx0XHRibGFja2JlcnJ5VmVyc2lvbiA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oWzAtOV0qKVxcLihbMC05XSopLyk7XG5cblx0XHRcdC8vIEJsYWNrQmVycnkgMTAuMysgZG9lcyBub3QgcmVxdWlyZSBGYXN0Y2xpY2sgbGlicmFyeS5cblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mdGxhYnMvZmFzdGNsaWNrL2lzc3Vlcy8yNTFcblx0XHRcdGlmIChibGFja2JlcnJ5VmVyc2lvblsxXSA+PSAxMCAmJiBibGFja2JlcnJ5VmVyc2lvblsyXSA+PSAzKSB7XG5cdFx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblxuXHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0Ly8gdXNlci1zY2FsYWJsZT1ubyBlbGltaW5hdGVzIGNsaWNrIGRlbGF5LlxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gd2lkdGg9ZGV2aWNlLXdpZHRoIChvciBsZXNzIHRoYW4gZGV2aWNlLXdpZHRoKSBlbGltaW5hdGVzIGNsaWNrIGRlbGF5LlxuXHRcdFx0XHRcdGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElFMTAgd2l0aCAtbXMtdG91Y2gtYWN0aW9uOiBub25lIG9yIG1hbmlwdWxhdGlvbiwgd2hpY2ggZGlzYWJsZXMgZG91YmxlLXRhcC10by16b29tIChpc3N1ZSAjOTcpXG5cdFx0aWYgKGxheWVyLnN0eWxlLm1zVG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIEZpcmVmb3ggdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXG5cdFx0ZmlyZWZveFZlcnNpb24gPSArKC9GaXJlZm94XFwvKFswLTldKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWywwXSlbMV07XG5cblx0XHRpZiAoZmlyZWZveFZlcnNpb24gPj0gMjcpIHtcblx0XHRcdC8vIEZpcmVmb3ggMjcrIGRvZXMgbm90IGhhdmUgdGFwIGRlbGF5IGlmIHRoZSBjb250ZW50IGlzIG5vdCB6b29tYWJsZSAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyMjg5NlxuXG5cdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cdFx0XHRpZiAobWV0YVZpZXdwb3J0ICYmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUUxMTogcHJlZml4ZWQgLW1zLXRvdWNoLWFjdGlvbiBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGFuZCBpdCdzIHJlY29tbWVuZGVkIHRvIHVzZSBub24tcHJlZml4ZWQgdmVyc2lvblxuXHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2FwcHMvSGg3NjczMTMuYXNweFxuXHRcdGlmIChsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ25vbmUnIHx8IGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbWFuaXB1bGF0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhIEZhc3RDbGljayBvYmplY3Rcblx0ICpcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRGYXN0Q2xpY2suYXR0YWNoID0gZnVuY3Rpb24obGF5ZXIsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbmV3IEZhc3RDbGljayhsYXllciwgb3B0aW9ucyk7XG5cdH07XG5cbiAgd2luZG93LkZhc3RDbGljayA9IEZhc3RDbGljaztcbn0oKSk7XG4iLCIvKipcbiAqIE1pY3JvRXZlbnQgLSB0byBtYWtlIGFueSBqcyBvYmplY3QgYW4gZXZlbnQgZW1pdHRlciAoc2VydmVyIG9yIGJyb3dzZXIpXG4gKiBcbiAqIC0gcHVyZSBqYXZhc2NyaXB0IC0gc2VydmVyIGNvbXBhdGlibGUsIGJyb3dzZXIgY29tcGF0aWJsZVxuICogLSBkb250IHJlbHkgb24gdGhlIGJyb3dzZXIgZG9tc1xuICogLSBzdXBlciBzaW1wbGUgLSB5b3UgZ2V0IGl0IGltbWVkaWF0ZWx5LCBubyBteXN0ZXJ5LCBubyBtYWdpYyBpbnZvbHZlZFxuICpcbiAqIC0gY3JlYXRlIGEgTWljcm9FdmVudERlYnVnIHdpdGggZ29vZGllcyB0byBkZWJ1Z1xuICogICAtIG1ha2UgaXQgc2FmZXIgdG8gdXNlXG4qL1xuXG4vKiogTk9URTogVGhpcyBsaWJyYXJ5IGlzIGN1c3RvbWl6ZWQgZm9yIE9uc2VuIFVJLiAqL1xuXG52YXIgTWljcm9FdmVudCAgPSBmdW5jdGlvbigpe307XG5NaWNyb0V2ZW50LnByb3RvdHlwZSAgPSB7XG4gIG9uICA6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdGhpcy5fZXZlbnRzW2V2ZW50XSB8fCBbXTtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdLnB1c2goZmN0KTtcbiAgfSxcbiAgb25jZSA6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5vZmYoZXZlbnQsIHdyYXBwZXIpO1xuICAgICAgcmV0dXJuIGZjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdGhpcy5vbihldmVudCwgd3JhcHBlcik7XG4gIH0sXG4gIG9mZiAgOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgaWYoIGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UgICkgIHJldHVybjtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdLnNwbGljZSh0aGlzLl9ldmVudHNbZXZlbnRdLmluZGV4T2YoZmN0KSwgMSk7XG4gIH0sXG4gIGVtaXQgOiBmdW5jdGlvbihldmVudCAvKiAsIGFyZ3MuLi4gKi8pe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICBpZiggZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSAgKSAgcmV0dXJuO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9ldmVudHNbZXZlbnRdLmxlbmd0aDsgaSsrKXtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF1baV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIG1peGluIHdpbGwgZGVsZWdhdGUgYWxsIE1pY3JvRXZlbnQuanMgZnVuY3Rpb24gaW4gdGhlIGRlc3RpbmF0aW9uIG9iamVjdFxuICpcbiAqIC0gcmVxdWlyZSgnTWljcm9FdmVudCcpLm1peGluKEZvb2Jhcikgd2lsbCBtYWtlIEZvb2JhciBhYmxlIHRvIHVzZSBNaWNyb0V2ZW50XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRoZSBvYmplY3Qgd2hpY2ggd2lsbCBzdXBwb3J0IE1pY3JvRXZlbnRcbiovXG5NaWNyb0V2ZW50Lm1peGluICA9IGZ1bmN0aW9uKGRlc3RPYmplY3Qpe1xuICB2YXIgcHJvcHMgPSBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ2VtaXQnXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArKyl7XG4gICAgaWYoIHR5cGVvZiBkZXN0T2JqZWN0ID09PSAnZnVuY3Rpb24nICl7XG4gICAgICBkZXN0T2JqZWN0LnByb3RvdHlwZVtwcm9wc1tpXV0gID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuICAgIH1lbHNle1xuICAgICAgZGVzdE9iamVjdFtwcm9wc1tpXV0gPSBNaWNyb0V2ZW50LnByb3RvdHlwZVtwcm9wc1tpXV07XG4gICAgfVxuICB9XG59XG5cbi8vIGV4cG9ydCBpbiBjb21tb24ganNcbmlmKCB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmICgnZXhwb3J0cycgaW4gbW9kdWxlKSl7XG4gIG1vZHVsZS5leHBvcnRzICA9IE1pY3JvRXZlbnQ7XG59XG5cbndpbmRvdy5NaWNyb0V2ZW50ID0gTWljcm9FdmVudDtcbiIsIiFmdW5jdGlvbiBuKHQsZSxyKXtmdW5jdGlvbiBvKHUsZil7aWYoIWVbdV0pe2lmKCF0W3VdKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKHUsITApO2lmKGkpcmV0dXJuIGkodSwhMCk7dmFyIHM9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIit1K1wiJ1wiKTt0aHJvdyBzLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsc312YXIgbD1lW3VdPXtleHBvcnRzOnt9fTt0W3VdWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKG4pe3ZhciBlPXRbdV1bMV1bbl07cmV0dXJuIG8oZT9lOm4pfSxsLGwuZXhwb3J0cyxuLHQsZSxyKX1yZXR1cm4gZVt1XS5leHBvcnRzfWZvcih2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLHU9MDt1PHIubGVuZ3RoO3UrKylvKHJbdV0pO3JldHVybiBvfSh7MTpbZnVuY3Rpb24obix0LGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXt9ZnVuY3Rpb24gbyhuKXt0cnl7cmV0dXJuIG4udGhlbn1jYXRjaCh0KXtyZXR1cm4gZD10LHd9fWZ1bmN0aW9uIGkobix0KXt0cnl7cmV0dXJuIG4odCl9Y2F0Y2goZSl7cmV0dXJuIGQ9ZSx3fX1mdW5jdGlvbiB1KG4sdCxlKXt0cnl7bih0LGUpfWNhdGNoKHIpe3JldHVybiBkPXIsd319ZnVuY3Rpb24gZihuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdGhpcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3XCIpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIGZ1bmN0aW9uXCIpO3RoaXMuXzM3PTAsdGhpcy5fMTI9bnVsbCx0aGlzLl81OT1bXSxuIT09ciYmdihuLHRoaXMpfWZ1bmN0aW9uIGMobix0LGUpe3JldHVybiBuZXcgbi5jb25zdHJ1Y3RvcihmdW5jdGlvbihvLGkpe3ZhciB1PW5ldyBmKHIpO3UudGhlbihvLGkpLHMobixuZXcgcCh0LGUsdSkpfSl9ZnVuY3Rpb24gcyhuLHQpe2Zvcig7Mz09PW4uXzM3OyluPW4uXzEyO3JldHVybiAwPT09bi5fMzc/dm9pZCBuLl81OS5wdXNoKHQpOnZvaWQgeShmdW5jdGlvbigpe3ZhciBlPTE9PT1uLl8zNz90Lm9uRnVsZmlsbGVkOnQub25SZWplY3RlZDtpZihudWxsPT09ZSlyZXR1cm4gdm9pZCgxPT09bi5fMzc/bCh0LnByb21pc2Usbi5fMTIpOmEodC5wcm9taXNlLG4uXzEyKSk7dmFyIHI9aShlLG4uXzEyKTtyPT09dz9hKHQucHJvbWlzZSxkKTpsKHQucHJvbWlzZSxyKX0pfWZ1bmN0aW9uIGwobix0KXtpZih0PT09bilyZXR1cm4gYShuLG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLlwiKSk7aWYodCYmKFwib2JqZWN0XCI9PXR5cGVvZiB0fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KSl7dmFyIGU9byh0KTtpZihlPT09dylyZXR1cm4gYShuLGQpO2lmKGU9PT1uLnRoZW4mJnQgaW5zdGFuY2VvZiBmKXJldHVybiBuLl8zNz0zLG4uXzEyPXQsdm9pZCBoKG4pO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpcmV0dXJuIHZvaWQgdihlLmJpbmQodCksbil9bi5fMzc9MSxuLl8xMj10LGgobil9ZnVuY3Rpb24gYShuLHQpe24uXzM3PTIsbi5fMTI9dCxoKG4pfWZ1bmN0aW9uIGgobil7Zm9yKHZhciB0PTA7dDxuLl81OS5sZW5ndGg7dCsrKXMobixuLl81OVt0XSk7bi5fNTk9bnVsbH1mdW5jdGlvbiBwKG4sdCxlKXt0aGlzLm9uRnVsZmlsbGVkPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpudWxsLHRoaXMub25SZWplY3RlZD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6bnVsbCx0aGlzLnByb21pc2U9ZX1mdW5jdGlvbiB2KG4sdCl7dmFyIGU9ITEscj11KG4sZnVuY3Rpb24obil7ZXx8KGU9ITAsbCh0LG4pKX0sZnVuY3Rpb24obil7ZXx8KGU9ITAsYSh0LG4pKX0pO2V8fHIhPT13fHwoZT0hMCxhKHQsZCkpfXZhciB5PW4oXCJhc2FwL3Jhd1wiKSxkPW51bGwsdz17fTt0LmV4cG9ydHM9ZixmLl85OT1yLGYucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24obix0KXtpZih0aGlzLmNvbnN0cnVjdG9yIT09ZilyZXR1cm4gYyh0aGlzLG4sdCk7dmFyIGU9bmV3IGYocik7cmV0dXJuIHModGhpcyxuZXcgcChuLHQsZSkpLGV9fSx7XCJhc2FwL3Jhd1wiOjR9XSwyOltmdW5jdGlvbihuLHQsZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihuKXt2YXIgdD1uZXcgbyhvLl85OSk7cmV0dXJuIHQuXzM3PTEsdC5fMTI9bix0fXZhciBvPW4oXCIuL2NvcmUuanNcIik7dC5leHBvcnRzPW87dmFyIGk9cighMCksdT1yKCExKSxmPXIobnVsbCksYz1yKHZvaWQgMCkscz1yKDApLGw9cihcIlwiKTtvLnJlc29sdmU9ZnVuY3Rpb24obil7aWYobiBpbnN0YW5jZW9mIG8pcmV0dXJuIG47aWYobnVsbD09PW4pcmV0dXJuIGY7aWYodm9pZCAwPT09bilyZXR1cm4gYztpZihuPT09ITApcmV0dXJuIGk7aWYobj09PSExKXJldHVybiB1O2lmKDA9PT1uKXJldHVybiBzO2lmKFwiXCI9PT1uKXJldHVybiBsO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBufHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuKXRyeXt2YXIgdD1uLnRoZW47aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdClyZXR1cm4gbmV3IG8odC5iaW5kKG4pKX1jYXRjaChlKXtyZXR1cm4gbmV3IG8oZnVuY3Rpb24obix0KXt0KGUpfSl9cmV0dXJuIHIobil9LG8uYWxsPWZ1bmN0aW9uKG4pe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4pO3JldHVybiBuZXcgbyhmdW5jdGlvbihuLGUpe2Z1bmN0aW9uIHIodSxmKXtpZihmJiYoXCJvYmplY3RcIj09dHlwZW9mIGZ8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGYpKXtpZihmIGluc3RhbmNlb2YgbyYmZi50aGVuPT09by5wcm90b3R5cGUudGhlbil7Zm9yKDszPT09Zi5fMzc7KWY9Zi5fMTI7cmV0dXJuIDE9PT1mLl8zNz9yKHUsZi5fMTIpOigyPT09Zi5fMzcmJmUoZi5fMTIpLHZvaWQgZi50aGVuKGZ1bmN0aW9uKG4pe3IodSxuKX0sZSkpfXZhciBjPWYudGhlbjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBjKXt2YXIgcz1uZXcgbyhjLmJpbmQoZikpO3JldHVybiB2b2lkIHMudGhlbihmdW5jdGlvbihuKXtyKHUsbil9LGUpfX10W3VdPWYsMD09PS0taSYmbih0KX1pZigwPT09dC5sZW5ndGgpcmV0dXJuIG4oW10pO2Zvcih2YXIgaT10Lmxlbmd0aCx1PTA7dTx0Lmxlbmd0aDt1Kyspcih1LHRbdV0pfSl9LG8ucmVqZWN0PWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgbyhmdW5jdGlvbih0LGUpe2Uobil9KX0sby5yYWNlPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgbyhmdW5jdGlvbih0LGUpe24uZm9yRWFjaChmdW5jdGlvbihuKXtvLnJlc29sdmUobikudGhlbih0LGUpfSl9KX0sby5wcm90b3R5cGVbXCJjYXRjaFwiXT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy50aGVuKG51bGwsbil9fSx7XCIuL2NvcmUuanNcIjoxfV0sMzpbZnVuY3Rpb24obix0LGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXtpZihjLmxlbmd0aCl0aHJvdyBjLnNoaWZ0KCl9ZnVuY3Rpb24gbyhuKXt2YXIgdDt0PWYubGVuZ3RoP2YucG9wKCk6bmV3IGksdC50YXNrPW4sdSh0KX1mdW5jdGlvbiBpKCl7dGhpcy50YXNrPW51bGx9dmFyIHU9bihcIi4vcmF3XCIpLGY9W10sYz1bXSxzPXUubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKHIpO3QuZXhwb3J0cz1vLGkucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oKXt0cnl7dGhpcy50YXNrLmNhbGwoKX1jYXRjaChuKXtvLm9uZXJyb3I/by5vbmVycm9yKG4pOihjLnB1c2gobikscygpKX1maW5hbGx5e3RoaXMudGFzaz1udWxsLGZbZi5sZW5ndGhdPXRoaXN9fX0se1wiLi9yYXdcIjo0fV0sNDpbZnVuY3Rpb24obix0LGUpeyhmdW5jdGlvbihuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKG4pe2YubGVuZ3RofHwodSgpLGM9ITApLGZbZi5sZW5ndGhdPW59ZnVuY3Rpb24gcigpe2Zvcig7czxmLmxlbmd0aDspe3ZhciBuPXM7aWYocys9MSxmW25dLmNhbGwoKSxzPmwpe2Zvcih2YXIgdD0wLGU9Zi5sZW5ndGgtcztlPnQ7dCsrKWZbdF09Zlt0K3NdO2YubGVuZ3RoLT1zLHM9MH19Zi5sZW5ndGg9MCxzPTAsYz0hMX1mdW5jdGlvbiBvKG4pe3ZhciB0PTEsZT1uZXcgYShuKSxyPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO3JldHVybiBlLm9ic2VydmUocix7Y2hhcmFjdGVyRGF0YTohMH0pLGZ1bmN0aW9uKCl7dD0tdCxyLmRhdGE9dH19ZnVuY3Rpb24gaShuKXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7Y2xlYXJUaW1lb3V0KGUpLGNsZWFySW50ZXJ2YWwociksbigpfXZhciBlPXNldFRpbWVvdXQodCwwKSxyPXNldEludGVydmFsKHQsNTApfX10LmV4cG9ydHM9ZTt2YXIgdSxmPVtdLGM9ITEscz0wLGw9MTAyNCxhPW4uTXV0YXRpb25PYnNlcnZlcnx8bi5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO3U9XCJmdW5jdGlvblwiPT10eXBlb2YgYT9vKHIpOmkociksZS5yZXF1ZXN0Rmx1c2g9dSxlLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcj1pfSkuY2FsbCh0aGlzLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6e30pfSx7fV0sNTpbZnVuY3Rpb24obix0LGUpe1wiZnVuY3Rpb25cIiE9dHlwZW9mIFByb21pc2UucHJvdG90eXBlLmRvbmUmJihQcm9taXNlLnByb3RvdHlwZS5kb25lPWZ1bmN0aW9uKG4sdCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD90aGlzLnRoZW4uYXBwbHkodGhpcyxhcmd1bWVudHMpOnRoaXM7ZS50aGVuKG51bGwsZnVuY3Rpb24obil7c2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IG59LDApfSl9KX0se31dLDY6W2Z1bmN0aW9uKG4sdCxlKXtuKFwiYXNhcFwiKTtcInVuZGVmaW5lZFwiPT10eXBlb2YgUHJvbWlzZSYmKFByb21pc2U9bihcIi4vbGliL2NvcmUuanNcIiksbihcIi4vbGliL2VzNi1leHRlbnNpb25zLmpzXCIpKSxuKFwiLi9wb2x5ZmlsbC1kb25lLmpzXCIpfSx7XCIuL2xpYi9jb3JlLmpzXCI6MSxcIi4vbGliL2VzNi1leHRlbnNpb25zLmpzXCI6MixcIi4vcG9seWZpbGwtZG9uZS5qc1wiOjUsYXNhcDozfV19LHt9LFs2XSk7XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDEyIEJhcm5lc2FuZG5vYmxlLmNvbSwgbGxjLCBEb25hdm9uIFdlc3QsIGFuZCBEb21lbmljIERlbmljb2xhXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciBzZXRJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3MpIHtcbiAgICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHBhcnRpYWxseUFwcGxpZWQuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHNldEltbWVkaWF0ZSwgYnV0XG4gICAgLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVxdWlyZXMgbm8gYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIHBhcnRpYWxseUFwcGxpZWQoaGFuZGxlcikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChuZXcgRnVuY3Rpb24oXCJcIiArIGhhbmRsZXIpKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFzaygpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgc2V0VGltZW91dChwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0oZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXM7fSgpKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVmlld3BvcnQoKSB7XG5cbiAgICAgICAgdGhpcy5QUkVfSU9TN19WSUVXUE9SVCA9IFwiaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEsIHVzZXItc2NhbGFibGU9bm9cIjtcbiAgICAgICAgdGhpcy5JT1M3X1ZJRVdQT1JUID0gXCJpbml0aWFsLXNjYWxlPTEsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ub1wiO1xuICAgICAgICB0aGlzLkRFRkFVTFRfVklFV1BPUlQgPSBcImluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLCB1c2VyLXNjYWxhYmxlPW5vXCI7XG5cbiAgICAgICAgdGhpcy5lbnN1cmVWaWV3cG9ydEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHt9O1xuICAgICAgICB0aGlzLnBsYXRmb3JtLm5hbWUgPSB0aGlzLmdldFBsYXRmb3JtTmFtZSgpO1xuICAgICAgICB0aGlzLnBsYXRmb3JtLnZlcnNpb24gPSB0aGlzLmdldFBsYXRmb3JtVmVyc2lvbigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuZW5zdXJlVmlld3BvcnRFbGVtZW50ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG4gICAgICAgIGlmKCF0aGlzLnZpZXdwb3J0RWxlbWVudCl7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50Lm5hbWUgPSBcInZpZXdwb3J0XCI7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMudmlld3BvcnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdwb3J0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1uby1hZGp1c3QnKSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnZpZXdwb3J0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0ubmFtZSA9PSAnaW9zJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsYXRmb3JtLnZlcnNpb24gPj0gNyAmJiBpc1dlYlZpZXcoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCB0aGlzLklPUzdfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY29udGVudCcsIHRoaXMuUFJFX0lPUzdfVklFV1BPUlQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgdGhpcy5ERUZBVUxUX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzV2ViVmlldygpIHtcbiAgICAgICAgICAgIHJldHVybiAhISh3aW5kb3cuY29yZG92YSB8fCB3aW5kb3cucGhvbmVnYXAgfHwgd2luZG93LlBob25lR2FwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuZ2V0UGxhdGZvcm1OYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJhbmRyb2lkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvaVBob25lfGlQYWR8aVBvZC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaW9zXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1bmtub3duXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5nZXRQbGF0Zm9ybVZlcnNpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignT1MgJyk7XG4gICAgICAgIHJldHVybiB3aW5kb3cuTnVtYmVyKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnN1YnN0cihzdGFydCArIDMsIDMpLnJlcGxhY2UoJ18nLCAnLicpKTtcbiAgICB9O1xuXG4gICAgd2luZG93LlZpZXdwb3J0ID0gVmlld3BvcnQ7XG59KSgpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgT3BlbiBUZWNobm9sb2dpZXMsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLiAgU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4vLyBKYXZhU2NyaXB0IER5bmFtaWMgQ29udGVudCBzaGltIGZvciBXaW5kb3dzIFN0b3JlIGFwcHNcbihmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAod2luZG93Lk1TQXBwICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG5cbiAgICAgICAgLy8gU29tZSBub2RlcyB3aWxsIGhhdmUgYW4gXCJhdHRyaWJ1dGVzXCIgcHJvcGVydHkgd2hpY2ggc2hhZG93cyB0aGUgTm9kZS5wcm90b3R5cGUuYXR0cmlidXRlcyBwcm9wZXJ0eVxuICAgICAgICAvLyAgYW5kIG1lYW5zIHdlIGRvbid0IGFjdHVhbGx5IHNlZSB0aGUgYXR0cmlidXRlcyBvZiB0aGUgTm9kZSAoaW50ZXJlc3RpbmdseSB0aGUgVlMgZGVidWcgY29uc29sZVxuICAgICAgICAvLyAgYXBwZWFycyB0byBzdWZmZXIgZnJvbSB0aGUgc2FtZSBpc3N1ZSkuXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBFbGVtZW50X3NldEF0dHJpYnV0ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsIFwic2V0QXR0cmlidXRlXCIpLnZhbHVlO1xuICAgICAgICB2YXIgRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEVsZW1lbnQucHJvdG90eXBlLCBcInJlbW92ZUF0dHJpYnV0ZVwiKS52YWx1ZTtcbiAgICAgICAgdmFyIEhUTUxFbGVtZW50X2luc2VydEFkamFjZW50SFRNTFByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBcImluc2VydEFkamFjZW50SFRNTFwiKTtcbiAgICAgICAgdmFyIE5vZGVfZ2V0X2F0dHJpYnV0ZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5vZGUucHJvdG90eXBlLCBcImF0dHJpYnV0ZXNcIikuZ2V0O1xuICAgICAgICB2YXIgTm9kZV9nZXRfY2hpbGROb2RlcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsIFwiY2hpbGROb2Rlc1wiKS5nZXQ7XG4gICAgICAgIHZhciBkZXRlY3Rpb25EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVfZ2V0X2F0dHJpYnV0ZXMuY2FsbChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEVsZW1lbnRfc2V0QXR0cmlidXRlLmNhbGwoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZS5jYWxsKGVsZW1lbnQsIGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGlsZE5vZGVzKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlX2dldF9jaGlsZE5vZGVzLmNhbGwoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlbXB0eShlbGVtZW50KSB7XG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0QWRqYWNlbnRIVE1MKGVsZW1lbnQsIHBvc2l0aW9uLCBodG1sKSB7XG4gICAgICAgICAgICBIVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEhUTUxQcm9wZXJ0eURlc2NyaXB0b3IudmFsdWUuY2FsbChlbGVtZW50LCBwb3NpdGlvbiwgaHRtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpblVuc2FmZU1vZGUoKSB7XG4gICAgICAgICAgICB2YXIgaXNVbnNhZmUgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRlY3Rpb25EaXYuaW5uZXJIVE1MID0gXCI8dGVzdC8+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBpc1Vuc2FmZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNVbnNhZmU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhbnNlKGh0bWwsIHRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBjbGVhbmVyID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiY2xlYW5lclwiKTtcbiAgICAgICAgICAgIGVtcHR5KGNsZWFuZXIuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRBZGphY2VudEhUTUwoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQsIFwiYWZ0ZXJiZWdpblwiLCBodG1sKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2NyaXB0cyA9IGNsZWFuZXIuZG9jdW1lbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHNjcmlwdHMsIGZ1bmN0aW9uIChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNjcmlwdC50eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSBcInRleHQvaW5lcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2VjbWFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQveC1qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2pzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvbGl2ZXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qYXZhc2NyaXB0MS4xXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHQxLjJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvamF2YXNjcmlwdDEuM1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSBcInRleHQvaW5lcnQtXCIgKyBzY3JpcHQudHlwZS5zbGljZShcInRleHQvXCIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24veC1qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwiYXBwbGljYXRpb24vaW5lcnQtXCIgKyBzY3JpcHQudHlwZS5zbGljZShcImFwcGxpY2F0aW9uL1wiLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFuc2VBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgYXR0cmlidXRlcyBjb2xsZWN0aW9uIGlzIGxpdmUgaXQgaXMgc2ltcGxlciB0byBxdWV1ZSB1cCB0aGUgcmVuYW1lc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChuYW1lWzBdID09PSBcIm9cIiB8fCBuYW1lWzBdID09PSBcIk9cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZVsxXSA9PT0gXCJuXCIgfHwgbmFtZVsxXSA9PT0gXCJOXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHsgbmFtZTogYXR0cmlidXRlLm5hbWUsIHZhbHVlOiBhdHRyaWJ1dGUudmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBldmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgXCJ4LVwiICsgYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gY2hpbGROb2RlcyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5zZUF0dHJpYnV0ZXMoY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFuc2VBdHRyaWJ1dGVzKGNsZWFuZXIuZG9jdW1lbnRFbGVtZW50KTtcblxuICAgICAgICAgICAgdmFyIGNsZWFuZWROb2RlcyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudC50YWdOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbmVkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5lci5oZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWROb2RlcyA9IGNsZWFuZWROb2Rlcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYWRvcHROb2RlKGNsZWFuZXIuaGVhZCkuY2hpbGROb2RlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5lci5ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWROb2RlcyA9IGNsZWFuZWROb2Rlcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYWRvcHROb2RlKGNsZWFuZXIuYm9keSkuY2hpbGROb2RlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNsZWFuZWROb2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuc2VQcm9wZXJ0eVNldHRlcihwcm9wZXJ0eSwgc2V0dGVyKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFNldHRlciA9IHByb3BlcnR5RGVzY3JpcHRvci5zZXQ7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgICAgIGdldDogcHJvcGVydHlEZXNjcmlwdG9yLmdldCxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZih3aW5kb3cuV2luSlMgJiYgd2luZG93LldpbkpTLl9leGVjVW5zYWZlICYmIGluVW5zYWZlTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFNldHRlci5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IGNsZWFuc2UodmFsdWUsIHRoYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcihwcm9wZXJ0eURlc2NyaXB0b3IsIHRoYXQsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBwcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhbnNlUHJvcGVydHlTZXR0ZXIoXCJpbm5lckhUTUxcIiwgZnVuY3Rpb24gKHByb3BlcnR5RGVzY3JpcHRvciwgdGFyZ2V0LCBlbGVtZW50cykge1xuICAgICAgICAgICAgZW1wdHkodGFyZ2V0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbGVtZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhbnNlUHJvcGVydHlTZXR0ZXIoXCJvdXRlckhUTUxcIiwgZnVuY3Rpb24gKHByb3BlcnR5RGVzY3JpcHRvciwgdGFyZ2V0LCBlbGVtZW50cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG59KCkpOyIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdW53cmFwID0gc3RyaW5nID0+IHN0cmluZy5zbGljZSgxLCAtMSk7XG5jb25zdCBpc09iamVjdFN0cmluZyA9IHN0cmluZyA9PiBzdHJpbmcuc3RhcnRzV2l0aCgneycpICYmIHN0cmluZy5lbmRzV2l0aCgnfScpO1xuY29uc3QgaXNBcnJheVN0cmluZyA9IHN0cmluZyA9PiBzdHJpbmcuc3RhcnRzV2l0aCgnWycpICYmIHN0cmluZy5lbmRzV2l0aCgnXScpO1xuY29uc3QgaXNRdW90ZWRTdHJpbmcgPSBzdHJpbmcgPT4gKHN0cmluZy5zdGFydHNXaXRoKCdcXCcnKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ1xcJycpKSB8fCAoc3RyaW5nLnN0YXJ0c1dpdGgoJ1wiJykgJiYgc3RyaW5nLmVuZHNXaXRoKCdcIicpKTtcblxuY29uc3QgZXJyb3IgPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHRva2VuIFxcJycgKyB0b2tlbiArICdcXCcgYXQgcG9zaXRpb24gJyArIChvcmlnaW5hbFN0cmluZy5sZW5ndGggLSBzdHJpbmcubGVuZ3RoIC0gMSkgKyAnIGluIHN0cmluZzogXFwnJyArIG9yaWdpbmFsU3RyaW5nICsgJ1xcJycpO1xufTtcblxuY29uc3QgcHJvY2Vzc1Rva2VuID0gKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSA9PiB7XG4gIGlmICh0b2tlbiA9PT0gJ3RydWUnIHx8IHRva2VuID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIHRva2VuID09PSAndHJ1ZSc7XG4gIH0gZWxzZSBpZiAoaXNRdW90ZWRTdHJpbmcodG9rZW4pKSB7XG4gICAgcmV0dXJuIHVud3JhcCh0b2tlbik7XG4gIH0gZWxzZSBpZiAoIWlzTmFOKHRva2VuKSkge1xuICAgIHJldHVybiArKHRva2VuKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdFN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3QodW53cmFwKHRva2VuKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheSh1bndyYXAodG9rZW4pKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gIH1cbn07XG5cbmNvbnN0IG5leHRUb2tlbiA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW1MZWZ0KCk7XG4gIGxldCBsaW1pdCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgaWYgKHN0cmluZ1swXSA9PT0gJzonIHx8IHN0cmluZ1swXSA9PT0gJywnKSB7XG5cbiAgICBsaW1pdCA9IDE7XG5cbiAgfSBlbHNlIGlmIChzdHJpbmdbMF0gPT09ICd7JyB8fCBzdHJpbmdbMF0gPT09ICdbJykge1xuXG4gICAgY29uc3QgYyA9IHN0cmluZy5jaGFyQ29kZUF0KDApO1xuICAgIGxldCBuZXN0ZWRPYmplY3QgPSAxO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IGMpIHtcbiAgICAgICAgbmVzdGVkT2JqZWN0Kys7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09PSBjICsgMikge1xuICAgICAgICBuZXN0ZWRPYmplY3QtLTtcbiAgICAgICAgaWYgKG5lc3RlZE9iamVjdCA9PT0gMCkge1xuICAgICAgICAgIGxpbWl0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIGlmIChzdHJpbmdbMF0gPT09ICdcXCcnIHx8IHN0cmluZ1swXSA9PT0gJ1xcXCInKSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZ1tpXSA9PT0gc3RyaW5nWzBdKSB7XG4gICAgICAgIGxpbWl0ID0gaSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2Uge1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChbJyAnLCAnLCcsICc6J10uaW5kZXhPZihzdHJpbmdbaV0pICE9PSAtMSkge1xuICAgICAgICBsaW1pdCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBsaW1pdCk7XG59O1xuXG5jb25zdCBwYXJzZU9iamVjdCA9IChzdHJpbmcpID0+IHtcbiAgY29uc3QgaXNWYWxpZEtleSA9IGtleSA9PiAvXltBLVpfXFwkXVtBLVowLTlfXFwkXSokL2kudGVzdChrZXkpO1xuXG4gIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG4gIGNvbnN0IG9yaWdpbmFsU3RyaW5nID0gc3RyaW5nO1xuICBjb25zdCBvYmplY3QgPSB7fTtcbiAgbGV0IHJlYWRpbmdLZXkgPSB0cnVlLCBrZXksIHByZXZpb3VzVG9rZW4sIHRva2VuO1xuXG4gIHdoaWxlKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHRva2VuID0gbmV4dFRva2VuKHN0cmluZyk7XG4gICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCwgc3RyaW5nLmxlbmd0aCkudHJpbUxlZnQoKTtcblxuICAgIGlmICgodG9rZW4gPT09ICc6JyAmJiAoIXJlYWRpbmdLZXkgfHwgIXByZXZpb3VzVG9rZW4gfHwgcHJldmlvdXNUb2tlbiA9PT0gJywnKSlcbiAgICAgICB8fCAodG9rZW4gPT09ICcsJyAmJiByZWFkaW5nS2V5KVxuICAgICAgIHx8ICh0b2tlbiAhPT0gJzonICYmIHRva2VuICE9PSAnLCcgJiYgKHByZXZpb3VzVG9rZW4gJiYgcHJldmlvdXNUb2tlbiAhPT0gJywnICYmIHByZXZpb3VzVG9rZW4gIT09ICc6JykpKSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJzonICYmIHJlYWRpbmdLZXkgJiYgcHJldmlvdXNUb2tlbikge1xuICAgICAgaWYgKGlzVmFsaWRLZXkocHJldmlvdXNUb2tlbikpIHtcbiAgICAgICAga2V5ID0gcHJldmlvdXNUb2tlbjtcbiAgICAgICAgcmVhZGluZ0tleSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSB0b2tlbiBcXCcnICsgcHJldmlvdXNUb2tlbiArICdcXCcgYXQgcG9zaXRpb24gMCBpbiBzdHJpbmc6IFxcJycgKyBvcmlnaW5hbFN0cmluZyArICdcXCcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnLCcgJiYgIXJlYWRpbmdLZXkgJiYgcHJldmlvdXNUb2tlbikge1xuICAgICAgb2JqZWN0W2tleV0gPSBwcm9jZXNzVG9rZW4ocHJldmlvdXNUb2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgICByZWFkaW5nS2V5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9rZW4pIHtcbiAgICBvYmplY3Rba2V5XSA9IHByb2Nlc3NUb2tlbih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufTtcblxuY29uc3QgcGFyc2VBcnJheSA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgY29uc3Qgb3JpZ2luYWxTdHJpbmcgPSBzdHJpbmc7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGxldCBwcmV2aW91c1Rva2VuLCB0b2tlbjtcblxuICB3aGlsZShzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcbiAgICB0b2tlbiA9IG5leHRUb2tlbihzdHJpbmcpO1xuICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSh0b2tlbi5sZW5ndGgsIHN0cmluZy5sZW5ndGgpLnRyaW1MZWZ0KCk7XG5cbiAgICBpZiAodG9rZW4gPT09ICcsJyAmJiAoIXByZXZpb3VzVG9rZW4gfHwgcHJldmlvdXNUb2tlbiA9PT0gJywnKSkge1xuICAgICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJykge1xuICAgICAgYXJyYXkucHVzaChwcm9jZXNzVG9rZW4ocHJldmlvdXNUb2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIGlmICh0b2tlbiAhPT0gJywnKSB7XG4gICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuY29uc3QgcGFyc2UgPSAoc3RyaW5nKSA9PiB7XG4gIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG5cbiAgaWYgKGlzT2JqZWN0U3RyaW5nKHN0cmluZykpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3QodW53cmFwKHN0cmluZykpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlTdHJpbmcoc3RyaW5nKSkge1xuICAgIHJldHVybiBwYXJzZUFycmF5KHVud3JhcChzdHJpbmcpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHN0cmluZyBtdXN0IGJlIG9iamVjdCBvciBhcnJheSBsaWtlOiAnICsgc3RyaW5nKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWF0aW9uT3B0aW9uc1BhcnNlIGZyb20gJy4vYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyJztcblxuY29uc3QgdXRpbCA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG51dGlsLnByZXBhcmVRdWVyeSA9IChxdWVyeSkgPT4ge1xuICByZXR1cm4gcXVlcnkgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHF1ZXJ5IDogKGVsZW1lbnQpID0+IHV0aWwubWF0Y2goZWxlbWVudCwgcXVlcnkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG51dGlsLm1hdGNoID0gKGVsZW1lbnQsIHF1ZXJ5KSA9PiB7XG4gIGlmIChxdWVyeVswXSA9PT0gJy4nKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHF1ZXJ5LnNsaWNlKDEpKTtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBxdWVyeTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICovXG51dGlsLmZpbmRDaGlsZCA9IChlbGVtZW50LCBxdWVyeSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IHV0aWwucHJlcGFyZVF1ZXJ5KHF1ZXJ5KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudC5jaGlsZHJlbltpXTtcbiAgICBpZiAobWF0Y2gobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICovXG51dGlsLmZpbmRQYXJlbnQgPSAoZWxlbWVudCwgcXVlcnkpID0+IHtcbiAgY29uc3QgbWF0Y2ggPSB1dGlsLnByZXBhcmVRdWVyeShxdWVyeSk7XG5cbiAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgZm9yICg7Oykge1xuICAgIGlmICghcGFyZW50IHx8IHBhcmVudCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobWF0Y2gocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG51dGlsLmlzQXR0YWNoZWQgPSAoZWxlbWVudCkgPT4ge1xuICB3aGlsZSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCA9IChlbGVtZW50KSA9PiB7XG4gIHdoaWxlIChlbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKC8ob25zLW5hdmlnYXRvcnxvbnMtdGFiYmFyfG9ucy1zbGlkaW5nLW1lbnV8b25zLXNwbGl0LXZpZXcpLykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0byBwcm9wYWdhdGVcbiAqL1xudXRpbC5wcm9wYWdhdGVBY3Rpb24gPSAoZWxlbWVudCwgYWN0aW9uKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgaWYgKGNoaWxkW2FjdGlvbl0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgY2hpbGRbYWN0aW9uXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbihjaGlsZCwgYWN0aW9uKTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSB0YWcgYW5kIGNsYXNzIG9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICogQHBhcmFtIHtFbGVtZW50fVxuICovXG51dGlsLmNyZWF0ZSA9IChzZWxlY3RvciA9ICcnLCBzdHlsZSA9IHt9KSA9PiB7XG4gIGNvbnN0IGNsYXNzTGlzdCA9IHNlbGVjdG9yLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGNsYXNzTGlzdC5zaGlmdCgpIHx8ICdkaXYnKTtcblxuICBpZiAoY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NMaXN0LmpvaW4oJyAnKTtcbiAgfVxuXG4gIHV0aWwuZXh0ZW5kKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbnV0aWwuY3JlYXRlRWxlbWVudCA9IChodG1sKSA9PiB7XG4gIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgd3JhcHBlci5pbm5lckhUTUwgPSBodG1sO1xuXG4gIGlmICh3cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiaHRtbFwiIG11c3QgYmUgb25lIHdyYXBwZXIgZWxlbWVudC4nKTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVyLmNoaWxkcmVuWzBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7SFRNTEZyYWdtZW50fVxuICovXG51dGlsLmNyZWF0ZUZyYWdtZW50ID0gKGh0bWwpID0+IHtcbiAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB3cmFwcGVyLmlubmVySFRNTCA9IGh0bWw7XG4gIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcblxuLypcbiAqIEBwYXJhbSB7T2JqZWN0fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNyYyBTb3VyY2Ugb2JqZWN0KHMpLlxuICogQHJldHVybnMge09iamVjdH0gUmVmZXJlbmNlIHRvIGBkc3RgLlxuICovXG51dGlsLmV4dGVuZCA9IChkc3QsIC4uLmFyZ3MpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFyZ3NbaV0pIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmdzW2ldKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2pdO1xuICAgICAgICBkc3Rba2V5XSA9IGFyZ3NbaV1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZHN0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJyYXlMaWtlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xudXRpbC5hcnJheUZyb20gPSAoYXJyYXlMaWtlKSA9PiB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXlMaWtlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGpzb25TdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmFpbFNhZmVdXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnV0aWwucGFyc2VKU09OT2JqZWN0U2FmZWx5ID0gKGpzb25TdHJpbmcsIGZhaWxTYWZlID0ge30pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKCcnICsganNvblN0cmluZyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWlsU2FmZTtcbiAgfVxuICByZXR1cm4gZmFpbFNhZmU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gcGF0aCBzdWNoIGFzICdteUFwcC5jb250cm9sbGVycy5kYXRhLmxvYWREYXRhJ1xuICogQHJldHVybiB7QW55fSAtIHdoYXRldmVyIGlzIGxvY2F0ZWQgYXQgdGhhdCBwYXRoXG4gKi9cbnV0aWwuZmluZEZyb21QYXRoID0gKHBhdGgpID0+IHtcbiAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgdmFyIGVsID0gd2luZG93LCBrZXk7XG4gIHdoaWxlIChrZXkgPSBwYXRoLnNoaWZ0KCkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgIGVsID0gZWxba2V5XTtcbiAgfVxuICByZXR1cm4gZWw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxdXG4gKiBAcmV0dXJuIHtDdXN0b21FdmVudH1cbiAqL1xudXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50ID0gKHRhcmdldCwgZXZlbnROYW1lLCBkZXRhaWwgPSB7fSkgPT4ge1xuXG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICBkZXRhaWw6IGRldGFpbFxuICB9KTtcblxuICBPYmplY3Qua2V5cyhkZXRhaWwpLmZvckVhY2goa2V5ID0+IHtcbiAgICBldmVudFtrZXldID0gZGV0YWlsW2tleV07XG4gIH0pO1xuXG4gIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICByZXR1cm4gZXZlbnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG51dGlsLmhhc01vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lKSA9PiB7XG4gIGlmICghdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKS5zcGxpdCgvXFxzKy8pLnNvbWUoZSA9PiBlID09PSBtb2RpZmllck5hbWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpdCB3YXMgYWRkZWQgb3Igbm90LlxuICovXG51dGlsLmFkZE1vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lKSA9PiB7XG4gIGlmICh1dGlsLmhhc01vZGlmaWVyKHRhcmdldCwgbW9kaWZpZXJOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG1vZGlmaWVyTmFtZSA9IG1vZGlmaWVyTmFtZS50cmltKCk7XG4gIGNvbnN0IG1vZGlmaWVyQXR0cmlidXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJztcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCAobW9kaWZpZXJBdHRyaWJ1dGUgKyAnICcgKyBtb2RpZmllck5hbWUpLnRyaW0oKSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpdCB3YXMgZm91bmQgb3Igbm90LlxuICovXG51dGlsLnJlbW92ZU1vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lKSA9PiB7XG4gIGlmICghdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IG1vZGlmaWVycyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykuc3BsaXQoL1xccysvKTtcblxuICBjb25zdCBuZXdNb2RpZmllcnMgPSBtb2RpZmllcnMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAmJiBpdGVtICE9PSBtb2RpZmllck5hbWUpO1xuICB0YXJnZXQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG5ld01vZGlmaWVycy5qb2luKCcgJykpO1xuXG4gIHJldHVybiBtb2RpZmllcnMubGVuZ3RoICE9PSBuZXdNb2RpZmllcnMubGVuZ3RoO1xufTtcblxudXRpbC51cGRhdGVQYXJlbnRQb3NpdGlvbiA9IChlbCkgPT4ge1xuICBpZiAoIWVsLl9wYXJlbnRVcGRhdGVkICYmIGVsLnBhcmVudEVsZW1lbnQpIHtcbiAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwucGFyZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIGVsLnBhcmVudEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBlbC5fcGFyZW50VXBkYXRlZCA9IHRydWU7XG4gIH1cbn07XG5cbnV0aWwudG9nZ2xlQXR0cmlidXRlID0gKGVsZW1lbnQsIG5hbWUsIGVuYWJsZSkgPT4ge1xuICBpZiAoZW5hYmxlKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59O1xuXG51dGlsLmJpbmRMaXN0ZW5lcnMgPSAoZWxlbWVudCwgbGlzdGVuZXJOYW1lcykgPT4ge1xuICBsaXN0ZW5lck5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgY29uc3QgYm91bmROYW1lID0gbmFtZS5yZXBsYWNlKC9eX1thLXpdLywgJ19ib3VuZCcgKyBuYW1lWzFdLnRvVXBwZXJDYXNlKCkpO1xuICAgIGVsZW1lbnRbYm91bmROYW1lXSA9IGVsZW1lbnRbYm91bmROYW1lXSB8fCBlbGVtZW50W25hbWVdLmJpbmQoZWxlbWVudCk7XG4gIH0pO1xufTtcblxudXRpbC5lYWNoID0gKG9iaiwgZikgPT4gT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiBmKGtleSwgb2JqW2tleV0pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cbnV0aWwudXBkYXRlUmlwcGxlID0gKHRhcmdldCkgPT4ge1xuICBjb25zdCByaXBwbGVFbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGFyZ2V0LCAnb25zLXJpcHBsZScpO1xuXG4gIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKSkge1xuICAgIGlmICghcmlwcGxlRWxlbWVudCkge1xuICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtcmlwcGxlJyksIHRhcmdldC5maXJzdENoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmlwcGxlRWxlbWVudCkge1xuICAgIHJpcHBsZUVsZW1lbnQucmVtb3ZlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlID0gYW5pbWF0aW9uT3B0aW9uc1BhcnNlO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xudXRpbC5pc0ludGVnZXIgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICBpc0Zpbml0ZSh2YWx1ZSkgJiZcbiAgICBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIOWIpOaWreivpeWFg+e0oOaYr+WQpuWtmOWcqOivpeagt+W8j+exu1xuICogQHBhcmFtIHRhcmdldCDopoHliKTmlq3nmoTlhYPntKBcbiAqIEBwYXJhbSBjbGFzc05hbWUg6KaB5Yik5pat55qE5qC35byP57G7XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudXRpbC5oYXNDbGFzcyA9ICh0YXJnZXQsIGNsYXNzTmFtZSkgPT4ge1xuICBsZXQgZmxhZyA9IGZhbHNlO1xuICBpZih0YXJnZXQpe1xuICAgIGNvbnN0IHRhcmdldENsYXNzID0gdGFyZ2V0LmNsYXNzTmFtZTtcbiAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAoJ14nK2NsYXNzTmFtZSsnJHxeJytjbGFzc05hbWUrJyB8ICcrY2xhc3NOYW1lKycgfCAnK2NsYXNzTmFtZSsnJCcpO1xuICAgIGlmKHJlLnRlc3QodGFyZ2V0Q2xhc3MpKXtcbiAgICAgIGZsYWcgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmxhZztcbn07XG5cbi8qKlxuICog5Y675o6J5a2X56ym5Liy5Lik5L6n55qE56m65qC8XG4gKiBAcGFyYW0gc3RyXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xudXRpbC50cmltID0gKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyheXFxzKil8KFxccyokKS9nLCAnJyk7XG59O1xuXG4vKipcbiAqIOiOt+WPluivpeWFg+e0oOaJgOWcqOeahOS9jee9rmluZGV4XG4gKiBAcGFyYW0gZWxlbWVudE9ialxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xudXRpbC5nZXRFbGVtZW50SW5kZXggPSAoZWxlbWVudE9iaikgPT4ge1xuICBjb25zdCBwYXJlbnRPYmogPSBlbGVtZW50T2JqLnBhcmVudE5vZGU7XG4gIGNvbnN0IGNoaWxkcmVucyA9IHBhcmVudE9iai5jaGlsZE5vZGVzO1xuICBjb25zdCBjaGlsZHJlbnNMZW4gPSBjaGlsZHJlbnMubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuICBmb3IobGV0IGk9MDsgaTxjaGlsZHJlbnNMZW47IGkrKyl7XG4gICAgaWYoZWxlbWVudE9iaiA9PT0gY2hpbGRyZW5zW2ldKXtcbiAgICAgIGluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIHB45oiW57qv5pWw5a2X6L2s5o2i5oiQcmVt5Y2V5L2NXG4gKiBAcGFyYW0gbnVtXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xudXRpbC5weFRvUmVtID0gKG51bSkgPT4ge1xuICBpZighL3JlbSQvLnRlc3QobnVtKSl7XG4gICAgbnVtID0gKG51bS8yMCkgKyAncmVtJztcbiAgfVxuICByZXR1cm4gbnVtO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXRpbDtcblxuXG51dGlsLm5leHQgPSAoZWxlbWVudCkgPT4ge1xuXG59O1xuIiwiLypcbiAqIEdlc3R1cmUgZGV0ZWN0b3IgbGlicmFyeSB0aGF0IGZvcmtlZCBmcm9tIGdpdGh1Yi5jb20vRWlnaHRNZWRpYS9oYW1tZXIuanMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnQsIFV0aWxzLCBEZXRlY3Rpb24sIFBvaW50ZXJFdmVudDtcblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5HZXN0dXJlRGV0ZWN0b3JcbiAqIEBjYXRlZ29yeSBnZXN0dXJlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVV0aWxpdHkgY2xhc3MgZm9yIGdlc3R1cmUgZGV0ZWN0aW9uLlsvZW5dXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PjgpLmpJznn6XjgZnjgovjgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjgq/jg6njgrnjgafjgZnjgIJbL2phXVxuICovXG5cbi8qKlxuICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICogQHNpZ25hdHVyZSBjb25zdHJ1Y3RvcihlbGVtZW50Wywgb3B0aW9uc10pXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dQ3JlYXRlIGEgbmV3IEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZS5bL2VuXVxuICogIFtqYV1HZXN0dXJlRGV0ZWN0b3Ljga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44KS5qSc55+l44GZ44KLRE9N6KaB57Sg44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXU9wdGlvbnMgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHJldHVybiB7b25zLkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX1cbiAqL1xudmFyIEdlc3R1cmVEZXRlY3RvciA9IGZ1bmN0aW9uIEdlc3R1cmVEZXRlY3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgR2VzdHVyZURldGVjdG9yLkluc3RhbmNlKGVsZW1lbnQsIG9wdGlvbnMgfHwge30pO1xufTtcblxuXG4vKipcbiAqIGRlZmF1bHQgc2V0dGluZ3MuXG4gKiBtb3JlIHNldHRpbmdzIGFyZSBkZWZpbmVkIHBlciBnZXN0dXJlIGF0IGAvZ2VzdHVyZXNgLiBFYWNoIGdlc3R1cmUgY2FuIGJlIGRpc2FibGVkL2VuYWJsZWRcbiAqIGJ5IHNldHRpbmcgaXQncyBuYW1lIChsaWtlIGBzd2lwZWApIHRvIGZhbHNlLlxuICogWW91IGNhbiBzZXQgdGhlIGRlZmF1bHRzIGZvciBhbGwgaW5zdGFuY2VzIGJ5IGNoYW5naW5nIHRoaXMgb2JqZWN0IGJlZm9yZSBjcmVhdGluZyBhbiBpbnN0YW5jZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBgXG4gKiAgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmRyYWcgPSBmYWxzZTtcbiAqICBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuYmVoYXZpb3IudG91Y2hBY3Rpb24gPSAncGFuLXknO1xuICogIGRlbGV0ZSBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuYmVoYXZpb3IudXNlclNlbGVjdDtcbiAqIGBgYGBcbiAqIEBwcm9wZXJ0eSBkZWZhdWx0c1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzID0ge1xuICBiZWhhdmlvcjoge1xuICAgIC8vIHVzZXJTZWxlY3Q6ICdub25lJywgLy8gQWxzbyBkaXNhYmxlcyBzZWxlY3Rpb24gaW4gYGlucHV0YCBjaGlsZHJlblxuICAgIHRvdWNoQWN0aW9uOiAncGFuLXknLFxuICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG4gICAgdXNlckRyYWc6ICdub25lJyxcbiAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gIH1cbn07XG5cbi8qKlxuICogR2VzdHVyZURldGVjdG9yIGRvY3VtZW50IHdoZXJlIHRoZSBiYXNlIGV2ZW50cyBhcmUgYWRkZWQgYXRcbiAqIEBwcm9wZXJ0eSBET0NVTUVOVFxuICogQHR5cGUge0hUTUxFbGVtZW50fVxuICogQGRlZmF1bHQgd2luZG93LmRvY3VtZW50XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCA9IGRvY3VtZW50O1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciBwb2ludGVyIGV2ZW50c1xuICogQHByb3BlcnR5IEhBU19QT0lOVEVSRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTID0gbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciB0b3VjaCBldmVudHNcbiAqIEBwcm9wZXJ0eSBIQVNfVE9VQ0hFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSEFTX1RPVUNIRVZFTlRTID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG5cbi8qKlxuICogZGV0ZWN0IG1vYmlsZSBicm93c2Vyc1xuICogQHByb3BlcnR5IElTX01PQklMRVxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5JU19NT0JJTEUgPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIGRldGVjdCBpZiB3ZSB3YW50IHRvIHN1cHBvcnQgbW91c2VldmVudHMgYXQgYWxsXG4gKiBAcHJvcGVydHkgTk9fTU9VU0VFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuTk9fTU9VU0VFVkVOVFMgPSAoR2VzdHVyZURldGVjdG9yLkhBU19UT1VDSEVWRU5UUyAmJiBHZXN0dXJlRGV0ZWN0b3IuSVNfTU9CSUxFKSB8fCBHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFM7XG5cbi8qKlxuICogaW50ZXJ2YWwgaW4gd2hpY2ggR2VzdHVyZURldGVjdG9yIHJlY2FsY3VsYXRlcyBjdXJyZW50IHZlbG9jaXR5L2RpcmVjdGlvbi9hbmdsZSBpbiBtc1xuICogQHByb3BlcnR5IENBTENVTEFURV9JTlRFUlZBTFxuICogQHR5cGUge051bWJlcn1cbiAqIEBkZWZhdWx0IDI1XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwgPSAyNTtcblxuLyoqXG4gKiBldmVudHR5cGVzIHBlciB0b3VjaGV2ZW50IChzdGFydCwgbW92ZSwgZW5kKSBhcmUgZmlsbGVkIGJ5IGBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzYCBvbiBgc2V0dXBgXG4gKiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBET00gZXZlbnQgbmFtZXMgcGVyIHR5cGUgKGBFVkVOVF9TVEFSVGAsIGBFVkVOVF9NT1ZFYCwgYEVWRU5UX0VORGApXG4gKiBAcHJvcGVydHkgRVZFTlRfVFlQRVNcbiAqIEBwcml2YXRlXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgRVZFTlRfVFlQRVMgPSB7fTtcblxuLyoqXG4gKiBkaXJlY3Rpb24gc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBESVJFQ1RJT05fRE9XTnxMRUZUfFVQfFJJR0hUXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnZG93bicgJ2xlZnQnICd1cCcgJ3JpZ2h0J1xuICovXG52YXIgRElSRUNUSU9OX0RPV04gPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX0RPV04gPSAnZG93bic7XG52YXIgRElSRUNUSU9OX0xFRlQgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XG52YXIgRElSRUNUSU9OX1VQID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9VUCA9ICd1cCc7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG5cbi8qKlxuICogcG9pbnRlcnR5cGUgc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBQT0lOVEVSX01PVVNFfFRPVUNIfFBFTlxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ21vdXNlJyAndG91Y2gnICdwZW4nXG4gKi9cbnZhciBQT0lOVEVSX01PVVNFID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfTU9VU0UgPSAnbW91c2UnO1xudmFyIFBPSU5URVJfVE9VQ0ggPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9UT1VDSCA9ICd0b3VjaCc7XG52YXIgUE9JTlRFUl9QRU4gPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9QRU4gPSAncGVuJztcblxuLyoqXG4gKiBldmVudHR5cGVzXG4gKiBAcHJvcGVydHkgRVZFTlRfU1RBUlR8TU9WRXxFTkR8UkVMRUFTRXxUT1VDSFxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ3N0YXJ0JyAnY2hhbmdlJyAnbW92ZScgJ2VuZCcgJ3JlbGVhc2UnICd0b3VjaCdcbiAqL1xudmFyIEVWRU5UX1NUQVJUID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1NUQVJUID0gJ3N0YXJ0JztcbnZhciBFVkVOVF9NT1ZFID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX01PVkUgPSAnbW92ZSc7XG52YXIgRVZFTlRfRU5EID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX0VORCA9ICdlbmQnO1xudmFyIEVWRU5UX1JFTEVBU0UgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfUkVMRUFTRSA9ICdyZWxlYXNlJztcbnZhciBFVkVOVF9UT1VDSCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9UT1VDSCA9ICd0b3VjaCc7XG5cbi8qKlxuICogaWYgdGhlIHdpbmRvdyBldmVudHMgYXJlIHNldC4uLlxuICogQHByb3BlcnR5IFJFQURZXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5SRUFEWSA9IGZhbHNlO1xuXG4vKipcbiAqIHBsdWdpbnMgbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkgcGx1Z2luc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLnBsdWdpbnMgPSBHZXN0dXJlRGV0ZWN0b3IucGx1Z2lucyB8fCB7fTtcblxuLyoqXG4gKiBnZXN0dXJlcyBuYW1lc3BhY2VcbiAqIHNlZSBgL2dlc3R1cmVzYCBmb3IgdGhlIGRlZmluaXRpb25zXG4gKiBAcHJvcGVydHkgZ2VzdHVyZXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyA9IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyB8fCB7fTtcblxuLyoqXG4gKiBzZXR1cCBldmVudHMgdG8gZGV0ZWN0IGdlc3R1cmVzIG9uIHRoZSBkb2N1bWVudFxuICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBjcmVhdGluZyBhbiBuZXcgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwKCkge1xuICBpZihHZXN0dXJlRGV0ZWN0b3IuUkVBRFkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBmaW5kIHdoYXQgZXZlbnR0eXBlcyB3ZSBhZGQgbGlzdGVuZXJzIHRvXG4gIEV2ZW50LmRldGVybWluZUV2ZW50VHlwZXMoKTtcblxuICAvLyBSZWdpc3RlciBhbGwgZ2VzdHVyZXMgaW5zaWRlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlc1xuICBVdGlscy5lYWNoKEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcywgZnVuY3Rpb24oZ2VzdHVyZSkge1xuICAgIERldGVjdGlvbi5yZWdpc3RlcihnZXN0dXJlKTtcbiAgfSk7XG5cbiAgLy8gQWRkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnRcbiAgRXZlbnQub25Ub3VjaChHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQsIEVWRU5UX01PVkUsIERldGVjdGlvbi5kZXRlY3QpO1xuICBFdmVudC5vblRvdWNoKEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCwgRVZFTlRfRU5ELCBEZXRlY3Rpb24uZGV0ZWN0KTtcblxuICAvLyBHZXN0dXJlRGV0ZWN0b3IgaXMgcmVhZHkuLi4hXG4gIEdlc3R1cmVEZXRlY3Rvci5SRUFEWSA9IHRydWU7XG59XG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqXG4gKiBAY2xhc3MgVXRpbHNcbiAqIEBzdGF0aWNcbiAqL1xuVXRpbHMgPSBHZXN0dXJlRGV0ZWN0b3IudXRpbHMgPSB7XG4gIC8qKlxuICAgKiBleHRlbmQgbWV0aG9kLCBjb3VsZCBhbHNvIGJlIHVzZWQgZm9yIGNsb25pbmcgd2hlbiBgZGVzdGAgaXMgYW4gZW1wdHkgb2JqZWN0LlxuICAgKiBjaGFuZ2VzIHRoZSBkZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXSAgZG8gYSBtZXJnZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGRlc3RcbiAgICovXG4gIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkgJiYgKGRlc3Rba2V5XSA9PT0gdW5kZWZpbmVkIHx8ICFtZXJnZSkpIHtcbiAgICAgICAgZGVzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgYWRkRXZlbnRMaXN0ZW5lciB3cmFwcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgcmVtb3ZlRXZlbnRMaXN0ZW5lciB3cmFwcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZvckVhY2ggb3ZlciBhcnJheXMgYW5kIG9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgKiBAcGFyYW0ge2FueX0gaXRlcmF0b3IuaXRlbVxuICAgKiBAcGFyYW0ge051bWJlcn0gaXRlcmF0b3IuaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGl0ZXJhdG9yLm9iaiB0aGUgc291cmNlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgIGluIHRoZSBpdGVyYXRvclxuICAgKi9cbiAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGksIGxlbjtcblxuICAgIC8vIG5hdGl2ZSBmb3JFYWNoIG9uIGFycmF5c1xuICAgIGlmKCdmb3JFYWNoJyBpbiBvYmopIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIC8vIGFycmF5c1xuICAgIH0gZWxzZSBpZihvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvcihpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gb2JqZWN0c1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IoaSBpbiBvYmopIHtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGkpICYmXG4gICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHRoZSBzdHJpbmcgdXNpbmcgaW5kZXhPZlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBpblN0cjogZnVuY3Rpb24gaW5TdHIoc3JjLCBmaW5kKSB7XG4gICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpID4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seWZpbGxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICAgKi9cbiAgaW5BcnJheTogZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQpIHtcbiAgICBpZihzcmMuaW5kZXhPZikge1xuICAgICAgdmFyIGluZGV4ID0gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgICByZXR1cm4gKGluZGV4ID09PSAtMSkgPyBmYWxzZSA6IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBzcmMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYoc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QgKGBhcmd1bWVudHNgLCBgdG91Y2hsaXN0YCkgdG8gYW4gYXJyYXlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGhhc1BhcmVudDogZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlKG5vZGUpIHtcbiAgICAgIGlmKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgcGFnZVhgLCBgcGFnZVlgLCBgY2xpZW50WGAgYW5kIGBjbGllbnRZYCBwcm9wZXJ0aWVzXG4gICAqL1xuICBnZXRDZW50ZXI6IGZ1bmN0aW9uIGdldENlbnRlcih0b3VjaGVzKSB7XG4gICAgdmFyIHBhZ2VYID0gW10sXG4gICAgICAgIHBhZ2VZID0gW10sXG4gICAgICAgIGNsaWVudFggPSBbXSxcbiAgICAgICAgY2xpZW50WSA9IFtdLFxuICAgICAgICBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlWDogdG91Y2hlc1swXS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IHRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgIGNsaWVudFg6IHRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogdG91Y2hlc1swXS5jbGllbnRZXG4gICAgICB9O1xuICAgIH1cblxuICAgIFV0aWxzLmVhY2godG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIHBhZ2VYLnB1c2godG91Y2gucGFnZVgpO1xuICAgICAgcGFnZVkucHVzaCh0b3VjaC5wYWdlWSk7XG4gICAgICBjbGllbnRYLnB1c2godG91Y2guY2xpZW50WCk7XG4gICAgICBjbGllbnRZLnB1c2godG91Y2guY2xpZW50WSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVg6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVgpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VYKSkgLyAyLFxuICAgICAgcGFnZVk6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVkpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VZKSkgLyAyLFxuICAgICAgY2xpZW50WDogKG1pbi5hcHBseShNYXRoLCBjbGllbnRYKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRYKSkgLyAyLFxuICAgICAgY2xpZW50WTogKG1pbi5hcHBseShNYXRoLCBjbGllbnRZKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRZKSkgLyAyXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAqL1xuICBnZXRWZWxvY2l0eTogZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmFicyhkZWx0YVggLyBkZWx0YVRpbWUpIHx8IDAsXG4gICAgICB5OiBNYXRoLmFicyhkZWx0YVkgLyBkZWx0YVRpbWUpIHx8IDBcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgZ2V0QW5nbGU6IGZ1bmN0aW9uIGdldEFuZ2xlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgfSxcblxuICAvKipcbiAgICogZG8gYSBzbWFsbCBjb21wYXJpc29uIHRvIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHRvdWNoZXMuXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX0xFRlR8UklHSFR8VVB8RE9XTmBcbiAgICovXG4gIGdldERpcmVjdGlvbjogZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSBNYXRoLmFicyh0b3VjaDEuY2xpZW50WCAtIHRvdWNoMi5jbGllbnRYKSxcbiAgICAgICAgeSA9IE1hdGguYWJzKHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkpO1xuXG4gICAgaWYoeCA+PSB5KSB7XG4gICAgICByZXR1cm4gdG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCA+IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkgPiAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gdG91Y2hlc1xuICAgKiBAcGFyYW0ge1RvdWNofXRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICAgKi9cbiAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uIGdldERpc3RhbmNlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byB0b3VjaExpc3RzXG4gICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAgICovXG4gIGdldFNjYWxlOiBmdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgLy8gbmVlZCB0d28gZmluZ2Vycy4uLlxuICAgIGlmKHN0YXJ0Lmxlbmd0aCA+PSAyICYmIGVuZC5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0pIC8gdGhpcy5nZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnNcbiAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdKSAtIHRoaXMuZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgb3V0IGlmIHRoZSBkaXJlY3Rpb24gaXMgdmVydGljYWwgICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX1VQfERPV05gXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzX3ZlcnRpY2FsXG4gICAqL1xuICBpc1ZlcnRpY2FsOiBmdW5jdGlvbiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikge1xuICAgIHJldHVybiBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQIHx8IGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTjtcbiAgfSxcblxuICAvKipcbiAgICogc2V0IGNzcyBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgcHJlZml4ZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzZXRQcmVmaXhlZENzczogZnVuY3Rpb24gc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSkge1xuICAgIHZhciBwcmVmaXhlcyA9IFsnJywgJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgIHByb3AgPSBVdGlscy50b0NhbWVsQ2FzZShwcm9wKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwcm9wO1xuICAgICAgLy8gcHJlZml4ZXNcbiAgICAgIGlmKHByZWZpeGVzW2ldKSB7XG4gICAgICAgIHAgPSBwcmVmaXhlc1tpXSArIHAuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHAuc2xpY2UoMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRlc3QgdGhlIHN0eWxlXG4gICAgICBpZihwIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtwXSA9ICh0b2dnbGUgPT09IG51bGwgfHwgdG9nZ2xlKSAmJiB2YWx1ZSB8fCAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiB0b2dnbGUgYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGJ5IHNldHRpbmcgY3NzIHByb3BlcnRpZXMuXG4gICAqIGB1c2VyU2VsZWN0PSdub25lJ2AgYWxzbyBzZXRzIGBlbGVtZW50Lm9uc2VsZWN0c3RhcnRgIHRvIGZhbHNlXG4gICAqIGB1c2VyRHJhZz0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbmRyYWdzdGFydGAgdG8gZmFsc2VcbiAgICpcbiAgICogQHBhcmFtIHtIdG1sRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAqL1xuICB0b2dnbGVCZWhhdmlvcjogZnVuY3Rpb24gdG9nZ2xlQmVoYXZpb3IoZWxlbWVudCwgcHJvcHMsIHRvZ2dsZSkge1xuICAgIGlmKCFwcm9wcyB8fCAhZWxlbWVudCB8fCAhZWxlbWVudC5zdHlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgY3NzIHByb3BlcnRpZXNcbiAgICBVdGlscy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcHJvcCkge1xuICAgICAgVXRpbHMuc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZmFsc2VGbiA9IHRvZ2dsZSAmJiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gYWxzbyB0aGUgZGlzYWJsZSBvbnNlbGVjdHN0YXJ0XG4gICAgaWYocHJvcHMudXNlclNlbGVjdCA9PSAnbm9uZScpIHtcbiAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG4gICAgfVxuICAgIC8vIGFuZCBkaXNhYmxlIG9uZHJhZ3N0YXJ0XG4gICAgaWYocHJvcHMudXNlckRyYWcgPT0gJ25vbmUnKSB7XG4gICAgICBlbGVtZW50Lm9uZHJhZ3N0YXJ0ID0gZmFsc2VGbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYSBzdHJpbmcgd2l0aCB1bmRlcnNjb3JlcyB0byBjYW1lbENhc2VcbiAgICogc28gcHJldmVudF9kZWZhdWx0IGJlY29tZXMgcHJldmVudERlZmF1bHRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNhbWVsQ2FzZVN0clxuICAgKi9cbiAgdG9DYW1lbENhc2U6IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW18tXShbYS16XSkvZywgZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHNbMV0udG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKi9cbi8qKlxuICogQGNsYXNzIEV2ZW50XG4gKiBAc3RhdGljXG4gKi9cbkV2ZW50ID0gR2VzdHVyZURldGVjdG9yLmV2ZW50ID0ge1xuICAvKipcbiAgICogd2hlbiB0b3VjaCBldmVudHMgaGF2ZSBiZWVuIGZpcmVkLCB0aGlzIGlzIHRydWVcbiAgICogdGhpcyBpcyB1c2VkIHRvIHN0b3AgbW91c2UgZXZlbnRzXG4gICAqIEBwcm9wZXJ0eSBwcmV2ZW50X21vdXNlZXZlbnRzXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgcHJldmVudE1vdXNlRXZlbnRzOiBmYWxzZSxcblxuICAvKipcbiAgICogaWYgRVZFTlRfU1RBUlQgaGFzIGJlZW4gZmlyZWRcbiAgICogQHByb3BlcnR5IHN0YXJ0ZWRcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzdGFydGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogd2hlbiB0aGUgbW91c2UgaXMgaG9sZCBkb3duLCB0aGlzIGlzIHRydWVcbiAgICogQHByb3BlcnR5IHNob3VsZF9kZXRlY3RcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzaG91bGREZXRlY3Q6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgYmluZGVyIHdpdGggYSBob29rIGFuZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB0eXBlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBob29rKSB7XG4gICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIFV0aWxzLm9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xuICAgICAgaG9vayAmJiBob29rKHR5cGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgdW5iaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgaG9vaykge1xuICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBVdGlscy5vZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlcik7XG4gICAgICBob29rICYmIGhvb2sodHlwZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRoZSBjb3JlIHRvdWNoIGV2ZW50IGhhbmRsZXIuXG4gICAqIHRoaXMgZmluZHMgb3V0IGlmIHdlIHNob3VsZCB0byBkZXRlY3QgZ2VzdHVyZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm4gb25Ub3VjaEhhbmRsZXIge0Z1bmN0aW9ufSB0aGUgY29yZSBldmVudCBoYW5kbGVyXG4gICAqL1xuICBvblRvdWNoOiBmdW5jdGlvbiBvblRvdWNoKGVsZW1lbnQsIGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBvblRvdWNoSGFuZGxlciA9IGZ1bmN0aW9uIG9uVG91Y2hIYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgc3JjVHlwZSA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBpc1BvaW50ZXIgPSBHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMsXG4gICAgICAgICAgaXNNb3VzZSA9IFV0aWxzLmluU3RyKHNyY1R5cGUsICdtb3VzZScpLFxuICAgICAgICAgIHRyaWdnZXJUeXBlO1xuXG4gICAgICAvLyBpZiB3ZSBhcmUgaW4gYSBtb3VzZWV2ZW50LCBidXQgdGhlcmUgaGFzIGJlZW4gYSB0b3VjaGV2ZW50IHRyaWdnZXJlZCBpbiB0aGlzIHNlc3Npb25cbiAgICAgIC8vIHdlIHdhbnQgdG8gZG8gbm90aGluZy4gc2ltcGx5IGJyZWFrIG91dCBvZiB0aGUgZXZlbnQuXG4gICAgICBpZihpc01vdXNlICYmIHNlbGYucHJldmVudE1vdXNlRXZlbnRzKSB7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyBtb3VzZWJ1dHRvbiBtdXN0IGJlIGRvd25cbiAgICAgIH0gZWxzZSBpZihpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSAoZXYuYnV0dG9ucyA9PT0gMSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfVE9VQ0gsIGV2KSk7XG4gICAgICAgIC8vIGp1c3QgYSB2YWxpZCBzdGFydCBldmVudCwgYnV0IG5vIG1vdXNlXG4gICAgICB9IGVsc2UgaWYoIWlzTW91c2UgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXIgZXZlbnQgYmVmb3JlIGVudGVyaW5nIHRoZSBkZXRlY3Rpb25cbiAgICAgIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBhcmUgaW4gYSB0b3VjaC9kb3duIHN0YXRlLCBzbyBhbGxvd2VkIGRldGVjdGlvbiBvZiBnZXN0dXJlc1xuICAgICAgaWYoc2VsZi5zaG91bGREZXRlY3QpIHtcbiAgICAgICAgdHJpZ2dlclR5cGUgPSBzZWxmLmRvRGV0ZWN0LmNhbGwoc2VsZiwgZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgaWYodHJpZ2dlclR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gZmFsc2U7XG4gICAgICAgIFBvaW50ZXJFdmVudC5yZXNldCgpO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXJldmVudCBvYmplY3QgYWZ0ZXIgdGhlIGRldGVjdGlvblxuICAgICAgfVxuXG4gICAgICBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICBQb2ludGVyRXZlbnQudXBkYXRlUG9pbnRlcihldmVudFR5cGUsIGV2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbihlbGVtZW50LCBFVkVOVF9UWVBFU1tldmVudFR5cGVdLCBvblRvdWNoSGFuZGxlcik7XG4gICAgcmV0dXJuIG9uVG91Y2hIYW5kbGVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0aGUgY29yZSBkZXRlY3Rpb24gbWV0aG9kXG4gICAqIHRoaXMgZmluZHMgb3V0IHdoYXQgR2VzdHVyZURldGVjdG9yLXRvdWNoLWV2ZW50cyB0byB0cmlnZ2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiB7U3RyaW5nfSB0cmlnZ2VyVHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICovXG4gIGRvRGV0ZWN0OiBmdW5jdGlvbiBkb0RldGVjdChldiwgZXZlbnRUeXBlLCBlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgdmFyIHRvdWNoTGlzdCA9IHRoaXMuZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpO1xuICAgIHZhciB0b3VjaExpc3RMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoO1xuICAgIHZhciB0cmlnZ2VyVHlwZSA9IGV2ZW50VHlwZTtcbiAgICB2YXIgdHJpZ2dlckNoYW5nZSA9IHRvdWNoTGlzdC50cmlnZ2VyOyAvLyB1c2VkIGJ5IGZha2VNdWx0aXRvdWNoIHBsdWdpblxuICAgIHZhciBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0TGVuZ3RoO1xuXG4gICAgLy8gYXQgZWFjaCB0b3VjaHN0YXJ0LWxpa2UgZXZlbnQgd2Ugd2FudCBhbHNvIHdhbnQgdG8gdHJpZ2dlciBhIFRPVUNIIGV2ZW50Li4uXG4gICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfVE9VQ0g7XG4gICAgICAvLyAuLi50aGUgc2FtZSBmb3IgYSB0b3VjaGVuZC1saWtlIGV2ZW50XG4gICAgfSBlbHNlIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9SRUxFQVNFO1xuXG4gICAgICAvLyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRvdWNoZXMgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoIC0gKChldi5jaGFuZ2VkVG91Y2hlcykgPyBldi5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggOiAxKTtcbiAgICB9XG5cbiAgICAvLyBhZnRlciB0aGVyZSBhcmUgc3RpbGwgdG91Y2hlcyBvbiB0aGUgc2NyZWVuLFxuICAgIC8vIHdlIGp1c3Qgd2FudCB0byB0cmlnZ2VyIGEgTU9WRSBldmVudC4gc28gY2hhbmdlIHRoZSBTVEFSVCBvciBFTkQgdG8gYSBNT1ZFXG4gICAgLy8gYnV0IG9ubHkgYWZ0ZXIgZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHRoZSBmaXJzdCB0aW1lIHdlIGFjdHVhbGx5IHdhbnQgYSBTVEFSVFxuICAgIGlmKGNoYW5nZWRMZW5ndGggPiAwICYmIHRoaXMuc3RhcnRlZCkge1xuICAgICAgdHJpZ2dlclR5cGUgPSBFVkVOVF9NT1ZFO1xuICAgIH1cblxuICAgIC8vIGRldGVjdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB3ZSBrZWVwIHRyYWNrIG9mIHRoaXMsIHNlZSBhYm92ZVxuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAvLyBnZW5lcmF0ZSBzb21lIGV2ZW50IGRhdGEsIHNvbWUgYmFzaWMgaW5mb3JtYXRpb25cbiAgICB2YXIgZXZEYXRhID0gdGhpcy5jb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIHRyaWdnZXJUeXBlLCB0b3VjaExpc3QsIGV2KTtcblxuICAgIC8vIHRyaWdnZXIgdGhlIHRyaWdnZXJUeXBlIGV2ZW50IGJlZm9yZSB0aGUgY2hhbmdlIChUT1VDSCwgUkVMRUFTRSkgZXZlbnRzXG4gICAgLy8gYnV0IHRoZSBFTkQgZXZlbnQgc2hvdWxkIGJlIGF0IGxhc3RcbiAgICBpZihldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgYSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudCwgdGhpcyBtZWFucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaGVzIGNoYW5nZWRcbiAgICBpZih0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICBldkRhdGEuY2hhbmdlZExlbmd0aCA9IGNoYW5nZWRMZW5ndGg7XG4gICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlckNoYW5nZTtcblxuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJUeXBlO1xuICAgICAgZGVsZXRlIGV2RGF0YS5jaGFuZ2VkTGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdGhlIEVORCBldmVudFxuICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgLy8gLi4uYW5kIHdlIGFyZSBkb25lIHdpdGggdGhlIGRldGVjdGlvblxuICAgICAgLy8gc28gcmVzZXQgZXZlcnl0aGluZyB0byBzdGFydCBlYWNoIGRldGVjdGlvbiB0b3RhbGx5IGZyZXNoXG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJpZ2dlclR5cGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHdlIGhhdmUgZGlmZmVyZW50IGV2ZW50cyBmb3IgZWFjaCBkZXZpY2UvYnJvd3NlclxuICAgKiBkZXRlcm1pbmUgd2hhdCB3ZSBuZWVkIGFuZCBzZXQgdGhlbSBpbiB0aGUgRVZFTlRfVFlQRVMgY29uc3RhbnRcbiAgICogdGhlIGBvblRvdWNoYCBtZXRob2QgaXMgYmluZCB0byB0aGVzZSBwcm9wZXJ0aWVzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2ZW50c1xuICAgKi9cbiAgZGV0ZXJtaW5lRXZlbnRUeXBlczogZnVuY3Rpb24gZGV0ZXJtaW5lRXZlbnRUeXBlcygpIHtcbiAgICB2YXIgdHlwZXM7XG4gICAgaWYoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICBpZih3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICdwb2ludGVyZG93bicsXG4gICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgICAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgbG9zdHBvaW50ZXJjYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgJ01TUG9pbnRlckRvd24nLFxuICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAnTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsIE1TTG9zdFBvaW50ZXJDYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihHZXN0dXJlRGV0ZWN0b3IuTk9fTU9VU0VFVkVOVFMpIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICd0b3VjaG1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyxcbiAgICAgICAgJ3RvdWNobW92ZSBtb3VzZW1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cCdcbiAgICAgIF07XG4gICAgfVxuXG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdID0gdHlwZXNbMF07XG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfTU9WRV0gPSB0eXBlc1sxXTtcbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9FTkRdID0gdHlwZXNbMl07XG4gICAgcmV0dXJuIEVWRU5UX1RZUEVTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjcmVhdGUgdG91Y2hMaXN0IGRlcGVuZGluZyBvbiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNoZXNcbiAgICovXG4gIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpIHtcbiAgICAvLyBnZXQgdGhlIGZha2UgcG9pbnRlckV2ZW50IHRvdWNobGlzdFxuICAgIGlmKEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudC5nZXRUb3VjaExpc3QoKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHRvdWNobGlzdFxuICAgIGlmKGV2LnRvdWNoZXMpIHtcbiAgICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9NT1ZFKSB7XG4gICAgICAgIHJldHVybiBldi50b3VjaGVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgIHZhciBjb25jYXQgPSBbXS5jb25jYXQoVXRpbHMudG9BcnJheShldi50b3VjaGVzKSwgVXRpbHMudG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcykpO1xuICAgICAgdmFyIHRvdWNoTGlzdCA9IFtdO1xuXG4gICAgICBVdGlscy5lYWNoKGNvbmNhdCwgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgaWYoVXRpbHMuaW5BcnJheShpZGVudGlmaWVycywgdG91Y2guaWRlbnRpZmllcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdG91Y2hMaXN0LnB1c2godG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2godG91Y2guaWRlbnRpZmllcik7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRvdWNoTGlzdDtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGZha2UgdG91Y2hMaXN0IGZyb20gbW91c2UgcG9zaXRpb25cbiAgICBldi5pZGVudGlmaWVyID0gMTtcbiAgICByZXR1cm4gW2V2XTtcbiAgfSxcblxuICAvKipcbiAgICogY29sbGVjdCBiYXNpYyBldmVudCBkYXRhXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgKi9cbiAgY29sbGVjdEV2ZW50RGF0YTogZnVuY3Rpb24gY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCBldmVudFR5cGUsIHRvdWNoZXMsIGV2KSB7XG4gICAgLy8gZmluZCBvdXQgcG9pbnRlclR5cGVcbiAgICB2YXIgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1RPVUNIO1xuICAgIGlmKFV0aWxzLmluU3RyKGV2LnR5cGUsICdtb3VzZScpIHx8IFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9NT1VTRSwgZXYpKSB7XG4gICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfTU9VU0U7XG4gICAgfSBlbHNlIGlmKFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9QRU4sIGV2KSkge1xuICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1BFTjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyOiBVdGlscy5nZXRDZW50ZXIodG91Y2hlcyksXG4gICAgICB0aW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICB0YXJnZXQ6IGV2LnRhcmdldCxcbiAgICAgIHRvdWNoZXM6IHRvdWNoZXMsXG4gICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgIHNyY0V2ZW50OiBldixcblxuICAgICAgLyoqXG4gICAgICAgKiBwcmV2ZW50IHRoZSBicm93c2VyIGRlZmF1bHQgYWN0aW9uc1xuICAgICAgICogbW9zdGx5IHVzZWQgdG8gZGlzYWJsZSBzY3JvbGxpbmcgb2YgdGhlIGJyb3dzZXJcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3JjRXZlbnQgPSB0aGlzLnNyY0V2ZW50O1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uICYmIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24oKTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQgJiYgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogc3RvcCBidWJibGluZyB0aGUgZXZlbnQgdXAgdG8gaXRzIHBhcmVudHNcbiAgICAgICAqL1xuICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogaW1tZWRpYXRlbHkgc3RvcCBnZXN0dXJlIGRldGVjdGlvblxuICAgICAgICogbWlnaHQgYmUgdXNlZnVsIGFmdGVyIGEgc3dpcGUgd2FzIGRldGVjdGVkXG4gICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICovXG4gICAgICBzdG9wRGV0ZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERldGVjdGlvbi5zdG9wRGV0ZWN0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIFBvaW50ZXJFdmVudFxuICogQHN0YXRpY1xuICovXG5Qb2ludGVyRXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuUG9pbnRlckV2ZW50ID0ge1xuICAvKipcbiAgICogaG9sZHMgYWxsIHBvaW50ZXJzLCBieSBgaWRlbnRpZmllcmBcbiAgICogQHByb3BlcnR5IHBvaW50ZXJzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBwb2ludGVyczoge30sXG5cbiAgLyoqXG4gICAqIGdldCB0aGUgcG9pbnRlcnMgYXMgYW4gYXJyYXlcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNobGlzdFxuICAgKi9cbiAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbiBnZXRUb3VjaExpc3QoKSB7XG4gICAgdmFyIHRvdWNobGlzdCA9IFtdO1xuICAgIC8vIHdlIGNhbiB1c2UgZm9yRWFjaCBzaW5jZSBwb2ludGVyRXZlbnRzIG9ubHkgaXMgaW4gSUUxMFxuICAgIFV0aWxzLmVhY2godGhpcy5wb2ludGVycywgZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgdG91Y2hsaXN0LnB1c2gocG9pbnRlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdWNobGlzdDtcbiAgfSxcblxuICAvKipcbiAgICogdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBhIHBvaW50ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJFdmVudFxuICAgKi9cbiAgdXBkYXRlUG9pbnRlcjogZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihldmVudFR5cGUsIHBvaW50ZXJFdmVudCkge1xuICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQgfHwgKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQgJiYgcG9pbnRlckV2ZW50LmJ1dHRvbnMgIT09IDEpKSB7XG4gICAgICBkZWxldGUgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlckV2ZW50LmlkZW50aWZpZXIgPSBwb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXSA9IHBvaW50ZXJFdmVudDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIGV2IG1hdGNoZXMgcG9pbnRlcnR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50ZXJUeXBlIG1hdGNoZXMgYFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOYFxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZcbiAgICovXG4gIG1hdGNoVHlwZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHBvaW50ZXJUeXBlLCBldikge1xuICAgIGlmKCFldi5wb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwdCA9IGV2LnBvaW50ZXJUeXBlLFxuICAgICAgICB0eXBlcyA9IHt9O1xuXG4gICAgdHlwZXNbUE9JTlRFUl9NT1VTRV0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBQT0lOVEVSX01PVVNFKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9UT1VDSF0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9UT1VDSCB8fCBQT0lOVEVSX1RPVUNIKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9QRU5dID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfUEVOIHx8IFBPSU5URVJfUEVOKSk7XG4gICAgcmV0dXJuIHR5cGVzW3BvaW50ZXJUeXBlXTtcbiAgfSxcblxuICAvKipcbiAgICogcmVzZXQgdGhlIHN0b3JlZCBwb2ludGVyc1xuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0TGlzdCgpIHtcbiAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBEZXRlY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xuRGV0ZWN0aW9uID0gR2VzdHVyZURldGVjdG9yLmRldGVjdGlvbiA9IHtcbiAgLy8gY29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gIGdlc3R1cmVzOiBbXSxcblxuICAvLyBkYXRhIG9mIHRoZSBjdXJyZW50IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvbiBzZXNzaW9uXG4gIGN1cnJlbnQ6IG51bGwsXG5cbiAgLy8gdGhlIHByZXZpb3VzIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHNlc3Npb24gZGF0YVxuICAvLyBpcyBhIGZ1bGwgY2xvbmUgb2YgdGhlIHByZXZpb3VzIGdlc3R1cmUuY3VycmVudCBvYmplY3RcbiAgcHJldmlvdXM6IG51bGwsXG5cbiAgLy8gd2hlbiB0aGlzIGJlY29tZXMgdHJ1ZSwgbm8gZ2VzdHVyZXMgYXJlIGZpcmVkXG4gIHN0b3BwZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzdGFydCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9IGluc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKi9cbiAgc3RhcnREZXRlY3Q6IGZ1bmN0aW9uIHN0YXJ0RGV0ZWN0KGluc3QsIGV2ZW50RGF0YSkge1xuICAgIC8vIGFscmVhZHkgYnVzeSB3aXRoIGEgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uIG9uIGFuIGVsZW1lbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIC8vIGhvbGRzIGN1cnJlbnQgc2Vzc2lvblxuICAgIHRoaXMuY3VycmVudCA9IHtcbiAgICAgIGluc3Q6IGluc3QsIC8vIHJlZmVyZW5jZSB0byBHZXN0dXJlRGV0ZWN0b3JJbnN0YW5jZSB3ZSdyZSB3b3JraW5nIGZvclxuICAgICAgc3RhcnRFdmVudDogVXRpbHMuZXh0ZW5kKHt9LCBldmVudERhdGEpLCAvLyBzdGFydCBldmVudERhdGEgZm9yIGRpc3RhbmNlcywgdGltaW5nIGV0Y1xuICAgICAgbGFzdEV2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGFcbiAgICAgIGxhc3RDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgZnV0dXJlQ2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgIGxhc3RDYWxjRGF0YToge30sIC8vIGxhc3QgbGFzdENhbGNEYXRhXG4gICAgICBuYW1lOiAnJyAvLyBjdXJyZW50IGdlc3R1cmUgd2UncmUgaW4vZGV0ZWN0ZWQsIGNhbiBiZSAndGFwJywgJ2hvbGQnIGV0Y1xuICAgIH07XG5cbiAgICB0aGlzLmRldGVjdChldmVudERhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBkZXRlY3Q6IGZ1bmN0aW9uIGRldGVjdChldmVudERhdGEpIHtcbiAgICBpZighdGhpcy5jdXJyZW50IHx8IHRoaXMuc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBldmVudCBkYXRhIHdpdGggY2FsY3VsYXRpb25zIGFib3V0IHNjYWxlLCBkaXN0YW5jZSBldGNcbiAgICBldmVudERhdGEgPSB0aGlzLmV4dGVuZEV2ZW50RGF0YShldmVudERhdGEpO1xuXG4gICAgLy8gR2VzdHVyZURldGVjdG9yIGluc3RhbmNlIGFuZCBpbnN0YW5jZSBvcHRpb25zXG4gICAgdmFyIGluc3QgPSB0aGlzLmN1cnJlbnQuaW5zdCxcbiAgICAgICAgaW5zdE9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAvLyBjYWxsIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGhhbmRsZXJzXG4gICAgVXRpbHMuZWFjaCh0aGlzLmdlc3R1cmVzLCBmdW5jdGlvbiB0cmlnZ2VyR2VzdHVyZShnZXN0dXJlKSB7XG4gICAgICAvLyBvbmx5IHdoZW4gdGhlIGluc3RhbmNlIG9wdGlvbnMgaGF2ZSBlbmFibGVkIHRoaXMgZ2VzdHVyZVxuICAgICAgaWYoIXRoaXMuc3RvcHBlZCAmJiBpbnN0LmVuYWJsZWQgJiYgaW5zdE9wdGlvbnNbZ2VzdHVyZS5uYW1lXSkge1xuICAgICAgICBnZXN0dXJlLmhhbmRsZXIuY2FsbChnZXN0dXJlLCBldmVudERhdGEsIGluc3QpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gc3RvcmUgYXMgcHJldmlvdXMgZXZlbnQgZXZlbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudC5sYXN0RXZlbnQgPSBldmVudERhdGE7XG4gICAgfVxuXG4gICAgaWYoZXZlbnREYXRhLmV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRoaXMuc3RvcERldGVjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudERhdGE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgfSxcblxuICAvKipcbiAgICogY2xlYXIgdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHZhcnNcbiAgICogdGhpcyBpcyBjYWxsZWQgb24gZW5kRGV0ZWN0LCBidXQgY2FuIGFsc28gYmUgdXNlZCB3aGVuIGEgZmluYWwgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgaGFzIGJlZW4gZGV0ZWN0ZWRcbiAgICogdG8gc3RvcCBvdGhlciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgZnJvbSBiZWluZyBmaXJlZFxuICAgKi9cbiAgc3RvcERldGVjdDogZnVuY3Rpb24gc3RvcERldGVjdCgpIHtcbiAgICAvLyBjbG9uZSBjdXJyZW50IGRhdGEgdG8gdGhlIHN0b3JlIGFzIHRoZSBwcmV2aW91cyBnZXN0dXJlXG4gICAgLy8gdXNlZCBmb3IgdGhlIGRvdWJsZSB0YXAgZ2VzdHVyZSwgc2luY2UgdGhpcyBpcyBhbiBvdGhlciBnZXN0dXJlIGRldGVjdCBzZXNzaW9uXG4gICAgdGhpcy5wcmV2aW91cyA9IFV0aWxzLmV4dGVuZCh7fSwgdGhpcy5jdXJyZW50KTtcblxuICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdmVsb2NpdHksIGFuZ2xlIGFuZCBkaXJlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZW50ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICovXG4gIGdldENhbGN1bGF0ZWREYXRhOiBmdW5jdGlvbiBnZXRDYWxjdWxhdGVkRGF0YShldiwgY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgcmVjYWxjID0gZmFsc2UsXG4gICAgICAgIGNhbGNFdiA9IGN1ci5sYXN0Q2FsY0V2ZW50LFxuICAgICAgICBjYWxjRGF0YSA9IGN1ci5sYXN0Q2FsY0RhdGE7XG5cbiAgICBpZihjYWxjRXYgJiYgZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcCA+IEdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwpIHtcbiAgICAgIGNlbnRlciA9IGNhbGNFdi5jZW50ZXI7XG4gICAgICBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wO1xuICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBjYWxjRXYuY2VudGVyLmNsaWVudFg7XG4gICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WTtcbiAgICAgIHJlY2FsYyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgfVxuXG4gICAgaWYoIWN1ci5sYXN0Q2FsY0V2ZW50IHx8IHJlY2FsYykge1xuICAgICAgY2FsY0RhdGEudmVsb2NpdHkgPSBVdGlscy5nZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIGNhbGNEYXRhLmFuZ2xlID0gVXRpbHMuZ2V0QW5nbGUoY2VudGVyLCBldi5jZW50ZXIpO1xuICAgICAgY2FsY0RhdGEuZGlyZWN0aW9uID0gVXRpbHMuZ2V0RGlyZWN0aW9uKGNlbnRlciwgZXYuY2VudGVyKTtcblxuICAgICAgY3VyLmxhc3RDYWxjRXZlbnQgPSBjdXIuZnV0dXJlQ2FsY0V2ZW50IHx8IGV2O1xuICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgIH1cblxuICAgIGV2LnZlbG9jaXR5WCA9IGNhbGNEYXRhLnZlbG9jaXR5Lng7XG4gICAgZXYudmVsb2NpdHlZID0gY2FsY0RhdGEudmVsb2NpdHkueTtcbiAgICBldi5pbnRlcmltQW5nbGUgPSBjYWxjRGF0YS5hbmdsZTtcbiAgICBldi5pbnRlcmltRGlyZWN0aW9uID0gY2FsY0RhdGEuZGlyZWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBleHRlbmQgZXZlbnREYXRhIGZvciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICovXG4gIGV4dGVuZEV2ZW50RGF0YTogZnVuY3Rpb24gZXh0ZW5kRXZlbnREYXRhKGV2KSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgc3RhcnRFdiA9IGN1ci5zdGFydEV2ZW50LFxuICAgICAgICBsYXN0RXYgPSBjdXIubGFzdEV2ZW50IHx8IHN0YXJ0RXY7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHN0YXJ0IHRvdWNobGlzdCB0byBjYWxjdWxhdGUgdGhlIHNjYWxlL3JvdGF0aW9uXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBzdGFydEV2LnRvdWNoZXMgPSBbXTtcbiAgICAgIFV0aWxzLmVhY2goZXYudG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgc3RhcnRFdi50b3VjaGVzLnB1c2goe1xuICAgICAgICAgIGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WTogdG91Y2guY2xpZW50WVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBzdGFydEV2LnRpbWVTdGFtcCxcbiAgICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBzdGFydEV2LmNlbnRlci5jbGllbnRYLFxuICAgICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFk7XG5cbiAgICB0aGlzLmdldENhbGN1bGF0ZWREYXRhKGV2LCBsYXN0RXYuY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcblxuICAgIFV0aWxzLmV4dGVuZChldiwge1xuICAgICAgc3RhcnRFdmVudDogc3RhcnRFdixcblxuICAgICAgZGVsdGFUaW1lOiBkZWx0YVRpbWUsXG4gICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgIGRlbHRhWTogZGVsdGFZLFxuXG4gICAgICBkaXN0YW5jZTogVXRpbHMuZ2V0RGlzdGFuY2Uoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBhbmdsZTogVXRpbHMuZ2V0QW5nbGUoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBkaXJlY3Rpb246IFV0aWxzLmdldERpcmVjdGlvbihzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIHNjYWxlOiBVdGlscy5nZXRTY2FsZShzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpLFxuICAgICAgcm90YXRpb246IFV0aWxzLmdldFJvdGF0aW9uKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcylcbiAgICB9KTtcblxuICAgIHJldHVybiBldjtcbiAgfSxcblxuICAvKipcbiAgICogcmVnaXN0ZXIgbmV3IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGdlc3R1cmUgb2JqZWN0LCBzZWUgYGdlc3R1cmVzL2AgZm9yIGRvY3VtZW50YXRpb25cbiAgICogQHJldHVybiB7QXJyYXl9IGdlc3R1cmVzXG4gICAqL1xuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZ2VzdHVyZSkge1xuICAgIC8vIGFkZCBhbiBlbmFibGUgZ2VzdHVyZSBvcHRpb25zIGlmIHRoZXJlIGlzIG5vIGdpdmVuXG4gICAgdmFyIG9wdGlvbnMgPSBnZXN0dXJlLmRlZmF1bHRzIHx8IHt9O1xuICAgIGlmKG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zW2dlc3R1cmUubmFtZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBHZXN0dXJlRGV0ZWN0b3IgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIG9wdGlvbnNcbiAgICBVdGlscy5leHRlbmQoR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLCBvcHRpb25zLCB0cnVlKTtcblxuICAgIC8vIHNldCBpdHMgaW5kZXhcbiAgICBnZXN0dXJlLmluZGV4ID0gZ2VzdHVyZS5pbmRleCB8fCAxMDAwO1xuXG4gICAgLy8gYWRkIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHRvIHRoZSBsaXN0XG4gICAgdGhpcy5nZXN0dXJlcy5wdXNoKGdlc3R1cmUpO1xuXG4gICAgLy8gc29ydCB0aGUgbGlzdCBieSBpbmRleFxuICAgIHRoaXMuZ2VzdHVyZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZihhLmluZGV4IDwgYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZihhLmluZGV4ID4gYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2VzdHVyZXM7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICovXG5cbi8qKlxuICogY3JlYXRlIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2VcbiAqIGFsbCBtZXRob2RzIHNob3VsZCByZXR1cm4gdGhlIGluc3RhbmNlIGl0c2VsZiwgc28gaXQgaXMgY2hhaW5hYmxlLlxuICpcbiAqIEBjbGFzcyBJbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHNgXG4gKiBAcmV0dXJuIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIHNldHVwIEdlc3R1cmVEZXRlY3RvckpTIHdpbmRvdyBldmVudHMgYW5kIHJlZ2lzdGVyIGFsbCBnZXN0dXJlc1xuICAvLyB0aGlzIGFsc28gc2V0cyB1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gIHNldHVwKCk7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbGVtZW50XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBvcHRpb25zLCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHNcbiAgICogb3B0aW9ucyB3aXRoIGFuIF8gYXJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2VcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIFV0aWxzLmVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBkZWxldGUgb3B0aW9uc1tuYW1lXTtcbiAgICBvcHRpb25zW1V0aWxzLnRvQ2FtZWxDYXNlKG5hbWUpXSA9IHZhbHVlO1xuICB9KTtcblxuICB0aGlzLm9wdGlvbnMgPSBVdGlscy5leHRlbmQoVXRpbHMuZXh0ZW5kKHt9LCBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMpLCBvcHRpb25zIHx8IHt9KTtcblxuICAvLyBhZGQgc29tZSBjc3MgdG8gdGhlIGVsZW1lbnQgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGRvaW5nIGl0cyBuYXRpdmUgYmVoYXZpb3JcbiAgaWYodGhpcy5vcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgVXRpbHMudG9nZ2xlQmVoYXZpb3IodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMuYmVoYXZpb3IsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGV2ZW50IHN0YXJ0IGhhbmRsZXIgb24gdGhlIGVsZW1lbnQgdG8gc3RhcnQgdGhlIGRldGVjdGlvblxuICAgKiBAcHJvcGVydHkgZXZlbnRTdGFydEhhbmRsZXJcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuZXZlbnRTdGFydEhhbmRsZXIgPSBFdmVudC5vblRvdWNoKGVsZW1lbnQsIEVWRU5UX1NUQVJULCBmdW5jdGlvbihldikge1xuICAgIGlmKHNlbGYuZW5hYmxlZCAmJiBldi5ldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIERldGVjdGlvbi5zdGFydERldGVjdChzZWxmLCBldik7XG4gICAgfSBlbHNlIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xuICAgICAgRGV0ZWN0aW9uLmRldGVjdChldik7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICoga2VlcCBhIGxpc3Qgb2YgdXNlciBldmVudCBoYW5kbGVycyB3aGljaCBuZWVkcyB0byBiZSByZW1vdmVkIHdoZW4gY2FsbGluZyAnZGlzcG9zZSdcbiAgICogQHByb3BlcnR5IGV2ZW50SGFuZGxlcnNcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG59O1xuXG5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQG1ldGhvZCBvblxuICAgKiBAc2lnbmF0dXJlIG9uKGdlc3R1cmVzLCBoYW5kbGVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1BZGRzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgZ2VzdHVyZS4gQXZhaWxhYmxlIGdlc3R1cmVzIGFyZTogZHJhZywgZHJhZ2xlZnQsIGRyYWdyaWdodCwgZHJhZ3VwLCBkcmFnZG93biwgaG9sZCwgcmVsZWFzZSwgc3dpcGUsIHN3aXBlbGVmdCwgc3dpcGVyaWdodCwgc3dpcGV1cCwgc3dpcGVkb3duLCB0YXAsIGRvdWJsZXRhcCwgdG91Y2gsIHRyYW5zZm9ybSwgcGluY2gsIHBpbmNoaW4sIHBpbmNob3V0IGFuZCByb3RhdGUuIFsvZW5dXG4gICAqICBbamFd44K444Kn44K544OB44Oj44Gr5a++44GZ44KL44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44KS6L+95Yqg44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL44K444Kn44K544OB44Oj5ZCN44Gv44CBZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIGhvbGQgcmVsZWFzZSBzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodCBzd2lwZXVwIHN3aXBlZG93biB0YXAgZG91YmxldGFwIHRvdWNoIHRyYW5zZm9ybSBwaW5jaCBwaW5jaGluIHBpbmNob3V0IHJvdGF0ZSDjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcbiAgICogICBbZW5dQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBnZXN0dXJlcy5bL2VuXVxuICAgKiAgIFtqYV3mpJznn6XjgZnjgovjgrjjgqfjgrnjg4Hjg6PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg5rjg7zjgrnjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgW2VuXUFuIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uLlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOODj+ODs+ODieODqeOBqOOBquOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb25FdmVudChnZXN0dXJlcywgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBFdmVudC5vbihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBzZWxmLmV2ZW50SGFuZGxlcnMucHVzaCh7IGdlc3R1cmU6IHR5cGUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgb2ZmXG4gICAqIEBzaWduYXR1cmUgb2ZmKGdlc3R1cmVzLCBoYW5kbGVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1SZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuWy9lbl1cbiAgICogIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLliYrpmaTjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcbiAgICogICBbZW5dQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBnZXN0dXJlcy5bL2VuXVxuICAgKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg5rjg7zjgrnjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgW2VuXUFuIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uLlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOODj+ODs+ODieODqeOBqOOBquOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgRXZlbnQub2ZmKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBpbmRleCA9IFV0aWxzLmluQXJyYXkoeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgICAgaWYoaW5kZXggIT09IGZhbHNlKSB7XG4gICAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0cmlnZ2VyIGdlc3R1cmUgZXZlbnRcbiAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAqIEBzaWduYXR1cmUgdHJpZ2dlcihnZXN0dXJlLCBldmVudERhdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXVxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGdlc3R1cmUsIGV2ZW50RGF0YSkge1xuICAgIC8vIG9wdGlvbmFsXG4gICAgaWYoIWV2ZW50RGF0YSkge1xuICAgICAgZXZlbnREYXRhID0ge307XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIERPTSBldmVudFxuICAgIHZhciBldmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoZ2VzdHVyZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQuZ2VzdHVyZSA9IGV2ZW50RGF0YTtcblxuICAgIC8vIHRyaWdnZXIgb24gdGhlIHRhcmdldCBpZiBpdCBpcyBpbiB0aGUgaW5zdGFuY2UgZWxlbWVudCxcbiAgICAvLyB0aGlzIGlzIGZvciBldmVudCBkZWxlZ2F0aW9uIHRyaWNrc1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGlmKFV0aWxzLmhhc1BhcmVudChldmVudERhdGEudGFyZ2V0LCBlbGVtZW50KSkge1xuICAgICAgZWxlbWVudCA9IGV2ZW50RGF0YS50YXJnZXQ7XG4gICAgfVxuXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBlbmFibGVcbiAgICogQHNpZ25hdHVyZSBlbmFibGUoc3RhdGUpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUVuYWJsZSBvciBkaXNhYmxlIGdlc3R1cmUgZGV0ZWN0aW9uLlsvZW5dXG4gICAqICBbamFd44K444Kn44K544OB44Oj5qSc55+l44KS5pyJ5Yq55YyWL+eEoeWKueWMluOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdGVcbiAgICogICBbZW5dU3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgZW5hYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd5pyJ5Yq544Gr44GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKHN0YXRlKSB7XG4gICAgdGhpcy5lbmFibGVkID0gc3RhdGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZGlzcG9zZVxuICAgKiBAc2lnbmF0dXJlIGRpc3Bvc2UoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1SZW1vdmUgYW5kIGRlc3Ryb3kgYWxsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGlzIGluc3RhbmNlLlsvZW5dXG4gICAqICBbamFd44GT44Gu44Kk44Oz44K544K/44Oz44K544Gn44Gu44K444Kn44K544OB44Oj44Gu5qSc55+l44KE44CB44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44KS5YWo44Gm6Kej6Zmk44GX44Gm5buD5qOE44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdmFyIGksIGVoO1xuXG4gICAgLy8gdW5kbyBhbGwgY2hhbmdlcyBtYWRlIGJ5IHN0b3BfYnJvd3Nlcl9iZWhhdmlvclxuICAgIFV0aWxzLnRvZ2dsZUJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLmJlaGF2aW9yLCBmYWxzZSk7XG5cbiAgICAvLyB1bmJpbmQgYWxsIGN1c3RvbSBldmVudCBoYW5kbGVyc1xuICAgIGZvcihpID0gLTE7IChlaCA9IHRoaXMuZXZlbnRIYW5kbGVyc1srK2ldKTspIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgVXRpbHMub2ZmKHRoaXMuZWxlbWVudCwgZWguZ2VzdHVyZSwgZWguaGFuZGxlcik7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICAvLyB1bmJpbmQgdGhlIHN0YXJ0IGV2ZW50IGxpc3RlbmVyXG4gICAgRXZlbnQub2ZmKHRoaXMuZWxlbWVudCwgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdLCB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIE1vdmUgd2l0aCB4IGZpbmdlcnMgKGRlZmF1bHQgMSkgYXJvdW5kIG9uIHRoZSBwYWdlLlxuICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLlxuICogYGBgYFxuICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnXCIsIGZ1bmN0aW9uKGV2KSB7XG4gKiAgICBjb25zb2xlLmxvZyhldik7XG4gKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gKiAgfSk7XG4gKiBgYGBgXG4gKlxuICogQGNsYXNzIERyYWdcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ1xuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdzdGFydFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFwbGVmdFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdyaWdodFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWd1cFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdkb3duXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKi9cbihmdW5jdGlvbihuYW1lKSB7XG4gIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBkcmFnR2VzdHVyZShldiwgaW5zdCkge1xuICAgIHZhciBjdXIgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgIC8vIG1heCB0b3VjaGVzXG4gICAgaWYoaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzID4gMCAmJlxuICAgICAgZXYudG91Y2hlcy5sZW5ndGggPiBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICBpZihldi5kaXN0YW5jZSA8IGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgJiZcbiAgICAgICAgY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydENlbnRlciA9IGN1ci5zdGFydEV2ZW50LmNlbnRlcjtcblxuICAgICAgLy8gd2UgYXJlIGRyYWdnaW5nIVxuICAgICAgaWYoY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICBjdXIubmFtZSA9IG5hbWU7XG4gICAgICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnRGlzdGFuY2VDb3JyZWN0aW9uICYmIGV2LmRpc3RhbmNlID4gMCkge1xuICAgICAgICAgIC8vIFdoZW4gYSBkcmFnIGlzIHRyaWdnZXJlZCwgc2V0IHRoZSBldmVudCBjZW50ZXIgdG8gZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBmcm9tIHRoZSBvcmlnaW5hbCBldmVudCBjZW50ZXIuXG4gICAgICAgICAgLy8gV2l0aG91dCB0aGlzIGNvcnJlY3Rpb24sIHRoZSBkcmFnZ2VkIGRpc3RhbmNlIHdvdWxkIGp1bXBzdGFydCBhdCBkcmFnTWluRGlzdGFuY2UgcGl4ZWxzIGluc3RlYWQgb2YgYXQgMC5cbiAgICAgICAgICAvLyBJdCBtaWdodCBiZSB1c2VmdWwgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgc3RhcnQgcG9pbnQgc29tZXdoZXJlXG4gICAgICAgICAgdmFyIGZhY3RvciA9IE1hdGguYWJzKGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgLyBldi5kaXN0YW5jZSk7XG4gICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLnBhZ2VZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcblxuICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIGV2ZW50IGRhdGEgdXNpbmcgbmV3IHN0YXJ0IHBvaW50XG4gICAgICAgICAgZXYgPSBEZXRlY3Rpb24uZXh0ZW5kRXZlbnREYXRhKGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBsb2NrIGRyYWcgdG8gYXhpcz9cbiAgICAgIGlmKGN1ci5sYXN0RXZlbnQuZHJhZ0xvY2tUb0F4aXMgfHxcbiAgICAgICAgKCBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tUb0F4aXMgJiZcbiAgICAgICAgICBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tNaW5EaXN0YW5jZSA8PSBldi5kaXN0YW5jZVxuICAgICAgICApKSB7XG4gICAgICAgICAgZXYuZHJhZ0xvY2tUb0F4aXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8ga2VlcCBkaXJlY3Rpb24gb24gdGhlIGF4aXMgdGhhdCB0aGUgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQgb25cbiAgICAgICAgdmFyIGxhc3REaXJlY3Rpb24gPSBjdXIubGFzdEV2ZW50LmRpcmVjdGlvbjtcbiAgICAgICAgaWYoZXYuZHJhZ0xvY2tUb0F4aXMgJiYgbGFzdERpcmVjdGlvbiAhPT0gZXYuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgaWYoVXRpbHMuaXNWZXJ0aWNhbChsYXN0RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgZXYuZGlyZWN0aW9uID0gKGV2LmRlbHRhWSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpZ2dlciBldmVudHNcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcblxuICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IFV0aWxzLmlzVmVydGljYWwoZXYuZGlyZWN0aW9uKTtcblxuICAgICAgICAvLyBibG9jayB0aGUgYnJvd3NlciBldmVudHNcbiAgICAgICAgaWYoKGluc3Qub3B0aW9ucy5kcmFnQmxvY2tWZXJ0aWNhbCAmJiBpc1ZlcnRpY2FsKSB8fFxuICAgICAgICAgIChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrSG9yaXpvbnRhbCAmJiAhaXNWZXJ0aWNhbCkpIHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgIGlmKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDw9IGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcykge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuRHJhZyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogNTAsXG4gICAgICBoYW5kbGVyOiBkcmFnR2VzdHVyZSxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtaW5pbWFsIG1vdmVtZW50IHRoYXQgaGF2ZSB0byBiZSBtYWRlIGJlZm9yZSB0aGUgZHJhZyBldmVudCBnZXRzIHRyaWdnZXJlZFxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ01pbkRpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTWluRGlzdGFuY2U6IDEwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiB0byB0cnVlIHRvIG1ha2UgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBkcmFnXG4gICAgICAgICAqIGJlIGNhbGN1bGF0ZWQgZnJvbSB3aGVyZSB0aGUgZHJhZyB3YXMgdHJpZ2dlcmVkLCBub3QgZnJvbSB3aGVyZSB0aGUgdG91Y2ggc3RhcnRlZC5cbiAgICAgICAgICogVXNlZnVsIHRvIGF2b2lkIGEgamVyay1zdGFydGluZyBkcmFnLCB3aGljaCBjYW4gbWFrZSBmaW5lLWFkanVzdG1lbnRzXG4gICAgICAgICAqIHRocm91Z2ggZHJhZ2dpbmcgZGlmZmljdWx0LCBhbmQgYmUgdmlzdWFsbHkgdW5hcHBlYWxpbmcuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgMCBmb3IgdW5saW1pdGVkLCBidXQgdGhpcyBjYW4gY29uZmxpY3Qgd2l0aCB0cmFuc2Zvcm1cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdNYXhUb3VjaGVzXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdNYXhUb3VjaGVzOiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciB3aGVuIGRyYWdnaW5nIG9jY3Vyc1xuICAgICAgICAgKiBiZSBjYXJlZnVsIHdpdGggaXQsIGl0IG1ha2VzIHRoZSBlbGVtZW50IGEgYmxvY2tpbmcgZWxlbWVudFxuICAgICAgICAgKiB3aGVuIHlvdSBhcmUgdXNpbmcgdGhlIGRyYWcgZ2VzdHVyZSwgaXQgaXMgYSBnb29kIHByYWN0aWNlIHRvIHNldCB0aGlzIHRydWVcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja0hvcml6b250YWxcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnQmxvY2tIb3Jpem9udGFsOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2FtZSBhcyBgZHJhZ0Jsb2NrSG9yaXpvbnRhbGAsIGJ1dCBmb3IgdmVydGljYWwgbW92ZW1lbnRcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdCbG9ja1ZlcnRpY2FsXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Jsb2NrVmVydGljYWw6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnTG9ja1RvQXhpcyBrZWVwcyB0aGUgZHJhZyBnZXN0dXJlIG9uIHRoZSBheGlzIHRoYXQgaXQgc3RhcnRlZCBvbixcbiAgICAgICAgICogSXQgZGlzYWxsb3dzIHZlcnRpY2FsIGRpcmVjdGlvbnMgaWYgdGhlIGluaXRpYWwgZGlyZWN0aW9uIHdhcyBob3Jpem9udGFsLCBhbmQgdmljZSB2ZXJzYS5cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrVG9BeGlzXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0xvY2tUb0F4aXM6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmFnIGxvY2sgb25seSBraWNrcyBpbiB3aGVuIGRpc3RhbmNlID4gZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgKiBUaGlzIHdheSwgbG9ja2luZyBvY2N1cnMgb25seSB3aGVuIHRoZSBkaXN0YW5jZSBoYXMgYmVjb21lIGxhcmdlIGVub3VnaCB0byByZWxpYWJseSBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyNVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0xvY2tNaW5EaXN0YW5jZTogMjVcbiAgICAgIH1cbiAgICB9O1xuICB9KSgnZHJhZycpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogdHJpZ2dlciBhIHNpbXBsZSBnZXN0dXJlIGV2ZW50LCBzbyB5b3UgY2FuIGRvIGFueXRoaW5nIGluIHlvdXIgaGFuZGxlci5cbiAgICogb25seSB1c2FibGUgaWYgeW91IGtub3cgd2hhdCB5b3VyIGRvaW5nLi4uXG4gICAqXG4gICAqIEBjbGFzcyBHZXN0dXJlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgZ2VzdHVyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5HZXN0dXJlID0ge1xuICAgIG5hbWU6ICdnZXN0dXJlJyxcbiAgICBpbmRleDogMTMzNyxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIFRvdWNoIHN0YXlzIGF0IHRoZSBzYW1lIHBsYWNlIGZvciB4IHRpbWVcbiAgICpcbiAgICogQGNsYXNzIEhvbGRcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBob2xkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHRpbWVyO1xuXG4gICAgZnVuY3Rpb24gaG9sZEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICAvLyBzZXQgdGhlIGdlc3R1cmUgc28gd2UgY2FuIGNoZWNrIGluIHRoZSB0aW1lb3V0IGlmIGl0IHN0aWxsIGlzXG4gICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLy8gc2V0IHRpbWVyIGFuZCBpZiBhZnRlciB0aGUgdGltZW91dCBpdCBzdGlsbCBpcyBob2xkLFxuICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBob2xkIGV2ZW50XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihjdXJyZW50ICYmIGN1cnJlbnQubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5ob2xkVGltZW91dCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIGlmKGV2LmRpc3RhbmNlID4gb3B0aW9ucy5ob2xkVGhyZXNob2xkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuSG9sZCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogMTAsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaW1lb3V0XG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDUwMFxuICAgICAgICAgKi9cbiAgICAgICAgaG9sZFRpbWVvdXQ6IDUwMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZW1lbnQgYWxsb3dlZCB3aGlsZSBob2xkaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSBob2xkVGhyZXNob2xkXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDJcbiAgICAgICAgICovXG4gICAgICAgIGhvbGRUaHJlc2hvbGQ6IDJcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyOiBob2xkR2VzdHVyZVxuICAgIH07XG4gIH0pKCdob2xkJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgcmVsZWFzZWQgZnJvbSB0aGUgcGFnZVxuICAgKlxuICAgKiBAY2xhc3MgUmVsZWFzZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHJlbGVhc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuUmVsZWFzZSA9IHtcbiAgICBuYW1lOiAncmVsZWFzZScsXG4gICAgaW5kZXg6IEluZmluaXR5LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogdHJpZ2dlcnMgc3dpcGUgZXZlbnRzIHdoZW4gdGhlIGVuZCB2ZWxvY2l0eSBpcyBhYm92ZSB0aGUgdGhyZXNob2xkXG4gICAqIGZvciBiZXN0IHVzYWdlLCBzZXQgYHByZXZlbnREZWZhdWx0YCAob24gdGhlIGRyYWcgZ2VzdHVyZSkgdG8gYHRydWVgXG4gICAqIGBgYGBcbiAgICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnbGVmdCBzd2lwZWxlZnRcIiwgZnVuY3Rpb24oZXYpIHtcbiAgICogICAgY29uc29sZS5sb2coZXYpO1xuICAgKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAqICB9KTtcbiAgICogYGBgYFxuICAgKlxuICAgKiBAY2xhc3MgU3dpcGVcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVsZWZ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZXJpZ2h0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZXVwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZWRvd25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuU3dpcGUgPSB7XG4gICAgbmFtZTogJ3N3aXBlJyxcbiAgICBpbmRleDogNDAsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogQHByb3BlcnR5IHN3aXBlTWluVG91Y2hlc1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAqL1xuICAgICAgc3dpcGVNaW5Ub3VjaGVzOiAxLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZU1heFRvdWNoZXNcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgKi9cbiAgICAgIHN3aXBlTWF4VG91Y2hlczogMSxcblxuICAgICAgLyoqXG4gICAgICAgKiBob3Jpem9udGFsIHN3aXBlIHZlbG9jaXR5XG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVhcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAwLjZcbiAgICAgICAqL1xuICAgICAgc3dpcGVWZWxvY2l0eVg6IDAuNixcblxuICAgICAgLyoqXG4gICAgICAgKiB2ZXJ0aWNhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlZXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgKi9cbiAgICAgIHN3aXBlVmVsb2NpdHlZOiAwLjZcbiAgICB9LFxuXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gc3dpcGVHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9ucyA9IGluc3Qub3B0aW9ucztcblxuICAgICAgICAvLyBtYXggdG91Y2hlc1xuICAgICAgICBpZih0b3VjaGVzIDwgb3B0aW9ucy5zd2lwZU1pblRvdWNoZXMgfHxcbiAgICAgICAgICB0b3VjaGVzID4gb3B0aW9ucy5zd2lwZU1heFRvdWNoZXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgaWYoZXYudmVsb2NpdHlYID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WCB8fFxuICAgICAgICAgIGV2LnZlbG9jaXR5WSA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVkpIHtcbiAgICAgICAgICAvLyB0cmlnZ2VyIHN3aXBlIGV2ZW50c1xuICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBTaW5nbGUgdGFwIGFuZCBhIGRvdWJsZSB0YXAgb24gYSBwbGFjZVxuICAgKlxuICAgKiBAY2xhc3MgVGFwXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdGFwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBkb3VibGV0YXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaGFzTW92ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRhcEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudCxcbiAgICAgICAgICBwcmV2ID0gRGV0ZWN0aW9uLnByZXZpb3VzLFxuICAgICAgICAgIHNpbmNlUHJldixcbiAgICAgICAgICBkaWREb3VibGVUYXA7XG5cbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIGhhc01vdmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIGhhc01vdmVkID0gaGFzTW92ZWQgfHwgKGV2LmRpc3RhbmNlID4gb3B0aW9ucy50YXBNYXhEaXN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX0VORDpcbiAgICAgICAgaWYoIVV0aWxzLmluU3RyKGV2LnNyY0V2ZW50LnR5cGUsICdjYW5jZWwnKSAmJiBldi5kZWx0YVRpbWUgPCBvcHRpb25zLnRhcE1heFRpbWUgJiYgIWhhc01vdmVkKSB7XG4gICAgICAgICAgLy8gcHJldmlvdXMgZ2VzdHVyZSwgZm9yIHRoZSBkb3VibGUgdGFwIHNpbmNlIHRoZXNlIGFyZSB0d28gZGlmZmVyZW50IGdlc3R1cmUgZGV0ZWN0aW9uc1xuICAgICAgICAgIHNpbmNlUHJldiA9IHByZXYgJiYgcHJldi5sYXN0RXZlbnQgJiYgZXYudGltZVN0YW1wIC0gcHJldi5sYXN0RXZlbnQudGltZVN0YW1wO1xuICAgICAgICAgIGRpZERvdWJsZVRhcCA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZG91YmxlIHRhcFxuICAgICAgICAgIGlmKHByZXYgJiYgcHJldi5uYW1lID09IG5hbWUgJiZcbiAgICAgICAgICAgIChzaW5jZVByZXYgJiYgc2luY2VQcmV2IDwgb3B0aW9ucy5kb3VibGVUYXBJbnRlcnZhbCkgJiZcbiAgICAgICAgICAgIGV2LmRpc3RhbmNlIDwgb3B0aW9ucy5kb3VibGVUYXBEaXN0YW5jZSkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdkb3VibGV0YXAnLCBldik7XG4gICAgICAgICAgICBkaWREb3VibGVUYXAgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRvIGEgc2luZ2xlIHRhcFxuICAgICAgICAgIGlmKCFkaWREb3VibGVUYXAgfHwgb3B0aW9ucy50YXBBbHdheXMpIHtcbiAgICAgICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoY3VycmVudC5uYW1lLCBldik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5UYXAgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDEwMCxcbiAgICAgIGhhbmRsZXI6IHRhcEdlc3R1cmUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IHRpbWUgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICogQHByb3BlcnR5IHRhcE1heFRpbWVcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjUwXG4gICAgICAgICAqL1xuICAgICAgICB0YXBNYXhUaW1lOiAyNTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCBkaXN0YW5jZSBvZiBtb3ZlbWVudCBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwTWF4RGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICovXG4gICAgICAgIHRhcE1heERpc3RhbmNlOiAxMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWx3YXlzIHRyaWdnZXIgdGhlIGB0YXBgIGV2ZW50LCBldmVuIHdoaWxlIGRvdWJsZS10YXBwaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBBbHdheXNcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRhcEFsd2F5czogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IGRpc3RhbmNlIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcERpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICAgICAqL1xuICAgICAgICBkb3VibGVUYXBEaXN0YW5jZTogMjAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCB0aW1lIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcEludGVydmFsXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDMwMFxuICAgICAgICAgKi9cbiAgICAgICAgZG91YmxlVGFwSW50ZXJ2YWw6IDMwMFxuICAgICAgfVxuICAgIH07XG4gIH0pKCd0YXAnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyB0b3VjaGVkIGF0IHRoZSBwYWdlXG4gICAqXG4gICAqIEBjbGFzcyBUb3VjaFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRvdWNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRvdWNoID0ge1xuICAgIG5hbWU6ICd0b3VjaCcsXG4gICAgaW5kZXg6IC1JbmZpbml0eSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgLyoqXG4gICAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IGF0IHRvdWNoc3RhcnQsIGFuZCBtYWtlcyB0aGUgZWxlbWVudCBibG9ja2luZyBieSBkaXNhYmxpbmcgdGhlIHNjcm9sbGluZyBvZiB0aGUgcGFnZSxcbiAgICAgICAqIGJ1dCBpdCBpbXByb3ZlcyBnZXN0dXJlcyBsaWtlIHRyYW5zZm9ybWluZyBhbmQgZHJhZ2dpbmcuXG4gICAgICAgKiBiZSBjYXJlZnVsIHdpdGggdXNpbmcgdGhpcywgaXQgY2FuIGJlIHZlcnkgYW5ub3lpbmcgZm9yIHVzZXJzIHRvIGJlIHN0dWNrIG9uIHRoZSBwYWdlXG4gICAgICAgKiBAcHJvcGVydHkgcHJldmVudERlZmF1bHRcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRpc2FibGUgbW91c2UgZXZlbnRzLCBzbyBvbmx5IHRvdWNoIChvciBwZW4hKSBpbnB1dCB0cmlnZ2VycyBldmVudHNcbiAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50TW91c2VcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgcHJldmVudE1vdXNlOiBmYWxzZVxuICAgIH0sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gdG91Y2hHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudE1vdXNlICYmIGV2LnBvaW50ZXJUeXBlID09IFBPSU5URVJfTU9VU0UpIHtcbiAgICAgICAgZXYuc3RvcERldGVjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgICAgaW5zdC50cmlnZ2VyKCd0b3VjaCcsIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBVc2VyIHdhbnQgdG8gc2NhbGUgb3Igcm90YXRlIHdpdGggMiBmaW5nZXJzXG4gICAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy4gVGhpcyBjYW4gYmUgZG9uZSB3aXRoIHRoZVxuICAgKiBgcHJldmVudERlZmF1bHRgIG9wdGlvbi5cbiAgICpcbiAgICogQGNsYXNzIFRyYW5zZm9ybVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdHJhbnNmb3Jtc3RhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybWVuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcGluY2hpblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcGluY2hvdXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHJvdGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICAvLyBhdCBsZWFzdCBtdWx0aXRvdWNoXG4gICAgICAgIGlmKGV2LnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZVRocmVzaG9sZCA9IE1hdGguYWJzKDEgLSBldi5zY2FsZSk7XG4gICAgICAgIHZhciByb3RhdGlvblRocmVzaG9sZCA9IE1hdGguYWJzKGV2LnJvdGF0aW9uKTtcblxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUgJiZcbiAgICAgICAgICByb3RhdGlvblRocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5Sb3RhdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGFyZSB0cmFuc2Zvcm1pbmchXG4gICAgICAgIERldGVjdGlvbi5jdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgIGlmKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTsgLy8gYmFzaWMgdHJhbnNmb3JtIGV2ZW50XG5cbiAgICAgICAgLy8gdHJpZ2dlciByb3RhdGUgZXZlbnRcbiAgICAgICAgaWYocm90YXRpb25UaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3JvdGF0ZScsIGV2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgcGluY2ggZXZlbnRcbiAgICAgICAgaWYoc2NhbGVUaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJywgZXYpO1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnICsgKGV2LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JyksIGV2KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBpZih0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8IDIpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRyYW5zZm9ybSA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogNDUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWluaW1hbCBzY2FsZSBmYWN0b3IsIG5vIHNjYWxlIGlzIDEsIHpvb21pbiBpcyB0byAwIGFuZCB6b29tb3V0IHVudGlsIGhpZ2hlciB0aGVuIDFcbiAgICAgICAgICogQHByb3BlcnR5IHRyYW5zZm9ybU1pblNjYWxlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDAuMDFcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zZm9ybU1pblNjYWxlOiAwLjAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5Sb3RhdGlvblxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2Zvcm1NaW5Sb3RhdGlvbjogMVxuICAgICAgfSxcblxuICAgICAgaGFuZGxlcjogdHJhbnNmb3JtR2VzdHVyZVxuICAgIH07XG4gIH0pKCd0cmFuc2Zvcm0nKTtcblxuZXhwb3J0IGRlZmF1bHQgR2VzdHVyZURldGVjdG9yO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5wbGF0Zm9ybVxuICogQGNhdGVnb3J5IHV0aWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVXRpbGl0eSBtZXRob2RzIHRvIGRldGVjdCBjdXJyZW50IHBsYXRmb3JtLlsvZW5dXG4gKiAgIFtqYV3nj77lnKjlrp/ooYzjgZXjgozjgabjgYTjgovjg5fjg6njg4Pjg4jjg5Xjgqnjg7zjg6DjgpLmpJznn6XjgZnjgovjgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjg6Hjgr3jg4Pjg4njgpLlj47jgoHjgZ/jgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICovXG5jbGFzcyBQbGF0Zm9ybSB7XG5cbiAgLyoqXG4gICAqIEFsbCBlbGVtZW50cyB3aWxsIGJlIHJlbmRlcmVkIGFzIGlmIHRoZSBhcHAgd2FzIHJ1bm5pbmcgb24gdGhpcyBwbGF0Zm9ybS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlbmRlclBsYXRmb3JtID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNlbGVjdFxuICAgKiBAc2lnbmF0dXJlIHNlbGVjdChwbGF0Zm9ybSlcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwbGF0Zm9ybSBOYW1lIG9mIHRoZSBwbGF0Zm9ybS5cbiAgICogICBbZW5dUG9zc2libGUgdmFsdWVzIGFyZTogXCJvcGVyYVwiLCBcImZpcmVmb3hcIiwgXCJzYWZhcmlcIiwgXCJjaHJvbWVcIiwgXCJpZVwiLCBcImFuZHJvaWRcIiwgXCJibGFja2JlcnJ5XCIsIFwiaW9zXCIgb3IgXCJ3cFwiLlsvZW5dXG4gICAqICAgW2phXVwib3BlcmFcIiwgXCJmaXJlZm94XCIsIFwic2FmYXJpXCIsIFwiY2hyb21lXCIsIFwiaWVcIiwgXCJhbmRyb2lkXCIsIFwiYmxhY2tiZXJyeVwiLCBcImlvc1wiLCBcIndwXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2V0cyB0aGUgcGxhdGZvcm0gdXNlZCB0byByZW5kZXIgdGhlIGVsZW1lbnRzLiBVc2VmdWwgZm9yIHRlc3RpbmcuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44KS5o+P55S744GZ44KL44Gf44KB44Gr5Yip55So44GZ44KL44OX44Op44OD44OI44OV44Kp44O844Og5ZCN44KS6Kit5a6a44GX44G+44GZ44CC44OG44K544OI44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIHNlbGVjdChwbGF0Zm9ybSkge1xuICAgIGlmICh0eXBlb2YgcGxhdGZvcm0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9IHBsYXRmb3JtLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzV2ViVmlld1xuICAgKiBAc2lnbmF0dXJlIGlzV2ViVmlldygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxuICAgKiAgIFtqYV1Db3Jkb3Zh5YaF44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzV2ViVmlldygpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT0gJ3VuaW5pdGlhbGl6ZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzV2ViVmlldygpIG1ldGhvZCBpcyBhdmFpbGFibGUgYWZ0ZXIgZG9tIGNvbnRlbnRzIGxvYWRlZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEod2luZG93LmNvcmRvdmEgfHwgd2luZG93LnBob25lZ2FwIHx8IHdpbmRvdy5QaG9uZUdhcCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPU1xuICAgKiBAc2lnbmF0dXJlIGlzSU9TKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgT1MgaXMgaU9TLlsvZW5dXG4gICAqICAgW2phXWlPU+S4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lPUygpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2lvcyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkXG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgT1MgaXMgQW5kcm9pZC5bL2VuXVxuICAgKiAgIFtqYV1BbmRyb2lk5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQW5kcm9pZCgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRQaG9uZVxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZFBob25lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgcGhvbmUuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOaQuuW4r+S4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWRQaG9uZSgpIHtcbiAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkVGFibGV0XG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkVGFibGV0KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgdGFibGV0LlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTjgr/jg5bjg6zjg4Pjg4jkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkVGFibGV0KCkge1xuICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dQKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnd3AnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiAvV2luMzJOVHxXaW5DRS9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9XaW5kb3dzIFBob25lfElFTW9iaWxlfFdQRGVza3RvcC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob3MgaXNJUGhvbmVcbiAgICogQHNpZ25hdHVyZSBpc0lQaG9uZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGhvbmUuWy9lbl1cbiAgICogICBbamFdaVBob25l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBob25lKCkge1xuICAgIHJldHVybiAvaVBob25lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSVBhZFxuICAgKiBAc2lnbmF0dXJlIGlzSVBhZCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGFkLlsvZW5dXG4gICAqICAgW2phXWlQYWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUGFkKCkge1xuICAgIHJldHVybiAvaVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBvZCgpIHtcbiAgICByZXR1cm4gL2lQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNCbGFja0JlcnJ5XG4gICAqIEBzaWduYXR1cmUgaXNCbGFja0JlcnJ5KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEJsYWNrQmVycnkuWy9lbl1cbiAgICogICBbamFdQmxhY2tCZXJyeeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0JsYWNrQmVycnkoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdibGFja2JlcnJ5JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gL0JsYWNrQmVycnkvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvQmxhY2tCZXJyeXxSSU0gVGFibGV0IE9TfEJCMTAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzT3BlcmFcbiAgICogQHNpZ25hdHVyZSBpc09wZXJhKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBPcGVyYS5bL2VuXVxuICAgKiAgIFtqYV1PcGVyYeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc09wZXJhKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnb3BlcmEnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0ZpcmVmb3hcbiAgICogQHNpZ25hdHVyZSBpc0ZpcmVmb3goKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEZpcmVmb3guWy9lbl1cbiAgICogICBbamFdRmlyZWZveOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0ZpcmVmb3goKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdmaXJlZm94JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICh0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1NhZmFyaVxuICAgKiBAc2lnbmF0dXJlIGlzU2FmYXJpKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBTYWZhcmkuWy9lbl1cbiAgICogICBbamFdU2FmYXJp5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzU2FmYXJpKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnc2FmYXJpJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNDaHJvbWVcbiAgICogQHNpZ25hdHVyZSBpc0Nocm9tZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgQ2hyb21lLlsvZW5dXG4gICAqICAgW2phXUNocm9tZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0Nocm9tZSgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2Nocm9tZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoISF3aW5kb3cuY2hyb21lICYmICEoISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApICYmICEobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgRWRnZS8nKSA+PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJRVxuICAgKiBAc2lnbmF0dXJlIGlzSUUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyLlsvZW5dXG4gICAqICAgW2phXUludGVybmV0IEV4cGxvcmVy5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSUUoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdpZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZSB8fCAhIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0VkZ2VcbiAgICogQHNpZ25hdHVyZSBpc0VkZ2UoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEVkZ2UuWy9lbl1cbiAgICogICBbamFdRWRnZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0VkZ2UoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdlZGdlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIEVkZ2UvJykgPj0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPUzdhYm92ZVxuICAgKiBAc2lnbmF0dXJlIGlzSU9TN2Fib3ZlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgaU9TIHZlcnNpb24gaXMgNyBvciBhYm92ZS5bL2VuXVxuICAgKiAgIFtqYV1pT1M35Lul5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSU9TN2Fib3ZlKCkge1xuICAgIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuICgvaU9TL2kudGVzdChkZXZpY2UucGxhdGZvcm0pICYmIChwYXJzZUludChkZXZpY2UudmVyc2lvbi5zcGxpdCgnLicpWzBdKSA+PSA3KSk7XG4gICAgfSBlbHNlIGlmKC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc3QgdmVyID0gKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1xcYlswLTldK19bMC05XSsoPzpfWzAtOV0rKT9cXGIvKSB8fCBbJyddKVswXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICByZXR1cm4gKHBhcnNlSW50KHZlci5zcGxpdCgnLicpWzBdKSA+PSA3KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldE1vYmlsZU9TKCkge1xuICAgIGlmICh0aGlzLmlzQW5kcm9pZCgpKSB7XG4gICAgICByZXR1cm4gJ2FuZHJvaWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSU9TKCkpIHtcbiAgICAgIHJldHVybiAnaW9zJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc1dQKCkpIHtcbiAgICAgIHJldHVybiAnd3AnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRJT1NEZXZpY2UoKSB7XG4gICAgaWYgKHRoaXMuaXNJUGhvbmUoKSkge1xuICAgICAgcmV0dXJuICdpcGhvbmUnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSVBhZCgpKSB7XG4gICAgICByZXR1cm4gJ2lwYWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSVBvZCgpKSB7XG4gICAgICByZXR1cm4gJ2lwb2QnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnbmEnO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBQbGF0Zm9ybSgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5ub3RpZmljYXRpb25cbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBjb2RlcGVuIFF3d3h5cFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2RpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBVdGlsaXR5IG1ldGhvZHMgdG8gY3JlYXRlIGRpZmZlcmVudCBraW5kcyBvZiBhbGVydCBkaWFsb2dzLiBUaGVyZSBhcmUgdGhyZWUgbWV0aG9kcyBhdmFpbGFibGU6XG4gKlxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uYWxlcnQoKWBcbiAqICAgICAqIGBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0oKWBcbiAqICAgICAqIGBvbnMubm90aWZpY2F0aW9uLnByb21wdCgpYFxuICpcbiAqICAgICBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBkaWFsb2cgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44GE44GP44Gk44GL44Gu56iu6aGe44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS5L2c5oiQ44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdIZWxsbywgd29ybGQhJyk7XG4gKlxuICogb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKCdBcmUgeW91IHJlYWR5PycpXG4gKiAgIC50aGVuKFxuICogICAgIGZ1bmN0aW9uKGFuc3dlcikge1xuICogICAgICAgaWYgKGFuc3dlciA9PT0gMSkge1xuICogICAgICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdMZXRcXCdzIGdvIScpO1xuICogICAgICAgfVxuICogICAgIH1cbiAqICAgKTtcbiAqXG4gKiBvbnMubm90aWZpY2F0aW9uLnByb21wdCgnSG93IG9sZCBhcmUgPycpXG4gKiAgIC50aGVuKFxuICogICAgIGZ1bmN0aW9uKGFnZSkge1xuICogICAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnWW91IGFyZSAnICsgYWdlICsgJyB5ZWFycyBvbGQuJyk7XG4gKiAgICAgfVxuICogICApO1xuICovXG5jb25zdCBub3RpZmljYXRpb24gPSB7fTtcblxubm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyA9IGZ1bmN0aW9uKHRpdGxlLCBtZXNzYWdlLFxuICBidXR0b25MYWJlbHMsIHByaW1hcnlCdXR0b25JbmRleCwgbW9kaWZpZXIsIGFuaW1hdGlvbiwgaWQsIGNhbGxiYWNrLFxuICBtZXNzYWdlSXNIVE1MLCBjYW5jZWxhYmxlLCBwcm9tcHREaWFsb2csIGF1dG9mb2N1cywgcGxhY2Vob2xkZXIsXG4gIGRlZmF1bHRWYWx1ZSwgc3VibWl0T25FbnRlciwgY29tcGlsZSkge1xuXG4gIGNvbXBpbGUgPSBjb21waWxlIHx8IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0OyB9O1xuXG4gIGNvbnN0IHRpdGxlRWxlbWVudEhUTUwgPSB0eXBlb2YgdGl0bGUgPT09ICdzdHJpbmcnID8gJzxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctdGl0bGVcIj48L2Rpdj4nIDogJyc7XG5cblxuICBsZXQgZGlhbG9nRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxvbnMtYWxlcnQtZGlhbG9nPlxuICAgICR7dGl0bGVFbGVtZW50SFRNTH1cbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRlbnRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWZvb3RlclwiPjwvZGl2PlxuICA8L29ucy1hbGVydC1kaWFsb2c+YCk7XG5cbiAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShkaWFsb2dFbGVtZW50KTtcblxuICBpZiAoaWQpIHtcbiAgICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gIH1cblxuICBsZXQgdGl0bGVFbGVtZW50ID0gZGlhbG9nRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuYWxlcnQtZGlhbG9nLXRpdGxlJyk7XG4gIGxldCBtZXNzYWdlRWxlbWVudCA9IGRpYWxvZ0VsZW1lbnQucXVlcnlTZWxlY3RvcignLmFsZXJ0LWRpYWxvZy1jb250ZW50Jyk7XG4gIGxldCBmb290ZXJFbGVtZW50ID0gZGlhbG9nRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuYWxlcnQtZGlhbG9nLWZvb3RlcicpO1xuICBsZXQgaW5wdXRFbGVtZW50O1xuICBjb25zdCByZXN1bHQgPSB7fTtcblxuICByZXN1bHQucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXN1bHQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgcmVzdWx0LnJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG5cbiAgbW9kaWZpZXIgPSBtb2RpZmllciB8fCBkaWFsb2dFbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKTtcblxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnc3RyaW5nJykge1xuICAgIHRpdGxlRWxlbWVudC50ZXh0Q29udGVudCA9IHRpdGxlO1xuICB9XG5cbiAgdGl0bGVFbGVtZW50ID0gbnVsbDtcblxuICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJywgYW5pbWF0aW9uKTtcblxuICBpZiAobWVzc2FnZUlzSFRNTCkge1xuICAgIG1lc3NhZ2VFbGVtZW50LmlubmVySFRNTCA9IG1lc3NhZ2U7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZUVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICB9XG5cbiAgaWYgKHByb21wdERpYWxvZykge1xuICAgIGlucHV0RWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudCgnPGlucHV0IGNsYXNzPVwidGV4dC1pbnB1dCB0ZXh0LWlucHV0LS11bmRlcmJhclwiIHR5cGU9XCJ0ZXh0XCI+PC9pbnB1dD4nKTtcblxuICAgIGlmIChtb2RpZmllcikge1xuICAgICAgaW5wdXRFbGVtZW50LmNsYXNzTGlzdC5hZGQoYHRleHQtaW5wdXQtLSR7bW9kaWZpZXJ9YCk7XG4gICAgfVxuXG4gICAgaW5wdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCBwbGFjZWhvbGRlcik7XG4gICAgaW5wdXRFbGVtZW50LnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIGlucHV0RWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBpbnB1dEVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gJzEwcHgnO1xuXG4gICAgbWVzc2FnZUVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRFbGVtZW50KTtcblxuICAgIGlmIChzdWJtaXRPbkVudGVyKSB7XG4gICAgICBpbnB1dEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICBkaWFsb2dFbGVtZW50LmhpZGUoe1xuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZShpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgICBkaWFsb2dFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICBkaWFsb2dFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGlhbG9nRWxlbWVudCk7XG5cbiAgY29tcGlsZShkaWFsb2dFbGVtZW50KTtcblxuICBpZiAoYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyKSB7XG4gICAgZm9vdGVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctZm9vdGVyLS1vbmUnKTtcbiAgfVxuXG4gIGNvbnN0IGNyZWF0ZUJ1dHRvbiA9IGZ1bmN0aW9uKGkpIHtcbiAgICBsZXQgYnV0dG9uRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudCgnPGJ1dHRvbiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIj48L2J1dHRvbj4nKTtcbiAgICBidXR0b25FbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGJ1dHRvbkxhYmVsc1tpXSkpO1xuXG4gICAgaWYgKGkgPT0gcHJpbWFyeUJ1dHRvbkluZGV4KSB7XG4gICAgICBidXR0b25FbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCcpO1xuICAgIH1cblxuICAgIGlmIChidXR0b25MYWJlbHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgIGJ1dHRvbkVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tb25lJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb25DbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgYnV0dG9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIGZhbHNlKTtcblxuICAgICAgZGlhbG9nRWxlbWVudC5oaWRlKHtcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChwcm9tcHREaWFsb2cpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0RWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHQucmVzb2x2ZShpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhpKTtcbiAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaWFsb2dFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgIGRpYWxvZ0VsZW1lbnQgPSBpbnB1dEVsZW1lbnQgPSBidXR0b25FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGJ1dHRvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrLCBmYWxzZSk7XG4gICAgZm9vdGVyRWxlbWVudC5hcHBlbmRDaGlsZChidXR0b25FbGVtZW50KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1dHRvbkxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIGNyZWF0ZUJ1dHRvbihpKTtcbiAgfVxuXG4gIGlmIChjYW5jZWxhYmxlKSB7XG4gICAgZGlhbG9nRWxlbWVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcbiAgICBkaWFsb2dFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbmNlbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByb21wdERpYWxvZykge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgcmVzdWx0LnJlamVjdChudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKC0xKTtcbiAgICAgICAgcmVzdWx0LnJlamVjdCgtMSk7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBkaWFsb2dFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBkaWFsb2dFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgaW5wdXRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIGRpYWxvZ0VsZW1lbnQuc2hvdyh7XG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGlucHV0RWxlbWVudCAmJiBwcm9tcHREaWFsb2cgJiYgYXV0b2ZvY3VzKSB7XG4gICAgICAgIGlucHV0RWxlbWVudC5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgbWVzc2FnZUVsZW1lbnQgPSBmb290ZXJFbGVtZW50ID0gbnVsbDtcblxuICBpZiAobW9kaWZpZXIpIHtcbiAgICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCAnJyk7XG4gICAgZGlhbG9nRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbW9kaWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5wcm9taXNlO1xufTtcblxubm90aWZpY2F0aW9uLl9hbGVydE9yaWdpbmFsID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG4gIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IChvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlKSA6IChvcHRpb25zID0gbWVzc2FnZSk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGJ1dHRvbkxhYmVsOiAn56Gu5a6aJyxcbiAgICBhbmltYXRpb246ICdkZWZhdWx0JyxcbiAgICB0aXRsZTogJycsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge31cbiAgfTtcblxuICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgaWYgKCFvcHRpb25zLm1lc3NhZ2UgJiYgIW9wdGlvbnMubWVzc2FnZUhUTUwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsZXJ0IGRpYWxvZyBtdXN0IGNvbnRhaW4gYSBtZXNzYWdlLicpO1xuICB9XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2coXG4gICAgb3B0aW9ucy50aXRsZSxcbiAgICBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTCxcbiAgICBbb3B0aW9ucy5idXR0b25MYWJlbF0sXG4gICAgMCxcbiAgICBvcHRpb25zLm1vZGlmaWVyLFxuICAgIG9wdGlvbnMuYW5pbWF0aW9uLFxuICAgIG9wdGlvbnMuaWQsXG4gICAgb3B0aW9ucy5jYWxsYmFjayxcbiAgICAhb3B0aW9ucy5tZXNzYWdlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsICcnLCAnJywgZmFsc2UsXG4gICAgb3B0aW9ucy5jb21waWxlXG4gICk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgYWxlcnRcbiAqIEBzaWduYXR1cmUgYWxlcnQobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHdoZW4gdGhlIGRpYWxvZyBpcyBjbG9zZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogICBbZW5dQWxlcnQgbWVzc2FnZS4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbCBidXQgaWYgaXQncyBub3QgZGVmaW5lZCBlaXRoZXIgYG9wdGlvbnMubWVzc2FnZWAgb3IgYG9wdGlvbnMubWVzc2FnZUhUTUxgIG11c3QgYmUgZGVmaW5lZCBpbnN0ZWFkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZV1cbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi+aWh+Wtl+WIl+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZUhUTUxdXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlIGluIEhUTUwuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi0hUTUzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJ1dHRvbkxhYmVsXVxuICogICBbZW5dTGFiZWwgZm9yIGNvbmZpcm1hdGlvbiBidXR0b24uIERlZmF1bHQgaXMgYFwiT0tcImAuWy9lbl1cbiAqICAgW2phXeeiuuiqjeODnOOCv+ODs+OBruODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiT0tcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXVxuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQncyBJRC5bL2VuXVxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+imgee0oOOBrklE44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aXRsZV1cbiAqICAgW2VuXURpYWxvZyB0aXRsZS4gRGVmYXVsdCBpcyBgXCJBbGVydFwiYC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu5LiK6YOo44Gr6KGo56S644GZ44KL44K/44Kk44OI44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJBbGVydFwi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cbiAqICAgW2VuXU1vZGlmaWVyIGZvciB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgZGlhbG9nIGhhcyBiZWVuIGNsb3NlZC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KJ44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheSBhbiBhbGVydCBkaWFsb2cgdG8gc2hvdyB0aGUgdXNlciBhIG1lc3NhZ2UuXG4gKlxuICogICAgIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlIGNhbiBiZSBlaXRoZXIgc2ltcGxlIHRleHQgb3IgSFRNTC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogICAgIGBgYFxuICogICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQobWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydChvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODpuODvOOCtuODvOOBuOODoeODg+OCu+ODvOOCuOOCkuimi+OBm+OCi+OBn+OCgeOBruOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICogICAgIOihqOekuuOBmeOCi+ODoeODg+OCu+ODvOOCuOOBr+OAgeODhuOCreOCueODiOOBi+OCguOBl+OBj+OBr0hUTUzjgpLmjIflrprjgafjgY3jgb7jgZnjgIJcbiAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi5hbGVydCA9IG5vdGlmaWNhdGlvbi5fYWxlcnRPcmlnaW5hbDtcblxubm90aWZpY2F0aW9uLl9jb25maXJtT3JpZ2luYWwgPSBmdW5jdGlvbihtZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gKG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2UpIDogKG9wdGlvbnMgPSBtZXNzYWdlKTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgYnV0dG9uTGFiZWxzOiBbJ+WPlua2iCcsICfnoa7lrponXSxcbiAgICBwcmltYXJ5QnV0dG9uSW5kZXg6IDEsXG4gICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXG4gICAgdGl0bGU6ICcnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHt9LFxuICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gIH07XG5cbiAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgaWYgKCFvcHRpb25zLm1lc3NhZ2UgJiYgIW9wdGlvbnMubWVzc2FnZUhUTUwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpcm0gZGlhbG9nIG11c3QgY29udGFpbiBhIG1lc3NhZ2UuJyk7XG4gIH1cblxuICByZXR1cm4gbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhcbiAgICBvcHRpb25zLnRpdGxlLFxuICAgIG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLm1lc3NhZ2VIVE1MLFxuICAgIG9wdGlvbnMuYnV0dG9uTGFiZWxzLFxuICAgIG9wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4LFxuICAgIG9wdGlvbnMubW9kaWZpZXIsXG4gICAgb3B0aW9ucy5hbmltYXRpb24sXG4gICAgb3B0aW9ucy5pZCxcbiAgICBvcHRpb25zLmNhbGxiYWNrLFxuICAgICFvcHRpb25zLm1lc3NhZ2UgPyB0cnVlIDogZmFsc2UsXG4gICAgb3B0aW9ucy5jYW5jZWxhYmxlLFxuICAgIGZhbHNlLCBmYWxzZSwgJycsICcnLCBmYWxzZSxcbiAgICBvcHRpb25zLmNvbXBpbGVcbiAgKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb25maXJtXG4gKiBAc2lnbmF0dXJlIGNvbmZpcm0obWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbmRleCBvZiB0aGUgYnV0dG9uIHRoYXQgd2FzIHByZXNzZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogICBbZW5dQWxlcnQgbWVzc2FnZS4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbCBidXQgaWYgaXQncyBub3QgZGVmaW5lZCBlaXRoZXIgYG9wdGlvbnMubWVzc2FnZWAgb3IgYG9wdGlvbnMubWVzc2FnZUhUTUxgIG11c3QgYmUgZGVmaW5lZCBpbnN0ZWFkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlXVxuICogICBbZW5dQ29uZmlybWF0aW9uIHF1ZXN0aW9uLlsvZW5dXG4gKiAgIFtqYV3norroqo3jg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgovjg6Hjg4Pjgrvjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VIVE1MXVxuICogICBbZW5dRGlhbG9nIGNvbnRlbnQgaW4gSFRNTC5bL2VuXVxuICogICBbamFd56K66KqN44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KLSFRNTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5idXR0b25MYWJlbHNdXG4gKiAgIFtlbl1MYWJlbHMgZm9yIHRoZSBidXR0b25zLiBEZWZhdWx0IGlzIGBbXCJDYW5jZWxcIiwgXCJPS1wiXWAuWy9lbl1cbiAqICAgW2phXeODnOOCv+ODs+OBruODqeODmeODq+OBrumFjeWIl+OCkuaMh+WumuOBl+OBvuOBmeOAgltcIkNhbmNlbFwiLCBcIk9LXCJd44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXhdXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyBgMWAuWy9lbl1cbiAqICAgW2phXeODl+ODqeOCpOODnuODquODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryAxIOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhbmNlbGFibGVdXG4gKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIERlZmF1bHQgaXMgYGZhbHNlYC4gSWYgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgY2xpY2tpbmcgdGhlIGJhY2tncm91bmQgb3IgcHJlc3NpbmcgdGhlIEFuZHJvaWQgYmFjayBidXR0b24uWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXVxuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQncyBJRC5bL2VuXVxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+imgee0oOOBrklE44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aXRsZV1cbiAqICAgW2VuXURpYWxvZyB0aXRsZS4gRGVmYXVsdCBpcyBgXCJDb25maXJtXCJgLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgr/jgqTjg4jjg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIkNvbmZpcm1cIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gKiAgIFtlbl1Nb2RpZmllciBmb3IgdGhlIGRpYWxvZy5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKiAgIFtlbl1cbiAqICAgICBGdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gY2xvc2VkLlxuICogICAgIEFyZ3VtZW50IGZvciB0aGUgZnVuY3Rpb24gaXMgdGhlIGluZGV4IG9mIHRoZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZCBvciBgLTFgIGlmIHRoZSBkaWFsb2cgd2FzIGNhbmNlbGVkLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KJ44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCXG4gKiAgICAg44GT44Gu6Zai5pWw44Gu5byV5pWw44Go44GX44Gm44CB5oq844GV44KM44Gf44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K55YCk44GM5rih44GV44KM44G+44GZ44CCXG4gKiAgICAg44KC44GX44OA44Kk44Ki44Ot44Kw44GM44Kt44Oj44Oz44K744Or44GV44KM44Gf5aC05ZCI44Gr44GvLTHjgYzmuKHjgZXjgozjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheSBhIGRpYWxvZyB0byBhc2sgdGhlIHVzZXIgZm9yIGNvbmZpcm1hdGlvbi5cbiAqICAgICBUaGUgZGVmYXVsdCBidXR0b24gbGFiZWxzIGFyZSBgXCJDYW5jZWxcImAgYW5kIGBcIk9LXCJgIGJ1dCB0aGV5IGNhbiBiZSBjdXN0b21pemVkLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24uY29uZmlybShvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODpuODvOOCtuOBq+eiuuiqjeOCkuS/g+OBmeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICogICAgIOODh+OCquODq+OBqOOBruODnOOCv+ODs+ODqeODmeODq+OBr+OAgVwiQ2FuY2VsXCLjgahcIk9LXCLjgafjgZnjgYzjgIHjgZPjgozjga/jgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgafjgqvjgrnjgr/jg57jgqTjgrrjgafjgY3jgb7jgZnjgIJcbiAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi5jb25maXJtID0gbm90aWZpY2F0aW9uLl9jb25maXJtT3JpZ2luYWw7XG5cbm5vdGlmaWNhdGlvbi5fcHJvbXB0T3JpZ2luYWwgPSBmdW5jdGlvbihtZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gKG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2UpIDogKG9wdGlvbnMgPSBtZXNzYWdlKTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgYnV0dG9uTGFiZWw6ICfnoa7lrponLFxuICAgIGFuaW1hdGlvbjogJ2RlZmF1bHQnLFxuICAgIHRpdGxlOiAnJyxcbiAgICBkZWZhdWx0VmFsdWU6ICcnLFxuICAgIHBsYWNlaG9sZGVyOiAnJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7fSxcbiAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICBhdXRvZm9jdXM6IHRydWUsXG4gICAgc3VibWl0T25FbnRlcjogdHJ1ZVxuICB9O1xuXG4gIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICBpZiAoIW9wdGlvbnMubWVzc2FnZSAmJiAhb3B0aW9ucy5tZXNzYWdlSFRNTCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvbXB0IGRpYWxvZyBtdXN0IGNvbnRhaW4gYSBtZXNzYWdlLicpO1xuICB9XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2coXG4gICAgb3B0aW9ucy50aXRsZSxcbiAgICBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTCxcbiAgICBbb3B0aW9ucy5idXR0b25MYWJlbF0sXG4gICAgMCxcbiAgICBvcHRpb25zLm1vZGlmaWVyLFxuICAgIG9wdGlvbnMuYW5pbWF0aW9uLFxuICAgIG9wdGlvbnMuaWQsXG4gICAgb3B0aW9ucy5jYWxsYmFjayxcbiAgICAhb3B0aW9ucy5tZXNzYWdlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIG9wdGlvbnMuY2FuY2VsYWJsZSxcbiAgICB0cnVlLFxuICAgIG9wdGlvbnMuYXV0b2ZvY3VzLFxuICAgIG9wdGlvbnMucGxhY2Vob2xkZXIsXG4gICAgb3B0aW9ucy5kZWZhdWx0VmFsdWUsXG4gICAgb3B0aW9ucy5zdWJtaXRPbkVudGVyLFxuICAgIG9wdGlvbnMuY29tcGlsZVxuICApO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHByb21wdFxuICogQHNpZ25hdHVyZSBwcm9tcHQobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogICBbZW5dQWxlcnQgbWVzc2FnZS4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbCBidXQgaWYgaXQncyBub3QgZGVmaW5lZCBlaXRoZXIgYG9wdGlvbnMubWVzc2FnZWAgb3IgYG9wdGlvbnMubWVzc2FnZUhUTUxgIG11c3QgYmUgZGVmaW5lZCBpbnN0ZWFkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB0byB0aGUgaW5wdXQgdmFsdWUgd2hlbiB0aGUgZGlhbG9nIGlzIGNsb3NlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VdXG4gKiAgIFtlbl1Qcm9tcHQgcXVlc3Rpb24uWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi+ODoeODg+OCu+ODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZUhUTUxdXG4gKiAgIFtlbl1EaWFsb2cgY29udGVudCBpbiBIVE1MLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgotIVE1M44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5idXR0b25MYWJlbF1cbiAqICAgW2VuXUxhYmVsIGZvciBjb25maXJtYXRpb24gYnV0dG9uLiBEZWZhdWx0IGlzIGBcIk9LXCJgLlsvZW5dXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleF1cbiAqICAgW2VuXUluZGV4IG9mIHByaW1hcnkgYnV0dG9uLiBEZWZhdWx0IGlzIGAxYC5bL2VuXVxuICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDEg44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FuY2VsYWJsZV1cbiAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gRGVmYXVsdCBpcyBmYWxzZS4gV2hlbiB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgaXQgd2lsbCBiZSBjbG9zZWQgaWYgdGhlIHVzZXIgdGFwcyB0aGUgYmFja2dyb3VuZCBvciBwcmVzc2VzIHRoZSBBbmRyb2lkIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gZmFsc2Ug44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAsIGBcImZhZGVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWRdXG4gKiAgIFtlbl1UaGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCdzIElELlsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n6KaB57Sg44GuSUTjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpdGxlXVxuICogICBbZW5dRGlhbG9nIHRpdGxlLiBEZWZhdWx0IGlzIGBcIkFsZXJ0XCJgLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgr/jgqTjg4jjg6vjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gXCJBbGVydFwiIOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGxhY2Vob2xkZXJdXG4gKiAgIFtlbl1QbGFjZWhvbGRlciBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODl+ODrOODvOOCueODm+ODq+ODgOOBq+ihqOekuuOBmeOCi+ODhuOCreOCueODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGVmYXVsdFZhbHVlXVxuICogICBbZW5dRGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODh+ODleOCqeODq+ODiOOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9mb2N1c11cbiAqICAgW2VuXUF1dG9mb2N1cyB0aGUgaW5wdXQgZWxlbWVudC4gRGVmYXVsdCBpcyBgdHJ1ZWAuWy9lbl1cbiAqICAgW2phXWlucHV06KaB57Sg44Gr6Ieq5YuV55qE44Gr44OV44Kp44O844Kr44K544GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvdHJ1ZeOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gKiAgIFtlbl1Nb2RpZmllciBmb3IgdGhlIGRpYWxvZy5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKiAgIFtlbl1cbiAqICAgICBGdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gY2xvc2VkLlxuICogICAgIEFyZ3VtZW50IGZvciB0aGUgZnVuY3Rpb24gaXMgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBmaWVsZCBvciBgbnVsbGAgaWYgdGhlIGRpYWxvZyB3YXMgY2FuY2VsZWQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgonjgozjgZ/lvozjgavlrp/ooYzjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJcbiAqICAgICDplqLmlbDjga7lvJXmlbDjgajjgZfjgabjgIHjgqTjg7Pjg5fjg4Pjg4jopoHntKDjga7kuK3jga7lgKTjgYzmuKHjgZXjgozjgb7jgZnjgILjg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgZ/loLTlkIjjgavjga/jgIFudWxs44GM5rih44GV44KM44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN1Ym1pdE9uRW50ZXJdXG4gKiAgIFtlbl1TdWJtaXQgYXV0b21hdGljYWxseSB3aGVuIGVudGVyIGlzIHByZXNzZWQuIERlZmF1bHQgaXMgYHRydWVgLlsvZW5dXG4gKiAgIFtqYV1FbnRlcuOBjOaKvOOBleOCjOOBn+mam+OBq+OBneOBrmZvcm3jgpJzdWJtaXTjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga90cnVl44Gn44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheSBhIGRpYWxvZyB3aXRoIGEgcHJvbXB0IHRvIGFzayB0aGUgdXNlciBhIHF1ZXN0aW9uLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQobWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjg7zjgavlhaXlipvjgpLkv4PjgZnjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi5wcm9tcHQgPSBub3RpZmljYXRpb24uX3Byb21wdE9yaWdpbmFsO1xuXG5leHBvcnQgZGVmYXVsdCBub3RpZmljYXRpb247XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5cbmNvbnN0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uID0ge1xuICBfdmFyaWFibGVzOiB7fSxcblxuICAvKipcbiAgICogRGVmaW5lIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZSBWYWx1ZSBvZiB0aGUgdmFyaWFibGUuIENhbiBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcndyaXRlIElmIHRoaXMgdmFsdWUgaXMgZmFsc2UsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIHdoZW4gdHJ5aW5nIHRvIGRlZmluZSBhIHZhcmlhYmxlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlxuICAgKi9cbiAgZGVmaW5lVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvdmVyd3JpdGU9ZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcmlhYmxlIG5hbWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFyaWFibGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBpcyBhbHJlYWR5IGRlZmluZWQuYCk7XG4gICAgfVxuICAgIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ3xGdW5jdGlvbnxudWxsfVxuICAgKi9cbiAgZ2V0VmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmFpYmxlLlxuICAgKi9cbiAgcmVtb3ZlVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QWxsVmFyaWFibGVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzO1xuICB9LFxuICBfcGFyc2VQYXJ0OiBmdW5jdGlvbihwYXJ0KSB7XG4gICAgbGV0IGMsXG4gICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZSxcbiAgICAgIGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcblxuICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IHBhcnQuY2hhckF0KGkpO1xuXG4gICAgICBpZiAoYyA9PT0gJyQnICYmIHBhcnQuY2hhckF0KGkgKyAxKSA9PT0gJ3snKSB7XG4gICAgICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RlZCBpbnRlcnBvbGF0aW9uIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSk7XG4gICAgICAgIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50SW5kZXggPSBpO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYyA9PT0gJ30nKSB7XG4gICAgICAgIGlmICghaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd9IG11c3QgYmUgcHJlY2VlZGVkIGJ5ICR7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpO1xuICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGkgKyAxO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VudGVybWluYXRlZCBpbnRlcnBvbGF0aW9uLicpO1xuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgcGFydC5sZW5ndGgpKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH0sXG4gIF9yZXBsYWNlVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgY29uc3QgcmUgPSAvXlxcJHsoLio/KX0kLyxcbiAgICAgIG1hdGNoID0gdG9rZW4ubWF0Y2gocmUpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBjb25zdCBuYW1lID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLmdldFZhcmlhYmxlKG5hbWUpO1xuXG4gICAgICBpZiAodmFyaWFibGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYXJpYWJsZSBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YXJpYWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gdmFyaWFibGUoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJ2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCByZXR1cm4gYSBzdHJpbmcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfSxcbiAgX3JlcGxhY2VUb2tlbnM6IGZ1bmN0aW9uKHRva2Vucykge1xuICAgIHJldHVybiB0b2tlbnMubWFwKHRoaXMuX3JlcGxhY2VUb2tlbi5iaW5kKHRoaXMpKTtcbiAgfSxcbiAgX3BhcnNlRXhwcmVzc2lvbjogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uLnNwbGl0KCcsJylcbiAgICAgIC5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFydC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5tYXAodGhpcy5fcGFyc2VQYXJ0LmJpbmQodGhpcykpXG4gICAgICAubWFwKHRoaXMuX3JlcGxhY2VUb2tlbnMuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAoKHBhcnQpID0+IHBhcnQuam9pbignJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiBBbiBwYWdlIGF0dHJpYnV0ZSBleHByZXNzaW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGV2YWx1YXRlOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgfVxufTtcblxuLy8gRGVmaW5lIGRlZmF1bHQgdmFyaWFibGVzLlxucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ21vYmlsZU9TJywgcGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSk7XG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgnaU9TRGV2aWNlJywgcGxhdGZvcm0uZ2V0SU9TRGV2aWNlKCkpO1xucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ3J1bnRpbWUnLCAoKSA9PiB7XG4gIHJldHVybiBwbGF0Zm9ybS5pc1dlYlZpZXcoKSA/ICdjb3Jkb3ZhJyA6ICdicm93c2VyJztcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5pbXBvcnQgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gZnJvbSAnLi4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XG5cbmNvbnN0IGludGVybmFsID0ge307XG5cbmludGVybmFsLmNvbmZpZyA9IHtcbiAgYXV0b1N0YXR1c0JhckZpbGw6IHRydWUsXG4gIGFuaW1hdGlvbnNEaXNhYmxlZDogZmFsc2Vcbn07XG5cbmludGVybmFsLm51bGxFbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICByZXR1cm4gISFpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MID0gaHRtbCA9PiB7XG4gIGh0bWwgPSAoJycgKyBodG1sKS50cmltKCk7XG5cbiAgaWYgKCFodG1sLm1hdGNoKC9ePG9ucy1wYWdlLykpIHtcbiAgICBodG1sID0gJzxvbnMtcGFnZSBfbXV0ZWQ+JyArIGh0bWwgKyAnPC9vbnMtcGFnZT4nO1xuICB9XG5cbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5pbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZCA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKHdpbmRvdy5kb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycgfHwgd2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgPT0gJ3VuaW5pdGlhbGl6ZWQnKSB7XG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwgPSBhY3Rpb24gPT4ge1xuICBjb25zdCBvblJlYWR5ID0gKCkgPT4ge1xuICAgIGlmIChpbnRlcm5hbC5zaG91bGRGaWxsU3RhdHVzQmFyKCkpIHtcbiAgICAgIGFjdGlvbigpO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBvblJlYWR5KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xuICB9IGVsc2UgaWYgKFsnY29tcGxldGUnLCAnaW50ZXJhY3RpdmUnXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID09PSAtMSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIG9uUmVhZHkoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvblJlYWR5KCk7XG4gIH1cbn07XG5cbmludGVybmFsLnNob3VsZEZpbGxTdGF0dXNCYXIgPSAoKSA9PiBpbnRlcm5hbC5pc0VuYWJsZWRBdXRvU3RhdHVzQmFyRmlsbCgpICYmIHBsYXRmb3JtLmlzV2ViVmlldygpICYmIHBsYXRmb3JtLmlzSU9TN2Fib3ZlKCk7XG5cbmludGVybmFsLnRlbXBsYXRlU3RvcmUgPSB7XG4gIF9zdG9yYWdlOiB7fSxcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtTdHJpbmcvbnVsbH0gdGVtcGxhdGVcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5fc3RvcmFnZVtrZXldIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gICAqL1xuICBzZXQoa2V5LCB0ZW1wbGF0ZSkge1xuICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuX3N0b3JhZ2Vba2V5XSA9IHRlbXBsYXRlO1xuICB9XG59O1xuXG53aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignX3RlbXBsYXRlbG9hZGVkJywgZnVuY3Rpb24oZSkge1xuICBpZiAoZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10ZW1wbGF0ZScpIHtcbiAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldChlLnRlbXBsYXRlSWQsIGUudGVtcGxhdGUpO1xuICB9XG59LCBmYWxzZSk7XG5cbndpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvb25zLXRlbXBsYXRlXCJdJyk7XG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvdGVtcGxhdGVcIl0nKTtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC9uZy10ZW1wbGF0ZVwiXScpO1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKHF1ZXJ5KSB7XG4gICAgY29uc3QgdGVtcGxhdGVzID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldCh0ZW1wbGF0ZXNbaV0uZ2V0QXR0cmlidXRlKCdpZCcpLCB0ZW1wbGF0ZXNbaV0udGV4dENvbnRlbnQpO1xuICAgIH1cbiAgfVxufSwgZmFsc2UpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5pbnRlcm5hbC5nZXRUZW1wbGF0ZUhUTUxBc3luYyA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgY2FjaGUgPSBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLmdldChwYWdlKTtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGh0bWwgPSB0eXBlb2YgY2FjaGUgPT09ICdzdHJpbmcnID8gY2FjaGUgOiBjYWNoZVsxXTtcbiAgICAgICAgcmVzb2x2ZShodG1sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgcGFnZSwgdHJ1ZSk7XG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIGNvbnN0IGh0bWwgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDQwMCAmJiB4aHIuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICByZWplY3QoaHRtbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShodG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcGFnZSBpcyBub3QgZm91bmQ6ICR7cGFnZX1gKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgY29uc3QgcGFnZXMgPSBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5ldmFsdWF0ZShwYWdlKTtcblxuICBjb25zdCBnZXRQYWdlID0gKHBhZ2UpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ011c3Qgc3BlY2lmeSBhIHBhZ2UuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jKHBhZ2UpXG4gICAgICAudGhlbihcbiAgICAgICAgZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTChodG1sKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBpZiAocGFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBnZXRQYWdlKHBhZ2VzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgICAudGhlbihodG1sID0+IGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKGh0bWwpKTtcbiAgfTtcblxuICByZXR1cm4gZ2V0UGFnZShwYWdlcy5zaGlmdCgpKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRvckZhY3Rvcnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5hbmltYXRvcnMgVGhlIGRpY3Rpb25hcnkgZm9yIGFuaW1hdG9yIGNsYXNzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5iYXNlQ2xhc3MgVGhlIGJhc2UgY2xhc3Mgb2YgYW5pbWF0b3JzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5iYXNlQ2xhc3NOYW1lXSBUaGUgbmFtZSBvZiB0aGUgYmFzZSBjbGFzcyBvZiBhbmltYXRvcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmRlZmF1bHRBbmltYXRpb25dIFRoZSBkZWZhdWx0IGFuaW1hdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9uc10gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLl9hbmltYXRvcnMgPSBvcHRzLmFuaW1hdG9ycztcbiAgICB0aGlzLl9iYXNlQ2xhc3MgPSBvcHRzLmJhc2VDbGFzcztcbiAgICB0aGlzLl9iYXNlQ2xhc3NOYW1lID0gb3B0cy5iYXNlQ2xhc3NOYW1lIHx8IG9wdHMuYmFzZUNsYXNzLm5hbWU7XG4gICAgdGhpcy5fYW5pbWF0aW9uID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uIHx8ICdkZWZhdWx0JztcbiAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBhbmltYXRpb246ICcgKyB0aGlzLl9hbmltYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ganNvblN0cmluZ1xuICAgKiBAcmV0dXJuIHtPYmplY3QvbnVsbH1cbiAgICovXG4gIHN0YXRpYyBwYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcoanNvblN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGpzb25TdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdcImFuaW1hdGlvbi1vcHRpb25zXCIgYXR0cmlidXRlIG11c3QgYmUgYSBKU09OIG9iamVjdCBzdHJpbmc6ICcgKyBqc29uU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgc2V0QW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl0gVGhlIGFuaW1hdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXSBUaGUgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRBbmltYXRvciBUaGUgZGVmYXVsdCBhbmltYXRvciBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGFuaW1hdG9yIGluc3RhbmNlXG4gICAqL1xuICBuZXdBbmltYXRvcihvcHRpb25zID0ge30sIGRlZmF1bHRBbmltYXRvcikge1xuXG4gICAgbGV0IGFuaW1hdG9yID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiBpbnN0YW5jZW9mIHRoaXMuX2Jhc2VDbGFzcykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIH1cblxuICAgIGxldCBBbmltYXRvciA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYW5pbWF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgQW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvcnNbb3B0aW9ucy5hbmltYXRpb25dO1xuICAgIH1cblxuICAgIGlmICghQW5pbWF0b3IgJiYgZGVmYXVsdEFuaW1hdG9yKSB7XG4gICAgICBhbmltYXRvciA9IGRlZmF1bHRBbmltYXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQW5pbWF0b3IgPSBBbmltYXRvciB8fCB0aGlzLl9hbmltYXRvcnNbdGhpcy5fYW5pbWF0aW9uXTtcblxuICAgICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyxcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgICBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID8ge2R1cmF0aW9uOiAwLCBkZWxheTogMH0gOiB7fVxuICAgICAgKTtcblxuICAgICAgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7XG5cbiAgICAgIGlmICh0eXBlb2YgYW5pbWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYW5pbWF0b3IgPSBuZXcgYW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKGFuaW1hdG9yIGluc3RhbmNlb2YgdGhpcy5fYmFzZUNsYXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImFuaW1hdG9yXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mICcgKyB0aGlzLl9iYXNlQ2xhc3NOYW1lICsgJy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGlmaWVyVXRpbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFxuICAgKi9cbiAgc3RhdGljIGRpZmYobGFzdCwgY3VycmVudCkge1xuICAgIGxhc3QgPSBtYWtlRGljdCgoJycgKyBsYXN0KS50cmltKCkpO1xuICAgIGN1cnJlbnQgPSBtYWtlRGljdCgoJycgKyBjdXJyZW50KS50cmltKCkpO1xuXG4gICAgY29uc3QgcmVtb3ZlZCA9IE9iamVjdC5rZXlzKGxhc3QpLnJlZHVjZSgocmVzdWx0LCB0b2tlbikgPT4ge1xuICAgICAgaWYgKCFjdXJyZW50W3Rva2VuXSkge1xuICAgICAgICByZXN1bHQucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGFkZGVkID0gT2JqZWN0LmtleXMoY3VycmVudCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XG4gICAgICBpZiAoIWxhc3RbdG9rZW5dKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHthZGRlZCwgcmVtb3ZlZH07XG5cbiAgICBmdW5jdGlvbiBtYWtlRGljdChtb2RpZmllcikge1xuICAgICAgY29uc3QgZGljdCA9IHt9O1xuICAgICAgTW9kaWZpZXJVdGlsLnNwbGl0KG1vZGlmaWVyKS5mb3JFYWNoKHRva2VuID0+IGRpY3RbdG9rZW5dID0gdG9rZW4pO1xuICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWZmXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjbGFzc0xpc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEaWZmVG9DbGFzc0xpc3QoZGlmZiwgY2xhc3NMaXN0LCB0ZW1wbGF0ZSkge1xuICAgIGRpZmYuYWRkZWRcbiAgICAgIC5tYXAobW9kaWZpZXIgPT4gdGVtcGxhdGUucmVwbGFjZSgvXFwqL2csIG1vZGlmaWVyKSlcbiAgICAgIC5mb3JFYWNoKGtsYXNzID0+IGNsYXNzTGlzdC5hZGQoa2xhc3MpKTtcblxuICAgIGRpZmYucmVtb3ZlZFxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxuICAgICAgLmZvckVhY2goa2xhc3MgPT4gY2xhc3NMaXN0LnJlbW92ZShrbGFzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWZmXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIGFwcGx5RGlmZlRvRWxlbWVudChkaWZmLCBlbGVtZW50LCBzY2hlbWUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gKGUsIHMpID0+IChlLm1hdGNoZXMgfHwgZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZS5tc01hdGNoZXNTZWxlY3RvcikuY2FsbChlLCBzKTtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIGluIHNjaGVtZSkge1xuICAgICAgaWYgKHNjaGVtZS5oYXNPd25Qcm9wZXJ0eShzZWxlY3RvcikpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudHMgPSAhc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikgPyBbZWxlbWVudF0gOiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvQ2xhc3NMaXN0KGRpZmYsIHRhcmdldEVsZW1lbnRzW2ldLmNsYXNzTGlzdCwgc2NoZW1lW3NlbGVjdG9yXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgb25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoTW9kaWZpZXJVdGlsLmRpZmYobGFzdCwgY3VycmVudCksIGVsZW1lbnQsIHNjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgaW5pdE1vZGlmaWVyKGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIGNvbnN0IG1vZGlmaWVyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG4gICAgaWYgKHR5cGVvZiBtb2RpZmllciAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuYXBwbHlEaWZmVG9FbGVtZW50KHtcbiAgICAgIHJlbW92ZWQ6IFtdLFxuICAgICAgYWRkZWQ6IE1vZGlmaWVyVXRpbC5zcGxpdChtb2RpZmllcilcbiAgICB9LCBlbGVtZW50LCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIHNwbGl0KG1vZGlmaWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RpZmllciAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kaWZpZXIudHJpbSgpLnNwbGl0KC8gKy8pLmZpbHRlcih0b2tlbiA9PiB0b2tlbiAhPT0gJycpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5cbmV4cG9ydCBjbGFzcyBMYXp5UmVwZWF0RGVsZWdhdGUge1xuXG4gIGNvbnN0cnVjdG9yKHVzZXJEZWxlZ2F0ZSwgdGVtcGxhdGVFbGVtZW50ID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdXNlckRlbGVnYXRlICE9PSAnb2JqZWN0JyB8fCB1c2VyRGVsZWdhdGUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cbiAgICB0aGlzLl91c2VyRGVsZWdhdGUgPSB1c2VyRGVsZWdhdGU7XG5cbiAgICBpZiAoISh0ZW1wbGF0ZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSAmJiB0ZW1wbGF0ZUVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdcInRlbXBsYXRlRWxlbWVudFwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQgb3IgbnVsbC4nKTtcbiAgICB9XG4gICAgdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gdGVtcGxhdGVFbGVtZW50O1xuICB9XG5cbiAgZ2V0IGl0ZW1IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJEZWxlZ2F0ZS5pdGVtSGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBoYXNSZW5kZXJGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLl9yZW5kZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgX3JlbmRlcihpdGVtcywgaGVpZ2h0KSB7XG4gICAgdGhpcy5fdXNlckRlbGVnYXRlLl9yZW5kZXIoaXRlbXMsIGhlaWdodCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQSBmdW5jdGlvbiB0aGF0IHRha2UgaXRlbSBvYmplY3QgYXMgcGFyYW1ldGVyLlxuICAgKi9cbiAgbG9hZEl0ZW1FbGVtZW50KGluZGV4LCBwYXJlbnQsIGRvbmUpIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmxvYWRJdGVtRWxlbWVudCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50KGluZGV4LCBwYXJlbnQsIGVsZW1lbnQgPT4gZG9uZSh7ZWxlbWVudH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3VzZXJEZWxlZ2F0ZS5jcmVhdGVJdGVtQ29udGVudChpbmRleCwgdGhpcy5fdGVtcGxhdGVFbGVtZW50KTtcbiAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBFcnJvcignY3JlYXRlSXRlbUNvbnRlbnQoKSBtdXN0IHJldHVybiBhbiBpbnN0YW5jZSBvZiBFbGVtZW50LicpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgZG9uZSh7ZWxlbWVudH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjb3VudEl0ZW1zKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgICBpZiAodHlwZW9mIGNvdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdW50SXRlbXMoKSBtdXN0IHJldHVybiBhIG51bWJlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGl0ZW0uZWxlbWVudFxuICAgKi9cbiAgdXBkYXRlSXRlbShpbmRleCwgaXRlbSkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUudXBkYXRlSXRlbUNvbnRlbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLnVwZGF0ZUl0ZW1Db250ZW50KGluZGV4LCBpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcignY2FsY3VsYXRlSXRlbUhlaWdodCgpIG11c3QgcmV0dXJuIGEgbnVtYmVyLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKi9cbiAgZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3lJdGVtIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95SXRlbShpbmRleCwgaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZSA9IHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGUgY29yZSBmdW5jdGlvbnMgZm9yIG9ucy1sYXp5LXJlcGVhdC5cbiAqL1xuZXhwb3J0IGNsYXNzIExhenlSZXBlYXRQcm92aWRlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gd3JhcHBlckVsZW1lbnRcbiAgICogQHBhcmFtIHtMYXp5UmVwZWF0RGVsZWdhdGV9IGRlbGVnYXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3cmFwcGVyRWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICBpZiAoIShkZWxlZ2F0ZSBpbnN0YW5jZW9mIExhenlSZXBlYXREZWxlZ2F0ZSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgTGF6eVJlcGVhdERlbGVnYXRlLicpO1xuICAgIH1cblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gd3JhcHBlckVsZW1lbnQ7XG4gICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcblxuICAgIGlmICh3cmFwcGVyRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdCcpIHtcbiAgICAgIHdyYXBwZXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhenktbGlzdCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VDb250ZW50ID0gdXRpbC5maW5kUGFyZW50KHdyYXBwZXJFbGVtZW50LCAnLnBhZ2VfX2NvbnRlbnQnKTtcblxuICAgIGlmICghdGhpcy5fcGFnZUNvbnRlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25zLWxhenktcmVwZWF0IG11c3QgYmUgYSBkZXNjZW5kYW50IG9mIGFuIDxvbnMtcGFnZT4gb3IgYW4gZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl90b3BQb3NpdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zID0ge307XG5cbiAgICBpZiAoIXRoaXMuX2RlbGVnYXRlLml0ZW1IZWlnaHQgJiYgIXRoaXMuX2RlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQoMCkpIHtcbiAgICAgIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICB9XG5cbiAgX2NoZWNrSXRlbUhlaWdodChjYWxsYmFjaykge1xuICAgIHRoaXMuX2RlbGVnYXRlLmxvYWRJdGVtRWxlbWVudCgwLCB0aGlzLl93cmFwcGVyRWxlbWVudCwgaXRlbSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Vua25vd25JdGVtSGVpZ2h0KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNoaWxkKGl0ZW0uZWxlbWVudCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl91bmtub3duSXRlbUhlaWdodDtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2l0ZW1IZWlnaHQgPSBpdGVtLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5faXRlbUhlaWdodCA+IDApIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHJ5IHRvIG1lYXN1cmUgb2Zmc2V0IGhlaWdodFxuICAgICAgLy8gZGlydHkgZml4IGZvciBhbmd1bGFyMiBkaXJlY3RpdmVcbiAgICAgIGNvbnN0IGxhc3RWaXNpYmlsaXR5ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eTtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIGl0ZW0uZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2l0ZW1IZWlnaHQgPSBpdGVtLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5faXRlbUhlaWdodCA9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgc3RhdGU6IHRoaXMuX2l0ZW1IZWlnaHQgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gbGFzdFZpc2liaWxpdHk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHN0YXRpY0l0ZW1IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLml0ZW1IZWlnaHQgfHwgdGhpcy5faXRlbUhlaWdodDtcbiAgfVxuXG4gIF9jb3VudEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb3VudEl0ZW1zKCk7XG4gIH1cblxuICBfZ2V0SXRlbUhlaWdodChpKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGljSXRlbUhlaWdodCB8fCB0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KGkpO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9yZW1vdmVBbGxFbGVtZW50cygpO1xuICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gIH1cblxuICBfcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLl91bmtub3duSXRlbUhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrSXRlbUhlaWdodCh0aGlzLl9yZW5kZXIuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0luVmlldygpO1xuXG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uICYmIHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uKCkpIHtcbiAgICAgIHRoaXMuX2RlbGVnYXRlLl9yZW5kZXIoaXRlbXMsIHRoaXMuX2xpc3RIZWlnaHQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qga2VlcCA9IHt9O1xuXG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIHRoaXMuX3JlbmRlckVsZW1lbnQoaXRlbSk7XG4gICAgICBrZWVwW2l0ZW0uaW5kZXhdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLmZvckVhY2goa2V5ID0+IGtlZXBba2V5XSB8fCB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSkpO1xuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fbGlzdEhlaWdodCArICdweCc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW0uaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW0udG9wXG4gICAqL1xuICBfcmVuZGVyRWxlbWVudCh7aW5kZXgsIHRvcH0pIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHRoaXMuX2RlbGVnYXRlLnVwZGF0ZUl0ZW0oaW5kZXgsIGl0ZW0pOyAvLyB1cGRhdGUgaWYgaXQgZXhpc3RzXG4gICAgICBpdGVtLmVsZW1lbnQuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQoaW5kZXgsIHRoaXMuX3dyYXBwZXJFbGVtZW50LCBpdGVtID0+IHtcbiAgICAgIHV0aWwuZXh0ZW5kKGl0ZW0uZWxlbWVudC5zdHlsZSwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiB0b3AgKyAncHgnLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdID0gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICovXG4gIF9yZW1vdmVFbGVtZW50KGluZGV4KSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuXG4gICAgdGhpcy5fZGVsZWdhdGUuZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pO1xuXG4gICAgaWYgKGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBpdGVtLmVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpdGVtLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgfVxuXG4gIF9yZW1vdmVBbGxFbGVtZW50cygpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKS5mb3JFYWNoKGtleSA9PiB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSkpO1xuICB9XG5cbiAgX2NhbGN1bGF0ZVN0YXJ0SW5kZXgoY3VycmVudCkge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IHRoaXMuX2l0ZW1Db3VudCAtIDE7XG5cbiAgICBpZiAodGhpcy5zdGF0aWNJdGVtSGVpZ2h0KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoLWN1cnJlbnQgLyB0aGlzLnN0YXRpY0l0ZW1IZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIEJpbmFyeSBzZWFyY2ggZm9yIGluZGV4IGF0IHRvcCBvZiBzY3JlZW4gc28gd2UgY2FuIHNwZWVkIHVwIHJlbmRlcmluZy5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudCArIHRoaXMuX3RvcFBvc2l0aW9uc1ttaWRkbGVdO1xuXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIDw9IDAgJiYgdmFsdWUgKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KG1pZGRsZSkgPiAwKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA+PSAwKSB7XG4gICAgICAgIGVuZCA9IG1pZGRsZSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zKCkge1xuICAgIGNvbnN0IGwgPSBNYXRoLm1pbih0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoLCB0aGlzLl9pdGVtQ291bnQpO1xuICAgIHRoaXMuX3RvcFBvc2l0aW9uc1swXSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDEsIGw7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuX3RvcFBvc2l0aW9uc1tpXSA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpIC0gMV0gKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KGkpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRJdGVtc0luVmlldygpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgY29uc3QgbGltaXQgPSA0ICogd2luZG93LmlubmVySGVpZ2h0IC0gb2Zmc2V0O1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fY291bnRJdGVtcygpO1xuXG4gICAgaWYgKGNvdW50ICE9PSB0aGlzLl9pdGVtQ291bnQpe1xuICAgICAgdGhpcy5faXRlbUNvdW50ID0gY291bnQ7XG4gICAgICB0aGlzLl9yZWNhbGN1bGF0ZVRvcFBvc2l0aW9ucygpO1xuICAgIH1cblxuICAgIGxldCBpID0gTWF0aC5tYXgoMCwgdGhpcy5fY2FsY3VsYXRlU3RhcnRJbmRleChvZmZzZXQpIC0gMzApO1xuXG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBmb3IgKHZhciB0b3AgPSB0aGlzLl90b3BQb3NpdGlvbnNbaV07IGkgPCBjb3VudCAmJiB0b3AgPCBsaW1pdDsgaSsrKSB7XG4gICAgICBpZiAoaSA+PSB0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoKSB7IC8vIHBlcmYgb3B0aW1pemF0aW9uXG4gICAgICAgIHRoaXMuX3RvcFBvc2l0aW9ucy5sZW5ndGggKz0gMTAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaV0gPSB0b3A7XG4gICAgICBpdGVtcy5wdXNoKHt0b3AsIGluZGV4OiBpfSk7XG4gICAgICB0b3AgKz0gdGhpcy5fZ2V0SXRlbUhlaWdodChpKTtcbiAgICB9XG4gICAgdGhpcy5fbGlzdEhlaWdodCA9IHRvcDtcblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIF9kZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIF9kb3VibGVGaXJlT25Ub3VjaGVuZCgpIHtcbiAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB0aGlzLl9kZWJvdW5jZSh0aGlzLl9yZW5kZXIuYmluZCh0aGlzKSwgMTAwKTtcbiAgfVxuXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB1dGlsLmJpbmRMaXN0ZW5lcnModGhpcywgWydfb25DaGFuZ2UnLCAnX2RvdWJsZUZpcmVPblRvdWNoZW5kJ10pO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9kZWJvdW5jZSh0aGlzLl9ib3VuZE9uQ2hhbmdlLCAzMCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fYm91bmREb3VibGVGaXJlT25Ub3VjaGVuZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW1vdmVBbGxFbGVtZW50cygpO1xuICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9wYXJlbnRFbGVtZW50ID0gdGhpcy5fZGVsZWdhdGUgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICB9XG59XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4vYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4vbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQge0xhenlSZXBlYXRQcm92aWRlciwgTGF6eVJlcGVhdERlbGVnYXRlfSBmcm9tICcuL2xhenktcmVwZWF0JztcblxuaW50ZXJuYWwuQW5pbWF0b3JGYWN0b3J5ID0gQW5pbWF0b3JGYWN0b3J5O1xuaW50ZXJuYWwuTW9kaWZpZXJVdGlsID0gTW9kaWZpZXJVdGlsO1xuaW50ZXJuYWwuTGF6eVJlcGVhdFByb3ZpZGVyID0gTGF6eVJlcGVhdFByb3ZpZGVyO1xuaW50ZXJuYWwuTGF6eVJlcGVhdERlbGVnYXRlID0gTGF6eVJlcGVhdERlbGVnYXRlO1xuXG5leHBvcnQgZGVmYXVsdCBpbnRlcm5hbDtcblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuY29uc3QgY3JlYXRlID0gKCkgPT4ge1xuXG4gIC8qKlxuICAgKiBAb2JqZWN0IG9ucy5vcmllbnRhdGlvblxuICAgKiBAY2F0ZWdvcnkgdXRpbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXRpbGl0eSBtZXRob2RzIGZvciBvcmllbnRhdGlvbiBkZXRlY3Rpb24uWy9lbl1cbiAgICogICBbamFd55S76Z2i44Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz5qSc55+l44Gu44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gm44GE44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGNvbnN0IG9iaiA9IHtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgZGV2aWNlIG9yaWVudGF0aW9uIGNoYW5nZXMuWy9lbl1cbiAgICAgKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYzlpInljJbjgZfjgZ/pmpvjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1BvcnRyYWl0XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3nj77lnKjjga7jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOOBruWgtOWQiOOBq3RydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBzaWduYXR1cmUgb24oZXZlbnROYW1lLCBsaXN0ZW5lcilcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1BZGQgYW4gZXZlbnQgbGlzdGVuZXIuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxuICAgICAqICAgW2phXeOBk+OBruOCpOODmeODs+ODiOOBjOeZuueBq+OBleOCjOOBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIG9uY2VcbiAgICAgKiBAc2lnbmF0dXJlIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcilcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgW2VuXUFkZCBhbiBldmVudCBsaXN0ZW5lciB0aGF0J3Mgb25seSB0cmlnZ2VyZWQgb25jZS5bL2VuXVxuICAgICAqICBbamFd5LiA5bqm44Gg44GR5ZG844Gz5Ye644GV44KM44KL44Kk44OZ44Oz44OI44Oq44K544OK44O844KS6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAc2lnbmF0dXJlIG9mZihldmVudE5hbWUsIFtsaXN0ZW5lcl0pXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogIFtlbl1SZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuIElmIHRoZSBsaXN0ZW5lciBpcyBub3Qgc3BlY2lmaWVkIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB0eXBlIHdpbGwgYmUgcmVtb3ZlZC5bL2VuXVxuICAgICAqICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5YmK6Zmk44GX44G+44GZ44CC44KC44GX44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5oyH5a6a44GX44Gq44GL44Gj44Gf5aC05ZCI44Gr44Gv44CB44Gd44Gu44Kk44OZ44Oz44OI44Gr57SQ44Gl44GP5YWo44Gm44Gu44Kk44OZ44Oz44OI44Oq44K544OK44O844GM5YmK6Zmk44GV44KM44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3liYrpmaTjgZnjgovjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLy8gYWN0dWFsIGltcGxlbWVudGF0aW9uIHRvIGRldGVjdCBpZiB3aGV0aGVyIGN1cnJlbnQgc2NyZWVuIGlzIHBvcnRyYWl0IG9yIG5vdFxuICAgIF9pc1BvcnRyYWl0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgaXNQb3J0cmFpdFxuICAgICAqIEBzaWduYXR1cmUgaXNQb3J0cmFpdCgpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgbW9kZS5bL2VuXVxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBvciBub3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOODouODvOODieOBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG4gICAgaXNQb3J0cmFpdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNQb3J0cmFpdCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGlzTGFuZHNjYXBlXG4gICAgICogQHNpZ25hdHVyZSBpc0xhbmRzY2FwZSgpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgbGFuZHNjYXBlIG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxsYW5kc2NhcGXjg6Ljg7zjg4njga7loLTlkIjjgat0cnVl44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NyZWVuIG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSBvciBub3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxsYW5kc2NhcGXjg6Ljg7zjg4njgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuICAgIGlzTGFuZHNjYXBlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5pc1BvcnRyYWl0KCk7XG4gICAgfSxcblxuICAgIF9pbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRPTUNvbnRlbnRMb2FkZWQuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICBpZiAoJ29yaWVudGF0aW9uJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfb25ET01Db250ZW50TG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb24oKTtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IHRoaXMuaXNQb3J0cmFpdCgpfSk7XG4gICAgfSxcblxuICAgIF9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGlzUG9ydHJhaXQgPSB3aW5kb3cuaW5uZXJXaWR0aCA8IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgaWYgKCEoJ29yaWVudGF0aW9uJyBpbiB3aW5kb3cpKSB7XG4gICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCkgPT09IDAgPyBpc1BvcnRyYWl0IDogIWlzUG9ydHJhaXQ7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCkgPT09IDkwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25PcmllbnRhdGlvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpc1BvcnRyYWl0ID0gdGhpcy5faXNQb3J0cmFpdCgpO1xuXG4gICAgICAvLyBXYWl0IGZvciB0aGUgZGltZW5zaW9ucyB0byBjaGFuZ2UgYmVjYXVzZVxuICAgICAgLy8gb2YgQW5kcm9pZCBpbmNvbnNpc3RlbmN5LlxuICAgICAgbGV0IG5JdGVyID0gMDtcbiAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBuSXRlcisrO1xuXG4gICAgICAgIGNvbnN0IHcgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgICBpZiAoKGlzUG9ydHJhaXQgJiYgdyA8PSBoKSB8fFxuICAgICAgICAgICAoIWlzUG9ydHJhaXQgJiYgdyA+PSBoKSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IGlzUG9ydHJhaXR9KTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChuSXRlciA9PT0gNTApIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiBpc1BvcnRyYWl0fSk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDIwKTtcbiAgICB9LFxuXG4gICAgLy8gUnVuIG9uIG5vdCBtb2JpbGUgYnJvd3Nlci5cbiAgICBfb25SZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogdGhpcy5pc1BvcnRyYWl0KCl9KTtcbiAgICB9XG4gIH07XG5cbiAgTWljcm9FdmVudC5taXhpbihvYmopO1xuXG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGUoKS5faW5pdCgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuY29uc3Qgc29mdHdhcmVLZXlib2FyZCA9IG5ldyBNaWNyb0V2ZW50KCk7XG5zb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gZmFsc2U7XG5cbmNvbnN0IG9uU2hvdyA9ICgpID0+IHtcbiAgc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IHRydWU7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnc2hvdycpO1xufTtcblxuY29uc3Qgb25IaWRlID0gKCkgPT4ge1xuICBzb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gZmFsc2U7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaGlkZScpO1xufTtcblxuY29uc3QgYmluZEV2ZW50cyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiBLZXlib2FyZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFydGlubW9zZS9jb3Jkb3ZhLWtleWJvYXJkL2Jsb2IvOTVmM2RhM2EzOGQ4ZjhlMWZhNDFmYmY0MDE0NTM1MmMxMzUzNWEwMC9SRUFETUUubWRcbiAgICBLZXlib2FyZC5vbnNob3cgPSBvblNob3c7XG4gICAgS2V5Ym9hcmQub25oaWRlID0gb25IaWRlO1xuICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaW5pdCcsIHt2aXNpYmxlOiBLZXlib2FyZC5pc1Zpc2libGV9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb3Jkb3ZhLnBsdWdpbnMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RyaWZ0eWNvL2lvbmljLXBsdWdpbnMta2V5Ym9hcmQvYmxvYi9jYTI3ZWNmL1JFQURNRS5tZFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRzaG93Jywgb25TaG93KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkaGlkZScsIG9uSGlkZSk7XG4gICAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdpbml0Jywge3Zpc2libGU6IGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5pc1Zpc2libGV9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3Qgbm9QbHVnaW5FcnJvciA9ICgpID0+IHtcbiAgY29uc29sZS53YXJuKCdvbnMta2V5Ym9hcmQ6IENvcmRvdmEgS2V5Ym9hcmQgcGx1Z2luIGlzIG5vdCBwcmVzZW50LicpO1xufTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCAoKSA9PiB7XG4gIGlmICghYmluZEV2ZW50cygpKSB7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tvbnMta2V5Ym9hcmQtYWN0aXZlXScpIHx8XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbb25zLWtleWJvYXJkLWluYWN0aXZlXScpKSB7XG4gICAgICBub1BsdWdpbkVycm9yKCk7XG4gICAgfVxuXG4gICAgc29mdHdhcmVLZXlib2FyZC5vbiA9IG5vUGx1Z2luRXJyb3I7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb2Z0d2FyZUtleWJvYXJkO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0nO1xuXG5cbmNvbnN0IHV0aWwgPSB7XG4gIF9yZWFkeTogZmFsc2UsXG5cbiAgX2RvbUNvbnRlbnRMb2FkZWQ6IGZhbHNlLFxuXG4gIF9vbkRPTUNvbnRlbnRMb2FkZWQ6ICgpID0+IHtcbiAgICB1dGlsLl9kb21Db250ZW50TG9hZGVkID0gdHJ1ZTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc1dlYlZpZXcoKSkge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgKCkgPT4ge1xuICAgICAgICB1dGlsLl9yZWFkeSA9IHRydWU7XG4gICAgICB9LCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuX3JlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgYWRkQmFja0J1dHRvbkxpc3RlbmVyOiBmdW5jdGlvbihmbikge1xuICAgIGlmICghdGhpcy5fZG9tQ29udGVudExvYWRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgYWZ0ZXIgRE9NQ29udGVudExvYWRlZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkeSkge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoIXRoaXMuX2RvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4gdXRpbC5fb25ET01Db250ZW50TG9hZGVkKCksIGZhbHNlKTtcblxuY29uc3QgSGFuZGxlclJlcG9zaXRvcnkgPSB7XG4gIF9zdG9yZToge30sXG5cbiAgX2dlbklkOiAoKCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gKCkgPT4gaSsrO1xuICB9KSgpLFxuXG4gIHNldDogZnVuY3Rpb24oZWxlbWVudCwgaGFuZGxlcikge1xuICAgIGlmIChlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQgPSBIYW5kbGVyUmVwb3NpdG9yeS5fZ2VuSWQoKTtcbiAgICB0aGlzLl9zdG9yZVtpZF0gPSBoYW5kbGVyO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0b3JlW2VsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkXTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xuXG4gICAgaWYgKCF0aGlzLl9zdG9yZVtpZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdG9yZVtpZF07XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50LmRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xuXG4gICAgcmV0dXJuICEhdGhpcy5fc3RvcmVbaWRdO1xuICB9XG59O1xuXG5jbGFzcyBEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2JvdW5kQ2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICB9XG5cblxuICAvKipcbiAgICogRW5hYmxlIHRvIGhhbmRsZSAnYmFja2J1dHRvbicgZXZlbnRzLlxuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICB1dGlsLmFkZEJhY2tCdXR0b25MaXN0ZW5lcih0aGlzLl9ib3VuZENhbGxiYWNrKTtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGUgdG8gaGFuZGxlICdiYWNrYnV0dG9uJyBldmVudHMuXG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHV0aWwucmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyKHRoaXMuX2JvdW5kQ2FsbGJhY2spO1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmUgYSAnYmFja2J1dHRvbicgZXZlbnQgbWFudWFsbHkuXG4gICAqL1xuICBmaXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50KCkge1xuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdiYWNrYnV0dG9uJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICBfY2FsbGJhY2soKSB7XG4gICAgdGhpcy5fZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBjcmVhdGVIYW5kbGVyKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIShjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgIF9jYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBfZWxlbWVudDogZWxlbWVudCxcblxuICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnJlbW92ZShlbGVtZW50KTtcbiAgICAgIH0sXG5cbiAgICAgIHNldExpc3RlbmVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgfSxcblxuICAgICAgZW5hYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkuc2V0KGVsZW1lbnQsIHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbmRsZXJSZXBvc2l0b3J5LmdldChlbGVtZW50KSA9PT0gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5yZW1vdmUoZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXIuZW5hYmxlKCk7XG5cbiAgICByZXR1cm4gaGFuZGxlcjtcbiAgfVxuXG4gIF9kaXNwYXRjaERldmljZUJhY2tCdXR0b25FdmVudCgpIHtcbiAgICBjb25zdCB0cmVlID0gdGhpcy5fY2FwdHVyZVRyZWUoKTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9maW5kSGFuZGxlckxlYWZFbGVtZW50KHRyZWUpO1xuXG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQoZWxlbWVudCk7XG4gICAgaGFuZGxlci5fY2FsbGJhY2soY3JlYXRlRXZlbnQoZWxlbWVudCkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRXZlbnQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX2VsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGNhbGxQYXJlbnRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaGFuZGxlciA9IEhhbmRsZXJSZXBvc2l0b3J5LmdldChwYXJlbnQpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuX2NhbGxiYWNrKGNyZWF0ZUV2ZW50KHBhcmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfY2FwdHVyZVRyZWUoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRyZWUoZG9jdW1lbnQuYm9keSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUcmVlKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGNoaWxkcmVuOiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnJheU9mKGVsZW1lbnQuY2hpbGRyZW4pLm1hcChmdW5jdGlvbihjaGlsZEVsZW1lbnQpIHtcblxuICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoaWxkRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgIUhhbmRsZXJSZXBvc2l0b3J5LmhhcyhjaGlsZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlVHJlZShjaGlsZEVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgIUhhbmRsZXJSZXBvc2l0b3J5LmhhcyhyZXN1bHQuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheU9mKHRhcmdldCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaCh0YXJnZXRbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyZWVcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKSB7XG4gICAgcmV0dXJuIGZpbmQodHJlZSk7XG5cbiAgICBmdW5jdGlvbiBmaW5kKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZpbmQobm9kZS5jaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS5lbGVtZW50O1xuICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmICghbGVmdCkge1xuICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxlZnRaID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobGVmdCwgJycpLnpJbmRleCwgMTApO1xuICAgICAgICBjb25zdCByaWdodFogPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyaWdodCwgJycpLnpJbmRleCwgMTApO1xuXG4gICAgICAgIGlmICghaXNOYU4obGVmdFopICYmICFpc05hTihyaWdodFopKSB7XG4gICAgICAgICAgcmV0dXJuIGxlZnRaID4gcmlnaHRaID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXB0dXJpbmcgYmFja2J1dHRvbi1oYW5kbGVyIGlzIGZhaWx1cmUuJyk7XG4gICAgICB9LCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyKCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vL+Wxj+iUvW9uc2Vu6Ieq5Yqo6L2s5o2i5qC35byP5Li76aKYXG5sZXQgYXV0b1N0eWxlRW5hYmxlZCA9IGZhbHNlO1xuLy8gbGV0IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlO1xuXG4vLyBNb2RpZmllcnNcbmNvbnN0IG1vZGlmaWVyc01hcCA9IHtcbiAgJ3F1aWV0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ2xpZ2h0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ291dGxpbmUnOiAnbWF0ZXJpYWwtLWZsYXQnLFxuICAnY3RhJzogJycsXG4gICdsYXJnZS0tcXVpZXQnOiAnbWF0ZXJpYWwtLWZsYXQgbGFyZ2UnLFxuICAnbGFyZ2UtLWN0YSc6ICdsYXJnZScsXG4gICdub2JvcmRlcic6ICcnLFxuICAnY2hldnJvbic6ICcnLFxuICAndGFwcGFibGUnOiAnJ1xufTtcblxuY29uc3QgcGxhdGZvcm1zID0ge307XG5cbnBsYXRmb3Jtcy5hbmRyb2lkID0gZWxlbWVudCA9PiB7XG5cbiAgaWYgKCEvb25zLWZhYnxvbnMtc3BlZWQtZGlhbHxvbnMtcHJvZ3Jlc3MvLnRlc3QoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmXG4gICAgIS9tYXRlcmlhbC8udGVzdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSkpIHtcblxuICAgIGNvbnN0IG9sZE1vZGlmaWVyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJyc7XG5cbiAgICBjb25zdCBuZXdNb2RpZmllciA9IG9sZE1vZGlmaWVyLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChlID0+IG1vZGlmaWVyc01hcC5oYXNPd25Qcm9wZXJ0eShlKSA/IG1vZGlmaWVyc01hcFtlXSA6IGUpO1xuICAgIG5ld01vZGlmaWVyLnVuc2hpZnQoJ21hdGVyaWFsJyk7XG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllci5qb2luKCcgJykudHJpbSgpKTtcbiAgfVxuXG4gIC8vIEVmZmVjdHNcbiAgaWYgKC9vbnMtYnV0dG9ufG9ucy1saXN0LWl0ZW18b25zLWZhYnxvbnMtc3BlZWQtZGlhbHxvbnMtdGFiJC8udGVzdChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpXG4gICAgJiYgIXV0aWwuZmluZENoaWxkKGVsZW1lbnQsICdvbnMtcmlwcGxlJykpIHtcblxuICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJykpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhcHBhYmxlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyaXBwbGUnLCAnJyk7XG4gICAgfVxuICB9XG59O1xuXG5wbGF0Zm9ybXMuaW9zID0gZWxlbWVudCA9PiB7XG5cbiAvLyBNb2RpZmllcnNcbiBpZiAoL21hdGVyaWFsLy50ZXN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSkge1xuICAgdXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwnKTtcblxuICAgaWYgKHV0aWwucmVtb3ZlTW9kaWZpZXIoZWxlbWVudCwgJ21hdGVyaWFsLS1mbGF0JykpIHtcbiAgICAgdXRpbC5hZGRNb2RpZmllcihlbGVtZW50LCAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbGFyZ2UnKSkgPyAnbGFyZ2UtLXF1aWV0JyA6ICdxdWlldCcpO1xuICAgfVxuXG4gICBpZiAoIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgfVxuIH1cblxuIC8vIEVmZmVjdHNcbiBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpKSB7XG4gICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdC1pdGVtJykge1xuICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFwcGFibGUnLCAnJyk7XG4gICB9XG5cbiAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyaXBwbGUnKTtcbiB9XG59O1xuXG5jb25zdCB1bmxvY2tlZCA9IHtcbiAgYW5kcm9pZDogdHJ1ZVxufTtcblxuY29uc3QgcHJlcGFyZUF1dG9TdHlsZSA9IChlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBpZiAoYXV0b1N0eWxlRW5hYmxlZCAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGUtYXV0by1zdHlsaW5nJykpIHtcbiAgICBjb25zdCBtb2JpbGVPUyA9IG9uc1BsYXRmb3JtLmdldE1vYmlsZU9TKCk7XG4gICAgaWYgKHBsYXRmb3Jtcy5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgJiYgKHVubG9ja2VkLmhhc093blByb3BlcnR5KG1vYmlsZU9TKSB8fCBmb3JjZSkpIHtcbiAgICAgIHBsYXRmb3Jtc1ttb2JpbGVPU10oZWxlbWVudCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzRW5hYmxlZDogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCxcbiAgZW5hYmxlOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkID0gdHJ1ZSxcbiAgZGlzYWJsZTogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCA9IGZhbHNlLFxuICBwcmVwYXJlOiBwcmVwYXJlQXV0b1N0eWxlXG59O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZW5lcmF0ZUlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaSsrO1xuICB9O1xufSkoKTtcblxuLyoqXG4gKiBEb29yIGxvY2tpbmcgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ11cbiAqL1xuY2xhc3MgRG9vckxvY2sge1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2xvY2tMaXN0ID0gW107XG4gICAgdGhpcy5fd2FpdExpc3QgPSBbXTtcbiAgICB0aGlzLl9sb2cgPSBvcHRpb25zLmxvZyB8fCBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbG9jay5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259IENhbGxiYWNrIGZvciB1bmxvY2tpbmcuXG4gICAqL1xuICBsb2NrKCkge1xuICAgIGNvbnN0IHVubG9jayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3VubG9jayh1bmxvY2spO1xuICAgIH07XG4gICAgdW5sb2NrLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuX2xvY2tMaXN0LnB1c2godW5sb2NrKTtcbiAgICB0aGlzLl9sb2coJ2xvY2s6ICcgKyAodW5sb2NrLmlkKSk7XG5cbiAgICByZXR1cm4gdW5sb2NrO1xuICB9XG5cbiAgX3VubG9jayhmbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9ja0xpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWdpc3RlcmVkIGluIHRoZSBsb2NrIGxpc3QuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9ja0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLl9sb2coJ3VubG9jazogJyArIGZuLmlkKTtcblxuICAgIHRoaXMuX3RyeVRvRnJlZVdhaXRMaXN0KCk7XG4gIH1cblxuICBfdHJ5VG9GcmVlV2FpdExpc3QoKSB7XG4gICAgd2hpbGUgKCF0aGlzLmlzTG9ja2VkKCkgJiYgdGhpcy5fd2FpdExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fd2FpdExpc3Quc2hpZnQoKSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZvciB3YWl0aW5nIHVubG9ja2VkIGRvb3IuXG4gICAqXG4gICAqIEBwYXJhbXMge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBvbiB1bmxvY2tpbmcgdGhlIGRvb3IgY29tcGxldGVseS5cbiAgICovXG4gIHdhaXRVbmxvY2soY2FsbGJhY2spIHtcbiAgICBpZiAoIShjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2FsbGJhY2sgcGFyYW0gbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgIHRoaXMuX3dhaXRMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tMaXN0Lmxlbmd0aCA+IDA7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRG9vckxvY2s7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuY29uc3QgcmVhZHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcXVldWVNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBpc0NvbnRlbnRSZWFkeShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgIHNldENvbnRlbnRSZWFkeShlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gcmVhZHlNYXAuaGFzKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBzZXRDb250ZW50UmVhZHkoZWxlbWVudCkge1xuICByZWFkeU1hcC5zZXQoZWxlbWVudCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENhbGxiYWNrKGVsZW1lbnQsIGZuKSB7XG4gIGlmICghcXVldWVNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgcXVldWVNYXAuc2V0KGVsZW1lbnQsIFtdKTtcbiAgfVxuICBxdWV1ZU1hcC5nZXQoZWxlbWVudCkucHVzaChmbik7XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVRdWV1ZShlbGVtZW50KSB7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IHF1ZXVlTWFwLmdldChlbGVtZW50LCBbXSkgfHwgW107XG4gIHF1ZXVlTWFwLmRlbGV0ZShlbGVtZW50KTtcbiAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRlbnRSZWFkeShlbGVtZW50LCBmbikge1xuICBhZGRDYWxsYmFjayhlbGVtZW50LCBmbik7XG5cbiAgaWYgKGlzQ29udGVudFJlYWR5KGVsZW1lbnQpKSB7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hhbmdlcyA9PiB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG4gIC8vIGZhaWxiYWNrIGZvciBlbGVtZW50cyBoYXMgZW1wdHkgY29udGVudC5cbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICB9KTtcbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4vZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5pbXBvcnQgbm90aWZpY2F0aW9uIGZyb20gJy4vbm90aWZpY2F0aW9uJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuL29yaWVudGF0aW9uJztcbmltcG9ydCBzb2Z0d2FyZUtleWJvYXJkIGZyb20gJy4vc29mdHdhcmUta2V5Ym9hcmQnO1xuaW1wb3J0IFBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIGZyb20gJy4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgYW5pbWF0aW9uT3B0aW9uc1BhcnNlciBmcm9tICcuL2FuaW1hdGlvbi1vcHRpb25zLXBhcnNlcic7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4vYXV0b3N0eWxlJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuL2Rvb3Jsb2NrJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi9jb250ZW50LXJlYWR5JztcblxuLyoqXG4gKiBAb2JqZWN0IG9uc1xuICogQGNhdGVnb3J5IHV0aWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbamFdT25zZW4gVUnjgafliKnnlKjjgafjgY3jgovjgrDjg63jg7zjg5Djg6vjgarjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogICBbZW5dQSBnbG9iYWwgb2JqZWN0IHRoYXQncyB1c2VkIGluIE9uc2VuIFVJLiBbL2VuXVxuICovXG5jb25zdCBvbnMgPSB7fTtcblxub25zLl91dGlsID0gdXRpbDtcbm9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlcjtcbm9ucy5faW50ZXJuYWwgPSBpbnRlcm5hbDtcbm9ucy5HZXN0dXJlRGV0ZWN0b3IgPSBHZXN0dXJlRGV0ZWN0b3I7XG5vbnMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbm9ucy5zb2Z0d2FyZUtleWJvYXJkID0gc29mdHdhcmVLZXlib2FyZDtcbm9ucy5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbiA9IFBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uO1xub25zLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG5vbnMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xub25zLl9hbmltYXRpb25PcHRpb25zUGFyc2VyID0gYW5pbWF0aW9uT3B0aW9uc1BhcnNlcjtcbm9ucy5fYXV0b1N0eWxlID0gYXV0b1N0eWxlO1xub25zLl9Eb29yTG9jayA9IERvb3JMb2NrO1xub25zLl9jb250ZW50UmVhZHkgPSBjb250ZW50UmVhZHk7XG5cbm9ucy5fcmVhZHlMb2NrID0gbmV3IERvb3JMb2NrKCk7XG5cbm9ucy5wbGF0Zm9ybS5zZWxlY3QoKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gubWF0Y2goL3BsYXRmb3JtPShbXFx3LV0rKS8pIHx8IFtdKVsxXSk7XG5cbndhaXREZXZpY2VSZWFkeSgpO1xuXG4vKipcbiAqIEBtZXRob2QgaXNSZWFkeVxuICogQHNpZ25hdHVyZSBpc1JlYWR5KClcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgT25zZW4gVUkgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqICAgW2phXeWIneacn+WMluOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFdT25zZW4gVUnjgYzjgZnjgafjgavliJ3mnJ/ljJbjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZnjg6Hjgr3jg4Pjg4njgafjgZnjgIJbL2phXVxuICovXG5vbnMuaXNSZWFkeSA9ICgpID0+IHtcbiAgcmV0dXJuICFvbnMuX3JlYWR5TG9jay5pc0xvY2tlZCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGlzV2ViVmlld1xuICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXR1cm5zIHRydWUgaWYgcnVubmluZyBpbnNpZGUgQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBmeODoeOCveODg+ODieOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5pc1dlYlZpZXcgPSBvbnMucGxhdGZvcm0uaXNXZWJWaWV3O1xuXG4vKipcbiAqIEBtZXRob2QgcmVhZHlcbiAqIEBzaWduYXR1cmUgcmVhZHkoY2FsbGJhY2spXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2phXeOCouODl+ODquOBruWIneacn+WMluOBq+WIqeeUqOOBmeOCi+ODoeOCveODg+ODieOBp+OBmeOAgua4oeOBleOCjOOBn+mWouaVsOOBr+OAgU9uc2VuIFVJ44Gu5Yid5pyf5YyW44GM57WC5LqG44GX44Gm44GE44KL5pmC54K544Gn5b+F44Ga5ZG844Gw44KM44G+44GZ44CCWy9qYV1cbiAqICAgW2VuXU1ldGhvZCB1c2VkIHRvIHdhaXQgZm9yIGFwcCBpbml0aWFsaXphdGlvbi4gVGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGV4ZWN1dGVkIHVudGlsIE9uc2VuIFVJIGhhcyBiZWVuIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIE9uc2VuIFVJIGhhcyBiZWVuIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV1PbnNlbiBVSeOBjOWIneacn+WMluOBjOWujOS6huOBl+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5yZWFkeSA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIG9ucy5fcmVhZHlMb2NrLndhaXRVbmxvY2soY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lclxuICogQHNpZ25hdHVyZSBzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyKGxpc3RlbmVyKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiBkZXZpY2UgYmFjayBidXR0b24gaXMgcHJlc3NlZC5bL2VuXVxuICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44GM5oq844GV44KM44Gf5pmC44Gr5a6f6KGM44GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dU2V0IGRlZmF1bHQgaGFuZGxlciBmb3IgZGV2aWNlIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgZ/jgoHjga7jg4fjg5Xjgqnjg6vjg4jjga7jg4/jg7Pjg4njg6njgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gIG9ucy5fZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyLnNldExpc3RlbmVyKGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbiAqIEBzaWduYXR1cmUgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXURpc2FibGUgZGV2aWNlIGJhY2sgYnV0dG9uIGV2ZW50IGhhbmRsZXIuWy9lbl1cbiAqIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgqTjg5njg7Pjg4jjgpLlj5fjgZHku5jjgZHjgarjgYTjgojjgYbjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gIG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuZGlzYWJsZSgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gKiBAc2lnbmF0dXJlIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXUVuYWJsZSBkZXZpY2UgYmFjayBidXR0b24gZXZlbnQgaGFuZGxlci5bL2VuXVxuICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOCi+OCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmVuYWJsZSgpO1xufTtcblxuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgc3RhdHVzIGJhciBmaWxsIGZlYXR1cmUgb24gaU9TNyBhbmQgYWJvdmUuWy9lbl1cbiAqICAgW2phXWlPUzfku6XkuIrjgafjgIHjgrnjg4bjg7zjgr/jgrnjg5Djg7zpg6jliIbjga7pq5jjgZXjgpLoh6rli5XnmoTjgavln4vjgoHjgovlh6bnkIbjgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZS5bL2VuXVxuICogICBbamFdaU9TN+S7peS4iuOBp+OAgeOCueODhuODvOOCv+OCueODkOODvOmDqOWIhuOBrumrmOOBleOCkuiHquWLleeahOOBq+Wfi+OCgeOCi+WHpueQhuOCkueEoeWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUFuaW1hdGlvbnMoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGFsbCBhbmltYXRpb25zLiBDb3VsZCBiZSBoYW5keSBmb3IgdGVzdGluZyBhbmQgb2xkZXIgZGV2aWNlcy5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5YWo44Gm54Sh5Yq544Gr44GX44G+44GZ44CC44OG44K544OI44Gu6Zqb44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVBbmltYXRpb25zID0gKCkgPT4ge1xuICBvbnMuX2ludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZW5hYmxlQW5pbWF0aW9ucygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUVuYWJsZSBhbmltYXRpb25zIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5pyJ5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZUFuaW1hdGlvbnMgPSAoKSA9PiB7XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBdXRvU3R5bGluZ1xuICogQHNpZ25hdHVyZSBkaXNhYmxlQXV0b1N0eWxpbmcoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGF1dG9tYXRpYyBzdHlsaW5nLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZGlzYWJsZUF1dG9TdHlsaW5nID0gb25zLl9hdXRvU3R5bGUuZGlzYWJsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUF1dG9TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUF1dG9TdHlsaW5nKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIGF1dG9tYXRpYyBzdHlsaW5nIGJhc2VkIG9uIE9TIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmVuYWJsZUF1dG9TdHlsaW5nID0gb25zLl9hdXRvU3R5bGUuZW5hYmxlO1xuXG4vKipcbiAqIEBtZXRob2QgZm9yY2VQbGF0Zm9ybVN0eWxpbmdcbiAqIEBzaWduYXR1cmUgZm9yY2VQbGF0Zm9ybVN0eWxpbmcocGxhdGZvcm0pXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlZnJlc2ggc3R5bGluZyBmb3IgdGhlIGdpdmVuIHBsYXRmb3JtLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtzdHJpbmd9IHBsYXRmb3JtIE5ldyBwbGF0Zm9ybSB0byBzdHlsZSB0aGUgZWxlbWVudHMuXG4gKi9cbm9ucy5mb3JjZVBsYXRmb3JtU3R5bGluZyA9IG5ld1BsYXRmb3JtID0+IHtcbiAgb25zLmVuYWJsZUF1dG9TdHlsaW5nKCk7XG4gIG9ucy5wbGF0Zm9ybS5zZWxlY3QobmV3UGxhdGZvcm0gfHwgJ2lvcycpO1xuXG4gIG9ucy5fdXRpbC5hcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKicpKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1pZicpIHtcbiAgICAgICAgZWxlbWVudC5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lLm1hdGNoKC9eb25zLS9pKSkge1xuICAgICAgICBvbnMuX2F1dG9TdHlsZS5wcmVwYXJlKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGFiYmFyJykge1xuICAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5vbnMuX2NyZWF0ZVBvcG92ZXJPcmlnaW5hbCA9IGZ1bmN0aW9uKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gIGlmICghcGFnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFnZSB1cmwgbXVzdCBiZSBkZWZpbmVkLicpO1xuICB9XG5cbiAgcmV0dXJuIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgIGh0bWwgPSBodG1sLm1hdGNoKC88b25zLXBvcG92ZXIvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1wb3BvdmVyPiR7aHRtbH08L29ucy1wb3BvdmVyPmA7XG4gICAgY29uc3QgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG5cbiAgICBjb25zdCBwb3BvdmVyID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ29ucy1wb3BvdmVyJyk7XG4gICAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShwb3BvdmVyKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBvcG92ZXIpO1xuXG4gICAgaWYgKG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zLmxpbmsocG9wb3Zlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcG92ZXI7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZVBvcG92ZXJcbiAqIEBzaWduYXR1cmUgY3JlYXRlUG9wb3ZlcihwYWdlLCBbb3B0aW9uc10pXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyZW50U2NvcGVdXG4gKiAgIFtlbl1QYXJlbnQgc2NvcGUgb2YgdGhlIGRpYWxvZy4gVXNlZCB0byBiaW5kIG1vZGVscyBhbmQgYWNjZXNzIHNjb3BlIG1ldGhvZHMgZnJvbSB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDlhoXjgafliKnnlKjjgZnjgovopqrjgrnjgrPjg7zjg5fjgpLmjIflrprjgZfjgb7jgZnjgILjg4DjgqTjgqLjg63jgrDjgYvjgonjg6Ljg4fjg6vjgoTjgrnjgrPjg7zjg5fjga7jg6Hjgr3jg4Pjg4njgavjgqLjgq/jgrvjgrnjgZnjgovjga7jgavkvb/jgYTjgb7jgZnjgILjgZPjga7jg5Hjg6njg6Hjg7zjgr/jga9Bbmd1bGFySlPjg5DjgqTjg7Pjg4fjgqPjg7PjgrDjgafjga7jgb/liKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBvcG92ZXIgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIHBvcG92ZXIgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuY3JlYXRlUG9wb3ZlciA9IG9ucy5fY3JlYXRlUG9wb3Zlck9yaWdpbmFsO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5saW5rXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xub25zLl9jcmVhdGVEaWFsb2dPcmlnaW5hbCA9IGZ1bmN0aW9uKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gIGlmICghcGFnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFnZSB1cmwgbXVzdCBiZSBkZWZpbmVkLicpO1xuICB9XG5cbiAgcmV0dXJuIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgIGh0bWwgPSBodG1sLm1hdGNoKC88b25zLWRpYWxvZy9naSkgPyBgPGRpdj4ke2h0bWx9PC9kaXY+YCA6IGA8b25zLWRpYWxvZz4ke2h0bWx9PC9vbnMtZGlhbG9nPmA7XG4gICAgY29uc3QgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG5cbiAgICBjb25zdCBkaWFsb2cgPSBkaXYucXVlcnlTZWxlY3Rvcignb25zLWRpYWxvZycpO1xuICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUoZGlhbG9nKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cbiAgICBpZiAob3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMubGluayhkaWFsb2cpO1xuICAgIH1cblxuICAgIHJldHVybiBkaWFsb2c7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZURpYWxvZ1xuICogQHNpZ25hdHVyZSBjcmVhdGVEaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZURpYWxvZyA9IG9ucy5fY3JlYXRlRGlhbG9nT3JpZ2luYWw7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5vbnMuX2NyZWF0ZUFsZXJ0RGlhbG9nT3JpZ2luYWwgPSBmdW5jdGlvbihwYWdlLCBvcHRpb25zID0ge30pIHtcblxuICBpZiAoIXBhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgdXJsIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgfVxuXG4gIHJldHVybiBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcbiAgICBodG1sID0gaHRtbC5tYXRjaCgvPG9ucy1hbGVydC1kaWFsb2cvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1hbGVydC1kaWFsb2c+JHtodG1sfTwvb25zLWFsZXJ0LWRpYWxvZz5gO1xuICAgIGNvbnN0IGRpdiA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuXG4gICAgY29uc3QgYWxlcnREaWFsb2cgPSBkaXYucXVlcnlTZWxlY3Rvcignb25zLWFsZXJ0LWRpYWxvZycpO1xuICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUoYWxlcnREaWFsb2cpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYWxlcnREaWFsb2cpO1xuXG4gICAgaWYgKG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zLmxpbmsoYWxlcnREaWFsb2cpO1xuICAgIH1cblxuICAgIHJldHVybiBhbGVydERpYWxvZztcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlQWxlcnREaWFsb2dcbiAqIEBzaWduYXR1cmUgY3JlYXRlQWxlcnREaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtYWxlcnQtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGFsZXJ0IGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgYWxlcnQgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZUFsZXJ0RGlhbG9nID0gb25zLl9jcmVhdGVBbGVydERpYWxvZ09yaWdpbmFsO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rXG4gKi9cbm9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlck9yaWdpbmFsID0gZnVuY3Rpb24ocGFnZSwgbGluaykge1xuICBjb25zdCBlbGVtZW50cyA9IG9ucy5fdXRpbC5hcnJheUZyb20od2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtbG9hZGluZy1wbGFjZWhvbGRlcl0nKSk7XG5cbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50c1xuICAgICAgLmZpbHRlcihlbGVtZW50ID0+ICFlbGVtZW50LmdldEF0dHJpYnV0ZSgncGFnZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdvbnMtbG9hZGluZy1wbGFjZWhvbGRlcicsIHBhZ2UpO1xuICAgICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSwgbGluayk7XG4gICAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyIGV4aXN0cy4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIHJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJcbiAqIEBzaWduYXR1cmUgcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihwYWdlKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gZWxlbWVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dSWYgbm8gcGFnZSBpcyBkZWZpbmVkIGZvciB0aGUgYG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUgaXQgd2lsbCB3YWl0IGZvciB0aGlzIG1ldGhvZCBiZWluZyBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy1sb2FkaW5nLXBsYWNlaG9sZGVy44Gu5bGe5oCn5YCk44Go44GX44Gm44Oa44O844K444GM5oyH5a6a44GV44KM44Gm44GE44Gq44GE5aC05ZCI44Gv44CB44Oa44O844K444Ot44O844OJ5YmN44Gr5ZG844Gw44KM44KLb25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXLlh6bnkIbjgYzooYzjgo/jgozjgovjgb7jgafooajnpLrjgZXjgozjgb7jgZvjgpPjgIJbL2phXVxuICovXG5vbnMucmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciA9IG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlck9yaWdpbmFsO1xuXG5vbnMuX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycyA9IGZ1bmN0aW9uKCkge1xuICBvbnMucmVhZHkoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcblxuICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBwYWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJyk7XG4gICAgICBpZiAodHlwZW9mIHBhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihlbGVtZW50LCBwYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5vbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSBmdW5jdGlvbihlbGVtZW50LCBwYWdlLCBsaW5rKSB7XG4gIGxpbmsgPSBsaW5rIHx8IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmUpIHsgZG9uZSgpOyB9O1xuICBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcblxuICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuICAgIGNvbnRlbnRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRlbnRFbGVtZW50KTtcblxuICAgIGxpbmsoY29udGVudEVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGVudEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH0pO1xuXG4gIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZWQgdG8gcmVzb2x2ZSBwbGFjZWhvbGRlcjogJyArIGVycm9yKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB3YWl0RGV2aWNlUmVhZHkoKSB7XG4gIGNvbnN0IHVubG9ja0RldmljZVJlYWR5ID0gb25zLl9yZWFkeUxvY2subG9jaygpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignV2ViQ29tcG9uZW50c1JlYWR5JywgKCkgPT4ge1xuICAgIGlmIChvbnMuaXNXZWJWaWV3KCkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIHVubG9ja0RldmljZVJlYWR5LCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVubG9ja0RldmljZVJlYWR5KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG59XG5cbndpbmRvdy5fc3VwZXJTZWNyZXRPbnMgPSBvbnM7XG5leHBvcnQgZGVmYXVsdCBvbnM7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50Q2xhc3MoKSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBCYXNlRWxlbWVudCA9ICgpID0+IHt9O1xuICAgIEJhc2VFbGVtZW50LnByb3RvdHlwZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldHVybiBCYXNlRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSFRNTEVsZW1lbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUVsZW1lbnQgZXh0ZW5kcyBnZXRFbGVtZW50Q2xhc3MoKSB7XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRlbXBsYXRlXG4gKiBAY2F0ZWdvcnkgdGVtcGxhdGVcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGVmaW5lIGEgc2VwYXJhdGUgSFRNTCBmcmFnbWVudCBhbmQgdXNlIGFzIGEgdGVtcGxhdGUuXG4gKlxuICogICAgIFRoZXNlIHRlbXBsYXRlcyBjYW4gYmUgbG9hZGVkIGFzIHBhZ2VzIGluIGA8b25zLW5hdmlnYXRvcj5gLCBgPG9ucy10YWJiYXI+YCBhbmQgYDxvbnMtc3BsaXR0ZXI+YC4gVGhleSBjYW4gYWxzbyBiZSB1c2VkIHRvIGdlbmVyYXRlIGRpYWxvZ3MuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgajjgZfjgabkvb/nlKjjgZnjgovjgZ/jgoHjga5IVE1M44OV44Op44Kw44Oh44Oz44OI44KS5a6a576p44GX44G+44GZ44CC44GT44Gu6KaB57Sg44GnSFRNTOOCkuWuo+iogOOBmeOCi+OBqOOAgWlk5bGe5oCn44Gr5oyH5a6a44GX44Gf5ZCN5YmN44KScGFnZeOBrlVSTOOBqOOBl+OBpm9ucy1uYXZpZ2F0b3Ljgarjganjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgYvjgonlj4LnhafjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIERlZmluaW5nTXVsdGlwbGVQYWdlc2luU2luZ2xlSFRNTFxuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLW5hdmlnYXRvclxuICogICBbZW5dVGhlIGA8b25zLW5hdmlnYXRvcj5gIGNvbXBvbmVudCBlbmFibGVzIHN0YWNrIGJhc2VkIG5hdmlnYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdGFiYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gYWRkIHRhYiBuYXZpZ2F0aW9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgZHJhZ2dhYmxlIG1lbnUgb3IgY29sdW1uIGJhc2VkIGxheW91dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiZm9vYmFyLmh0bWxcIj5cbiAqICAgPG9ucy1wYWdlPlxuICogICAgIFBhZ2UgY29udGVudFxuICogICA8L29ucy1wYWdlPlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKlxuICogPG9ucy1uYXZpZ2F0b3IgcGFnZT1cImZvb2Jhci5odG1sXCI+XG4gKiA8L29ucy1uYXZpZ2F0b3I+XG4gKi9cbmNsYXNzIFRlbXBsYXRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHRlbXBsYXRlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRlbXBsYXRlIGNvbnRlbnQuIFRoaXMgcHJvcGVydHkgY2FuIG5vdCBiZSB1c2VkIHdpdGggQW5ndWxhckpTIGJpbmRpbmdzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5pbm5lckhUTUw7XG5cbiAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ190ZW1wbGF0ZWxvYWRlZCcsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlfSk7XG4gICAgZXZlbnQudGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgIGV2ZW50LnRlbXBsYXRlSWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbn1cblxud2luZG93Lk9uc1RlbXBsYXRlRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRlbXBsYXRlJywge1xuICBwcm90b3R5cGU6IFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9yaWVudGF0aW9uIGZyb20gJ29ucy9vcmllbnRhdGlvbic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1pZlxuICogQGNhdGVnb3J5IGNvbmRpdGlvbmFsXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaWZcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29uZGl0aW9uYWxseSBkaXNwbGF5IGNvbnRlbnQgZGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSwgZGV2aWNlIG9yaWVudGF0aW9uIG9yIGJvdGguXG4gKlxuICogICAgIFNvbWV0aW1lcyBpdCBpcyB1c2VmdWwgdG8gY29uZGl0aW9uYWxseSBoaWRlIG9yIHNob3cgY2VydGFpbiBjb21wb25lbnRzIGJhc2VkIG9uIHBsYXRmb3JtLiBXaGVuIHJ1bm5pbmcgb24gaU9TIHRoZSBgPG9ucy1pZj5gIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gaGlkZSB0aGUgYDxvbnMtZmFiPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgVXRpbGl0eUFQSXNcbiAqICAgW2VuXU90aGVyIHV0aWxpdHkgQVBJc1svZW5dXG4gKiAgIFtqYV3ku5bjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqNBUElbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy1pZiBvcmllbnRhdGlvbj1cImxhbmRzY2FwZVwiPlxuICogICAgIExhbmRzY2FwZSB2aWV3IVxuICogICA8L29ucy1pZj5cbiAqICAgPG9ucy1pZiBwbGF0Zm9ybT1cImFuZHJvaWRcIj5cbiAqICAgICBUaGlzIGlzIEFuZHJvaWQuXG4gKiAgIDwvb25zLWlmPlxuICogICA8b25zLWlmIHBsYXRmb3JtPVwiaW9zIG90aGVyXCI+XG4gKiAgICAgVGhpcyBpcyBub3QgQW5kcm9pZC5cbiAqICAgPC9vbnMtaWY+XG4gKiA8L29ucy1wYWdlPlxuICovXG5jbGFzcyBDb25kaXRpb25hbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGxhdGZvcm1cbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwYWNlLXNlcGFyYXRlZCBwbGF0Zm9ybSBuYW1lcy4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJpb3NcImAsIGBcImFuZHJvaWRcImAsIGBcIndpbmRvd3NcImAgYW5kIGBcIm90aGVyXCJgLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb3JpZW50YXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRWl0aGVyIGBcInBvcnRyYWl0XCJgIG9yIGBcImxhbmRzY2FwZVwiYC5bL2VuXVxuICAgKiAgW2phXXBvcnRyYWl044KC44GX44GP44GvbGFuZHNjYXBl44KS5oyH5a6a44GX44G+44GZWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAocGxhdGZvcm0uX3JlbmRlclBsYXRmb3JtICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgICB0aGlzLmNoaWxkTm9kZXNbMF0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UoKTtcbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgb3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSkge1xuICAgIGlmIChuYW1lID09PSAnb3JpZW50YXRpb24nKSB7XG4gICAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICBvcmllbnRhdGlvbi5vZmYoJ2NoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICB9XG5cbiAgX3BsYXRmb3JtVXBkYXRlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IHRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkgPyAnJyA6ICdub25lJztcbiAgfVxuXG4gIF9pc0FsbG93ZWRQbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZ2V0QXR0cmlidXRlKCdwbGF0Zm9ybScpIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwbGF0Zm9ybScpLnNwbGl0KC9cXHMrLykuaW5kZXhPZihwbGF0Zm9ybS5nZXRNb2JpbGVPUygpKSA+PSAwO1xuICB9XG5cbiAgX29uT3JpZW50YXRpb25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdvcmllbnRhdGlvbicpICYmIHRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnb3JpZW50YXRpb24nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgY3VycmVudE9yaWVudGF0aW9uID0gb3JpZW50YXRpb24uaXNQb3J0cmFpdCgpID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnO1xuXG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAoY29uZGl0aW9uYWxPcmllbnRhdGlvbiA9PT0gY3VycmVudE9yaWVudGF0aW9uKSA/ICcnIDogJ25vbmUnO1xuICAgIH1cbiAgfVxufVxuXG53aW5kb3cuT25zQ29uZGl0aW9uYWxFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtaWYnLCB7XG4gIHByb3RvdHlwZTogQ29uZGl0aW9uYWxFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5leHBvcnQgY2xhc3MgQWxlcnREaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgdGhpcy50aW1pbmcgPSB0aW1pbmc7XG4gICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgc2hvdyhkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbi8qKlxuICogQW5kcm9pZCBzdHlsZSBhbmltYXRvciBmb3IgYWxlcnQgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGR1cmF0aW9uID0gMC4yLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgwLjksIDAuOSwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMC45LCAwLjksIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGFsZXJ0IGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGR1cmF0aW9uID0gMC4yLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcbiAgfVxuXG4gIC8qXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMywgMS4zLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4wLCAxLjAsIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHtBbGVydERpYWxvZ0FuaW1hdG9yLCBJT1NBbGVydERpYWxvZ0FuaW1hdG9yLCBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvcn0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJ29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmFsZXJ0LWRpYWxvZyc6ICdhbGVydC1kaWFsb2ctLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1jb250YWluZXInOiAnYWxlcnQtZGlhbG9nLWNvbnRhaW5lci0tKicsXG4gICcuYWxlcnQtZGlhbG9nLXRpdGxlJzogJ2FsZXJ0LWRpYWxvZy10aXRsZS0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnOiAnYWxlcnQtZGlhbG9nLWNvbnRlbnQtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1mb290ZXInOiAnYWxlcnQtZGlhbG9nLWZvb3Rlci0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctZm9vdGVyLS1vbmUnOiAnYWxlcnQtZGlhbG9nLWZvb3Rlci0tb25lLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctYnV0dG9uLS1vbmUnOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tb25lLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctYnV0dG9uLS1wcmltYWwnOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctbWFzayc6ICdhbGVydC1kaWFsb2ctbWFzay0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdub25lJzogQWxlcnREaWFsb2dBbmltYXRvcixcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIDogSU9TQWxlcnREaWFsb2dBbmltYXRvcixcbiAgJ2ZhZGUnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIDogSU9TQWxlcnREaWFsb2dBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYWxlcnQtZGlhbG9nXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEFsZXJ0IGRpYWxvZyB0aGF0IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGN1cnJlbnQgc2NyZWVuLiBVc2VmdWwgZm9yIGRpc3BsYXlpbmcgcXVlc3Rpb25zLCB3YXJuaW5ncyBvciBlcnJvciBtZXNzYWdlcyB0byB0aGUgdXNlci4gVGhlIHRpdGxlLCBjb250ZW50IGFuZCBidXR0b25zIGNhbiBiZSBlYXNpbHkgY3VzdG9taXplZCBhbmQgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHN3aXRjaCBzdHlsZSBiYXNlZCBvbiB0aGUgcGxhdGZvcm0uXG4gKlxuICogICAgIFRvIHVzZSB0aGUgZWxlbWVudCBpdCBjYW4gZWl0aGVyIGJlIGF0dGFjaGVkIGRpcmVjdGx5IHRvIHRoZSBgPGJvZHk+YCBlbGVtZW50IG9yIGR5bmFtaWNhbGx5IGNyZWF0ZWQgZnJvbSBhIHRlbXBsYXRlIHVzaW5nIHRoZSBgb25zLmNyZWF0ZUFsZXJ0RGlhbG9nKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIFF3d3h5cFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2RpYWxvZ1xuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSBVc2luZ0FsZXJ0XG4gKiAgIFtlbl1MZWFybiBob3cgdG8gdXNlIHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruS9v+OBhOaWueOBruino+iqrOOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1vbnMtZGlhbG9nIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1vbnMtcG9wb3ZlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMubm90aWZpY2F0aW9uXG4gKiAgIFtlbl1Vc2luZyBvbnMubm90aWZpY2F0aW9uIHV0aWxpdHkgZnVuY3Rpb25zLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovjgavjga/jgIFvbnMubm90aWZpY2F0aW9u44Kq44OW44K444Kn44Kv44OI44Gu44Oh44K944OD44OJ44KS5L2/44GG44GT44Go44KC44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWFsZXJ0LWRpYWxvZyBpZD1cImFsZXJ0LWRpYWxvZ1wiPlxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+V2FybmluZyE8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gKiAgICAgQW4gZXJyb3IgaGFzIG9jY3VycmVkIVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1mb290ZXJcIj5cbiAqICAgICA8YnV0dG9uIGlkPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiIGNsYXNzPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiPk9LPC9idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtYWxlcnQtZGlhbG9nPlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FsZXJ0LWRpYWxvZycpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5jbGFzcyBBbGVydERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBzaG93aW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruihqOekuuOCkuatouOCgeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBoaWRpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KI44GG44Go44GZ44KL44Gu44KS5q2i44KB44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7opovjgZ/nm67jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBp+OBr1wibm9uZVwi44GLXCJkZWZhdWx0XCLjgYzmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgILkvovvvJp7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgcmdiYSgwLCAwLCAwLCAwLjIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG1hc2suIERlZmF1bHQgaXMgXCJyZ2JhKDAsIDAsIDAsIDAuMilcIi5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2ctbWFzaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2cnKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX3RpdGxlRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLCAnLmFsZXJ0LWRpYWxvZy10aXRsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0sICcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnKTtcbiAgfVxuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcblxuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gdGhpcy5fY2FuY2VsLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IEFsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnQWxlcnREaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgLyoqXG4gICAgICogRXhwZWN0ZWQgcmVzdWx0IGFmdGVyIGNvbXBpbGU6XG4gICAgICpcbiAgICAgKiA8b25zLWFsZXJ0LWRpYWxvZyBzdHlsZT1cIm5vbmVcIj5cbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctbWFza1wiPjwvZGl2PlxuICAgICAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZ1wiPlxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgPC9kaXY+XG4gICAgICogPC9vbnMtYWxlcnQtZGlhbG9nPlxuICAgICAqL1xuXG4gICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGlmICghdGhpcy5fbWFzayAmJiAhdGhpcy5fZGlhbG9nKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1hc2suY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLW1hc2snKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG1hc2ssIHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2cnKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGRpYWxvZywgbnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2csICcuYWxlcnQtZGlhbG9nLWNvbnRhaW5lcicpKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctY29udGFpbmVyJyk7XG4gICAgICB0aGlzLl9kaWFsb2cuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0uYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICB0aGlzLl9kaWFsb2cuc3R5bGUuekluZGV4ID0gMjAwMDE7XG4gICAgdGhpcy5fbWFzay5zdHlsZS56SW5kZXggPSAyMDAwMDtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpKSB7XG4gICAgICB0aGlzLl9tYXNrLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IGNhbmNlbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NhbmNlbGFibGUnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2NhbmNlbGFibGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovjga7jga/jgIFcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovjgrPjg7zjg6vjg5Djg4Pjgq/jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXUEgYFByb21pc2VgIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlc2hvdycsIHtcbiAgICAgIGFsZXJ0RGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlTaG93ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX21hc2suc3R5bGUub3BhY2l0eSA9ICcxJztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIGFuaW1hdG9yLnNob3codGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0c2hvdycsIHthbGVydERpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXNob3cgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL44Kz44O844Or44OQ44OD44Kv44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGFsZXJ0IGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlaGlkZScsIHtcbiAgICAgIGFsZXJ0RGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlIaWRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3IuaGlkZSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RoaWRlJywge2FsZXJ0RGlhbG9nOiB0aGlzfSk7XG5cbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiByZXNvbHZlKHRyeUhpZGUoKSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlaGlkZSBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGlkZSh7XG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gZSA9PiB0aGlzLmNhbmNlbGFibGUgPyB0aGlzLl9jYW5jZWwoKSA6IGUuY2FsbFBhcmVudEhhbmRsZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgIHRoaXMuX21hc2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdhbmltYXRpb24nKSB7XG4gICAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgT25zQWxlcnREaWFsb2dFbGVtZW50ID0gd2luZG93Lk9uc0FsZXJ0RGlhbG9nRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWFsZXJ0LWRpYWxvZycsIHtcbiAgcHJvdG90eXBlOiBBbGVydERpYWxvZ0VsZW1lbnQucHJvdG90eXBlXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAqL1xuT25zQWxlcnREaWFsb2dFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xuICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBBbGVydERpYWxvZ0FuaW1hdG9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNBbGVydERpYWxvZ0VsZW1lbnQuQWxlcnREaWFsb2dBbmltYXRvcicpO1xuICB9XG4gIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbn07XG5cbk9uc0FsZXJ0RGlhbG9nRWxlbWVudC5BbGVydERpYWxvZ0FuaW1hdG9yID0gQWxlcnREaWFsb2dBbmltYXRvcjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG52YXIgc2NoZW1lID0ge1xuICAnJzogJ2JhY2stYnV0dG9uLS0qJyxcbiAgJy5iYWNrLWJ1dHRvbl9faWNvbic6ICdiYWNrLWJ1dHRvbi0tKl9faWNvbicsXG4gICcuYmFjay1idXR0b25fX2xhYmVsJzogJ2JhY2stYnV0dG9uLS0qX19sYWJlbCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJhY2stYnV0dG9uXG4gKiBAY2F0ZWdvcnkgdG9vbGJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBCYWNrIGJ1dHRvbiBjb21wb25lbnQgZm9yIGA8b25zLXRvb2xiYXI+YC4gUHV0IGl0IGluIHRoZSBsZWZ0IHBhcnQgb2YgdGhlIGA8b25zLXRvb2xiYXI+YC5cbiAqXG4gKiAgICAgSXQgd2lsbCBmaW5kIHRoZSBwYXJlbnQgYDxvbnMtbmF2aWdhdG9yPmAgZWxlbWVudCBhbmQgcG9wIGEgcGFnZSB3aGVuIGNsaWNrZWQuIFRoaXMgYmVoYXZpb3IgY2FuIGJlIG92ZXJyaWRlbiBieSBzcGVjaWZ5aW5nIHRoZSBgb25DbGlja2AgcHJvcGVydHkuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gYUhtR0xcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9uYXZpZ2F0b3JcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5db25zLXRvb2xiYXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1uYXZpZ2F0b3JcbiAqICAgW2VuXW9ucy1uYXZpZ2F0b3IgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1uYXZpZ2F0b3LjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGd1aWRlIEFkZGluZ2F0b29sYmFyXG4gKiAgIFtlbl1BZGRpbmcgYSB0b29sYmFyWy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBrui/veWKoFsvamFdXG4gKiBAZ3VpZGUgUmV0dXJuaW5nZnJvbWFwYWdlXG4gKiAgIFtlbl1SZXR1cm5pbmcgZnJvbSBhIHBhZ2VbL2VuXVxuICogICBbamFd5LiA44Gk5YmN44Gu44Oa44O844K444Gr5oi744KLWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRvb2xiYXI+XG4gKiAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgPG9ucy1iYWNrLWJ1dHRvbj5CYWNrPC9vbnMtYmFjay1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgVGl0bGVcbiAqICAgPGRpdj5cbiAqIDwvb25zLXRvb2xiYXI+XG4gKi9cblxuY2xhc3MgQmFja0J1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODkOODg+OCr+ODnOOCv+ODs+OBruimi+OBn+ebruOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdiYWNrLWJ1dHRvbicpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2stYnV0dG9uX19sYWJlbCcpKSB7XG4gICAgICBjb25zdCBsYWJlbCA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19sYWJlbCcpO1xuXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgICAgY29uc3QgaWNvbiA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19pY29uJyk7XG5cbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGljb24sIHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wdGlvbnMgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIgYW5kIFwibm9uZVwiLlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgXCItaW9zXCIgb3IgXCItbWRcIlxuICAgKiAgICAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBcImxpZnQtaW9zXCIsIFwibGlmdC1tZFwiLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIFwic2xpZGUtaW9zXCIgYW5kIFwiZmFkZS1tZFwiLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuY2FsbGJhY2tcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5yZWZyZXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIHJlZnJlc2hlZCAoZGVzdHJveWVkIGFuZCBjcmVhdGVkIGFnYWluKSBiZWZvcmUgcG9wUGFnZSBhY3Rpb24uWy9lbl1cbiAgICogICBbamFdcG9wUGFnZeOBmeOCi+WJjeOBq+OAgeWJjeOBq+OBguOCi+ODmuODvOOCuOOCkueUn+aIkOOBl+OBquOBiuOBl+OBpuabtOaWsOOBmeOCi+WgtOWQiOOBq3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cblxuICBzZXQgb3B0aW9ucyhvYmplY3QpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb2JqZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkNsaWNrXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmFjayBidXR0b24gYmVoYXZpb3IuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIF9vbkNsaWNrKCkge1xuICAgIGlmICh0aGlzLm9uQ2xpY2spIHtcbiAgICAgIHRoaXMub25DbGljay5hcHBseSh0aGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBuYXZpZ2F0b3IgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1uYXZpZ2F0b3InKTtcbiAgICAgIGlmIChuYXZpZ2F0b3IpIHtcbiAgICAgICAgbmF2aWdhdG9yLnBvcFBhZ2UodGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxufVxuXG53aW5kb3cuT25zQmFja0J1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1iYWNrLWJ1dHRvbicsIHtcbiAgcHJvdG90eXBlOiBCYWNrQnV0dG9uRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdib3R0b20tYmFyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJvdHRvbS10b29sYmFyXG4gKiBAY2F0ZWdvcnkgdG9vbGJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Ub29sYmFyIGNvbXBvbmVudCB0aGF0IGlzIHBvc2l0aW9uZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFd44Oa44O844K45LiL6YOo44Gr6YWN572u44GV44KM44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dTWFrZSB0aGUgdG9vbGJhciB0cmFuc3BhcmVudC5bL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6IOM5pmv44KS6YCP5piO44Gr44GX44Gm6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgQWRkaW5nYXRvb2xiYXJcbiAqICAgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJvdHRvbS10b29sYmFyPlxuICogICBDb250ZW50XG4gKiA8L29ucy1ib3R0b20tdG9vbGJhcj5cbiAqL1xuY2xhc3MgQm90dG9tVG9vbGJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7opovjgZ/nm67jga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdib3R0b20tYmFyJyk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLl90cnlUb0Vuc3VyZU5vZGVQb3NpdGlvbigpO1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl90cnlUb0Vuc3VyZU5vZGVQb3NpdGlvbigpKTtcbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKTtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKSk7XG4gIH1cblxuICBfdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcblxuICAgIGlmIChwYWdlICYmIHBhZ2UgIT09IHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgcGFnZS5fcmVnaXN0ZXJCb3R0b21Ub29sYmFyKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG59XG5cbndpbmRvdy5PbnNCb3R0b21Ub29sYmFyRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWJvdHRvbS10b29sYmFyJywge1xuICBwcm90b3R5cGU6IEJvdHRvbVRvb2xiYXJFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2J1dHRvbi0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1idXR0b25cbiAqIEBjYXRlZ29yeSBidXR0b25cbiAqIEBtb2RpZmllciBvdXRsaW5lXG4gKiAgIFtlbl1CdXR0b24gd2l0aCBvdXRsaW5lIGFuZCB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kWy9lbl1cbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuaMgeOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGlnaHRcbiAqICAgW2VuXUJ1dHRvbiB0aGF0IGRvZXNuJ3Qgc3RhbmQgb3V0LlsvZW5dXG4gKiAgIFtqYV3nm67nq4vjgZ/jgarjgYTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIHF1aWV0XG4gKiAgIFtlbl1CdXR0b24gd2l0aCBubyBvdXRsaW5lIGFuZCBvciBiYWNrZ3JvdW5kLi5bL2VuXVxuICogICBbamFd5p6g57ea44KE6IOM5pmv44GM54Sh44GE5paH5a2X44Gg44GR44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBjdGFcbiAqICAgW2VuXUJ1dHRvbiB0aGF0IHJlYWxseSBzdGFuZHMgb3V0LlsvZW5dXG4gKiAgIFtqYV3nm67nq4vjgaTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlXG4gKiAgIFtlbl1MYXJnZSBidXR0b24gdGhhdCBjb3ZlcnMgdGhlIHdpZHRoIG9mIHRoZSBzY3JlZW4uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi+Wkp+OBjeOBquODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2UtLXF1aWV0XG4gKiAgIFtlbl1MYXJnZSBxdWlldCBidXR0b24uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi3F1aWV044Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZS0tY3RhXG4gKiAgIFtlbl1MYXJnZSBjYWxsIHRvIGFjdGlvbiBidXR0b24uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi2N0YeODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBidXR0b25bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oc44K/44OzWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbC0tZmxhdFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIGZsYXQgYnV0dG9uWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODleODqeODg+ODiOODnOOCv+ODs1svamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEJ1dHRvbiBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgYnV0dG9uIGluIGEgdG9vbGJhciwgdXNlIGA8b25zLXRvb2xiYXItYnV0dG9uPmAgb3IgYDxvbnMtYmFjay1idXR0b24+YCBpbnN0ZWFkLlxuICpcbiAqICAgICBXaWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhcyBhIE1hdGVyaWFsIERlc2lnbiBidXR0b24gd2l0aCBhIHJpcHBsZSBlZmZlY3Qgb24gQW5kcm9pZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODnOOCv+ODs+eUqOOCs+ODs+ODneODvOODjeODs+ODiOOAguODhOODvOODq+ODkOODvOOBq+ODnOOCv+ODs+OCkuioree9ruOBmeOCi+WgtOWQiOOBr+OAgW9ucy10b29sYmFyLWJ1dHRvbuOCguOBl+OBj+OBr29ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2J1dHRvblxuICogQGd1aWRlIEJ1dHRvbiBbZW5dR3VpZGUgZm9yIGA8b25zLWJ1dHRvbj5gWy9lbl1bamFdPG9ucy1idXR0b24+44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBndWlkZSBPdmVycmlkaW5nQ1NTc3R5bGVzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtYnV0dG9uIG1vZGlmaWVyPVwibGFyZ2UtLWN0YVwiPlxuICogICBUYXAgTWVcbiAqIDwvb25zLWJ1dHRvbj5cbiAqL1xuXG5jbGFzcyBCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogIFtqYV3jg5zjgr/jg7Pjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSByaXBwbGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgdGhlIGJ1dHRvbiB3aWxsIGhhdmUgYSByaXBwbGUgZWZmZWN0LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgLy9ub2luc3BlY3Rpb24gSlNBbm5vdGF0b3JcbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2J1dHRvbicpO1xuXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxufVxuXG53aW5kb3cuT25zQnV0dG9uRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWJ1dHRvbicsIHtcbiAgcHJvdG90eXBlOiBCdXR0b25FbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2Nhcm91c2VsLWl0ZW0tLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWwtaXRlbVxuICogQGNhdGVnb3J5IGNhcm91c2VsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENhcm91c2VsIGl0ZW0gY29tcG9uZW50LiBVc2VkIGFzIGEgY2hpbGQgb2YgdGhlIGA8b25zLWNhcm91c2VsPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4YmJ6T1FcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9jYXJvdXNlbFxuICogQHNlZWFsc28gb25zLWNhcm91c2VsXG4gKiAgIFtlbl1gPG9ucy1jYXJvdXNlbD5gIGNvbXBvbmVudHNbL2VuXVxuICogICBbamFdPG9ucy1jYXJvdXNlbD7jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtY2Fyb3VzZWwgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAyMDBweFwiPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiA8L29ucy1jYXJvdXNlbD5cbiAqL1xuY2xhc3MgQ2Fyb3VzZWxJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG59XG5cbndpbmRvdy5PbnNDYXJvdXNlbEl0ZW1FbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtY2Fyb3VzZWwtaXRlbScsIHtcbiAgcHJvdG90eXBlOiBDYXJvdXNlbEl0ZW1FbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJ29ucy9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBEb29yTG9jayBmcm9tICdvbnMvZG9vcmxvY2snO1xuXG5jb25zdCBWZXJ0aWNhbE1vZGVUcmFpdCA9IHtcblxuICBfZ2V0U2Nyb2xsRGVsdGE6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuICB9LFxuXG4gIF9nZXRTY3JvbGxWZWxvY2l0eTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS52ZWxvY2l0eVk7XG4gIH0sXG5cbiAgX2dldEVsZW1lbnRTaXplOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcbiAgfSxcblxuICBfZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm06IGZ1bmN0aW9uKHNjcm9sbCkge1xuICAgIHJldHVybiAndHJhbnNsYXRlM2QoMHB4LCAnICsgLXNjcm9sbCArICdweCwgMHB4KSc7XG4gIH0sXG5cbiAgX3VwZGF0ZURpbWVuc2lvbkRhdGE6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICB0aGlzLl9kaW1lbnNpb25zID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfSxcblxuICBfdXBkYXRlT2Zmc2V0OiBmdW5jdGlvbigpe1xuICAgIGlmICh0aGlzLmNlbnRlcmVkKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSAodGhpcy5fZGltZW5zaW9ucy5oZWlnaHQgfHwgMCkgLSBwYXJzZUludCh0aGlzLl9zdHlsZS5wYWRkaW5nVG9wLCAxMCkgLSBwYXJzZUludCh0aGlzLl9zdHlsZS5wYWRkaW5nQm90dG9tLCAxMCk7XG4gICAgICB0aGlzLl9vZmZzZXQgPSAtKGhlaWdodCAtIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSkgLyAyO1xuICAgIH1cbiAgfSxcblxuICBfbGF5b3V0Q2Fyb3VzZWxJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpO1xuXG4gICAgY29uc3Qgc2l6ZUF0dHIgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplQXR0cigpO1xuICAgIGNvbnN0IHNpemVJbmZvID0gdGhpcy5fZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplQXR0cik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS5oZWlnaHQgPSBzaXplQXR0cjtcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSAoaSAqIHNpemVJbmZvLm51bWJlcikgKyBzaXplSW5mby51bml0O1xuICAgIH1cbiAgfSxcblxuICBfc2V0dXA6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uRGF0YSgpO1xuICAgIHRoaXMuX3VwZGF0ZU9mZnNldCgpO1xuICAgIHRoaXMuX2xheW91dENhcm91c2VsSXRlbXMoKTtcbiAgfVxufTtcblxuY29uc3QgSG9yaXpvbnRhbE1vZGVUcmFpdCA9IHtcblxuICBfZ2V0U2Nyb2xsRGVsdGE6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xuICB9LFxuXG4gIF9nZXRTY3JvbGxWZWxvY2l0eTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS52ZWxvY2l0eVg7XG4gIH0sXG5cbiAgX2dldEVsZW1lbnRTaXplOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEVsZW1lbnRTaXplO1xuICB9LFxuXG4gIF9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybTogZnVuY3Rpb24oc2Nyb2xsKSB7XG4gICAgcmV0dXJuICd0cmFuc2xhdGUzZCgnICsgLXNjcm9sbCArICdweCwgMHB4LCAwcHgpJztcbiAgfSxcblxuICBfdXBkYXRlRGltZW5zaW9uRGF0YTogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpO1xuICAgIHRoaXMuX2RpbWVuc2lvbnMgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9LFxuXG4gIF91cGRhdGVPZmZzZXQ6IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMuY2VudGVyZWQpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gKHRoaXMuX2RpbWVuc2lvbnMud2lkdGggfHwgMCkgLSBwYXJzZUludCh0aGlzLl9zdHlsZS5wYWRkaW5nTGVmdCwgMTApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ1JpZ2h0LCAxMCk7XG4gICAgICB0aGlzLl9vZmZzZXQgPSAtKHdpZHRoIC0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpKSAvIDI7XG4gICAgfVxuICB9LFxuXG4gIF9sYXlvdXRDYXJvdXNlbEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCk7XG5cbiAgICBjb25zdCBzaXplQXR0ciA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemVBdHRyKCk7XG4gICAgY29uc3Qgc2l6ZUluZm8gPSB0aGlzLl9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemVBdHRyKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLndpZHRoID0gc2l6ZUF0dHI7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9IChpICogc2l6ZUluZm8ubnVtYmVyKSArIHNpemVJbmZvLnVuaXQ7XG4gICAgfVxuICB9LFxuXG4gIF9zZXR1cDogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25EYXRhKCk7XG4gICAgdGhpcy5fdXBkYXRlT2Zmc2V0KCk7XG4gICAgdGhpcy5fbGF5b3V0Q2Fyb3VzZWxJdGVtcygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jYXJvdXNlbFxuICogQGNhdGVnb3J5IGNhcm91c2VsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENhcm91c2VsIGNvbXBvbmVudC4gQSBjYXJvdXNlbCBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IHNldmVyYWwgaXRlbXMgaW4gdGhlIHNhbWUgc3BhY2UuXG4gKlxuICogICAgIFRoZSBjb21wb25lbnQgc3VwcG9ydHMgZGlzcGxheWluZyBjb250ZW50IGJvdGggaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LiBUaGUgdXNlciBjYW4gc2Nyb2xsIHRocm91Z2ggdGhlIGl0ZW1zIGJ5IGRyYWdnaW5nIGFuZCBpdCBjYW4gYWxzbyBiZSBjb250cm9sbGVyIHByb2dyYW1tYXRpY2FsbHkuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geGJiek9RXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2Fyb3VzZWxcbiAqIEBzZWVhbHNvIG9ucy1jYXJvdXNlbC1pdGVtXG4gKiAgIFtlbl1gPG9ucy1jYXJvdXNlbC1pdGVtPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1jYXJvdXNlbC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBndWlkZSBVc2luZ0Nhcm91c2VsXG4gKiAgIFtlbl1MZWFybiBob3cgdG8gdXNlIHRoZSBjYXJvdXNlbCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXWNhcm91c2Vs44Kz44Oz44Od44O844ON44Oz44OI44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWNhcm91c2VsIHN0eWxlPVwid2lkdGg6IDEwMCU7IGhlaWdodDogMjAwcHhcIj5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogPC9vbnMtY2Fyb3VzZWw+XG4gKi9cbmNsYXNzIENhcm91c2VsRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGN1cnJlbnQgY2Fyb3VzZWwgaXRlbSBoYXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrjgZfjgabjgYTjgovjgqvjg6vjg7zjgrvjg6vjga7opoHntKDjgYzlpInjgo/jgaPjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxuICAgKiAgIFtlbl1DYXJvdXNlbCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44GfQ2Fyb3VzZWzjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYWN0aXZlSW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50Lmxhc3RBY3RpdmVJbmRleFxuICAgKiAgIFtlbl1QcmV2aW91cyBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd5Lul5YmN44Ki44Kv44OG44Kj44OW44Gg44Gj44Gf6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCByZWZyZXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBjYXJvdXNlbCBoYXMgYmVlbiByZWZyZXNoZWQuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or44GM5pu05paw44GV44KM44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY2Fyb3VzZWxcbiAgICogICBbZW5dQ2Fyb3VzZWwgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBvdmVyc2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBjYXJvdXNlbCBoYXMgYmVlbiBvdmVyc2Nyb2xsZWQuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or44GM44Kq44O844OQ44O844K544Kv44Ot44O844Or44GX44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY2Fyb3VzZWxcbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOabtOaWsOOBleOCjOOBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5hY3RpdmVJbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGFjdGl2ZSBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQuZGlyZWN0aW9uXG4gICAqICAgW2VuXUNhbiBiZSBvbmUgb2YgZWl0aGVyIFwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiIG9yIFwicmlnaHRcIi5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg7zjg5Djg7zjgrnjgq/jg63jg7zjg6vjgZXjgozjgZ/mlrnlkJHjgYzlvpfjgonjgozjgb7jgZnjgIJcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwi44Gu44GE44Ga44KM44GL44Gu5pa55ZCR44GM5rih44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQud2FpdFRvUmV0dXJuXG4gICAqICAgW2VuXVRha2VzIGEgPGNvZGU+UHJvbWlzZTwvY29kZT4gb2JqZWN0IGFzIGFuIGFyZ3VtZW50LiBUaGUgY2Fyb3VzZWwgd2lsbCBub3Qgc2Nyb2xsIGJhY2sgdW50aWwgdGhlIHByb21pc2UgaGFzIGJlZW4gcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44GvUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkuW8leaVsOOBqOOBl+OBpuWPl+OBkeWPluOCiuOBvuOBmeOAgua4oeOBl+OBn1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgYxyZXNvbHZl44GV44KM44KL44GLcmVqZWN044GV44KM44KL44G+44Gn44CB44Kr44Or44O844K744Or44Gv44K544Kv44Ot44O844Or44OQ44OD44Kv44GX44G+44Gb44KT44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgZGlyZWN0aW9uIG9mIHRoZSBjYXJvdXNlbC4gQ2FuIGJlIGVpdGhlciBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIuIERlZmF1bHQgaXMgXCJob3Jpem9udGFsXCIuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or44Gu5pa55ZCR44KS5oyH5a6a44GX44G+44GZ44CCXCJob3Jpem9udGFsXCLjgYtcInZlcnRpY2FsXCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJcImhvcml6b250YWxcIuOBjOODh+ODleOCqeODq+ODiOWApOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZ1bGxzY3JlZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBjb3ZlciB0aGUgd2hvbGUgc2NyZWVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgWFic29sdXRl44Od44K444K344On44Oz44KS5L2/44Gj44Gm44Kr44Or44O844K744Or44GM6Ieq5YuV55qE44Gr55S76Z2i44GE44Gj44Gx44GE44Gr5bqD44GM44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb3ZlcnNjcm9sbGFibGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBiZSBzY3JvbGxhYmxlIG92ZXIgdGhlIGVkZ2UuIEl0IHdpbGwgYm91bmNlIGJhY2sgd2hlbiByZWxlYXNlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjgr/jg4Pjg4HjgoTjg4njg6njg4PjgrDjgafnq6/jgb7jgafjgrnjgq/jg63jg7zjg6vjgZfjgZ/mmYLjgavjgIHjg5Djgqbjg7Pjg4njgZnjgovjgojjgYbjgarlirnmnpzjgYzlvZPjgZ/jgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjZW50ZXJlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB0aGVuIHRoZSBzZWxlY3RlZCBpdGVtIHdpbGwgYmUgaW4gdGhlIGNlbnRlciBvZiB0aGUgY2Fyb3VzZWwgaW5zdGVhZCBvZiB0aGUgYmVnaW5uaW5nLiBVc2VmdWwgb25seSB3aGVuIHRoZSBpdGVtcyBhcmUgc21hbGxlciB0aGFuIHRoZSBjYXJvdXNlbC4gWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB6YG444KT44Gn44GE44KLb25zLWNhcm91c2VsLWl0ZW3jga/jgqvjg6vjg7zjgrvjg6vjga7nnJ/jgpPkuK3jgbjooYzjgY3jgb7jgZnjgILpoIXnm67jgYzjgqvjg6vjg7zjgrvjg6vjgojjgorjgoLlsI/jgZXjgYTloLTlkIjjgavjga7jgb/jgIHjgZPjgozjga/kvr/liKnjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpdGVtLXdpZHRoXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgICBbZW5db25zLWNhcm91c2VsLWl0ZW0ncyB3aWR0aC4gT25seSB3b3JrcyB3aGVuIHRoZSBkaXJlY3Rpb24gaXMgc2V0IHRvIFwiaG9yaXpvbnRhbFwiLlsvZW5dXG4gICAqICAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOBruW5heOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWxnuaAp+OBr+OAgWRpcmVjdGlvbuWxnuaAp+OBq1wiaG9yaXpvbnRhbFwi44KS5oyH5a6a44GX44Gf5pmC44Gu44G/5pyJ5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaXRlbS1oZWlnaHRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXW9ucy1jYXJvdXNlbC1pdGVtJ3MgaGVpZ2h0LiBPbmx5IHdvcmtzIHdoZW4gdGhlIGRpcmVjdGlvbiBpcyBzZXQgdG8gXCJ2ZXJ0aWNhbFwiLlsvZW5dXG4gICAqICAgW2phXW9ucy1jYXJvdXNlbC1pdGVt44Gu6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu5bGe5oCn44Gv44CBZGlyZWN0aW9u5bGe5oCn44GrXCJ2ZXJ0aWNhbFwi44KS5oyH5a6a44GX44Gf5pmC44Gu44G/5pyJ5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0by1zY3JvbGxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNjcm9sbGVkIHRvIHRoZSBjbG9zZXN0IGl0ZW0gYm9yZGVyIHdoZW4gcmVsZWFzZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB5LiA55Wq6L+R44GEY2Fyb3VzZWwtaXRlbeOBruWig+eVjOOBvuOBp+iHquWLleeahOOBq+OCueOCr+ODreODvOODq+OBmeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsLXJhdGlvXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgICBbZW5dQSBudW1iZXIgYmV0d2VlbiAwLjAgYW5kIDEuMCB0aGF0IHNwZWNpZmllcyBob3cgbXVjaCB0aGUgdXNlciBtdXN0IGRyYWcgdGhlIGNhcm91c2VsIGluIG9yZGVyIGZvciBpdCB0byBhdXRvIHNjcm9sbCB0byB0aGUgbmV4dCBpdGVtLlsvZW5dXG4gICAqICAgIFtqYV0wLjDjgYvjgokxLjDjgb7jgafjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgILjgqvjg6vjg7zjgrvjg6vjga7opoHntKDjgpLjganjgozjgZDjgonjgYTjga7libLlkIjjgb7jgafjg4njg6njg4PjgrDjgZnjgovjgajmrKHjga7opoHntKDjgavoh6rli5XnmoTjgavjgrnjgq/jg63jg7zjg6vjgZnjgovjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZWFibGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgY2FuIGJlIHNjcm9sbGVkIGJ5IGRyYWcgb3Igc3dpcGUuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44Kr44Or44O844K744Or44KS44K544Ov44Kk44OX44KE44OJ44Op44OD44Kw44Gn56e75YuV44Gn44GN44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CBZHJhZ+OChHRvdWNo44KEc3dpcGXjgpLlj5fjgZHku5jjgZHjgarjgY/jgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbml0aWFsLWluZGV4XG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIG9ucy1jYXJvdXNlbC1pdGVtIHRvIHNob3cgaW5pdGlhbGx5LiBEZWZhdWx0IGlzIDAuWy9lbl1cbiAgICogICBbamFd5pyA5Yid44Gr6KGo56S644GZ44KLb25zLWNhcm91c2VsLWl0ZW3jgpIw5aeL44G+44KK44Gu44Kk44Oz44OH44OD44Kv44K544Gn5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI5YCk44GvIDAg44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0by1yZWZyZXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGVuIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggd2hlbiB0aGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzIGNoYW5nZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHlrZDopoHntKDjga7mlbDjgYzlpInjgo/jgovjgajjgqvjg6vjg7zjgrvjg6vjga/oh6rli5XnmoTjgavmm7TmlrDjgZXjgozjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAguS+i++8mntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgdGhpcy5fc2Nyb2xsID0gMDtcbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IDA7XG5cbiAgICB0aGlzLl9ib3VuZE9uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnRW5kID0gdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPblJlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9taXhpbih0aGlzLl9pc1ZlcnRpY2FsKCkgPyBWZXJ0aWNhbE1vZGVUcmFpdCA6IEhvcml6b250YWxNb2RlVHJhaXQpO1xuXG4gICAgdGhpcy5fc2V0dXAoKTtcbiAgICAvL+a3u+WKoOi9ruaSreeahOeCuVxuICAgIHRoaXMuX2FkZEltYWdlQnRucygpO1xuICAgIHRoaXMuX3NldHVwSW5pdGlhbEluZGV4KCk7XG5cbiAgICB0aGlzLl9zYXZlTGFzdFN0YXRlKCk7XG4gIH1cblxuICBfYWRkSW1hZ2VCdG5zKCkge1xuICAgIC8v5b2T5qCH562+5LiK5pyJaW1hZ2XlsZ7mgKfml7Ys5YiZ5piv5Zu+54mH6L2u5pKtXG4gICAgaWYodGhpcy5oYXNBdHRyaWJ1dGUoJ2ltYWdlJykpe1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpO1xuICAgICAgY29uc3QgYnRucyA9IHV0aWwuY3JlYXRlKCdiaC1jYXJvdXNlbC1idG5zJyk7XG4gICAgICAvL+iuvue9ruWbvueJh+aAu+aVsFxuICAgICAgYnRucy5zZXRBdHRyaWJ1dGUoJ2NvdW50JywgY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgIC8v6K6+572u5L2N572uXG4gICAgICBidG5zLnNldEF0dHJpYnV0ZSgnY2VudGVyJywgdHJ1ZSk7XG4gICAgICBidG5zLnNldEF0dHJpYnV0ZSgnYm90dG9tJywgdHJ1ZSk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGJ0bnMpO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlc2l6ZSgpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fc2Nyb2xsIC8gdGhpcy5fY3VycmVudEVsZW1lbnRTaXplO1xuICAgIGRlbGV0ZSB0aGlzLl9jdXJyZW50RWxlbWVudFNpemU7XG4gICAgdGhpcy5zZXRBY3RpdmVJbmRleChpKTtcbiAgfVxuXG4gIF9vbkRpcmVjdGlvbkNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCgpKSB7XG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WCA9ICdhdXRvJztcbiAgICAgIHRoaXMuc3R5bGUub3ZlcmZsb3dZID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGUub3ZlcmZsb3dYID0gJyc7XG4gICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJztcbiAgICB9XG5cbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuXG4gIF9zYXZlTGFzdFN0YXRlKCkge1xuICAgIHRoaXMuX2xhc3RTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnRTaXplOiB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCksXG4gICAgICBjYXJvdXNlbEVsZW1lbnRDb3VudDogdGhpcy5pdGVtQ291bnQsXG4gICAgICB3aWR0aDogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogdGhpcy5pdGVtQ291bnRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIF9nZXRDYXJvdXNlbEl0ZW1TaXplKCkge1xuICAgIGNvbnN0IHNpemVBdHRyID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKTtcbiAgICBjb25zdCBzaXplSW5mbyA9IHRoaXMuX2RlY29tcG9zZVNpemVTdHJpbmcoc2l6ZUF0dHIpO1xuICAgIGNvbnN0IGVsZW1lbnRTaXplID0gdGhpcy5fZ2V0RWxlbWVudFNpemUoKTtcblxuICAgIGlmIChzaXplSW5mby51bml0ID09PSAnJScpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNpemVJbmZvLm51bWJlciAvIDEwMCAqIGVsZW1lbnRTaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemVJbmZvLnVuaXQgPT09ICdweCcpIHtcbiAgICAgIHJldHVybiBzaXplSW5mby5udW1iZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBfZ2V0SW5pdGlhbEluZGV4KCkge1xuICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ2luaXRpYWwtaW5kZXgnKSwgMTApO1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGluZGV4KSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGluZGV4LCB0aGlzLml0ZW1Db3VudCAtIDEpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIF9nZXRDYXJvdXNlbEl0ZW1TaXplQXR0cigpIHtcbiAgICBjb25zdCBhdHRyTmFtZSA9ICdpdGVtLScgKyAodGhpcy5faXNWZXJ0aWNhbCgpID8gJ2hlaWdodCcgOiAnd2lkdGgnKTtcbiAgICBjb25zdCBpdGVtU2l6ZUF0dHIgPSAoJycgKyB0aGlzLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpLnRyaW0oKTtcblxuICAgIHJldHVybiBpdGVtU2l6ZUF0dHIubWF0Y2goL15cXGQrKHB4fCUpJC8pID8gaXRlbVNpemVBdHRyIDogJzEwMCUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIF9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gc2l6ZS5tYXRjaCgvXihcXGQrKShweHwlKS8pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlcjogcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLFxuICAgICAgdW5pdDogbWF0Y2hlc1syXSxcbiAgICB9O1xuICB9XG5cbiAgX3NldHVwSW5pdGlhbEluZGV4KCkge1xuICAgIHRoaXMuX3Njcm9sbCA9ICh0aGlzLl9vZmZzZXQgfHwgMCkgKyB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgKiB0aGlzLl9nZXRJbml0aWFsSW5kZXgoKTtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJbml0aWFsSW5kZXgoKTtcbiAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0QWN0aXZlSW5kZXhcbiAgICogQHNpZ25hdHVyZSBzZXRBY3RpdmVJbmRleChpbmRleCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dVGhlIGluZGV4IHRoYXQgdGhlIGNhcm91c2VsIHNob3VsZCBiZSBzZXQgdG8uWy9lbl1cbiAgICogICBbamFdY2Fyb3VzZWzopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBpbmRleCBvZiB0aGUgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIHRvIHNob3cuWy9lbl1cbiAgICogICBbamFd6KGo56S644GZ44KLb25zLWNhcm91c2VsLWl0ZW3jgpJpbmRleOOBp+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIHsgZHVyYXRpb246IDAuMywgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyB9LFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykgPyB1dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkgOiB7fVxuICAgICk7XG5cbiAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLml0ZW1Db3VudCAtIDEpKTtcbiAgICBjb25zdCBzY3JvbGwgPSAodGhpcy5fb2Zmc2V0IHx8IDApICsgdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogaW5kZXg7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCk7XG5cbiAgICB0aGlzLl9zY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHNjcm9sbCkpO1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwsIG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544GM6L+U44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GV44KM44Gm44GE44KLb25zLWNhcm91c2VsLWl0ZW3opoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlSW5kZXgoKSB7XG4gICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5fc2Nyb2xsIC0gKHRoaXMuX29mZnNldCB8fCAwKTtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuaXRlbUNvdW50O1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCk7XG5cbiAgICBpZiAoc2Nyb2xsIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGlmIChzaXplICogaSA8PSBzY3JvbGwgJiYgc2l6ZSAqIChpICsgMSkgPiBzY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWF4IGNhcm91c2VsIGluZGV4XG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBuZXh0XG4gICAqIEBzaWduYXR1cmUgbmV4dChbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgbmV4dCBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd5qyh44Gub25zLWNhcm91c2VsLWl0ZW3jgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgbmV4dChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlSW5kZXgodGhpcy5nZXRBY3RpdmVJbmRleCgpICsgMSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwcmV2XG4gICAqIEBzaWduYXR1cmUgcHJldihbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgcHJldmlvdXMgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeWJjeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHByZXYob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSAtIDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfaXNFbmFibGVkQ2hhbmdlRXZlbnQoKSB7XG4gICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLl9nZXRFbGVtZW50U2l6ZSgpO1xuICAgIGNvbnN0IGNhcm91c2VsSXRlbVNpemUgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCk7XG5cbiAgICByZXR1cm4gdGhpcy5hdXRvU2Nyb2xsICYmIGVsZW1lbnRTaXplID09PSBjYXJvdXNlbEl0ZW1TaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfaXNWZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnO1xuICB9XG5cbiAgX3ByZXBhcmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHtkcmFnTWluRGlzdGFuY2U6IDF9KTtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gdGhpcy5yZWZyZXNoKCkpO1xuXG4gICAgdGhpcy5fdXBkYXRlU3dpcGVhYmxlKCk7XG4gICAgdGhpcy5fdXBkYXRlQXV0b1JlZnJlc2goKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG51bGw7XG5cbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIF91cGRhdGVTd2lwZWFibGUoKSB7XG4gICAgaWYgKHRoaXMuX2dlc3R1cmVEZXRlY3Rvcikge1xuICAgICAgaWYgKHRoaXMuc3dpcGVhYmxlKSB7XG4gICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duJywgdGhpcy5fYm91bmRPbkRyYWcpO1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnIGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFndXAgZHJhZ2Rvd24gc3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHQgc3dpcGV1cCBzd2lwZWRvd24nLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUF1dG9SZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9tdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tcmVmcmVzaCcpKSB7XG4gICAgICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpIHtcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmdldEFjdGl2ZUluZGV4KCk7XG5cbiAgICBpZiAodGhpcy5fbGFzdEFjdGl2ZUluZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgIGNvbnN0IGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX2xhc3RBY3RpdmVJbmRleDtcbiAgICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IGN1cnJlbnRJbmRleDtcblxuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0Y2hhbmdlJywge1xuICAgICAgICBjYXJvdXNlbDogdGhpcyxcbiAgICAgICAgYWN0aXZlSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgbGFzdEFjdGl2ZUluZGV4OiBsYXN0QWN0aXZlSW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmRpcmVjdGlvbjtcbiAgICBpZiAoKHRoaXMuX2lzVmVydGljYWwoKSAmJiAoZGlyZWN0aW9uID09PSAnbGVmdCcgfHwgZGlyZWN0aW9uID09PSAncmlnaHQnKSkgfHwgKCF0aGlzLl9pc1ZlcnRpY2FsKCkgJiYgKGRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBkaXJlY3Rpb24gPT09ICdkb3duJykpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICB0aGlzLl9sYXN0RHJhZ0V2ZW50ID0gZXZlbnQ7XG5cbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSB0aGlzLl9nZXRTY3JvbGxEZWx0YShldmVudCk7XG4gICAgdGhpcy5fc2Nyb2xsVG8oc2Nyb2xsKTtcbiAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XG4gIH1cblxuICBfb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fc2Nyb2xsIC0gdGhpcy5fZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpO1xuXG4gICAgaWYgKHRoaXMuX2dldFNjcm9sbERlbHRhKGV2ZW50KSAhPT0gMCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzT3ZlclNjcm9sbCh0aGlzLl9zY3JvbGwpKSB7XG4gICAgICBsZXQgd2FpdEZvckFjdGlvbiA9IGZhbHNlO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdvdmVyc2Nyb2xsJywge1xuICAgICAgICBjYXJvdXNlbDogdGhpcyxcbiAgICAgICAgYWN0aXZlSW5kZXg6IHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSxcbiAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9nZXRPdmVyU2Nyb2xsRGlyZWN0aW9uKCksXG4gICAgICAgIHdhaXRUb1JldHVybjogKHByb21pc2UpID0+IHtcbiAgICAgICAgICB3YWl0Rm9yQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4gdGhpcy5fc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghd2FpdEZvckFjdGlvbikge1xuICAgICAgICB0aGlzLl9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXJ0TW9tZW50dW1TY3JvbGwoKTtcbiAgICAgIC8v6L2u5pKt5YiH5o2i5pe2LOWIh+aNoumrmOS6rueahOeCuVxuICAgICAgaWYodGhpcy5oYXNBdHRyaWJ1dGUoJ2ltYWdlJykpe1xuICAgICAgICBjb25zdCBpID0gdGhpcy5fc2Nyb2xsIC8gdGhpcy5fY3VycmVudEVsZW1lbnRTaXplO1xuICAgICAgICB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnYmgtY2Fyb3VzZWwtYnRucycpLnNldEFjdGl2ZUluZGV4KGkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9sYXN0RHJhZ0V2ZW50ID0gbnVsbDtcblxuICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhaXRcbiAgICovXG4gIF9taXhpbih0cmFpdCkge1xuICAgIE9iamVjdC5rZXlzKHRyYWl0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhpc1trZXldID0gdHJhaXRba2V5XTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgX3N0YXJ0TW9tZW50dW1TY3JvbGwoKSB7XG4gICAgaWYgKHRoaXMuX2xhc3REcmFnRXZlbnQpIHtcbiAgICAgIGNvbnN0IHZlbG9jaXR5ID0gdGhpcy5fZ2V0U2Nyb2xsVmVsb2NpdHkodGhpcy5fbGFzdERyYWdFdmVudCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IDAuMztcbiAgICAgIGNvbnN0IHNjcm9sbERlbHRhID0gZHVyYXRpb24gKiAxMDAgKiB2ZWxvY2l0eTtcbiAgICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX25vcm1hbGl6ZVNjcm9sbFBvc2l0aW9uKFxuICAgICAgICB0aGlzLl9zY3JvbGwgKyAodGhpcy5fZ2V0U2Nyb2xsRGVsdGEodGhpcy5fbGFzdERyYWdFdmVudCkgPiAwID8gLXNjcm9sbERlbHRhIDogc2Nyb2xsRGVsdGEpXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9zY3JvbGwgPSBzY3JvbGw7XG5cbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0odGhpcy5fc2Nyb2xsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5wbGF5KCk7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZVNjcm9sbFBvc2l0aW9uKHNjcm9sbCkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuXG4gICAgaWYgKCF0aGlzLmF1dG9TY3JvbGwpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHNjcm9sbCkpO1xuICAgIH1cbiAgICBsZXQgYXJyID0gW107XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKTtcbiAgICBjb25zdCBuYnJPZkl0ZW1zID0gdGhpcy5pdGVtQ291bnQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ick9mSXRlbXM7IGkrKykge1xuICAgICAgaWYgKGkgKiBzaXplICsgdGhpcy5fb2Zmc2V0IDwgbWF4KSB7XG4gICAgICAgIGFyci5wdXNoKGkgKiBzaXplICsgdGhpcy5fb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXJyLnB1c2gobWF4KTtcblxuICAgIGFyci5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBsZWZ0ID0gTWF0aC5hYnMobGVmdCAtIHNjcm9sbCk7XG4gICAgICByaWdodCA9IE1hdGguYWJzKHJpZ2h0IC0gc2Nyb2xsKTtcblxuICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICB9KTtcblxuICAgIGFyciA9IGFyci5maWx0ZXIoZnVuY3Rpb24oaXRlbSwgcG9zKSB7XG4gICAgICByZXR1cm4gIXBvcyB8fCBpdGVtICE9IGFycltwb3MgLSAxXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGxhc3RTY3JvbGwgPSB0aGlzLl9sYXN0QWN0aXZlSW5kZXggKiBzaXplICsgdGhpcy5fb2Zmc2V0O1xuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gTWF0aC5hYnMoc2Nyb2xsIC0gbGFzdFNjcm9sbCkgLyBzaXplO1xuICAgIGxldCByZXN1bHQgPSBhcnJbMF07XG5cbiAgICBpZiAoc2Nyb2xsUmF0aW8gPD0gdGhpcy5hdXRvU2Nyb2xsUmF0aW8pIHtcbiAgICAgIHJlc3VsdCA9IGxhc3RTY3JvbGw7XG4gICAgfSBlbHNlIGlmIChzY3JvbGxSYXRpbyA8IDEuMCkge1xuICAgICAgaWYgKGFyclswXSA9PT0gbGFzdFNjcm9sbCAmJiBhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICByZXN1bHQgPSBhcnJbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgcmVzdWx0KSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBfZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pXG4gICAgICAuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1jYXJvdXNlbC1pdGVtJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50XG4gICAqL1xuICBfc2Nyb2xsVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpc092ZXJzY3JvbGxhYmxlID0gdGhpcy5vdmVyc2Nyb2xsYWJsZTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZVNjcm9sbCA9IChzY3JvbGwpID0+IHtcbiAgICAgIGNvbnN0IHJhdGlvID0gMC4zNTtcblxuICAgICAgaWYgKHNjcm9sbCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGlzT3ZlcnNjcm9sbGFibGUgPyBNYXRoLnJvdW5kKHNjcm9sbCAqIHJhdGlvKSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1heFNjcm9sbCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuICAgICAgaWYgKG1heFNjcm9sbCA8IHNjcm9sbCkge1xuICAgICAgICByZXR1cm4gaXNPdmVyc2Nyb2xsYWJsZSA/IG1heFNjcm9sbCArIE1hdGgucm91bmQoKHNjcm9sbCAtIG1heFNjcm9sbCkgKiByYXRpbykgOiBtYXhTY3JvbGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY3JvbGw7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0obm9ybWFsaXplU2Nyb2xsKHNjcm9sbCkpXG4gICAgICAgIH0sIG9wdGlvbnMuYW5pbWF0aW9uICAhPT0gJ25vbmUnID8gb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIDoge30pXG4gICAgICAgIC5wbGF5KCgpID0+IHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfY2FsY3VsYXRlTWF4U2Nyb2xsKCkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMuaXRlbUNvdW50ICogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpIC0gdGhpcy5fZ2V0RWxlbWVudFNpemUoKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKG1heCA8IDAgPyAwIDogbWF4KTsgLy8gTmVlZCB0byByZXR1cm4gYW4gaW50ZWdlciB2YWx1ZS5cbiAgfVxuXG4gIF9pc092ZXJTY3JvbGwoc2Nyb2xsKSB7XG4gICAgaWYgKHNjcm9sbCA8IDAgfHwgc2Nyb2xsID4gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfZ2V0T3ZlclNjcm9sbERpcmVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsIDw9IDAgPyAndXAnIDogJ2Rvd24nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsIDw9IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cbiAgfVxuXG4gIF9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCkge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gMC40O1xuXG4gICAgaWYgKHRoaXMuX3Njcm9sbCA8IDApIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0oMClcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC40LCAuMSwgMSknXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAucGxheSgpO1xuICAgICAgdGhpcy5fc2Nyb2xsID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXhTY3JvbGwgPSB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcblxuICAgIGlmIChtYXhTY3JvbGwgPCB0aGlzLl9zY3JvbGwpIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0obWF4U2Nyb2xsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjQsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5wbGF5KCk7XG4gICAgICB0aGlzLl9zY3JvbGwgPSBtYXhTY3JvbGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpdGVtQ291bnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgbnVtYmVyIG9mIGNhcm91c2VsIGl0ZW1zLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+imgee0oOOBruaVsOOBp+OBmeOAglsvamFdXG4gICAqL1xuICBnZXQgaXRlbUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlZnJlc2hcbiAgICogQHNpZ25hdHVyZSByZWZyZXNoKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVwZGF0ZSB0aGUgbGF5b3V0IG9mIHRoZSBjYXJvdXNlbC4gVXNlZCB3aGVuIGFkZGluZyBgPG9ucy1jYXJvdXNlbC1pdGVtcz5gIGR5bmFtaWNhbGx5IG9yIHRvIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHRoZSBzaXplLlsvZW5dXG4gICAqICAgW2phXeODrOOCpOOCouOCpuODiOOChOWGhemDqOOBrueKtuaFi+OCkuacgOaWsOOBruOCguOBruOBq+abtOaWsOOBl+OBvuOBmeOAgm9ucy1jYXJvdXNlbC1pdGVt44KS5YuV55qE44Gr5aKX44KE44GX44Gf44KK44CBb25zLWNhcm91c2Vs44Gu5aSn44GN44GV44KS5YuV55qE44Gr5aSJ44GI44KL6Zqb44Gr5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgLy8gQnVnIGZpeFxuICAgIGlmICh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9taXhpbih0aGlzLl9pc1ZlcnRpY2FsKCkgPyBWZXJ0aWNhbE1vZGVUcmFpdCA6IEhvcml6b250YWxNb2RlVHJhaXQpO1xuICAgIHRoaXMuX3NldHVwKCk7XG5cbiAgICBpZiAodGhpcy5fbGFzdFN0YXRlICYmIHRoaXMuX2xhc3RTdGF0ZS53aWR0aCA+IDApIHtcbiAgICAgIGxldCBzY3JvbGwgPSB0aGlzLl9zY3JvbGw7Ly8gLSB0aGlzLl9vZmZzZXQ7XG5cbiAgICAgIGlmICh0aGlzLl9pc092ZXJTY3JvbGwoc2Nyb2xsKSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxUb0tpbGxPdmVyU2Nyb2xsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hdXRvU2Nyb2xsKSB7XG4gICAgICAgICAgc2Nyb2xsID0gdGhpcy5fbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oc2Nyb2xsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvKHNjcm9sbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc2F2ZUxhc3RTdGF0ZSgpO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWZyZXNoJywge2Nhcm91c2VsOiB0aGlzfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBmaXJzdFxuICAgKiBAc2lnbmF0dXJlIGZpcnN0KClcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nIGZ1bmN0aW9uIG9mIHRoZSBhbmltYXRpb24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBmaXJzdCBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd5pyA5Yid44Gub25zLWNhcm91c2VsLWl0ZW3jgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZmlyc3Qob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KDAsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbGFzdFxuICAgKiBAc2lnbmF0dXJlIGxhc3QoKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgbGFzdCBvbnMtY2Fyb3VzZWwgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3mnIDlvozjga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBsYXN0KG9wdGlvbnMpIHtcbiAgICB0aGlzLnNldEFjdGl2ZUluZGV4KFxuICAgICAgTWF0aC5tYXgodGhpcy5pdGVtQ291bnQgLSAxLCAwKSwgb3B0aW9uc1xuICAgICk7XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3ByZXBhcmVFdmVudExpc3RlbmVycygpO1xuXG4gICAgdGhpcy5fc2V0dXAoKTtcbiAgICB0aGlzLl9zZXR1cEluaXRpYWxJbmRleCgpO1xuXG4gICAgdGhpcy5fc2F2ZUxhc3RTdGF0ZSgpO1xuXG4gICAgLy8gRml4IHJlbmRlcmluZyBnbGl0Y2ggb24gQW5kcm9pZCA0LjFcbiAgICBpZiAodGhpcy5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLnJlZnJlc2goKSk7XG4gICAgfVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ3N3aXBlYWJsZSc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVN3aXBlYWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2F1dG8tcmVmcmVzaCc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZUF1dG9SZWZyZXNoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlyZWN0aW9uJzpcbiAgICAgICAgdGhpcy5fb25EaXJlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGF1dG9TY3JvbGxSYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgYXV0byBzY3JvbGwgcmF0aW8uIFsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruOCquODvOODiOOCueOCr+ODreODvOODq+OBrnJhdGlv5YCk44CCWy9qYV1cbiAgICovXG4gIGdldCBhdXRvU2Nyb2xsUmF0aW8oKSB7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdXRvLXNjcm9sbC1yYXRpbycpO1xuXG4gICAgaWYgKCFhdHRyKSB7XG4gICAgICByZXR1cm4gMC41O1xuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gcGFyc2VGbG9hdChhdHRyKTtcbiAgICBpZiAoc2Nyb2xsUmF0aW8gPCAwLjAgfHwgc2Nyb2xsUmF0aW8gPiAxLjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYXRpby4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOYU4oc2Nyb2xsUmF0aW8pID8gMC41IDogc2Nyb2xsUmF0aW87XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbFJhdGlvKHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvIDwgMC4wIHx8IHJhdGlvID4gMS4wKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmF0aW8uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJywgcmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzd2lwZWFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl10cnVlIGlmIHRoZSBjYXJvdXNlbCBpcyBzd2lwZWFibGUuWy9lbl1cbiAgICogICBbamFdc3dpcGVhYmxl44Gn44GC44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgc3dpcGVhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnc3dpcGVhYmxlJyk7XG4gIH1cblxuICBzZXQgc3dpcGVhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdzd2lwZWFibGUnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGF1dG9TY3JvbGxcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl10cnVlIGlmIGF1dG8gc2Nyb2xsIGlzIGVuYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Kq44O844OI44K544Kv44Ot44O844Or44GM5pyJ5Yq544Gn44GC44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgYXV0b1Njcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsJyk7XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnYXV0by1zY3JvbGwnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3ZlcnNjcm9sbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBvdmVyc2Nyb2xsYWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFdb3ZlcnNjcm9sbOOBp+OBjeOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IG92ZXJzY3JvbGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnb3ZlcnNjcm9sbGFibGUnKTtcbiAgfVxuXG4gIHNldCBvdmVyc2Nyb2xsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnb3ZlcnNjcm9sbGFibGUnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNlbnRlcmVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgY2VudGVyZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXWNlbnRlcmVk54q25oWL44Gr44Gq44Gj44Gm44GE44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgY2VudGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjZW50ZXJlZCcpO1xuICB9XG5cbiAgc2V0IGNlbnRlcmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjZW50ZXJlZCcsIHZhbHVlKTtcbiAgfVxufVxuXG53aW5kb3cuT25zQ2Fyb3VzZWxFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtY2Fyb3VzZWwnLCB7XG4gIHByb3RvdHlwZTogQ2Fyb3VzZWxFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNvbFxuICogQGNhdGVnb3J5IGdyaWRcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIGNvbHVtbiBpbiB0aGUgZ3JpZCBzeXN0ZW0uIFVzZSB3aXRoIGA8b25zLXJvdz5gIHRvIGxheW91dCBjb21wb25lbnRzLlsvZW5dXG4gKiAgIFtqYV3jgrDjg6rjg4Pjg4njgrfjgrnjg4bjg6DjgavjgabliJfjgpLlrprnvqnjgZfjgb7jgZnjgIJvbnMtcm9344Go44Go44KC44Gr5L2/55So44GX44CB44Kz44Oz44Od44O844ON44Oz44OI44Gu44Os44Kk44Ki44Km44OI44Gr5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBub3RlXG4gKiAgIFtlbl1Gb3IgQW5kcm9pZCA0LjMgYW5kIGVhcmxpZXIsIGFuZCBpT1M2IGFuZCBlYXJsaWVyLCB3aGVuIHVzaW5nIG1peGVkIGFsaWdubWVudCB3aXRoIG9ucy1yb3cgYW5kIG9ucy1jb2x1bW4sIHRoZXkgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LiBZb3UgY2FuIHVzZSBvbmx5IG9uZSBhbGlnbm1lbnQuWy9lbl1cbiAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29sdW1u44KS57WE44G/5ZCI44KP44Gb44Gf5aC05ZCI44Gr5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIEdndWpDIHt3aWRlfVxuICogQGd1aWRlIGxheW91dGluZyBbZW5dTGF5b3V0aW5nIGd1aWRlWy9lbl1bamFd44Os44Kk44Ki44Km44OI5qmf6IO9Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yb3dcbiAqICAgW2VuXVRoZSBgPG9ucy1yb3c+YCBjb21wb25lbnQgaXMgdGhlIHBhcmVudCBvZiBgPG9ucy1jb2w+YC5bL2VuXVxuICogICBbamFdb25zLXJvd+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1yb3c+XG4gKiAgIDxvbnMtY29sIHdpZHRoPVwiNTBweFwiPjxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+PC9vbnMtY29sPlxuICogICA8b25zLWNvbD5UZXh0PC9vbnMtY29sPlxuICogPC9vbnMtcm93PlxuICovXG5cbi8qKlxuICogQGF0dHJpYnV0ZSB2ZXJ0aWNhbC1hbGlnblxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVmVydGljYWwgYWxpZ25tZW50IG9mIHRoZSBjb2x1bW4uIFZhbGlkIHZhbHVlcyBhcmUgXCJ0b3BcIiwgXCJjZW50ZXJcIiwgYW5kIFwiYm90dG9tXCIuWy9lbl1cbiAqICAgW2phXee4puOBrumFjee9ruOCkuaMh+WumuOBmeOCi+OAglwidG9wXCIsIFwiY2VudGVyXCIsIFwiYm90dG9tXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5cbi8qKlxuICogQGF0dHJpYnV0ZSB3aWR0aFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4uIFZhbGlkIHZhbHVlcyBhcmUgY3NzIHdpZHRoIHZhbHVlcyAoXCIxMCVcIiwgXCI1MHB4XCIpLlsvZW5dXG4gKiAgIFtqYV3jgqvjg6njg6Djga7mqKrluYXjgpLmjIflrprjgZnjgovjgILjg5Hjg7zjgrvjg7Pjg4jjgoLjgZfjgY/jga/jg5Tjgq/jgrvjg6vjgafmjIflrprjgZfjgb7jgZnvvIgxMCXjgoQ1MHB477yJ44CCWy9qYV1cbiAqL1xuY2xhc3MgQ29sdW1uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSB7XG4gICAgICB0aGlzLl91cGRhdGVXaWR0aCgpO1xuICAgIH1cbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICd3aWR0aCcpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVdpZHRoKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVdpZHRoKCkge1xuICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgIGlmICh0eXBlb2Ygd2lkdGggID09PSAnc3RyaW5nJykge1xuICAgICAgd2lkdGggPSAoJycgKyB3aWR0aCkudHJpbSgpO1xuICAgICAgd2lkdGggPSB3aWR0aC5tYXRjaCgvXlxcZCskLykgPyB3aWR0aCArICclJyA6IHdpZHRoO1xuXG4gICAgICB0aGlzLnN0eWxlLndlYmtpdEJveEZsZXggPSAnMCc7XG4gICAgICB0aGlzLnN0eWxlLndlYmtpdEZsZXggPSAnMCAwICcgKyB3aWR0aDtcbiAgICAgIHRoaXMuc3R5bGUubW96Qm94RmxleCA9ICcwJztcbiAgICAgIHRoaXMuc3R5bGUubW96RmxleCA9ICcwIDAgJyArIHdpZHRoO1xuICAgICAgdGhpcy5zdHlsZS5tc0ZsZXggPSAnMCAwICcgKyB3aWR0aDtcbiAgICAgIHRoaXMuc3R5bGUuZmxleCA9ICcwIDAgJyArIHdpZHRoO1xuICAgICAgdGhpcy5zdHlsZS5tYXhXaWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgfVxufVxuXG53aW5kb3cuT25zQ29sRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWNvbCcsIHtcbiAgcHJvdG90eXBlOiBDb2x1bW5FbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5leHBvcnQgY2xhc3MgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHRoaXMudGltaW5nID0gdGltaW5nO1xuICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFuZHJvaWREaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2Vhc2UtaW4tb3V0JywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuM30gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNjAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgSU9TRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgMzAwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIDMwMCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgU2xpZGVEaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTUwJSwgLTM1MCUsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtNTAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC0zNTAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQge0RpYWxvZ0FuaW1hdG9yLCBJT1NEaWFsb2dBbmltYXRvciwgQW5kcm9pZERpYWxvZ0FuaW1hdG9yLCBTbGlkZURpYWxvZ0FuaW1hdG9yfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICdvbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJ29ucy9kb29ybG9jayc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcuZGlhbG9nJzogJ2RpYWxvZy0tKicsXG4gICcuZGlhbG9nLWNvbnRhaW5lcic6ICdkaWFsb2ctY29udGFpbmVyLS0qJyxcbiAgJy5kaWFsb2ctbWFzayc6ICdkaWFsb2ctbWFzay0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBbmRyb2lkRGlhbG9nQW5pbWF0b3IgOiBJT1NEaWFsb2dBbmltYXRvcixcbiAgJ2ZhZGUnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWREaWFsb2dBbmltYXRvciA6IElPU0RpYWxvZ0FuaW1hdG9yLFxuICAnc2xpZGUnOiBTbGlkZURpYWxvZ0FuaW1hdG9yLFxuICAnbm9uZSc6IERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiBjdXJyZW50IHNjcmVlbi4gQXMgb3Bwb3NlZCB0byB0aGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCwgdGhpcyBjb21wb25lbnQgY2FuIGNvbnRhaW4gYW55IGtpbmQgb2YgY29udGVudC5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGA8b25zLmNyZWF0ZURpYWxvZyh0ZW1wbGF0ZSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5cbiAqXG4gKiAgICAgVGhlIGRpYWxvZyBpcyB1c2VmdWwgZm9yIGRpc3BsYXlpbmcgbWVudXMsIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb3IgdG8gYXNrIHRoZSB1c2VyIHRvIG1ha2UgYSBkZWNpc2lvbi5cbiAqXG4gKiAgICAgSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRpc3BsYXllZCBhcyBNYXRlcmlhbCBEZXNpZ24gd2hlbiBydW5uaW5nIG9uIGFuIEFuZHJvaWQgZGV2aWNlLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBkaWFsb2cuWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiB6eHhhR2FcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9kaWFsb2dcbiAqIEBndWlkZSBVc2luZ0RpYWxvZ1xuICogICBbZW5dTGVhcm4gaG93IHRvIHVzZSB0aGUgZGlhbG9nIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44Kz44Oz44Od44O844ON44Oz44OI44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXWA8b25zLWFsZXJ0LWRpYWxvZz5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1gPG9ucy1wb3BvdmVyPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wb3BvdmVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWRpYWxvZyBpZD1cImRpYWxvZ1wiPlxuICogICA8cD5UaGlzIGlzIGEgZGlhbG9nITwvcD5cbiAqIDwvb25zLWRpYWxvZz5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlhbG9nJykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmNsYXNzIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJkZWZhdWx0XCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBnZXQgX21hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuZGlhbG9nLW1hc2snKTtcbiAgfVxuXG4gIGdldCBfZGlhbG9nKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZycpO1xuICB9XG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuXG4gICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgdGhpcy5fYm91bmRDYW5jZWwgPSB0aGlzLl9jYW5jZWwuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogRGlhbG9nQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnRGlhbG9nQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIC8qIEV4cGVjdGVkIHJlc3VsdDpcbiAgICAgKiAgIDxvbnMtZGlhbG9nPlxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLW1hc2tcIj48L2Rpdj5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZ1wiPlxuICAgICAqICAgICAgIDxkaXYgY2xhc3M9XCJkaWFsb2ctY29udGFpbmVyXCI+Li4uPC9kaXY+XG4gICAgICogICAgIDwvZGl2PlxuICAgICAqICAgPC9vbnMtZGlhbG9nPlxuICAgICAqL1xuXG4gICAgaWYgKCF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIGNvbnN0IGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGlhbG9nLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZycpO1xuXG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdkaWFsb2ctY29udGFpbmVyJyk7XG5cbiAgICAgIGRpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcsICcnKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGlkZSh7XG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAsIGBcImZhZGVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNob3cgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudC5cbiAgICovXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGNhbmNlbCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZXNob3cnLCB7XG4gICAgICBkaWFsb2c6IHRoaXMsXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIGNvbnN0IHRyeVNob3cgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3Iuc2hvdyh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RzaG93Jywge2RpYWxvZzogdGhpc30pO1xuXG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXNob3cgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJzbGlkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlaGlkZScsIHtcbiAgICAgIGRpYWxvZzogdGhpcyxcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbmNlbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgY29uc3QgdHJ5SGlkZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xuICAgICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIGFuaW1hdG9yLmhpZGUodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0aGlkZScsIHtkaWFsb2c6IHRoaXN9KTtcblxuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5SGlkZSgpKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVoaWRlIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBBIGNhbmNlbGFibGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IGUgPT4gdGhpcy5jYW5jZWxhYmxlID8gdGhpcy5fY2FuY2VsKCkgOiBlLmNhbGxQYXJlbnRIYW5kbGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG5cbiAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IE9uc0RpYWxvZ0VsZW1lbnQgPSB3aW5kb3cuT25zRGlhbG9nRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWRpYWxvZycsIHtcbiAgcHJvdG90eXBlOiBEaWFsb2dFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RGlhbG9nQW5pbWF0b3J9IEFuaW1hdG9yXG4gKi9cbk9uc0RpYWxvZ0VsZW1lbnQucmVnaXN0ZXJBbmltYXRvciA9IGZ1bmN0aW9uKG5hbWUsIEFuaW1hdG9yKSB7XG4gIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIERpYWxvZ0FuaW1hdG9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNEaWFsb2dFbGVtZW50LkRpYWxvZ0FuaW1hdG9yJyk7XG4gIH1cbiAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xufTtcblxuT25zRGlhbG9nRWxlbWVudC5EaWFsb2dBbmltYXRvciA9IERpYWxvZ0FuaW1hdG9yO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnZmFiLS0qJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtZmFiXG4gKiBAY2F0ZWdvcnkgZmFiXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBGbG9hdGluZyBhY3Rpb24gYnV0dG9uIGlzIGEgY2lyY3VsYXIgYnV0dG9uIGRlZmluZWQgaW4gdGhlIFtNYXRlcmlhbCBEZXNpZ24gc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL2J1dHRvbnMtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5odG1sKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCB0byBwcm9tb3RlIHRoZSBwcmltYXJ5IGFjdGlvbiBvZiB0aGUgYXBwLlxuICpcbiAqICAgICBJdCBjYW4gYmUgZGlzcGxheWVkIGVpdGhlciBhcyBhbiBpbmxpbmUgZWxlbWVudCBvciBpbiBvbmUgb2YgdGhlIGNvcm5lcnMuIE5vcm1hbGx5IGl0IHdpbGwgYmUgcG9zaXRpb25lZCBpbiB0aGUgbG93ZXIgcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JlZW4uXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2ZhYlxuICogQHNlZWFsc28gb25zLXNwZWVkLWRpYWxcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsPmAgY29tcG9uZW50IGlzIGEgRmxvYXRpbmcgYWN0aW9uIGJ1dHRvbiB0aGF0IGRpc3BsYXlzIGEgbWVudSB3aGVuIHRhcHBlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xuY2xhc3MgRmFiRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIHRhcHBlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBwb3NpdGlvbiBvZiB0aGUgYnV0dG9uLiBTaG91bGQgYmUgYSBzdHJpbmcgbGlrZSBgXCJib3R0b20gcmlnaHRcImAgb3IgYFwidG9wIGxlZnRcImAuIElmIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBkZWZpbmVkIGl0IHdpbGwgYmUgZGlzcGxheWVkIGFzIGFuIGlubGluZSBlbGVtZW50LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWInKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5mYWJfX2ljb24nKSkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnZmFiX19pY29uJyk7XG5cbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKCFlbGVtZW50LnRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcmlwcGxlJykge1xuICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cbiAgICB0aGlzLnNob3coKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICB0aGlzLnNob3coKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHRoaXMuaGlkZSgpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdmYWItLXRvcF9fbGVmdCcsXG4gICAgICAnZmFiLS1ib3R0b21fX3JpZ2h0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fbGVmdCcsXG4gICAgICAnZmFiLS10b3BfX3JpZ2h0JyxcbiAgICAgICdmYWItLXRvcF9fY2VudGVyJyxcbiAgICAgICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICBjYXNlICd0b3AgY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICBjYXNlICdib3R0b20gY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBmbG9hdGluZyBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuICAgIHRoaXMuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSGlkZSB0aGUgZmxvYXRpbmcgYWN0aW9uIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDApJztcbiAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgwKSc7XG4gIH1cblxuICAvL25vaW5zcGVjdGlvbiBKU0Fubm90YXRvclxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9PT0gJ3NjYWxlKDEpJyAmJiB0aGlzLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMudmlzaWJsZSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cbn1cblxud2luZG93Lk9uc0ZhYkVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1mYWInLCB7XG4gIHByb3RvdHlwZTogRmFiRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICdvbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWdlc3R1cmUtZGV0ZWN0b3JcbiAqIEBjYXRlZ29yeSBnZXN0dXJlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNvbXBvbmVudCB0byBkZXRlY3QgZmluZ2VyIGdlc3R1cmVzIHdpdGhpbiB0aGUgd3JhcHBlZCBlbGVtZW50LiBTZWUgdGhlIGd1aWRlIGZvciBtb3JlIGRldGFpbHMuWy9lbl1cbiAqICAgW2phXeimgee0oOWGheOBruOCuOOCp+OCueODgeODo+ODvOaTjeS9nOOCkuaknOefpeOBl+OBvuOBmeOAguips+OBl+OBj+OBr+OCrOOCpOODieOCkuWPgueFp+OBl+OBpuOBj+OBoOOBleOBhOOAglsvamFdXG4gKiBAZ3VpZGUgRGV0ZWN0aW5nRmluZ2VyR2VzdHVyZXNcbiAqICAgW2VuXURldGVjdGluZyBmaW5nZXIgZ2VzdHVyZXNbL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44O85pON5L2c44Gu5qSc55+lWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWdlc3R1cmUtZGV0ZWN0b3Igc3R5bGU9XCJoZWlnaHQ6IDEwMCU7IHdpZHRoOiAxMDAlO1wiPlxuICogICAuLi5cbiAqIDwvb25zLWdlc3R1cmUtZGV0ZWN0b3I+XG4gKi9cbmNsYXNzIEdlc3R1cmVEZXRlY3RvckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMpO1xuICB9XG59XG5cbndpbmRvdy5PbnNHZXN0dXJlRGV0ZWN0b3JFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtZ2VzdHVyZS1kZXRlY3RvcicsIHtcbiAgcHJvdG90eXBlOiBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuIENvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuICovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWljb25cbiAqIEBjYXRlZ29yeSBpY29uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXlzIGFuIGljb24uIFRoZSBmb2xsb3dpbmcgaWNvbiBzdWl0ZXMgYXJlIGF2YWlsYWJsZTpcbiAqXG4gKiAgICAgKiBbRm9udCBBd2Vzb21lXShodHRwczovL2ZvcnRhd2Vzb21lLmdpdGh1Yi5pby9Gb250LUF3ZXNvbWUvKVxuICogICAgICogW0lvbmljb25zXShodHRwOi8vaW9uaWNvbnMuY29tLylcbiAqICAgICAqIFtNYXRlcmlhbCBEZXNpZ24gSWNvbmljIEZvbnRdKGh0dHA6Ly96YXZvbG9rbG9tLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbmljLWZvbnQvKVxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhBaHZnXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaWNvblxuICogQGd1aWRlIFVzaW5nSWNvbnMgW2VuXVVzaW5nIGljb25zWy9lbl1bamFd44Ki44Kk44Kz44Oz44KS5L2/44GGWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWljb25cbiAqICAgaWNvbj1cIm1kLWNhclwiXG4gKiAgIHNpemU9XCIyMHB4XCJcbiAqICAgc3R5bGU9XCJjb2xvcjogcmVkXCI+XG4gKiA8L29ucy1pY29uPlxuICpcbiAqIDxvbnMtYnV0dG9uPlxuICogICA8b25zLWljb24gaWNvbj1cIm1kLWNhclwiPjwvb25zLWljb24+XG4gKiAgIENhclxuICogPC9vbnMtYnV0dG9uPlxuICovXG5jbGFzcyBJY29uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAgIC8qKlxuICAgICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dXG4gICAgICogICAgIFRoZSBpY29uIG5hbWUuIGBcIm1kLVwiYCBwcmVmaXggZm9yIE1hdGVyaWFsIEljb25zLCBgXCJmYS1cImAgZm9yIEZvbnQgQXdlc29tZSBhbmQgYFwiaW9uLVwiYCBwcmVmaXggZm9yIElvbmljb25zLlxuICAgICAqXG4gICAgICogICAgIFNlZSBhbGwgYXZhaWxhYmxlIGljb25zIG9uIHRoZWlyIHJlc3BlY3RpdmUgc2l0ZXM6XG4gICAgICpcbiAgICAgKiAgICAgKiBbRm9udCBBd2Vzb21lXShodHRwczovL2ZvcnRhd2Vzb21lLmdpdGh1Yi5pby9Gb250LUF3ZXNvbWUvKVxuICAgICAqICAgICAqIFtJb25pY29uc10oaHR0cDovL2lvbmljb25zLmNvbSlcbiAgICAgKiAgICAgKiBbTWF0ZXJpYWwgRGVzaWduIEljb25pYyBGb250XShodHRwOi8vemF2b2xva2xvbS5naXRodWIuaW8vbWF0ZXJpYWwtZGVzaWduLWljb25pYy1mb250LylcbiAgICAgKlxuICAgICAqICAgICBJY29ucyBjYW4gYWxzbyBiZSBzdHlsZWQgYmFzZWQgb24gbW9kaWZpZXIgcHJlc2VuY2UuIEFkZCBjb21tYS1zZXBhcmF0ZWQgaWNvbnMgd2l0aCBgXCJtb2RpZmllck5hbWU6XCJgIHByZWZpeC5cbiAgICAgKlxuICAgICAqICAgICBUaGUgY29kZTpcbiAgICAgKlxuICAgICAqICAgICBgYGBcbiAgICAgKiAgICAgPG9ucy1pY29uXG4gICAgICogICAgICAgaWNvbj1cImlvbi1lZGl0LCBtYXRlcmlhbDptZC1lZGl0XCI+XG4gICAgICogICAgIDwvb25zLWljb24+XG4gICAgICogICAgIGBgYFxuICAgICAqXG4gICAgICogICAgIHdpbGwgZGlzcGxheSBgXCJtZC1lZGl0XCJgIGZvciBNYXRlcmlhbCBEZXNpZ24gYW5kIGBcImlvbi1lZGl0XCJgIGFzIHRoZSBkZWZhdWx0IGljb24uXG4gICAgICogICBbL2VuXVxuICAgICAqICAgW2phXVsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYXR0cmlidXRlIHNpemVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXVxuICAgICAqICAgICBUaGUgc2l6ZXMgb2YgdGhlIGljb24uIFZhbGlkIHZhbHVlcyBhcmUgbGcsIDJ4LCAzeCwgNHgsIDV4LCBvciBpbiB0aGUgc2l6ZSBpbiBwaXhlbHMuXG4gICAgICogICAgIEljb25zIGNhbiBhbHNvIGJlIHN0eWxlZCBiYXNlZCBvbiBtb2RpZmllciBwcmVzZW5jZS4gQWRkIGNvbW1hLXNlcGFyYXRlZCBpY29ucyB3aXRoIGBcIm1vZGlmaWVyTmFtZTpcImAgcHJlZml4LlxuICAgICAqXG4gICAgICogICAgIFRoZSBjb2RlOlxuICAgICAqXG4gICAgICogICAgIGBgYFxuICAgICAqICAgICA8b25zLWljb25cbiAgICAgKiAgICAgICBpY29uPVwiaW9uLWVkaXRcIlxuICAgICAqICAgICAgIHNpemU9XCIzMnB4LCBtYXRlcmlhbDoyNHB4XCI+XG4gICAgICogICAgIDwvb25zLWljb24+XG4gICAgICogICAgIGBgYFxuICAgICAqXG4gICAgICogICAgIHdpbGwgcmVuZGVyIGFzIGEgYDI0cHhgIGljb24gaWYgdGhlIGBcIm1hdGVyaWFsXCJgIG1vZGlmaWVyIGlzIHByZXNlbnQgYW5kIGAzMnB4YCBvdGhlcndpc2UuXG4gICAgICogICBbL2VuXVxuICAgICAqICAgW2phXVsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYXR0cmlidXRlIHJvdGF0ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dTnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIDkwLCAxODAgYW5kIDI3MC5bL2VuXVxuICAgICAqICAgW2phXeOCouOCpOOCs+ODs+OCkuWbnui7ouOBl+OBpuihqOekuuOBl+OBvuOBmeOAgjkwLCAxODAsIDI3MOOBi+OCieaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYXR0cmlidXRlIGZpeGVkLXdpZHRoXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgW2VuXVdoZW4gdXNlZCBpbiBhIGxpc3QsIHlvdSB3YW50IHRoZSBpY29ucyB0byBoYXZlIHRoZSBzYW1lIHdpZHRoIHNvIHRoYXQgdGhleSBhbGlnbiB2ZXJ0aWNhbGx5IGJ5IGRlZmluaW5nIHRoaXMgYXR0cmlidXRlLlsvZW5dXG4gICAgICogIFtqYV1bL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQGF0dHJpYnV0ZSBzcGluXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dU3BlY2lmeSB3aGV0aGVyIHRoZSBpY29uIHNob3VsZCBiZSBzcGlubmluZy5bL2VuXVxuICAgICAqICAgW2phXeOCouOCpOOCs+ODs+OCkuWbnui7ouOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICBpZiAoWydpY29uJywgJ3NpemUnLCAnbW9kaWZpZXInXS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY29tcGlsZSgpIHtcbiAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICAgIH1cblxuICAgIF91cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKTtcbiAgICAgICAgY29uc3Qge2NsYXNzTGlzdCwgc3R5bGV9ID0gdGhpcy5fYnVpbGRDbGFzc0FuZFN0eWxlKHRoaXMuX2dldEF0dHJpYnV0ZSgnaWNvbicpLCB0aGlzLl9nZXRBdHRyaWJ1dGUoJ3NpemUnKSk7XG4gICAgICAgIHV0aWwuZXh0ZW5kKHRoaXMuc3R5bGUsIHN0eWxlKTtcblxuICAgICAgICBjbGFzc0xpc3QuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkpO1xuICAgIH1cblxuICAgIF9nZXRBdHRyaWJ1dGUoYXR0cikge1xuICAgICAgICBjb25zdCBwYXJ0cyA9ICh0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSB8fCAnJykuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgICBjb25zdCBkZWYgPSBwYXJ0c1swXTtcbiAgICAgICAgbGV0IG1kID0gcGFydHNbMV07XG4gICAgICAgIG1kID0gKG1kIHx8ICcnKS5zcGxpdCgvXFxzKjpcXHMqLyk7XG4gICAgICAgIHJldHVybiAodXRpbC5oYXNNb2RpZmllcih0aGlzLCBtZFswXSkgPyBtZFsxXSA6IGRlZikgfHwgJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHVubmVlZGVkIGNsYXNzIHZhbHVlLlxuICAgICAqL1xuICAgIF9jbGVhbkNsYXNzQXR0cmlidXRlKCkge1xuICAgICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNsYXNzTGlzdClcbiAgICAgICAgICAgIC5maWx0ZXIoY2xhc3NOYW1lID0+IC9eKGZhJHxmYS18aW9uLXx6bWRpLSkvLnRlc3QoY2xhc3NOYW1lKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSk7XG5cbiAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCd6bWRpJyk7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnb25zLWljb24tLWlvbicpO1xuICAgIH1cblxuICAgIF9idWlsZENsYXNzQW5kU3R5bGUoaWNvbk5hbWUsIHNpemUpIHtcbiAgICAgICAgY29uc3QgY2xhc3NMaXN0ID0gWydvbnMtaWNvbiddO1xuICAgICAgICBjb25zdCBzdHlsZSA9IHt9O1xuXG4gICAgICAgIC8vIEljb25cbiAgICAgICAgLy8gaWYgKGljb25OYW1lLmluZGV4T2YoJ2lvbi0nKSA9PT0gMCkge1xuICAgICAgICAvLyAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xuICAgICAgICAvLyAgICAgY2xhc3NMaXN0LnB1c2goJ29ucy1pY29uLS1pb24nKTtcbiAgICAgICAgLy8gfSBlbHNlIGlmIChpY29uTmFtZS5pbmRleE9mKCdmYS0nKSA9PT0gMCkge1xuICAgICAgICAvLyAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xuICAgICAgICAvLyAgICAgY2xhc3NMaXN0LnB1c2goJ2ZhJyk7XG4gICAgICAgIC8vIH0gZWxzZSBpZiAoaWNvbk5hbWUuaW5kZXhPZignbWQtJykgPT09IDApIHtcbiAgICAgICAgLy8gICAgIGNsYXNzTGlzdC5wdXNoKCd6bWRpJyk7XG4gICAgICAgIC8vICAgICBjbGFzc0xpc3QucHVzaCgnem1kaS0nICsgaWNvbk5hbWUuc3BsaXQoL1xcLSguKyk/LylbMV0pO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWNvbk5hbWUgPSBpY29uTmFtZS5yZXBsYWNlKC9pY29uXFwtL2csICcnKTtcblxuICAgICAgICBjbGFzc0xpc3QucHVzaCgnaWNvbmZvbnQnKTtcbiAgICAgICAgY2xhc3NMaXN0LnB1c2goJ2ljb24tJyArIGljb25OYW1lKTtcblxuICAgICAgICAvLyBTaXplXG4gICAgICAgIGlmIChzaXplLm1hdGNoKC9eWzEtNV14fGxnJC8pKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QucHVzaCgnZmEtJyArIHNpemUpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnZm9udC1zaXplJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5mb250U2l6ZSA9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xhc3NMaXN0OiBjbGFzc0xpc3QsXG4gICAgICAgICAgICBzdHlsZTogc3R5bGVcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbndpbmRvdy5PbnNJY29uRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWljb24nLCB7XG4gICAgcHJvdG90eXBlOiBJY29uRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCB7TGF6eVJlcGVhdERlbGVnYXRlLCBMYXp5UmVwZWF0UHJvdmlkZXJ9IGZyb20gJ29ucy9pbnRlcm5hbC9sYXp5LXJlcGVhdCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxhenktcmVwZWF0XG4gKiBAY2F0ZWdvcnkgbGF6eS1yZXBlYXRcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVXNpbmcgdGhpcyBjb21wb25lbnQgYSBsaXN0IHdpdGggbWlsbGlvbnMgb2YgaXRlbXMgY2FuIGJlIHJlbmRlcmVkIHdpdGhvdXQgYSBkcm9wIGluIHBlcmZvcm1hbmNlLlxuICogICAgIEl0IGRvZXMgdGhhdCBieSBcImxhemlseVwiIGxvYWRpbmcgZWxlbWVudHMgaW50byB0aGUgRE9NIHdoZW4gdGhleSBjb21lIGludG8gdmlldyBhbmRcbiAqICAgICByZW1vdmluZyBpdGVtcyBmcm9tIHRoZSBET00gd2hlbiB0aGV5IGFyZSBub3QgdmlzaWJsZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOWGheOBp+aPj+eUu+OBleOCjOOCi+OCouOCpOODhuODoOOBrkRPTeimgee0oOOBruiqreOBv+i+vOOBv+OBr+OAgeeUu+mdouOBq+imi+OBiOOBneOBhuOBq+OBquOBo+OBn+aZguOBvuOBp+iHquWLleeahOOBq+mBheW7tuOBleOCjOOAgVxuICogICAgIOeUu+mdouOBi+OCieimi+OBiOOBquOBj+OBquOBo+OBn+WgtOWQiOOBq+OBr+OBneOBruimgee0oOOBr+WLleeahOOBq+OCouODs+ODreODvOODieOBleOCjOOBvuOBmeOAglxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9v+OBhuOBk+OBqOOBp+OAgeODkeODleOCqeODvOODnuODs+OCueOCkuWKo+WMluOBleOBm+OCi+OBk+OBqOeEoeOBl+OBq+W3qOWkp+OBquaVsOOBruimgee0oOOCkuaPj+eUu+OBp+OBjeOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gUXdyR0JtXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGF6eS1yZXBlYXRcbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdD5gIGVsZW1lbnQgaXMgdXNlZCB0byByZW5kZXIgYSBsaXN0LlsvZW5dXG4gKiAgIFtqYV1gPG9ucy1saXN0PmDopoHntKDjga/jg6rjgrnjg4jjgpLmj4/nlLvjgZnjgovjga7jgavkvb/jgo/jgozjgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIFVzaW5nTGF6eVJlcGVhdFxuICogICBbZW5dSG93IHRvIHVzZSBMYXp5IFJlcGVhdFsvZW5dXG4gKiAgIFtqYV3jg6zjgqTjgrjjg7zjg6rjg5Tjg7zjg4jjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxzY3JpcHQ+XG4gKiAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgdmFyIGxhenlSZXBlYXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbGlzdCcpO1xuICogICAgIGxhenlSZXBlYXQuZGVsZWdhdGUgPSB7XG4gKiAgICAgIGNyZWF0ZUl0ZW1Db250ZW50OiBmdW5jdGlvbihpLCB0ZW1wbGF0ZSkge1xuICogICAgICAgIHZhciBkb20gPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gKiAgICAgICAgZG9tLmlubmVyVGV4dCA9IGk7XG4gKlxuICogICAgICAgIHJldHVybiBkb207XG4gKiAgICAgIH0sXG4gKiAgICAgIGNvdW50SXRlbXM6IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHJldHVybiAxMDAwMDAwMDtcbiAqICAgICAgfSxcbiAqICAgICAgZGVzdHJveUl0ZW06IGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG4gKiAgICAgICAgY29uc29sZS5sb2coJ0Rlc3Ryb3llZCBpdGVtIHdpdGggaW5kZXg6ICcgKyBpbmRleCk7XG4gKiAgICAgIH1cbiAqICAgICB9O1xuICogICB9KTtcbiAqIDwvc2NyaXB0PlxuICpcbiAqIDxvbnMtbGlzdCBpZD1cImxpc3RcIj5cbiAqICAgPG9ucy1sYXp5LXJlcGVhdD5cbiAqICAgICA8b25zLWxpc3QtaXRlbT48L29ucy1saXN0LWl0ZW0+XG4gKiAgIDwvb25zLWxhenktcmVwZWF0PlxuICogPC9vbnMtbGlzdD5cbiAqL1xuY2xhc3MgTGF6eVJlcGVhdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB1dGlsLnVwZGF0ZVBhcmVudFBvc2l0aW9uKHRoaXMpO1xuXG4gICAgLy8gbm90IHZlcnkgZ29vZCBpZGVhIGFuZCBhbHNvIG5vdCBkb2N1bWVudGVkXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkZWxlZ2F0ZScpKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gd2luZG93W3RoaXMuZ2V0QXR0cmlidXRlKCdkZWxlZ2F0ZScpXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgYSBkZWxlZ2F0ZSBvYmplY3QgdG8gbG9hZCBhbmQgdW5sb2FkIGl0ZW0gZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV3opoHntKDjga7jg63jg7zjg4njgIHjgqLjg7Pjg63jg7zjg4njgarjganjga7lh6bnkIbjgpLlp5TorbLjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNyZWF0ZUl0ZW1Db250ZW50XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYEhUTUxFbGVtZW50YC5cbiAgICpcbiAgICogICAgIFRvIGhlbHAgcmVuZGVyaW5nIHRoZSBlbGVtZW50LCB0aGUgY3VycmVudCBpbmRleCBhbmQgYSB0ZW1wbGF0ZSBpcyBzdXBwbGllZCBhcyBhcmd1bWVudHMuIFRoZSB0ZW1wbGF0ZSBpcyB0aGUgaW5pdGlhbCBjb250ZW50IG9mIHRoZSBgPG9ucy1sYXp5LXJlcGVhdD5gIGVsZW1lbnQuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgZPjga7plqLmlbDjga9gSFRNTEVsZW1lbnRg44KS6L+U44GX44Gm44GP44Gg44GV44GE44CCXG4gICAqICAgICDopoHntKDjgpLnlJ/miJDjgZfjgoTjgZnjgY/jgZnjgovjgZ/jgoHjgavjgIHnj77lnKjjga7jgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgajjg4bjg7Pjg5fjg6zjg7zjg4jjgYzlvJXmlbDjgavmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOBk+OBruODhuODs+ODl+ODrOODvOODiOOBr+OAgWA8b25zLWxhenktcmVwZWF0PmDopoHntKDjga7jgrPjg7Pjg4bjg7Pjg4TjgYzmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNvdW50SXRlbXNcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdWxkIHJldHVybiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0LlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOWGheOBruOCouOCpOODhuODoOaVsOOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFNob3VsZCByZXR1cm4gdGhlIGhlaWdodCBvZiBhbiBpdGVtLiBUaGUgaW5kZXggaXMgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQuXG4gICAqXG4gICAqICAgICBUaGlzIGlzIGltcG9ydGFudCB3aGVuIHJlbmRlcmluZyBsaXN0cyB3aGVyZSB0aGUgaXRlbXMgaGF2ZSBkaWZmZXJlbnQgaGVpZ2h0LlxuICAgKlxuICAgKiAgICAgVGhlIGZ1bmN0aW9uIGlzIG9wdGlvbmFsIGFuZCBpZiBpdCBpc24ndCBwcmVzZW50IHRoZSBoZWlnaHQgb2YgdGhlIGZpcnN0IGl0ZW0gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgYW5kIHVzZWQgZm9yIGFsbCBvdGhlciBpdGVtcy5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOCouOCpOODhuODoOOBrumrmOOBlSjjg5Tjgq/jgrvjg6sp44KS6L+U44GX44Gm44GP44Gg44GV44GE44CC44Ki44Kk44OG44Og44Gu44Kk44Oz44OH44OD44Kv44K55YCk44Gv5byV5pWw44Gn5rih44GV44KM44G+44GZ44CCXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgIHjgZ3jgozjgZ7jgozjga7jgqLjgqTjg6DjgYzpgZXjgaPjgZ/pq5jjgZXjgpLmjIHjgaTjg6rjgrnjg4jjgpLjg6zjg7Pjg4Djg6rjg7PjgrDjgZnjgovpmpvjgavph43opoHjgafjgZnjgIJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OCquODl+OCt+ODp+ODiuODq+OBp+OBmeOAguOCguOBl+OBk+OBrumWouaVsOOBjOeEoeOBhOWgtOWQiOOBq+OBr+OAgVxuICAgKiAgICAg5pyA5Yid44Gu44Ki44Kk44OG44Og44Gu6auY44GV44GM5LuW44Gu44GZ44G544Gm44Gu44Ki44Kk44OG44Og44Gu6auY44GV44Go44GX44Gm5Yip55So44GV44KM44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5kZXN0cm95SXRlbVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBjYWxsZWQgd2hlbiBhbiBpdGVtIGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLiBUaGUgaW5kZXggYW5kIERPTSBlbGVtZW50IGlzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cy5cbiAgICpcbiAgICogICAgIFRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbCBidXQgbWF5IGJlIGltcG9ydGFudCBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgbGVha3MuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgIHjgYLjgovjgqLjgqTjg4bjg6DjgYxET03jg4Tjg6rjg7zjgYvjgonpmaTjgYvjgozjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueWApOOBqERPTeimgee0oOOBjOW8leaVsOOBqOOBl+OBpua4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44Kq44OX44K344On44OK44Or44Gn44GZ44GM44CB5ZCE44Ki44Kk44OG44Og44Gu5b6M5Yem55CG44GM5b+F6KaB44Gq5aC05ZCI44Gr44Gv44Oh44Oi44Oq44O844Oq44O844Kv44KS6YG/44GR44KL44Gf44KB44Gr6YeN6KaB44Gn44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgc2V0IGRlbGVnYXRlKHVzZXJEZWxlZ2F0ZSkge1xuICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciAmJiB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIuZGVzdHJveSgpO1xuXG4gICAgaWYgKCF0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgJiYgdGhpcy5jaGlsZHJlblswXSkge1xuICAgICAgdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmNoaWxkcmVuWzBdKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWxlZ2F0ZSA9IG5ldyBMYXp5UmVwZWF0RGVsZWdhdGUodXNlckRlbGVnYXRlLCB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgfHwgbnVsbCk7XG4gICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyID0gbmV3IExhenlSZXBlYXRQcm92aWRlcih0aGlzLnBhcmVudEVsZW1lbnQsIGRlbGVnYXRlKTtcbiAgfVxuXG4gIGdldCBkZWxlZ2F0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgcHJvcGVydHkgY2FuIG9ubHkgYmUgdXNlZCB0byBzZXQgdGhlIGRlbGVnYXRlIG9iamVjdC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlZnJlc2hcbiAgICogQHNpZ25hdHVyZSByZWZyZXNoKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJlZnJlc2ggdGhlIGxpc3QuIFVzZSB0aGlzIG1ldGhvZCB3aGVuIHRoZSBkYXRhIGhhcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOOCkuabtOaWsOOBl+OBvuOBmeOAguOCguOBl+ODh+ODvOOCv+OBjOWkieOCj+OBo+OBn+WgtOWQiOOBq+OBr+OBk+OBruODoeOCveODg+ODieOCkuS9v+OBo+OBpuOBj+OBoOOBleOBhOOAglsvamFdXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciAmJiB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIucmVmcmVzaCgpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHt9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyKSB7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxufVxuXG53aW5kb3cuT25zTGF6eVJlcGVhdEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1sYXp5LXJlcGVhdCcsIHtcbiAgcHJvdG90eXBlOiBMYXp5UmVwZWF0RWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0X19oZWFkZXItLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdC1oZWFkZXJcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUhlYWRlciBlbGVtZW50IGZvciBsaXN0IGl0ZW1zLiBNdXN0IGJlIHB1dCBpbnNpZGUgdGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXeODquOCueODiOimgee0oOOBq+S9v+eUqOOBmeOCi+ODmOODg+ODgOODvOeUqOOCs+ODs+ODneODvOODjeODs+ODiOOAgm9ucy1saXN044Go5YWx44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdD5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1pdGVtXG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdC1pdGVtPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGd1aWRlIFVzaW5nTGlzdCBbZW5dVXNpbmcgbGlzdHNbL2VuXVtqYV3jg6rjgrnjg4jjgpLkvb/jgYZbL2phXVxuICogQGNvZGVwZW4geXhjQ3RcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9saXN0XG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gbGlzdCBoZWFkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0PlxuICogICA8b25zLWxpc3QtaGVhZGVyPkhlYWRlciBUZXh0PC9vbnMtbGlzdC1oZWFkZXI+XG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gKiA8L29ucy1saXN0PlxuICovXG5jbGFzcyBMaXN0SGVhZGVyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaGVhZGVyLlsvZW5dXG4gICAqICAgW2phXeODmOODg+ODgOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdF9faGVhZGVyJyk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk9uc0xpc3RIZWFkZXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtbGlzdC1oZWFkZXInLCB7XG4gIHByb3RvdHlwZTogTGlzdEhlYWRlckVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG4gQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgICAnLmxpc3RfX2l0ZW0nOiAnbGlzdF9faXRlbS0tKicsXG4gICAgJy5saXN0X19pdGVtX19sZWZ0JzogJ2xpc3RfX2l0ZW0tLSpfX2xlZnQnLFxuICAgICcubGlzdF9faXRlbV9fY2VudGVyJzogJ2xpc3RfX2l0ZW0tLSpfX2NlbnRlcicsXG4gICAgJy5saXN0X19pdGVtX19yaWdodCc6ICdsaXN0X19pdGVtLS0qX19yaWdodCcsXG4gICAgJy5saXN0X19pdGVtX19sYWJlbCc6ICdsaXN0X19pdGVtLS0qX19sYWJlbCcsXG4gICAgJy5saXN0X19pdGVtX190aXRsZSc6ICdsaXN0X19pdGVtLS0qX190aXRsZScsXG4gICAgJy5saXN0X19pdGVtX19zdWJ0aXRsZSc6ICdsaXN0X19pdGVtLS0qX19zdWJ0aXRsZScsXG4gICAgJy5saXN0X19pdGVtX190aHVtYm5haWwnOiAnbGlzdF9faXRlbS0tKl9fdGh1bWJuYWlsJyxcbiAgICAnLmxpc3RfX2l0ZW1fX2ljb24nOiAnbGlzdF9faXRlbS0tKl9faWNvbidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3QtaXRlbVxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBtb2RpZmllciB0YXBwYWJsZVxuICogICBbZW5dTWFrZSB0aGUgbGlzdCBpdGVtIGNoYW5nZSBhcHBlYXJhbmNlIHdoZW4gaXQncyB0YXBwZWQuIE9uIGlPUyBpdCBpcyBiZXR0ZXIgdG8gdXNlIHRoZSBcInRhcHBhYmxlXCIgYW5kIFwidGFwLWJhY2tncm91bmQtY29sb3JcIiBhdHRyaWJ1dGUgZm9yIGJldHRlciBiZWhhdmlvciB3aGVuIHNjcm9sbGluZy5bL2VuXVxuICogICBbamFd44K/44OD44OX44KE44Kv44Oq44OD44Kv44GX44Gf5pmC44Gr5Yq55p6c44GM6KGo56S644GV44KM44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBjaGV2cm9uXG4gKiAgIFtlbl1EaXNwbGF5IGEgY2hldnJvbiBhdCB0aGUgcmlnaHQgZW5kIG9mIHRoZSBsaXN0IGl0ZW0gYW5kIG1ha2UgaXQgY2hhbmdlIGFwcGVhcmFuY2Ugd2hlbiB0YXBwZWQuIFRoZSBjaGV2cm9uIGlzIG5vdCBkaXNwbGF5ZWQgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIGxvbmdkaXZpZGVyXG4gKiAgIFtlbl1EaXNwbGF5cyBhIGxvbmcgaG9yaXpvbnRhbCBkaXZpZGVyIGJldHdlZW4gaXRlbXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbm9kaXZpZGVyXG4gKiAgIFtlbl1SZW1vdmVzIHRoZSBkaXZpZGVyIGJldHdlZW4gbGlzdCBpdGVtcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGl0ZW0uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgZWFjaCBpdGVtIGluIHRoZSBsaXN0LiBNdXN0IGJlIHB1dCBpbnNpZGUgdGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnQuXG4gKlxuICogICAgIFRoZSBsaXN0IGl0ZW0gaXMgY29tcG9zZWQgb2YgdGhyZWUgcGFydHMgdGhhdCBhcmUgcmVwcmVzZW50ZWQgd2l0aCB0aGUgYGxlZnRgLCBgY2VudGVyYCBhbmQgYHJpZ2h0YCBjbGFzc2VzLiBUaGVzZSBjbGFzc2VzIGNhbiBiZSB1c2VkIHRvIGVuc3VyZSB0aGF0IHRoZSBjb250ZW50IG9mIHRoZSBsaXN0IGl0ZW1zIGlzIHByb3Blcmx5IGFsaWduZWQuXG4gKlxuICogICAgIGBgYFxuICogICAgIDxvbnMtbGlzdC1pdGVtPlxuICogICAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5MZWZ0PC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+Q2VudGVyPC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5SaWdodDwvZGl2PlxuICogICAgIDwvb25zLWxpc3QtaXRlbT5cbiAqICAgICBgYGBcbiAqXG4gKiAgICAgVGhlcmUgaXMgYWxzbyBhIG51bWJlciBvZiBjbGFzc2VzIChwcmVmaXhlZCB3aXRoIGBsaXN0X19pdGVtX18qYCkgdGhhdCBoZWxwIHdoZW4gcHV0dGluZyB0aGluZ3MgbGlrZSBpY29ucyBhbmQgdGh1bWJuYWlscyBpbnRvIHRoZSBsaXN0IGl0ZW1zLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1vbnMtbGlzdCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaGVhZGVyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgVXNpbmdMaXN0XG4gKiAgIFtlbl1Vc2luZyBsaXN0c1svZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjgpLkvb/jgYZbL2phXVxuICogQGNvZGVwZW4geXhjQ3RcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9saXN0XG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0LWl0ZW0+XG4gKiAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgPG9ucy1pY29uIGljb249XCJtZC1mYWNlXCIgY2xhc3M9XCJsaXN0X19pdGVtX19pY29uXCI+PC9vbnMtaWNvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGlzdF9faXRlbV9fdGl0bGVcIj5UaXRsZTwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJsaXN0X19pdGVtX19zdWJ0aXRsZVwiPlN1YnRpdGxlPC9kaXY+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cbiAqICAgICA8b25zLXN3aXRjaD48L29ucy1zd2l0Y2g+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtbGlzdC1pdGVtPlxuICovXG5jbGFzcyBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgICAvKipcbiAgICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdCBpdGVtLlsvZW5dXG4gICAgICogICBbamFd5ZCE6KaB57Sg44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBhdHRyaWJ1dGUgbG9jay1vbi1kcmFnXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1QcmV2ZW50IHZlcnRpY2FsIHNjcm9sbGluZyB3aGVuIHRoZSB1c2VyIGRyYWdzIGhvcml6b250YWxseS5bL2VuXVxuICAgICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODpuODvOOCtuODvOOBjOOBk+OBruimgee0oOOCkuaoquaWueWQkeOBq+ODieODqeODg+OCsOOBl+OBpuOBhOOCi+aZguOBq+OAgee4puaWueWQkeOBruOCueOCr+ODreODvOODq+OBjOi1t+OBjeOBquOBhOOCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYXR0cmlidXRlIHRhcHBhYmxlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dTWFrZXMgdGhlIGVsZW1lbnQgcmVhY3QgdG8gdGFwcy5bL2VuXVxuICAgICAqICAgW2phXVsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYXR0cmlidXRlIHRhcC1iYWNrZ3JvdW5kLWNvbG9yXG4gICAgICogQHR5cGUge0NvbG9yfVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXSBDaGFuZ2VzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHdoZW4gdGFwcGVkLiBGb3IgdGhpcyB0byB3b3JrLCB0aGUgYXR0cmlidXRlIFwidGFwcGFibGVcIiBuZWVkcyB0byBiZSBzZXQuIFRoZSBkZWZhdWx0IGNvbG9yIGlzIFwiI2Q5ZDlkOVwiLiBJdCB3aWxsIGRpc3BsYXkgYXMgYSByaXBwbGUgZWZmZWN0IG9uIEFuZHJvaWQuWy9lbl1cbiAgICAgKiAgIFtqYV1bL2phXVxuICAgICAqL1xuXG4gICAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfY29tcGlsZSgpIHtcbiAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdF9faXRlbScpO1xuXG4gICAgICAgIGxldCBsZWZ0LCBjZW50ZXIsIHJpZ2h0O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdsZWZ0JykpIHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0X19pdGVtX19sZWZ0Jyk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgICAgICAgICAgIGNlbnRlciA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdyaWdodCcpKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbGlzdF9faXRlbV9fcmlnaHQnKTtcbiAgICAgICAgICAgICAgICByaWdodCA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjZW50ZXIpIHtcbiAgICAgICAgICAgIGNlbnRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICBpZiAoIWxlZnQgJiYgIXJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXIuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbCAhPT0gbGVmdCAmJiBlbCAhPT0gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlci5pbnNlcnRCZWZvcmUoZWwsIGNlbnRlci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoY2VudGVyLCByaWdodCB8fCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdjZW50ZXInKTtcbiAgICAgICAgY2VudGVyLmNsYXNzTGlzdC5hZGQoJ2xpc3RfX2l0ZW1fX2NlbnRlcicpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblRvdWNoKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICAvLyBpZiAodXRpbC5tYXRjaCh0aGlzLCAnLmxpc3RfX2l0ZW0tLWV4cGFuZCcpKSB7ICAvLyDngrnlh7vlsZXlvIBcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICAgICAgLy8gfVxuICAgICAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICAgIHRoaXMudGFwcGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaCk7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Ub3VjaCk7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB9XG5cbiAgICBnZXQgX3RyYW5zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiAnYmFja2dyb3VuZC1jb2xvciAwLjBzIGxpbmVhciAwLjAycywgYm94LXNoYWRvdyAwLjBzIGxpbmVhciAwLjAycyc7XG4gICAgfVxuXG4gICAgZ2V0IF90YXBwYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCd0YXBwYWJsZScpO1xuICAgIH1cblxuICAgIGdldCBfdGFwQmFja2dyb3VuZENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhcC1iYWNrZ3JvdW5kLWNvbG9yJykgfHwgJyNkOWQ5ZDknO1xuICAgIH1cblxuICAgIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICAgIH1cblxuICAgIF9vbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQubm9kZU5hbWUgPT0gJ09OUy1MSVNUJyAmJiB1dGlsLmhhc0NsYXNzKCdsaXN0LS1zdWJMaXN0JykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZXhwYW5kJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnZXhwYW5kJyk7XG4gICAgICAgICAgICAgICAgbmV4dC5yZW1vdmVBdHRyaWJ1dGUoJ2V4cGFuZCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZXhwYW5kJywgJycpO1xuICAgICAgICAgICAgICAgIG5leHQuc2V0QXR0cmlidXRlKCdleHBhbmQnLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfb25EcmFnKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGdlc3R1cmUgPSBldmVudC5nZXN0dXJlO1xuICAgICAgICAvLyBQcmV2ZW50IHZlcnRpY2FsIHNjcm9sbGluZyBpZiB0aGUgdXNlcnMgcGFucyBsZWZ0IG9yIHJpZ2h0LlxuICAgICAgICBpZiAodGhpcy5fc2hvdWxkTG9ja09uRHJhZygpICYmIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZ2VzdHVyZS5kaXJlY3Rpb24pID4gLTEpIHtcbiAgICAgICAgICAgIGdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9vblRvdWNoKCkge1xuICAgICAgICBpZiAodGhpcy50YXBwZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGFwcGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uO1xuICAgICAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uO1xuICAgICAgICB0aGlzLnN0eWxlLk1velRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLl90YXBwYWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl90YXBCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmJveFNoYWRvdyA9IGAwcHggLTFweCAwcHggMHB4ICR7dGhpcy5fdGFwQmFja2dyb3VuZENvbG9yfWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfb25SZWxlYXNlKCkge1xuICAgICAgICB0aGlzLnRhcHBlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgICAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcbiAgICAgICAgdGhpcy5zdHlsZS5Nb3pUcmFuc2l0aW9uID0gJyc7XG5cbiAgICAgICAgdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciB8fCAnJztcbiAgICAgICAgdGhpcy5zdHlsZS5ib3hTaGFkb3cgPSAnJztcbiAgICB9XG5cbiAgICBfc2hvdWxkTG9ja09uRHJhZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdsb2NrLW9uLWRyYWcnKTtcbiAgICB9XG59XG5cbndpbmRvdy5PbnNMaXN0SXRlbUVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1saXN0LWl0ZW0nLCB7XG4gICAgcHJvdG90eXBlOiBMaXN0SXRlbUVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3Qgc2NoZW1lID0geycnOiAnbGlzdC0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0XG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQG1vZGlmaWVyIGluc2V0XG4gKiAgIFtlbl1JbnNldCBsaXN0IHRoYXQgZG9lc24ndCBjb3ZlciB0aGUgd2hvbGUgd2lkdGggb2YgdGhlIHBhcmVudC5bL2VuXVxuICogICBbamFd6Kaq6KaB57Sg44Gu55S76Z2i44GE44Gj44Gx44GE44Gr5bqD44GM44KJ44Gq44GE44Oq44K544OI44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBub2JvcmRlclxuICogICBbZW5dQSBsaXN0IHdpdGggbm8gYm9yZGVycyBhdCB0aGUgdG9wIGFuZCBib3R0b20uWy9lbl1cbiAqICAgW2phXeODquOCueODiOOBruS4iuS4i+OBruODnOODvOODgOODvOOBjOeEoeOBhOODquOCueODiOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNvbXBvbmVudCB0byBkZWZpbmUgYSBsaXN0LCBhbmQgdGhlIGNvbnRhaW5lciBmb3Igb25zLWxpc3QtaXRlbShzKS5bL2VuXVxuICogICBbamFd44Oq44K544OI44KS6KGo54++44GZ44KL44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44CCb25zLWxpc3QtaXRlbeOBruOCs+ODs+ODhuODiuOBqOOBl+OBpuS9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1pdGVtXG4gKiAgIFtlbl1vbnMtbGlzdC1pdGVtIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWhlYWRlclxuICogICBbZW5db25zLWxpc3QtaGVhZGVyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1oZWFkZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGd1aWRlIFVzaW5nTGlzdFxuICogICBbZW5dVXNpbmcgbGlzdHNbL2VuXVxuICogICBbamFd44Oq44K544OI44KS5L2/44GGWy9qYV1cbiAqIEBjb2RlcGVuIHl4Y0N0XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWhlYWRlcj5IZWFkZXIgVGV4dDwvb25zLWxpc3QtaGVhZGVyPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqL1xuY2xhc3MgTGlzdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0LlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdsaXN0Jyk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk9uc0xpc3RFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtbGlzdCcsIHtcbiAgcHJvdG90eXBlOiBMaXN0RWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJyxcbiAgJy50ZXh0LWlucHV0X19sYWJlbCc6ICd0ZXh0LWlucHV0LS0qX19sYWJlbCcsXG4gICcucmFkaW8tYnV0dG9uJzogJ3JhZGlvLWJ1dHRvbi0tKicsXG4gICcucmFkaW8tYnV0dG9uX19pbnB1dCc6ICdyYWRpby1idXR0b24tLSpfX2lucHV0JyxcbiAgJy5yYWRpby1idXR0b25fX2NoZWNrbWFyayc6ICdyYWRpby1idXR0b24tLSpfX2NoZWNrbWFyaycsXG4gICcuY2hlY2tib3gnOiAnY2hlY2tib3gtLSonLFxuICAnLmNoZWNrYm94X19pbnB1dCc6ICdjaGVja2JveC0tKl9faW5wdXQnLFxuICAnLmNoZWNrYm94X19jaGVja21hcmsnOiAnY2hlY2tib3gtLSpfX2NoZWNrbWFyaydcbn07XG5cbmNvbnN0IElOUFVUX0FUVFJJQlVURVMgPSBbXG4gICdhdXRvY2FwaXRhbGl6ZScsXG4gICdhdXRvY29tcGxldGUnLFxuICAnYXV0b2NvcnJlY3QnLFxuICAnYXV0b2ZvY3VzJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2lucHV0bW9kZScsXG4gICdtYXgnLFxuICAnbWF4bGVuZ3RoJyxcbiAgJ21pbicsXG4gICdtaW5sZW5ndGgnLFxuICAnbmFtZScsXG4gICdwYXR0ZXJuJyxcbiAgJ3BsYWNlaG9sZGVyJyxcbiAgJ3JlYWRvbmx5JyxcbiAgJ3NpemUnLFxuICAnc3RlcCcsXG4gICd0eXBlJyxcbiAgJ3ZhbGlkYXRvcicsXG4gICd2YWx1ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWlucHV0XG4gKiBAY2F0ZWdvcnkgaW5wdXRcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHVuZGVyYmFyXG4gKiAgW2VuXURpc3BsYXlzIGEgaG9yaXpvbnRhbCBsaW5lIHVuZGVybmVhdGggYSB0ZXh0IGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBbiBpbnB1dCBlbGVtZW50LiBUaGUgYHR5cGVgIGF0dHJpYnV0ZSBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIGlucHV0IHR5cGUuIEFsbCB0ZXh0IGlucHV0IHR5cGVzIGFzIHdlbGwgYXMgYGNoZWNrYm94YCBhbmQgYHJhZGlvYCBhcmUgc3VwcG9ydGVkLlxuICpcbiAqICAgIFRoZSBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciBhcyBhIE1hdGVyaWFsIERlc2lnbiBpbnB1dCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKlxuICogICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8aW5wdXQ+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLWlucHV0PmAgZWxlbWVudC5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQGNvZGVwZW4gb2pReExqXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaW5wdXRcbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSBVc2luZ0Zvcm1Db21wb25lbnRzXG4gKiAgIFtlbl1Vc2luZyBmb3JtIGNvbXBvbmVudHNbL2VuXVxuICogICBbamFd44OV44Kp44O844Og44KS5L2/44GGWy9qYV1cbiAqIEBndWlkZSBFdmVudEhhbmRsaW5nXG4gKiAgIFtlbl1FdmVudCBoYW5kbGluZyBkZXNjcmlwdGlvbnNbL2VuXVxuICogICBbamFd44Kk44OZ44Oz44OI5Yem55CG44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWlucHV0IHBsYWNlaG9sZGVyPVwiVXNlcm5hbWVcIiBmbG9hdD48L29ucy1pbnB1dD5cbiAqIDxvbnMtaW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD48L29ucy1pbnB1dD5cbiAqL1xuY2xhc3MgSW5wdXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBsYWNlaG9sZGVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QbGFjZWhvbGRlciB0ZXh0LiBJbiBNYXRlcmlhbCBEZXNpZ24sIHRoaXMgcGxhY2Vob2xkZXIgd2lsbCBiZSBhIGZsb2F0aW5nIGxhYmVsLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZsb2F0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHByZXNlbnQsIHRoZSBwbGFjZWhvbGRlciB3aWxsIGJlIGFuaW1hdGVkIGluIE1hdGVyaWFsIERlc2lnbi5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+aZguOAgeODqeODmeODq+OBr+OCouODi+ODoeODvOOCt+ODp+ODs+OBmeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHR5cGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIFNwZWNpZnkgdGhlIGlucHV0IHR5cGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIFwidHlwZVwiIGF0dHJpYnV0ZSBmb3Igbm9ybWFsIGlucHV0cy4gSG93ZXZlciwgZm9yIFwicmFuZ2VcIiB5b3Ugc2hvdWxkIGluc3RlYWQgdXNlIDxvbnMtcmFuZ2U+IGVsZW1lbnQuXG4gICAqXG4gICAqICAgIFBsZWFzZSB0YWtlIGEgbG9vayBhdCBbTUROXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjYXR0ci10eXBlKSBmb3IgYW4gZXhoYXVzdGl2ZSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcy4gRGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSBhbmQgYnJvd3NlciB2ZXJzaW9uIHNvbWUgb2YgdGhlc2UgbWlnaHQgbm90IHdvcmsuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIFwiaWRcIiBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIDxsYWJlbCBmb3I9XCIuLi5cIj4gZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb250ZW50LWxlZnRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIEhUTUwgY29udGVudCBvZiBgPG9ucy1pbnB1dD5gIGlzIHBsYWNlZCBiZWZvcmUgdGhlIGFjdHVhbCBpbnB1dCBhcyBhIGxhYmVsLiBPbWl0IHRoaXMgdG8gZGlzcGxheSBpdCBhZnRlciB0aGUgaW5wdXQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdjaGVja2VkJywgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9ib3VuZE9uSW5wdXQgPSB0aGlzLl9vbklucHV0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkZvY3VzaW4gPSB0aGlzLl9vbkZvY3VzaW4uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRm9jdXNvdXQgPSB0aGlzLl9vbkZvY3Vzb3V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50ID0gdGhpcy5fZGVsZWdhdGVFdmVudC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoZWxwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgaGVscGVyLmNsYXNzTGlzdC5hZGQoJ19oZWxwZXInKTtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JykpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChoZWxwZXIpO1xuXG4gICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnaW5wdXQtbGFiZWwnKTtcblxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChlbGVtZW50ID0+IGxhYmVsLmFwcGVuZENoaWxkKGVsZW1lbnQpKTtcbiAgICB0aGlzLmhhc0F0dHJpYnV0ZSgnY29udGVudC1sZWZ0JykgPyBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGxhYmVsLCBjb250YWluZXIuZmlyc3RDaGlsZCkgOiBjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgc3dpdGNoICh0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpKSB7XG4gICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnY2hlY2tib3gnKTtcbiAgICAgICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZCgnY2hlY2tib3hfX2lucHV0Jyk7XG4gICAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QuYWRkKCdjaGVja2JveF9fY2hlY2ttYXJrJyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbicpO1xuICAgICAgICB0aGlzLl9pbnB1dC5jbGFzc0xpc3QuYWRkKCdyYWRpby1idXR0b25fX2lucHV0Jyk7XG4gICAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QuYWRkKCdyYWRpby1idXR0b25fX2NoZWNrbWFyaycpO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXQnKTtcbiAgICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXRfX2xhYmVsJyk7XG4gICAgICAgIHRoaXMuX2lucHV0LnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dF9fY29udGFpbmVyJyk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWwoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxDb2xvcigpO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2lucHV0LWlkJykpIHtcbiAgICAgIHRoaXMuX2lucHV0LmlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lucHV0LWlkJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncGxhY2Vob2xkZXInKSB7XG4gICAgICByZXR1cm4gY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZUxhYmVsKCkpO1xuICAgIH0gaWYgKG5hbWUgPT09ICdpbnB1dC1pZCcpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9pbnB1dC5pZCA9IGN1cnJlbnQpO1xuICAgIH0gaWYgKG5hbWUgPT09ICdjaGVja2VkJykge1xuICAgICAgdGhpcy5jaGVja2VkID0gY3VycmVudCAhPT0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoSU5QVVRfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgIHJldHVybiBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkpO1xuICAgIH1cbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dC50eXBlICE9PSAnY2hlY2tib3gnICYmIHRoaXMuX2lucHV0LnR5cGUgIT09ICdyYWRpbycpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fYm91bmRPbkZvY3VzaW4pO1xuICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuX2JvdW5kT25Gb2N1c291dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX2JvdW5kT25Gb2N1c2luKTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5fYm91bmRPbkZvY3Vzb3V0KTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgX3NldExhYmVsKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9oZWxwZXIudGV4dENvbnRlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9oZWxwZXIudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9oZWxwZXIuaW5uZXJUZXh0ID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUxhYmVsKCkge1xuICAgIHRoaXMuX3NldExhYmVsKHRoaXMuaGFzQXR0cmlidXRlKCdwbGFjZWhvbGRlcicpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykgOiAnJyk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3VwZGF0ZUxhYmVsQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLl9pbnB1dCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgdGhpcy5faGVscGVyLnN0eWxlLmNvbG9yID0gJyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5faGVscGVyLnN0eWxlLmNvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC41KSc7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUxhYmVsQ2xhc3MoKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1pbnB1dF9fbGFiZWwtLWFjdGl2ZScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChbJ2NoZWNrYm94JywgJ3JhZGlvJ10uaW5kZXhPZih0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpKSA9PT0gLTEpe1xuICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXRfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICB9XG4gIH1cblxuICBfZGVsZWdhdGVFdmVudChldmVudCkge1xuICAgIGNvbnN0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQudHlwZSwge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgX29uSW5wdXQoZXZlbnQpIHtcbiAgICB0aGlzLl91cGRhdGVMYWJlbENsYXNzKCk7XG4gICAgdGhpcy5fdXBkYXRlTGFiZWxDb2xvcigpO1xuICB9XG5cbiAgX29uRm9jdXNpbihldmVudCkge1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcbiAgICB0aGlzLl91cGRhdGVMYWJlbENvbG9yKCk7XG4gIH1cblxuICBfb25Gb2N1c291dChldmVudCkge1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ29sb3IoKTtcbiAgfVxuXG4gIGdldCBfaW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgfVxuXG4gIGdldCBfaGVscGVyKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5faGVscGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQgPT09IG51bGxcbiAgICAgID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcbiAgICAgIDogdGhpcy5faW5wdXQudmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHZhbDtcbiAgICAgIHRoaXMuX29uSW5wdXQoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBpbnB1dCBpcyBjaGVja2VkIG9yIG5vdC4gT25seSB3b3JrcyBmb3IgYHJhZGlvYCBhbmQgYGNoZWNrYm94YCB0eXBlIGlucHV0cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LmNoZWNrZWQ7XG4gIH1cblxuICBzZXQgY2hlY2tlZCh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQuY2hlY2tlZCA9IHZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBpbnB1dCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgZ2V0IF9pc1RleHRJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlICE9PSAncmFkaW8nICYmIHRoaXMudHlwZSAhPT0gJ2NoZWNrYm94JztcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICB9XG59XG5cbndpbmRvdy5PbnNJbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1pbnB1dCcsIHtcbiAgcHJvdG90eXBlOiBJbnB1dEVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSAwLjI7XG5cbiAgICB0aGlzLnRpbWluZyA9IG9wdGlvbnMudGltaW5nIHx8IHRoaXMudGltaW5nO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogdGhpcy5kdXJhdGlvbjtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWxheSA6IHRoaXMuZGVsYXk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBNb2RhbEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWRlTW9kYWxBbmltYXRvciBleHRlbmRzIE1vZGFsQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnRpbWluZyA9IG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICAgIG9wdGlvbnMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8ICcwLjMnO1xuICAgIG9wdGlvbnMuZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICB9KVxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBGYWRlTW9kYWxBbmltYXRvciBmcm9tICcuL2ZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBEb29yTG9jayBmcm9tICdvbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdtb2RhbC0tKicsXG4gICdtb2RhbF9fY29udGVudCc6ICdtb2RhbC0tKl9fY29udGVudCdcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogTW9kYWxBbmltYXRvcixcbiAgJ2ZhZGUnOiBGYWRlTW9kYWxBbmltYXRvcixcbiAgJ25vbmUnOiBNb2RhbEFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1tb2RhbFxuICogQGNhdGVnb3J5IG1vZGFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIE1vZGFsIGNvbXBvbmVudCB0aGF0IG1hc2tzIGN1cnJlbnQgc2NyZWVuLiBVbmRlcmx5aW5nIGNvbXBvbmVudHMgYXJlIG5vdCBzdWJqZWN0IHRvIGFueSBldmVudHMgd2hpbGUgdGhlIG1vZGFsIGNvbXBvbmVudCBpcyBzaG93bi5cbiAqXG4gKiAgICAgVGhpcyBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gYmxvY2sgdXNlciBpbnB1dCB3aGlsZSBzb21lIG9wZXJhdGlvbiBpcyBydW5uaW5nIG9yIHRvIHNob3cgc29tZSBpbmZvcm1hdGlvbiB0byB0aGUgdXNlci5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOeUu+mdouWFqOS9k+OCkuODnuOCueOCr+OBmeOCi+ODouODvOODgOODq+eUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguS4i+WBtOOBq+OBguOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBr+OAgVxuICogICAgIOODouODvOODgOODq+OBjOihqOekuuOBleOCjOOBpuOBhOOCi+mWk+OBr+OCpOODmeODs+ODiOmAmuefpeOBjOihjOOCj+OCjOOBvuOBm+OCk+OAglxuICogICBbL2phXVxuICogQGd1aWRlIFVzaW5nTW9kYWxcbiAqICAgW2VuXVVzaW5nIG9ucy1tb2RhbCBjb21wb25lbnRbL2VuXVxuICogICBbamFd44Oi44O844OA44Or44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBndWlkZSBDYWxsaW5nQ29tcG9uZW50QVBJc2Zyb21KYXZhU2NyaXB0XG4gKiAgIFtlbl1Vc2luZyBuYXZpZ2F0b3IgZnJvbSBKYXZhU2NyaXB0Wy9lbl1cbiAqICAgW2phXUphdmFTY3JpcHTjgYvjgonjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLlkbzjgbPlh7rjgZlbL2phXVxuICogQHNlZWFsc28gb25zLWRpYWxvZ1xuICogICBbZW5dVGhlIGA8b25zLWRpYWxvZz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBtb2RhbCBkaWFsb2cuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBkZXZJZ1xuICogQGV4YW1wbGVcbiAqIDxvbnMtbW9kYWwgaWQ9XCJtb2RhbFwiPlxuICogICBNb2RhbCBjb250ZW50XG4gKiA8L29ucy1tb2RhbD5cbiAqIDxzY3JpcHQ+XG4gKiAgIHZhciBtb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2RhbCcpO1xuICogICBtb2RhbC5zaG93KCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuY2xhc3MgTW9kYWxFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgbW9kYWwuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCBvciBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICBbamFd44Oi44O844OA44Or44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCLjgoLjgZfjgY/jga9cImZhZGVcIuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IE1vZGFsQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTW9kYWxBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihoYW5kbGVyKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGhhbmRsZXIpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbW9kYWwnKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5tb2RhbF9fY29udGVudCcpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ21vZGFsX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgY29udGVudC5pbnNlcnRCZWZvcmUobm9kZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHNldEltbWVkaWF0ZSh0aGlzLl9lbnN1cmVOb2RlUG9zaXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIH1cblxuICBfZW5zdXJlTm9kZVBvc2l0aW9uKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnROb2RlIHx8IHRoaXMuaGFzQXR0cmlidXRlKCdpbmxpbmUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1wYWdlJykge1xuICAgICAgdmFyIHBhZ2UgPSB0aGlzO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBwYWdlID0gcGFnZS5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYWdlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtcGFnZScpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFnZS5fcmVnaXN0ZXJFeHRyYUVsZW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgbW9kYWwuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIGNvbnN0IHRyeVNob3cgPSAoKSA9PiB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlJztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgYW5pbWF0b3Iuc2hvdyh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlTaG93KCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgbW9kYWwgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjga7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2hvdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgbW9kYWwuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGhpZGUob3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIGNvbnN0IHRyeUhpZGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBhbmltYXRvci5oaWRlKHRoaXMsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlIaWRlKCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk9uc01vZGFsRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLW1vZGFsJywge1xuICBwcm90b3R5cGU6IE1vZGFsRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICovXG53aW5kb3cuT25zTW9kYWxFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xuICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RhbEFuaW1hdG9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNNb2RhbEVsZW1lbnQuTW9kYWxBbmltYXRvcicpO1xuICB9XG4gIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbn07XG5cbndpbmRvdy5PbnNNb2RhbEVsZW1lbnQuTW9kYWxBbmltYXRvciA9IE1vZGFsQW5pbWF0b3I7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICBkdXJhdGlvbjogJzAuNCcsXG4gICAgICBkZWxheTogJzAnXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLnRpbWluZyA9IG9wdGlvbnMudGltaW5nO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICB9XG5cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24gbGlrZSBpT1MncyBzY3JlZW4gc2xpZGUgdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsXG4gICAgICBkZWxheTogMFxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyBvcGFjaXR5OiAwOyB6LWluZGV4OiAyXCI+PC9kaXY+XG4gICAgYCk7XG4gIH1cblxuICBfZGVjb21wb3NlKHBhZ2UpIHtcbiAgICBDdXN0b21FbGVtZW50cy51cGdyYWRlKHBhZ2UpO1xuICAgIGNvbnN0IHRvb2xiYXIgPSBwYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpO1xuICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUodG9vbGJhcik7XG4gICAgY29uc3QgbGVmdCA9IHRvb2xiYXIuX2dldFRvb2xiYXJMZWZ0SXRlbXNFbGVtZW50KCk7XG4gICAgY29uc3QgcmlnaHQgPSB0b29sYmFyLl9nZXRUb29sYmFyUmlnaHRJdGVtc0VsZW1lbnQoKTtcblxuICAgIGNvbnN0IGV4Y2x1ZGVCYWNrQnV0dG9uTGFiZWwgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtYmFjay1idXR0b24nKSB7XG4gICAgICAgICAgY29uc3QgaWNvbkVsZW1lbnQgPSBlbGVtZW50c1tpXS5xdWVyeVNlbGVjdG9yKCcuYmFjay1idXR0b25fX2ljb24nKTtcbiAgICAgICAgICBpZiAoaWNvbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGljb25FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGNvbnN0IG90aGVyID0gW11cbiAgICAgIC5jb25jYXQobGVmdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBsZWZ0IDogZXhjbHVkZUJhY2tCdXR0b25MYWJlbChsZWZ0LmNoaWxkcmVuKSlcbiAgICAgIC5jb25jYXQocmlnaHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gcmlnaHQgOiBleGNsdWRlQmFja0J1dHRvbkxhYmVsKHJpZ2h0LmNoaWxkcmVuKSk7XG5cbiAgICBjb25zdCBwYWdlTGFiZWxzID0gW1xuICAgICAgdG9vbGJhci5fZ2V0VG9vbGJhckNlbnRlckl0ZW1zRWxlbWVudCgpLFxuICAgICAgdG9vbGJhci5fZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQoKVxuICAgIF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnZUxhYmVsczogcGFnZUxhYmVscyxcbiAgICAgIG90aGVyOiBvdGhlcixcbiAgICAgIGNvbnRlbnQ6IHBhZ2UuX2dldENvbnRlbnRFbGVtZW50KCksXG4gICAgICBiYWNrZ3JvdW5kOiBwYWdlLl9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpLFxuICAgICAgdG9vbGJhcjogdG9vbGJhcixcbiAgICAgIGJvdHRvbVRvb2xiYXI6IHBhZ2UuX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50KClcbiAgICB9O1xuICB9XG5cbiAgX3Nob3VsZEFuaW1hdGVUb29sYmFyKGVudGVyUGFnZSwgbGVhdmVQYWdlKSB7XG4gICAgY29uc3QgYm90aFBhZ2VIYXNUb29sYmFyID1cbiAgICAgIGVudGVyUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKSAmJiBsZWF2ZVBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCk7XG5cbiAgICB2YXIgbm9NYXRlcmlhbFRvb2xiYXIgPVxuICAgICAgIWVudGVyUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMoJ25hdmlnYXRpb24tYmFyLS1tYXRlcmlhbCcpICYmXG4gICAgICAhbGVhdmVQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucygnbmF2aWdhdGlvbi1iYXItLW1hdGVyaWFsJyk7XG5cbiAgICByZXR1cm4gYm90aFBhZ2VIYXNUb29sYmFyICYmIG5vTWF0ZXJpYWxUb29sYmFyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgZW50ZXJQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShlbnRlclBhZ2UpO1xuICAgIGNvbnN0IGxlYXZlUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UobGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IGRlbHRhID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBsZWF2ZVBhZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMikgKiAwLjYpO1xuICAgIH0pKCk7XG5cbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDAuMVxuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgLnF1ZXVlKChkb25lKSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG5cbiAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgbWFza0NsZWFyLFxuXG4gICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnBhZ2VMYWJlbHMpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgZGVsdGEgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnBhZ2VMYWJlbHMpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLScgKyBkZWx0YSArICdweCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAxfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAwfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG5cbiAgICAgICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBkb25lKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgIGNvbnN0IGVudGVyUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UoZW50ZXJQYWdlKTtcbiAgICBjb25zdCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCBkZWx0YSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBsZWF2ZVBhZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMikgKiAwLjYpO1xuICAgIH0pKCk7XG5cbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMC4xLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgIH0pXG4gICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgLnF1ZXVlKChkb25lKSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG5cbiAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgbWFza0NsZWFyLFxuXG4gICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ucGFnZUxhYmVscylcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ub3RoZXIpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDF9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KFtsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQoMClcbiAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZmluaXNoKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpKSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknLFxuICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5wYWdlTGFiZWxzKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBkZWx0YSArICdweCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZShmdW5jdGlvbihmaW5pc2gpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuLyoqXG4gKiBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLFxuICAgICAgZGVsYXk6IDBcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoYmxhY2ssIHdoaXRlKTtcIj48L2Rpdj5cbiAgICBgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgbWFza0NsZWFyLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIC0xMCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgLTEwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMTAwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG5cbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuXG4vKipcbiAqIEZhZGUtaW4gc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgIGR1cmF0aW9uOiAnMC40JyxcbiAgICAgIGRlbGF5OiAnMCdcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KFtlbnRlclBhZ2UuX2dldENvbnRlbnRFbGVtZW50KCksIGVudGVyUGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKV0pXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChbbGVhdmVQYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBsZWF2ZVBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCldKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsXG4gICAgICBkZWxheTogMFxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDI7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyBvcGFjaXR5OiAwO1wiPjwvZGl2PlxuICAgIGApO1xuICAgIHRoaXMuYmxhY2tNYXNrT3BhY2l0eSA9IDAuNDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IHRoaXMuYmxhY2tNYXNrT3BhY2l0eVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTQ1JSwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLndhaXQoMC4yKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZG9uZSkge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5ibGFja01hc2tPcGFjaXR5LFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTQ1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KDAuMilcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGZpbmlzaCkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuXG4vKipcbiAqIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyxcbiAgICAgIGRlbGF5OiAwLjA1XG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XCI+PC9kaXY+XG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uKVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIG1hc2tDbGVhcixcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbilcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5cbi8qKlxuICogRmFkZS1pbiArIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICB0aW1pbmc6ICdlYXNlLW91dCcsXG4gICAgICBkdXJhdGlvbjogJzAuMjUnLFxuICAgICAgZGVsYXk6ICcwJ1xuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDQycHgsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KDAuMTUpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAzOHB4LCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCgwLjA0KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vbmVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vaW9zLXNsaWRlLWFuaW1hdG9yJztcbmltcG9ydCBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vaW9zLWxpZnQtYW5pbWF0b3InO1xuaW1wb3J0IElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9pb3MtZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL21kLXNsaWRlLWFuaW1hdG9yJztcbmltcG9ydCBNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9tZC1saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9tZC1mYWRlLWFuaW1hdG9yJztcbmltcG9ydCBOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbm9uZS1hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdzbGlkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnbGlmdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2ZhZGUnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdzbGlkZS1pb3MnOiBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ3NsaWRlLW1kJzogTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2xpZnQtaW9zJzogSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2xpZnQtbWQnOiBNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdmYWRlLWlvcyc6IElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnbm9uZSc6IE5vbmVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Jcbn07XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuYXZpZ2F0b3JTaWRlRWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkobmF2aWdhdG9yRWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5hdmlnYXRvckVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGxpbmsobmF2aWdhdG9yRWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRhcmdldCk7XG4gIH1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLW5hdmlnYXRvclxuICogQGNhdGVnb3J5IG5hdmlnYXRpb25cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQSBjb21wb25lbnQgdGhhdCBwcm92aWRlcyBwYWdlIHN0YWNrIG1hbmFnZW1lbnQgYW5kIG5hdmlnYXRpb24uIFN0YWNrIG5hdmlnYXRpb24gaXMgdGhlIG1vc3QgY29tbW9uIG5hdmlnYXRpb24gcGF0dGVybiBmb3IgbW9iaWxlIGFwcHMuXG4gKlxuICogICAgIFdoZW4gYSBwYWdlIGlzIHB1c2hlZCBvbiB0b3Agb2YgdGhlIHN0YWNrIGl0IGlzIGRpc3BsYXllZCB3aXRoIGEgdHJhbnNpdGlvbiBhbmltYXRpb24uIFdoZW4gdGhlIHVzZXIgcmV0dXJucyB0byB0aGUgcHJldmlvdXMgcGFnZSB0aGUgdG9wIHBhZ2Ugd2lsbCBiZSBwb3BwZWQgZnJvbSB0aGUgdG9wIG9mIHRoZSBzdGFjayBhbmQgaGlkZGVuIHdpdGggYW4gb3Bwb3NpdGUgdHJhbnNpdGlvbiBhbmltYXRpb24uXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geXJodHZcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9uYXZpZ2F0b3JcbiAqIEBndWlkZSBQYWdlTmF2aWdhdGlvblxuICogICBbZW5dR3VpZGUgZm9yIHBhZ2UgbmF2aWdhdGlvblsvZW5dXG4gKiAgIFtqYV3jg5rjg7zjgrjjg4rjg5PjgrLjg7zjgrfjg6fjg7Pjga7mpoLopoFbL2phXVxuICogQGd1aWRlIENhbGxpbmdDb21wb25lbnRBUElzZnJvbUphdmFTY3JpcHRcbiAqICAgW2VuXVVzaW5nIG5hdmlnYXRvciBmcm9tIEphdmFTY3JpcHRbL2VuXVxuICogICBbamFdSmF2YVNjcmlwdOOBi+OCieOCs+ODs+ODneODvOODjeODs+ODiOOCkuWRvOOBs+WHuuOBmVsvamFdXG4gKiBAZ3VpZGUgRXZlbnRIYW5kbGluZ1xuICogICBbZW5dRXZlbnQgaGFuZGxpbmcgZGVzY3JpcHRpb25zWy9lbl1cbiAqICAgW2phXeOCpOODmeODs+ODiOWHpueQhuOBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgRGVmaW5pbmdNdWx0aXBsZVBhZ2VzaW5TaW5nbGVIVE1MXG4gKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5dVGhlIGA8b25zLXRvb2xiYXI+YCBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgdG9vbGJhciBvbiB0aGUgdG9wIG9mIGEgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgY29tcG9uZW50IGxldHMgdGhlIHVzZXIgcmV0dXJuIHRvIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtbmF2aWdhdG9yIGlkPVwibmF2aWdhdG9yXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICA8b25zLXRvb2xiYXI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICAgIFRpdGxlXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICA8L29ucy10b29sYmFyPlxuICogICAgIDxwPlxuICogICAgICAgPG9ucy1idXR0b25cbiAqICAgICAgICAgb25jbGljaz1cImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduYXZpZ2F0b3InKS5wdXNoUGFnZSgncGFnZS5odG1sJylcIj5cbiAqICAgICAgICAgUHVzaCBwYWdlXG4gKiAgICAgICA8L29ucy1idXR0b24+XG4gKiAgICAgPC9wPlxuICogICA8L29ucy1wYWdlPlxuICogPC9vbnMtbmF2aWdhdG9yPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJwYWdlLmh0bWxcIj5cbiAqICAgPG9ucy1wYWdlPlxuICogICAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICAgICAgPC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICAgIEFub3RoZXIgcGFnZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICovXG5jbGFzcyBOYXZpZ2F0b3JFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJzdCBwYWdlIHRvIHNob3cgd2hlbiBuYXZpZ2F0b3IgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAgICogICBbamFd44OK44OT44Ky44O844K/44O844GM5Yid5pyf5YyW44GV44KM44Gf5pmC44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICpcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgIGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0uXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZXB1c2hcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIGEgcGFnZSBpcyBwdXNoZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHB1c2jjgZXjgozjgovnm7TliY3jgavnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmN1cnJlbnRQYWdlXG4gICAqICAgW2VuXUN1cnJlbnQgcGFnZSBvYmplY3QuWy9lbl1cbiAgICogICBbamFd54++5Zyo44GucGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBwdXNoLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgXB1c2jlh6bnkIbjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZXBvcFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgYSBwYWdlIGlzIHBvcHBlZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GMcG9w44GV44KM44KL55u05YmN44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxuICAgKiAgIFtlbl1DdXJyZW50IHBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgcG9wLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgXBhZ2Xjga5wb3DjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RwdXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwdXNoZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHB1c2jjgZXjgozjgabjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzntYLkuobjgZfjgabjgYvjgonnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmVudGVyUGFnZVxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIG5leHQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1wdXNo44GV44KM44GfcGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gICAqICAgW2phXeS7peWJjeOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3Rwb3BcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgYSBwYWdlIGlzIHBvcHBlZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GMcG9w44GV44KM44Gm44Ki44OL44Oh44O844K344On44Oz44GM57WC44KP44Gj44Gf5b6M44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBuZXh0IHBhZ2UuWy9lbl1cbiAgICogICBbamFdcG9w44GV44KM44Gm6KGo56S644GV44KM44KL44Oa44O844K444Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmxlYXZlUGFnZVxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIHByZXZpb3VzIHBhZ2UuWy9lbl1cbiAgICogICBbamFdcG9w44GV44KM44Gm5raI44GI44KL44Oa44O844K444Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IGFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5pbWF0b3JGYWN0b3J5O1xuICB9XG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gdGhpcy5fb25EZXZpY2VCYWNrQnV0dG9uLmJpbmQodGhpcyk7XG5cbiAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ3BhZ2UnKSkge1xuICAgICAgICB0aGlzLnB1c2hQYWdlKHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyksIHthbmltYXRpb246ICdub25lJ30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMucGFnZXNbaV0ubm9kZU5hbWUgIT09ICdPTlMtUEFHRScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNoaWxkcmVuIG9mIDxvbnMtbmF2aWdhdG9yPiBuZWVkIHRvIGJlIG9mIHR5cGUgPG9ucy1wYWdlPicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9wUGFnZS5fc2hvdygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcG9wUGFnZVxuICAgKiBAc2lnbmF0dXJlIHBvcFBhZ2UoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVmcmVzaF1cbiAgICogICBbZW5dVGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSByZWZyZXNoZWQgKGRlc3Ryb3llZCBhbmQgY3JlYXRlZCBhZ2FpbikgYmVmb3JlIHBvcFBhZ2UgYWN0aW9uLlsvZW5dXG4gICAqICAgW2phXXBvcFBhZ2XjgZnjgovliY3jgavjgIHliY3jgavjgYLjgovjg5rjg7zjgrjjgpLnlJ/miJDjgZfjgarjgYrjgZfjgabmm7TmlrDjgZnjgovloLTlkIjjgat0cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHJldmVhbGVkIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5piO44KJ44GL44Gr44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Qb3BzIHRoZSBjdXJyZW50IHBhZ2UgZnJvbSB0aGUgcGFnZSBzdGFjay4gVGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S65Lit44Gu44Oa44O844K444KS44Oa44O844K444K544K/44OD44Kv44GL44KJ5Y+W44KK6Zmk44GN44G+44GZ44CC5LiA44Gk5YmN44Gu44Oa44O844K444Gr5oi744KK44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHBvcFBhZ2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcG9wVXBkYXRlID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXS5fZGVzdHJveSgpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIG9wdGlvbnMgPSB0aGlzLl9wcmVwYXJlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGlmICghb3B0aW9ucy5yZWZyZXNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9wUGFnZShvcHRpb25zLCBwb3BVcGRhdGUpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMjtcblxuICAgIGlmICghdGhpcy5wYWdlc1tpbmRleF0ubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZyZXNoIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIHBhZ2VzIGRpcmVjdGx5IGluc2lkZSB0aGUgTmF2aWdhdG9yLiBVc2Ugb25zLXRlbXBsYXRlIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyh0aGlzLnBhZ2VzW2luZGV4XS5uYW1lKS50aGVuKHRlbXBsYXRlSFRNTCA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmV4dGVuZCh0aGlzLl9jcmVhdGVQYWdlRWxlbWVudCh0ZW1wbGF0ZUhUTUwpLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5wYWdlc1tpbmRleF0ubmFtZSxcbiAgICAgICAgICBkYXRhOiB0aGlzLnBhZ2VzW2luZGV4XS5kYXRhLFxuICAgICAgICAgIHB1c2hlZE9wdGlvbnM6IHRoaXMucGFnZXNbaW5kZXhdLnB1c2hlZE9wdGlvbnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV3cml0YWJsZXMubGluayh0aGlzLCBlbGVtZW50LCB0aGlzLnBhZ2VzW2luZGV4XS5vcHRpb25zLCBlbGVtZW50ID0+IHtcbiAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShlbGVtZW50LCB0aGlzLnBhZ2VzW2luZGV4XSA/IHRoaXMucGFnZXNbaW5kZXhdIDogbnVsbCk7XG4gICAgICAgICAgdGhpcy5wYWdlc1tpbmRleCArIDFdLl9kZXN0cm95KCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKCkgPT4gdGhpcy5fcG9wUGFnZShvcHRpb25zLCBwb3BVcGRhdGUpKTtcbiAgfVxuXG4gIF9wb3BQYWdlKG9wdGlvbnMsIHVwZGF0ZSA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLCBwYWdlcyA9IFtdKSB7XG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwb3BQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdvbnMtbmF2aWdhdG9yXFwncyBwYWdlIHN0YWNrIGlzIGVtcHR5LicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0UHJlUG9wRXZlbnQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwb3AgZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbCA9IHRoaXMucGFnZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMucGFnZXNbbCAtIDJdLnVwZGF0ZUJhY2tCdXR0b24oKGwgLSAyKSA+IDApO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdmFyIGxlYXZlUGFnZSA9IHRoaXMucGFnZXNbbCAtIDFdO1xuICAgICAgdmFyIGVudGVyUGFnZSA9IHRoaXMucGFnZXNbbCAtIDJdO1xuICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IGxlYXZlUGFnZS5wdXNoZWRPcHRpb25zLmFuaW1hdGlvbiB8fCBvcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucy5hbmltYXRpb25PcHRpb25zLCBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30pO1xuXG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgcGFnZXMucG9wKCk7XG4gICAgICAgIHVwZGF0ZShwYWdlcywgdGhpcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBlbnRlclBhZ2UuX3Nob3coKTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3Rwb3AnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZShlbnRlclBhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGxlYXZlUGFnZS5faGlkZSgpO1xuICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG4gICAgICBhbmltYXRvci5wb3AodGhpcy5wYWdlc1tsIC0gMl0sIHRoaXMucGFnZXNbbCAtIDFdLCBjYWxsYmFjayk7XG4gICAgfSkuY2F0Y2goKCkgPT4gdGhpcy5faXNSdW5uaW5nID0gZmFsc2UpO1xuICB9XG5cblxuICAvKipcbiAgICogQG1ldGhvZCBwdXNoUGFnZVxuICAgKiBAc2lnbmF0dXJlIHB1c2hQYWdlKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYWdlXVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhIEhUTUwgZG9jdW1lbnQgb3IgYSB0ZW1wbGF0ZSBkZWZpbmVkIHdpdGggdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFnZV1cbiAgICogICBbZW5dUGFnZSBVUkwuIE9ubHkgbmVjZXNzYXJ5IGlmIGBwYWdlYCBwYXJhbWV0ZXIgaXMgb21pdHRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFnZUhUTUxdXG4gICAqICAgW2VuXUhUTUwgY29kZSB0aGF0IHdpbGwgYmUgY29tcHV0ZWQgYXMgYSBuZXcgcGFnZS4gT3ZlcndyaXRlcyBgcGFnZWAgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICpcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV1wdXNoUGFnZSgp44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtBbnl9IFtvcHRpb25zLmRhdGFdXG4gICAqICAgW2VuXUN1c3RvbSBkYXRhIHRoYXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcHVzaGVkIHBhZ2UuWy9lbl1cbiAgICogICBbamFd6L+95Yqg44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QdXNoZXMgdGhlIHNwZWNpZmllZCBwYWdlIGludG8gdGhlIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn3BhZ2XjgpLmlrDjgZfjgYTjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgavov73liqDjgZfjgb7jgZnjgILmlrDjgZfjgYTjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcHVzaFBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMsIHBhZ2UpO1xuICAgIGNvbnN0IHJ1biA9IHRlbXBsYXRlSFRNTCA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmV4dGVuZCh0aGlzLl9jcmVhdGVQYWdlRWxlbWVudCh0ZW1wbGF0ZUhUTUwpLCB7XG4gICAgICAgIG5hbWU6IG9wdGlvbnMucGFnZSxcbiAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5wYWdlSFRNTCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMsICgpID0+IHJ1bihvcHRpb25zLnBhZ2VIVE1MKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdXNoUGFnZShvcHRpb25zLCAoKSA9PiBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKG9wdGlvbnMucGFnZSkudGhlbihydW4pKTtcbiAgfVxuXG4gIF9wdXNoUGFnZShvcHRpb25zID0ge30sIHVwZGF0ZSA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLCBwYWdlcyA9IFtdLCBwYWdlID0ge30pIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3B1c2hQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZW1pdFByZVB1c2hFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXB1c2ggZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKTtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucyB8fCB7fSwge2FuaW1hdGlvbk9wdGlvbnN9LCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgcGFnZXMucHVzaChwYWdlKTtcblxuICAgIHJldHVybiB1cGRhdGUocGFnZXMsIHRoaXMpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgcGFnZUxlbmd0aCA9IHRoaXMucGFnZXMubGVuZ3RoO1xuXG4gICAgICB2YXIgZW50ZXJQYWdlICA9IHRoaXMucGFnZXNbcGFnZUxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxlYXZlUGFnZSA9IHRoaXMucGFnZXNbcGFnZUxlbmd0aCAtIDJdO1xuXG4gICAgICBpZiAoZW50ZXJQYWdlLm5vZGVOYW1lICE9PSAnT05TLVBBR0UnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBlbGVtZW50cyBvZiB0eXBlIDxvbnMtcGFnZT4gY2FuIGJlIHB1c2hlZCB0byB0aGUgbmF2aWdhdG9yJyk7XG4gICAgICB9XG5cbiAgICAgIGVudGVyUGFnZS51cGRhdGVCYWNrQnV0dG9uKHBhZ2VMZW5ndGggLSAxKTtcblxuICAgICAgZW50ZXJQYWdlLnB1c2hlZE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgZW50ZXJQYWdlLmRhdGEgPSBlbnRlclBhZ2UuZGF0YSB8fCBvcHRpb25zLmRhdGE7XG4gICAgICBlbnRlclBhZ2UubmFtZSA9IGVudGVyUGFnZS5uYW1lIHx8IG9wdGlvbnMucGFnZTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB2YXIgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChsZWF2ZVBhZ2UpIHtcbiAgICAgICAgICAgIGxlYXZlUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVudGVyUGFnZS5fc2hvdygpO1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdHB1c2gnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZShlbnRlclBhZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGVyUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgIHZhciBwdXNoID0gKCkgPT4gIHtcbiAgICAgICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgaWYgKGxlYXZlUGFnZSkge1xuICAgICAgICAgICAgbGVhdmVQYWdlLl9oaWRlKCk7XG4gICAgICAgICAgICBhbmltYXRvci5wdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBkb25lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvcHRpb25zLl9saW5rZWQgPyBwdXNoKCkgOiByZXdyaXRhYmxlcy5saW5rKHRoaXMsIGVudGVyUGFnZSwgb3B0aW9ucywgcHVzaCk7XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZXBsYWNlUGFnZVxuICAgKiBAc2lnbmF0dXJlIHJlcGxhY2VQYWdlKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXBsYWNlcyB0aGUgY3VycmVudCB0b3AgcGFnZSB3aXRoIHRoZSBzcGVjaWZpZWQgb25lLiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuS4reOBruODmuODvOOCuOOCkuOCkuaMh+WumuOBl+OBn+ODmuODvOOCuOOBq+e9ruOBjeaPm+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICByZXBsYWNlUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gdGhpcy5fcHJlcGFyZU9wdGlvbnMob3B0aW9ucywgcGFnZSk7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXG4gICAgb3B0aW9ucy5jYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDJdLl9kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaW5zZXJ0UGFnZVxuICAgKiBAc2lnbmF0dXJlIGluc2VydFBhZ2UoaW5kZXgsIHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB3aGVyZSBpdCBzaG91bGQgYmUgaW5zZXJ0ZWQuWy9lbl1cbiAgICogICBbamFd44K544K/44OD44Kv44Gr5oy/5YWl44GZ44KL5L2N572u44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgaW5zZXJ0ZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUluc2VydCB0aGUgc3BlY2lmaWVkIHBhZ2UgaW50byB0aGUgc3RhY2sgd2l0aCBhdCBhIHBvc2l0aW9uIGRlZmluZWQgYnkgdGhlIGBpbmRleGAgYXJndW1lbnQuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBrmluZGV444Gn5oyH5a6a44GX44Gf5L2N572u44Gr6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGluc2VydFBhZ2UoaW5kZXgsIHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB0aGlzLl9wcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBwYWdlKTtcbiAgICBpbmRleCA9IHRoaXMuX25vcm1hbGl6ZUluZGV4KGluZGV4KTtcblxuICAgIGlmIChpbmRleCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFBhZ2Uob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgcnVuID0gdGVtcGxhdGVIVE1MID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmV4dGVuZCh0aGlzLl9jcmVhdGVQYWdlRWxlbWVudCh0ZW1wbGF0ZUhUTUwpLCB7XG4gICAgICAgIG5hbWU6IG9wdGlvbnMucGFnZSxcbiAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhLFxuICAgICAgICBwdXNoZWRPcHRpb25zOiBvcHRpb25zXG4gICAgICB9KTtcblxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSxcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9XG4gICAgICApO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoZWxlbWVudCwgdGhpcy5wYWdlc1tpbmRleF0pO1xuICAgICAgICB0aGlzLnRvcFBhZ2UudXBkYXRlQmFja0J1dHRvbih0cnVlKTtcblxuICAgICAgICByZXdyaXRhYmxlcy5saW5rKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMsIGVsZW1lbnQgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucGFnZXNbaW5kZXhdKTtcbiAgICAgICAgICB9LCAxMDAwIC8gNjApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5wYWdlSFRNTCkge1xuICAgICAgcmV0dXJuIHJ1bihvcHRpb25zLnBhZ2VIVE1MKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMob3B0aW9ucy5wYWdlKS50aGVuKHJ1bik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVzZXRUb1BhZ2VcbiAgICogQHNpZ25hdHVyZSByZXNldFRvUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg4jjg4Pjg5fjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNsZWFycyBwYWdlIHN0YWNrIGFuZCBhZGRzIHRoZSBzcGVjaWZpZWQgcGFnZSB0byB0aGUgc3RhY2suIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd44Oa44O844K444K544K/44OD44Kv44KS44Oq44K744OD44OI44GX44CB5oyH5a6a44GX44Gf44Oa44O844K444KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlc2V0VG9QYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB0aGlzLl9wcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBwYWdlKTtcblxuICAgIGlmICghb3B0aW9ucy5hbmltYXRvciAmJiAhb3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gJ25vbmUnO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB3aGlsZSAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMucGFnZXNbMF0uX2Rlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWdlc1swXS51cGRhdGVCYWNrQnV0dG9uKGZhbHNlKTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5wYWdlICYmICFvcHRpb25zLnBhZ2VIVE1MICYmIHRoaXMuaGFzQXR0cmlidXRlKCdwYWdlJykpIHtcbiAgICAgIG9wdGlvbnMucGFnZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHVzaFBhZ2Uob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBicmluZ1BhZ2VUb3BcbiAgICogQHNpZ25hdHVyZSBicmluZ1BhZ2VUb3AoaXRlbSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGl0ZW1cbiAgICogICBbZW5dUGFnZSBVUkwgb3IgaW5kZXggb2YgYW4gZXhpc3RpbmcgcGFnZSBpbiBuYXZpZ2F0b3IncyBzdGFjay5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjga5VUkzjgYvjgoLjgZfjgY/jga9vbnMtbmF2aWdhdG9y44Gu44Oa44O844K444K544K/44OD44Kv44Gu44Kk44Oz44OH44OD44Kv44K55YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbmV3IHRvcCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODiOODg+ODl+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQnJpbmdzIHRoZSBnaXZlbiBwYWdlIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc3RhY2sgaWYgaXQgYWxyZWFkeSBleGlzdHMgb3IgcHVzaGVzIGl0IGludG8gdGhlIHN0YWNrIGlmIGRvZXNuJ3QuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Oa44O844K444KS44Oa44O844K444K544K/44OD44Kv44Gu5LiA55Wq5LiK44Gr56e75YuV44GX44G+44GZ44CC44KC44GX5oyH5a6a44GX44Gf44Oa44O844K444GM54Sh44GL44Gj44Gf5aC05ZCI5paw44GX44GPcHVzaOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBicmluZ1BhZ2VUb3AoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKFsnbnVtYmVyJywgJ3N0cmluZyddLmluZGV4T2YodHlwZW9mIGl0ZW0pID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcGFnZSBuYW1lIG9yIHRoZSBpbmRleCBvZiBhbiBleGlzdGluZyBwYWdlLiBZb3Ugc3VwcGxpZWQgJyArIGl0ZW0pO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyA/IHRoaXMuX25vcm1hbGl6ZUluZGV4KGl0ZW0pIDogdGhpcy5fbGFzdEluZGV4T2ZQYWdlKGl0ZW0pO1xuICAgIGNvbnN0IHBhZ2UgPSB0aGlzLnBhZ2VzW2luZGV4XTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zID0gdGhpcy5fcHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMucGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYWdlKTtcbiAgICB9XG4gICAgaWYgKCFwYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGl0ZW0gJyArIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3B1c2hQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQdXNoRXZlbnQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwdXNoIGV2ZW50LicpO1xuICAgIH1cblxuICAgIHV0aWwuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgIHBhZ2U6IHBhZ2UubmFtZSxcbiAgICAgIF9saW5rZWQ6IHRydWVcbiAgICB9KTtcbiAgICBwYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgcGFnZS5zZXRBdHRyaWJ1dGUoJ19za2lwaW5pdCcsICcnKTtcbiAgICBwYWdlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocGFnZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMpO1xuICB9XG5cbiAgX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMgPSB7fSwgcGFnZSkge1xuICAgIGlmICh0eXBlb2YgcGFnZSA9PT0gJ29iamVjdCcgJiYgcGFnZSAhPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHBhZ2U7XG4gICAgICBwYWdlID0gb3B0aW9ucy5wYWdlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICB9XG4gICAgcGFnZSA9IHBhZ2UgfHwgb3B0aW9ucy5wYWdlO1xuXG4gICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMsIHtwYWdlfSk7XG4gIH1cblxuICBfdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnBhZ2VzW2luZGV4XS51cGRhdGVCYWNrQnV0dG9uKGluZGV4ID4gMCk7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZUluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IE1hdGguYWJzKHRoaXMucGFnZXMubGVuZ3RoICsgaW5kZXgpICUgdGhpcy5wYWdlcy5sZW5ndGg7XG4gIH1cblxuICBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wb3BQYWdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG5cbiAgX2xhc3RJbmRleE9mUGFnZShwYWdlTmFtZSkge1xuICAgIGxldCBpbmRleDtcbiAgICBmb3IgKGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBpZiAodGhpcy5wYWdlc1tpbmRleF0ubmFtZSA9PT0gcGFnZU5hbWUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIF9lbWl0UHJlRXZlbnQobmFtZSwgZGF0YSA9IHt9KSB7XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlJyArIG5hbWUsIHV0aWwuZXh0ZW5kKHtcbiAgICAgIG5hdmlnYXRvcjogdGhpcyxcbiAgICAgIGN1cnJlbnRQYWdlOiB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0sXG4gICAgICBjYW5jZWw6ICgpID0+IGlzQ2FuY2VsZWQgPSB0cnVlXG4gICAgfSwgZGF0YSkpO1xuXG4gICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gIH1cblxuICBfZW1pdFByZVB1c2hFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdFByZUV2ZW50KCdwdXNoJyk7XG4gIH1cblxuICBfZW1pdFByZVBvcEV2ZW50KCkge1xuICAgIGNvbnN0IGwgPSB0aGlzLnBhZ2VzLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fZW1pdFByZUV2ZW50KCdwb3AnLCB7XG4gICAgICBsZWF2ZVBhZ2U6IHRoaXMucGFnZXNbbCAtIDFdLFxuICAgICAgZW50ZXJQYWdlOiB0aGlzLnBhZ2VzW2wgLSAyXVxuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCkge1xuICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKHRlbXBsYXRlSFRNTCkpO1xuXG4gICAgaWYgKHBhZ2VFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcGFnZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3VwcGx5IGFuIFwib25zLXBhZ2VcIiBlbGVtZW50IHRvIFwib25zLW5hdmlnYXRvclwiLicpO1xuICAgIH1cblxuICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUocGFnZUVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHBhZ2VFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHRvcFBhZ2VcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgdG9wIHBhZ2UgZWxlbWVudC4gVXNlIHRoaXMgbWV0aG9kIHRvIGFjY2VzcyBvcHRpb25zIHBhc3NlZCBieSBgcHVzaFBhZ2UoKWAtbGlrZSBtZXRob2RzLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODmuODvOOCuOOCkuWPluW+l+OBl+OBvuOBmeOAgnB1c2hQYWdlKCnjgoRyZXNldFRvUGFnZSgp44Oh44K944OD44OJ44Gu5byV5pWw44KS5Y+W5b6X44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCB0b3BQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZXNcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MQ29sbGVjdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU5hdmlnYXRvcidzIHBhZ2Ugc3RhY2suWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGVmYXVsdCBvcHRpb25zIG9iamVjdC4gQXR0cmlidXRlcyBoYXZlIHByaW9yaXR5IG92ZXIgdGhpcyBwcm9wZXJ0eS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMucmVmcmVzaFxuICAgKiBAZGVmYXVsdCAgZmFsc2VcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHBhcmFtZXRlciBpcyBgdHJ1ZWAsIHRoZSBwcmV2aW91cyBwYWdlIHdpbGwgYmUgcmVmcmVzaGVkIChkZXN0cm95ZWQgYW5kIGNyZWF0ZWQgYWdhaW4pIGJlZm9yZSBgcG9wUGFnZSgpYCBhY3Rpb24uWy9lbl1cbiAgICogICBbamFdcG9wUGFnZeOBmeOCi+WJjeOBq+OAgeWJjeOBq+OBguOCi+ODmuODvOOCuOOCkueUn+aIkOOBl+OBquOBiuOBl+OBpuabtOaWsOOBmeOCi+WgtOWQiOOBq3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIHNldCBfaXNSdW5uaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19pcy1ydW5uaW5nJywgdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgfVxuICBnZXQgX2lzUnVubmluZygpIHtcbiAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKCdfaXMtcnVubmluZycpKTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcbiAgICAgIHRoaXMudG9wUGFnZS5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcbiAgICAgIHRoaXMudG9wUGFnZS5faGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnBhZ2VzW2ldLl9kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG59XG5cbndpbmRvdy5PbnNOYXZpZ2F0b3JFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtbmF2aWdhdG9yJywge1xuICBwcm90b3R5cGU6IE5hdmlnYXRvckVsZW1lbnQucHJvdG90eXBlXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gQW5pbWF0b3JcbiAqL1xud2luZG93Lk9uc05hdmlnYXRvckVsZW1lbnQucmVnaXN0ZXJBbmltYXRvciA9IGZ1bmN0aW9uKG5hbWUsIEFuaW1hdG9yKSB7XG4gIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zTmF2aWdhdG9yRWxlbWVudC5OYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3InKTtcbiAgfVxuXG4gIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbn07XG5cbndpbmRvdy5PbnNOYXZpZ2F0b3JFbGVtZW50LnJld3JpdGFibGVzID0gcmV3cml0YWJsZXM7XG53aW5kb3cuT25zTmF2aWdhdG9yRWxlbWVudC5OYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgPSBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3I7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJ29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3BhZ2UtLSonLFxuICAnLnBhZ2VfX2NvbnRlbnQnOiAncGFnZS0tKl9fY29udGVudCcsXG4gICcucGFnZV9fYmFja2dyb3VuZCc6ICdwYWdlLS0qX19iYWNrZ3JvdW5kJ1xufTtcblxuY29uc3QgbnVsbFRvb2xiYXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXRvb2xiYXInKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcGFnZVxuICogQGNhdGVnb3J5IHBhZ2VcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoaXMgY29tcG9uZW50IGRlZmluZXMgdGhlIHJvb3Qgb2YgZWFjaCBwYWdlLiBJZiB0aGUgY29udGVudCBpcyBsYXJnZSBpdCB3aWxsIGJlY29tZSBzY3JvbGxhYmxlLlxuICpcbiAqICAgICBBIG5hdmlnYXRpb24gYmFyIGNhbiBiZSBhZGRlZCB0byB0aGUgdG9wIG9mIHRoZSBwYWdlIHVzaW5nIHRoZSBgPG9ucy10b29sYmFyPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODmuODvOOCuOWumue+qeOBruOBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBruWGheWuueOBr+OCueOCr+ODreODvOODq+OBjOioseWPr+OBleOCjOOBvuOBmeOAglsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcGFnZVxuICogQGd1aWRlIE1hbmFnaW5nTXVsdGlwbGVQYWdlc1xuICogICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBndWlkZSBQYWdlbGlmZWN5Y2xlXG4gKiAgIFtlbl1QYWdlIGxpZmUgY3ljbGUgZXZlbnRzWy9lbl1cbiAqICAgW2phXeODmuODvOOCuOODqeOCpOODleOCteOCpOOCr+ODq+OCpOODmeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgSGFuZGxpbmdCYWNrQnV0dG9uXG4gKiAgIFtlbl1IYW5kbGluZyBiYWNrIGJ1dHRvblsvZW5dXG4gKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjgavlr77lv5zjgZnjgotbL2phXVxuICogQGd1aWRlIE92ZXJyaWRpbmdDU1NzdHlsZXNcbiAqICAgW2VuXU92ZXJyaWRpbmcgQ1NTIHN0eWxlc1svZW5dXG4gKiAgIFtqYV1DU1Pjgrnjgr/jgqTjg6vjga7jgqrjg7zjg5Djg7zjg6njgqTjg4lbL2phXVxuICogQGd1aWRlIERlZmluaW5nTXVsdGlwbGVQYWdlc2luU2luZ2xlSFRNTFxuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVVzZSB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQgdG8gYWRkIGEgbmF2aWdhdGlvbiBiYXIgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgPG9ucy1iYWNrLWJ1dHRvbj5CYWNrPC9vbnMtYmFjay1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlRpdGxlPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKlxuICogICA8cD5QYWdlIGNvbnRlbnQ8L3A+XG4gKiA8L29ucy1wYWdlPlxuICpcbiAqIC8vIEluZmluaXRlIFNjcm9sbCBoYW5kbGVyXG4gKiBwYWdlLm9uSW5maW5pdGVTY3JvbGwgPSBmdW5jdGlvbihkb25lKSB7XG4gKiAgIGxvYWRNb3JlKCkudGhlbihkb25lKTtcbiAqIH07XG4gKi9cbmNsYXNzIFBhZ2VFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgaW5pdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgYXR0YWNoZWQuWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM44Ki44K/44OD44OB44GV44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGRlc3Ryb3lcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGJlZm9yZSB0aGUgcGFnZSBpcyBkZXN0cm95ZWQuWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM56C05qOE44GV44KM44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgbW9kaWZpZXIgbmFtZSB0byBzcGVjaWZ5IGN1c3RvbSBzdHlsZXMuWy9lbl1cbiAgICogICBbamFd44K544K/44Kk44Or5a6a576p44KS44Kr44K544K/44Oe44Kk44K644GZ44KL44Gf44KB44Gu5ZCN5YmN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb24taW5maW5pdGUtc2Nyb2xsXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QYXRoIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiBpbmZpbml0ZSBzY3JvbGxpbmcuIEV4YW1wbGU6IGBhcHAubG9hZERhdGFgLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYSBkb25lIGNhbGxiYWNrIHRoYXQgbXVzdCBiZSBjYWxsZWQgd2hlbiBpdCdzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3BhZ2UnKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2lzTXV0ZWQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnX211dGVkJyk7XG4gICAgICB0aGlzLl9za2lwSW5pdCA9IHRoaXMuaGFzQXR0cmlidXRlKCdfc2tpcGluaXQnKTtcbiAgICAgIHRoaXMucHVzaGVkT3B0aW9ucyA9IHt9O1xuICAgIH0pO1xuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9za2lwSW5pdCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdfc2tpcGluaXQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdpbml0JykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCh0aGlzKSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdHJ5VG9GaWxsU3RhdHVzQmFyKCk7XG5cbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb24taW5maW5pdGUtc2Nyb2xsJykpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ29uLWluZmluaXRlLXNjcm9sbCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdvbi1pbmZpbml0ZS1zY3JvbGwnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVCYWNrQnV0dG9uKHNob3cpIHtcbiAgICBpZiAodGhpcy5iYWNrQnV0dG9uKSB7XG4gICAgICBzaG93ID8gdGhpcy5iYWNrQnV0dG9uLnNob3coKSA6IHRoaXMuYmFja0J1dHRvbi5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgc2V0IG5hbWUoc3RyKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBzdHIpO1xuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgfVxuXG4gIGdldCBiYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbicpO1xuICB9XG5cbiAgX3RyeVRvRmlsbFN0YXR1c0Jhcigpe1xuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCBlID0+IGUuaGFzQXR0cmlidXRlKCdzdGF0dXMtYmFyLWZpbGwnKSk7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3RhdHVzLWJhci1maWxsJywgIWZpbGxlZCAmJiAodGhpcy5fY2FuQW5pbWF0ZVRvb2xiYXIoKSB8fCAhdGhpcy5faGFzQVBhZ2VDb250cm9sQ2hpbGQoKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgX2hhc0FQYWdlQ29udHJvbENoaWxkKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9jb250ZW50RWxlbWVudCwgZSA9PiBlLm5vZGVOYW1lLm1hdGNoKC9vbnMtKHNwbGl0dGVyfHNsaWRpbmctbWVudXxuYXZpZ2F0b3J8dGFiYmFyKS9pKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uSW5maW5pdGVTY3JvbGxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBzY3JvbGxpbmcgdG8gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgZG9uZSBjYWxsYmFjayBhcyBhbiBhcmd1bWVudCB0aGF0IG11c3QgYmUgY2FsbGVkIHdoZW4gaXQncyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgb25JbmZpbml0ZVNjcm9sbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25JbmZpbml0ZVNjcm9sbCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgbnVsbCcpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX29uSW5maW5pdGVTY3JvbGwpIHtcbiAgICAgIHRoaXMuX2luZmluaXRlU2Nyb2xsTGltaXQgPSAwLjk7XG4gICAgICB0aGlzLl9ib3VuZE9uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwpO1xuICAgIH1cbiAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsID0gdmFsdWU7XG4gIH1cblxuICBnZXQgb25JbmZpbml0ZVNjcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25JbmZpbml0ZVNjcm9sbDtcbiAgfVxuXG4gIF9vblNjcm9sbCgpIHtcbiAgICBjb25zdCBjID0gdGhpcy5fY29udGVudEVsZW1lbnQsXG4gICAgICBvdmVyTGltaXQgPSAoYy5zY3JvbGxUb3AgKyBjLmNsaWVudEhlaWdodCkgLyBjLnNjcm9sbEhlaWdodCA+PSB0aGlzLl9pbmZpbml0ZVNjcm9sbExpbWl0O1xuXG4gICAgaWYgKHRoaXMuX29uSW5maW5pdGVTY3JvbGwgJiYgIXRoaXMuX2xvYWRpbmdDb250ZW50ICYmIG92ZXJMaW1pdCkge1xuICAgICAgdGhpcy5fbG9hZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCgoKSA9PiB0aGlzLl9sb2FkaW5nQ29udGVudCA9IGZhbHNlKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldENvbnRlbnRFbGVtZW50KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdmYWlsIHRvIGdldCBcIi5wYWdlX19jb250ZW50XCIgZWxlbWVudC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2NhbkFuaW1hdGVUb29sYmFyKCkge1xuICAgIGlmICh1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhIXV0aWwuZmluZENoaWxkKHRoaXMuX2NvbnRlbnRFbGVtZW50LCBlbCA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlbCwgJ29ucy10b29sYmFyJykgJiYgIWVsLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ2ZhaWwgdG8gZ2V0IFwiLnBhZ2VfX2JhY2tncm91bmRcIiBlbGVtZW50LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWJvdHRvbS10b29sYmFyJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJykgfHwgbnVsbFRvb2xiYXJFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRvb2xiYXIgZWxlbWVudCB0byB0aGlzIHBhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIF9yZWdpc3RlclRvb2xiYXIoZWxlbWVudCkge1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIHRoaXMuY2hpbGRyZW5bMF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRvb2xiYXIgZWxlbWVudCB0byB0aGlzIHBhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIF9yZWdpc3RlckJvdHRvbVRvb2xiYXIoZWxlbWVudCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncGFnZS13aXRoLWJvdHRvbS10b29sYmFyJyk7XG4gICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdfbXV0ZWQnKSB7XG4gICAgICB0aGlzLl9pc011dGVkID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19tdXRlZCcpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ19za2lwaW5pdCcpIHtcbiAgICAgIHRoaXMuX3NraXBJbml0ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19za2lwaW5pdCcpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ29uLWluZmluaXRlLXNjcm9sbCcpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSAoZG9uZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGYgPSB1dGlsLmZpbmRGcm9tUGF0aChjdXJyZW50KTtcbiAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBmO1xuICAgICAgICAgIGYoZG9uZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5jcmVhdGUoJy5wYWdlX19jb250ZW50Jyk7XG5cbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmNsYXNzTGlzdCB8fCAhbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3BhZ2VfX2JhY2tncm91bmQnKSkge1xuICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJykpIHtcbiAgICAgIGNvbnN0IGJhY2tncm91bmQgPSB1dGlsLmNyZWF0ZSgnLnBhZ2VfX2JhY2tncm91bmQnKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGJhY2tncm91bmQsIHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgX3JlZ2lzdGVyRXh0cmFFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBsZXQgZXh0cmEgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2V4dHJhJyk7XG4gICAgaWYgKCFleHRyYSkge1xuICAgICAgZXh0cmEgPSB1dGlsLmNyZWF0ZSgnLnBhZ2VfX2V4dHJhJywge3pJbmRleDogMTAwMDF9KTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZXh0cmEpO1xuICAgIH1cblxuICAgIGV4dHJhLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duICYmIHV0aWwuaXNBdHRhY2hlZCh0aGlzKSkge1xuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Nob3cnKTtcbiAgICAgIH1cblxuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfc2hvdycpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG5cbiAgICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2hpZGUnKTtcbiAgICAgIH1cblxuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfaGlkZScpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuX2hpZGUoKTtcblxuICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdkZXN0cm95Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub25EZXZpY2VCYWNrQnV0dG9uKSB7XG4gICAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbi5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfZGVzdHJveScpO1xuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGF0YVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZXIncyBjdXN0b20gZGF0YSBwYXNzZWQgdG8gYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbn1cblxud2luZG93Lk9uc1BhZ2VFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcGFnZScsIHtcbiAgcHJvdG90eXBlOiBQYWdlRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuY2xhc3MgUG9wb3ZlckFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLFxuICAgICAgZHVyYXRpb246IDAuMixcbiAgICAgIGRlbGF5OiAwXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGhpZGUocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgX2FuaW1hdGUoZWxlbWVudCwge2Zyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjaywgcmVzdG9yZSA9IGZhbHNlLCBhbmltYXRpb259KSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgZnJvbSA9IGFuaW1hdGlvbi5mcm9tO1xuICAgICAgdG8gPSBhbmltYXRpb24udG87XG4gICAgfVxuXG4gICAgYW5pbWF0aW9uID0gYW5pbWl0KGVsZW1lbnQpO1xuICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uc2F2ZVN0eWxlKCk7XG4gICAgfVxuICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZShmcm9tKS53YWl0KG9wdGlvbnMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgIGNzczogdG8sXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgIHRpbWluZzogb3B0aW9ucy50aW1pbmdcbiAgICB9KTtcbiAgICBpZiAocmVzdG9yZSkge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnJlc3RvcmVTdHlsZSgpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZSgoZG9uZSkgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuXG4gIF9hbmltYXRlQWxsKGVsZW1lbnQsIGFuaW1hdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhhbmltYXRpb25zKS5mb3JFYWNoKGtleSA9PiB0aGlzLl9hbmltYXRlKGVsZW1lbnRba2V5XSwgYW5pbWF0aW9uc1trZXldKS5wbGF5KCkpO1xuICB9XG5cbn1cblxuY29uc3QgZmFkZSA9IHtcbiAgb3V0OiB7XG4gICAgZnJvbToge29wYWNpdHk6IDEuMH0sXG4gICAgdG86IHtvcGFjaXR5OiAwfVxuICB9LFxuICBpbjoge1xuICAgIGZyb206IHtvcGFjaXR5OiAwfSxcbiAgICB0bzoge29wYWNpdHk6IDEuMH1cbiAgfVxufTtcblxuY2xhc3MgTURGYWRlUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgUG9wb3ZlckFuaW1hdG9yIHtcbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUuaW4sXG4gICAgICBfcG9wb3Zlcjoge2FuaW1hdGlvbjogZmFkZS5pbiwgcmVzdG9yZTogdHJ1ZSwgY2FsbGJhY2t9XG4gICAgfSk7XG4gIH1cblxuICBoaWRlKHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5vdXQsXG4gICAgICBfcG9wb3Zlcjoge2FuaW1hdGlvbjogZmFkZS5vdXQsIHJlc3RvcmU6IHRydWUsIGNhbGxiYWNrfVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBNREZhZGVQb3BvdmVyQW5pbWF0b3Ige1xuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5pbixcbiAgICAgIF9wb3BvdmVyOiB7XG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZTNkKDEuMywgMS4zLCAxLjApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjAsIDEuMCwgIDEuMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LFxuICAgICAgICByZXN0b3JlOiB0cnVlLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtQb3BvdmVyQW5pbWF0b3IsIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsIE1ERmFkZVBvcG92ZXJBbmltYXRvcn07XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJ29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBhbmltYXRvcnMgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJ29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnBvcG92ZXInOiAncG9wb3Zlci0tKicsXG4gICcucG9wb3Zlci1tYXNrJzogJ3BvcG92ZXItbWFzay0tKicsXG4gICcucG9wb3Zlcl9fY29udGFpbmVyJzogJ3BvcG92ZXJfX2NvbnRhaW5lci0tKicsXG4gICcucG9wb3Zlcl9fY29udGVudCc6ICdwb3BvdmVyX19jb250ZW50LS0qJyxcbiAgJy5wb3BvdmVyX19hcnJvdyc6ICdwb3BvdmVyX19hcnJvdy0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBhbmltYXRvcnMuTURGYWRlUG9wb3ZlckFuaW1hdG9yIDogYW5pbWF0b3JzLklPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdub25lJzogYW5pbWF0b3JzLlBvcG92ZXJBbmltYXRvcixcbiAgJ2ZhZGUtaW9zJzogYW5pbWF0b3JzLklPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogYW5pbWF0b3JzLk1ERmFkZVBvcG92ZXJBbmltYXRvclxufTtcblxuY29uc3QgdGVtcGxhdGVTb3VyY2UgPSB1dGlsLmNyZWF0ZUZyYWdtZW50KGBcbiAgPGRpdiBjbGFzcz1cInBvcG92ZXItbWFza1wiPjwvZGl2PlxuICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fY29udGFpbmVyXCI+XG4gICAgPGRpdiBjbGFzcz1cInBvcG92ZXJfX2NvbnRlbnRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fYXJyb3dcIj48L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuY29uc3QgcG9zaXRpb25zID0ge1xuICB1cDogJ2JvdHRvbScsXG4gIGxlZnQ6ICdyaWdodCcsXG4gIGRvd246ICd0b3AnLFxuICByaWdodDogJ2xlZnQnXG59O1xuXG5jb25zdCBkaXJlY3Rpb25zID0gT2JqZWN0LmtleXMocG9zaXRpb25zKTtcbi8qKlxuICogQGVsZW1lbnQgb25zLXBvcG92ZXJcbiAqIEBjYXRlZ29yeSBwb3BvdmVyXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIGNvbXBvbmVudCB0aGF0IGRpc3BsYXlzIGEgcG9wb3ZlciBuZXh0IHRvIGFuIGVsZW1lbnQuIFRoZSBwb3BvdmVyIGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgZXh0cmEgaW5mb3JtYXRpb24gYWJvdXQgYSBjb21wb25lbnQgb3IgYSB0b29sdGlwLlxuICpcbiAqICAgIEFub3RoZXIgY29tbW9uIHdheSB0byB1c2UgdGhlIHBvcG92ZXIgaXMgdG8gZGlzcGxheSBhIG1lbnUgd2hlbiBhIGJ1dHRvbiBvbiB0aGUgc2NyZWVuIGlzIHRhcHBlZC5cbiAqICBbL2VuXVxuICogIFtqYV3jgYLjgovopoHntKDjgpLlr77osaHjgajjgZnjgovjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQGNvZGVwZW4gWllZUktvXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcG9wb3ZlclxuICogQGV4YW1wbGVcbiAqIDxvbnMtYnV0dG9uIG9uY2xpY2s9XCJzaG93UG9wb3Zlcih0aGlzKVwiPlxuICogICBDbGljayBtZSFcbiAqIDwvb25zLWJ1dHRvbj5cbiAqXG4gKiA8b25zLXBvcG92ZXIgZGlyZWN0aW9uPVwiZG93blwiIGlkPVwicG9wb3ZlclwiPlxuICogICA8cD5UaGlzIGlzIGEgcG9wb3ZlciE8L3A+XG4gKiA8L29ucy1wb3BvdmVyPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIHZhciBzaG93UG9wb3ZlciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAqICAgICB2YXIgcG9wb3ZlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwb3BvdmVyJyk7XG4gKiAgICAgcG9wb3Zlci5zaG93KGVsZW1lbnQpO1xuICogICB9O1xuICogPC9zY3JpcHQ+XG4gKi9cbmNsYXNzIFBvcG92ZXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBwb3BvdmVyIGZyb20gYmVpbmcgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CB44Od44OD44OX44Kq44O844OQ44O844Gu6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgcG9wb3ZlciBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZWhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBwb3BvdmVyIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgcG9wb3ZlciBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzpmqDjgozjgovlh6bnkIbjgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwb3BvdmVyLlsvZW5dXG4gICAqICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVxuICAgKiAgICBBIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGRpcmVjdGlvbnMuIElmIG1vcmUgdGhhbiBvbmUgZGlyZWN0aW9uIGlzIHNwZWNpZmllZCxcbiAgICogICAgaXQgd2lsbCBiZSBjaG9zZW4gYXV0b21hdGljYWxseS4gVmFsaWQgZGlyZWN0aW9ucyBhcmUgYFwidXBcImAsIGBcImRvd25cImAsIGBcImxlZnRcImAgYW5kIGBcInJpZ2h0XCJgLlxuICAgKiAgWy9lbl1cbiAgICogIFtqYV1cbiAgICogICAg44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GZ44KL5pa55ZCR44KS56m655m95Yy65YiH44KK44Gn6KSH5pWw5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgIOaMh+WumuOBp+OBjeOCi+aWueWQkeOBr+OAgVwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiLCBcInJpZ2h0XCLjga4044Gk44Gn44GZ44CC56m655m95Yy65YiH44KK44Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44KC44Gn44GN44G+44GZ44CCXG4gICAqICAgIOikh+aVsOaMh+WumuOBleOCjOOBn+WgtOWQiOOAgeWvvuixoeOBqOOBmeOCi+imgee0oOOBq+WQiOOCj+OBm+OBpuaMh+WumuOBl+OBn+WApOOBi+OCieiHquWLleeahOOBq+mBuOaKnuOBleOCjOOBvuOBmeOAglxuICAgKiAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2FuY2VsYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBwb3BvdmVyIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CB44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44Gf5pmC44Gr44CB6IOM5pmv44KE44OQ44OD44Kv44Oc44K/44Oz44KS44K/44OD44OX44GX44Gf5pmC44Gr44KS44Od44OD44OX44Kq44O844OQ44O86ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY292ZXItdGFyZ2V0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiBzZXQgdGhlIHBvcG92ZXIgd2lsbCBjb3ZlciB0aGUgdGFyZ2V0IG9uIHRoZSBzY3JlZW4uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuIGhpZGluZyB0aGUgcG9wb3Zlci4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgLCBgXCJkZWZhdWx0XCJgLCBgXCJmYWRlLWlvc1wiYCBvciBgXCJmYWRlLW1kXCJgLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtDb2xvcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG1hc2suIERlZmF1bHQgaXMgYFwicmdiYSgwLCAwLCAwLCAwLjIpXCJgLlsvZW5dXG4gICAqICAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr1wicmdiYSgwLCAwLCAwLCAwLjIpXCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBnZXQgX21hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcucG9wb3Zlci1tYXNrJyk7XG4gIH1cblxuICBnZXQgX3BvcG92ZXIoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcucG9wb3Zlcl9fY29udGFpbmVyJyk7XG4gIH1cblxuICBnZXQgX2NvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX3BvcG92ZXIsICcucG9wb3Zlcl9fY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IF9hcnJvdygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fcG9wb3ZlciwgJy5wb3BvdmVyX19hcnJvdycpO1xuICB9XG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLl9pbml0QW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gdGhpcy5fY2FuY2VsLmJpbmQodGhpcyk7XG4gIH1cblxuICBfaW5pdEFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICBjb25zdCBmYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IGFuaW1hdG9ycy5Qb3BvdmVyQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnUG9wb3ZlckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSB8fCAnZGVmYXVsdCdcbiAgICB9KTtcbiAgICB0aGlzLl9hbmltYXRvciA9IChvcHRpb25zKSA9PiBmYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuICB9XG5cbiAgX3Bvc2l0aW9uUG9wb3Zlcih0YXJnZXQpIHtcbiAgICBjb25zdCB7X3JhZGl1czogcmFkaXVzLCBfY29udGVudDogZWwsIF9tYXJnaW46IG1hcmdpbn0gPSB0aGlzO1xuICAgIGNvbnN0IHBvcyA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBpc01EID0gdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKTtcbiAgICBjb25zdCBjb3ZlciA9IGlzTUQgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvdmVyLXRhcmdldCcpO1xuXG4gICAgY29uc3QgZGlzdGFuY2UgPSB7XG4gICAgICB0b3A6IHBvcy50b3AgLSBtYXJnaW4sXG4gICAgICBsZWZ0OiBwb3MubGVmdCAtIG1hcmdpbixcbiAgICAgIHJpZ2h0OiB3aW5kb3cuaW5uZXJXaWR0aCAtIHBvcy5yaWdodCAtIG1hcmdpbixcbiAgICAgIGJvdHRvbTogd2luZG93LmlubmVySGVpZ2h0IC0gcG9zLmJvdHRvbSAtIG1hcmdpblxuICAgIH07XG5cbiAgICBjb25zdCB7dmVydGljYWwsIHByaW1hcnksIHNlY29uZGFyeX0gPSB0aGlzLl9jYWxjdWxhdGVEaXJlY3Rpb25zKGRpc3RhbmNlKTtcbiAgICB0aGlzLl9wb3BvdmVyLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItLScgKyBwcmltYXJ5KTtcblxuICAgIGNvbnN0IG9mZnNldCA9IGNvdmVyID8gMCA6ICh2ZXJ0aWNhbCA/IHBvcy5oZWlnaHQgOiBwb3Mud2lkdGgpICsgKGlzTUQgPyAwIDogMTQpO1xuICAgIHRoaXMuc3R5bGVbcHJpbWFyeV0gPSBNYXRoLm1heCgwLCBkaXN0YW5jZVtwcmltYXJ5XSArIG9mZnNldCkgKyBtYXJnaW4gKyAncHgnO1xuICAgIGVsLnN0eWxlW3ByaW1hcnldID0gMDtcblxuICAgIGNvbnN0IGwgPSB2ZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICBjb25zdCBzaXplcyA9IChzdHlsZSA9PiAoe1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJykpLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKSlcbiAgICB9KSkod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpKTtcblxuICAgIGVsLnN0eWxlW3NlY29uZGFyeV0gPSBNYXRoLm1heCgwLCBkaXN0YW5jZVtzZWNvbmRhcnldIC0gKHNpemVzW2xdIC0gcG9zW2xdKSAvIDIpICsgJ3B4JztcbiAgICB0aGlzLl9hcnJvdy5zdHlsZVtzZWNvbmRhcnldID0gTWF0aC5tYXgocmFkaXVzLCBkaXN0YW5jZVtzZWNvbmRhcnldICsgcG9zW2xdIC8gMikgKyAncHgnO1xuXG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtT3JpZ2luKGRpc3RhbmNlLCBzaXplcywgcG9zLCBwcmltYXJ5KTtcblxuICAgIC8vIFByZXZlbnQgYW5pbWl0IGZyb20gcmVzdG9yaW5nIHRoZSBzdHlsZS5cbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYW5pbWl0LW9yaWctc3R5bGUnKTtcbiAgfVxuXG4gIF9zZXRUcmFuc2Zvcm1PcmlnaW4oZGlzdGFuY2UsIHNpemVzLCBwb3MsIHByaW1hcnkpIHtcbiAgICBjb25zdCBjYWxjID0gKGEsIG8sIGwpID0+IHByaW1hcnkgPT09IGEgPyBzaXplc1tsXSAvIDIgOiBkaXN0YW5jZVthXSArIChwcmltYXJ5ID09PSBvID8gLXNpemVzW2xdIDogc2l6ZXNbbF0gLSBwb3NbbF0pIC8gMjtcbiAgICBjb25zdCBbeCwgeV0gPSBbY2FsYygnbGVmdCcsICdyaWdodCcsICd3aWR0aCcpICsgJ3B4JywgY2FsYygndG9wJywgJ2JvdHRvbScsICdoZWlnaHQnKSArICdweCddO1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMuX3BvcG92ZXIuc3R5bGUsIHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogeCArICcgJyArIHksXG4gICAgICB3ZWJraXRUcmFuc2Zvcm1PcmlnaW5YOiB4LFxuICAgICAgd2Via2l0VHJhbnNmb3JtT3JpZ2luWTogeVxuICAgIH0pO1xuICB9XG5cbiAgX2NhbGN1bGF0ZURpcmVjdGlvbnMoZGlzdGFuY2UpIHtcbiAgICBjb25zdCBvcHRpb25zID0gKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSB8fCAndXAgZG93biBsZWZ0IHJpZ2h0Jykuc3BsaXQoL1xccysvKS5tYXAoZSA9PiBwb3NpdGlvbnNbZV0pO1xuICAgIGNvbnN0IHByaW1hcnkgPSBvcHRpb25zLnNvcnQoKGEsIGIpID0+IGRpc3RhbmNlW2FdIC0gZGlzdGFuY2VbYl0pWzBdO1xuICAgIGNvbnN0IHZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwcmltYXJ5KSAhPT0gLTE7XG4gICAgbGV0IHNlY29uZGFyeTtcblxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UubGVmdCA8IGRpc3RhbmNlLnJpZ2h0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UudG9wIDwgZGlzdGFuY2UuYm90dG9tID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICB9XG5cbiAgICByZXR1cm4ge3ZlcnRpY2FsLCBwcmltYXJ5LCBzZWNvbmRhcnl9O1xuICB9XG5cbiAgX2NsZWFyU3R5bGVzKCkge1xuICAgIFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuX2Fycm93LnN0eWxlW2VdID0gdGhpcy5fY29udGVudC5zdHlsZVtlXSA9IHRoaXMuc3R5bGVbZV0gPSAnJztcbiAgICAgIHRoaXMuX3BvcG92ZXIuY2xhc3NMaXN0LnJlbW92ZShgcG9wb3Zlci0tJHtlfWApO1xuICAgIH0pO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY3VycmVudFRhcmdldCkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvblBvcG92ZXIodGhpcy5fY3VycmVudFRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGlmICh0aGlzLmNsYXNzTGlzdC5jb250YWlucygncG9wb3ZlcicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyJyk7XG5cbiAgICBjb25zdCBoYXNEZWZhdWx0Q29udGFpbmVyID0gdGhpcy5fcG9wb3ZlciAmJiB0aGlzLl9jb250ZW50O1xuXG4gICAgaWYgKGhhc0RlZmF1bHRDb250YWluZXIpIHtcblxuICAgICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWFzay5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLW1hc2snKTtcbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobWFzaywgdGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9hcnJvdykge1xuICAgICAgICBjb25zdCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhcnJvdy5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyX19hcnJvdycpO1xuICAgICAgICB0aGlzLl9wb3BvdmVyLmFwcGVuZENoaWxkKGFycm93KTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgY29uc3QgY29udGVudCA9IHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy5wb3BvdmVyX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgIHRoaXMuX3BvcG92ZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnbWFzay1jb2xvcicpKSB7XG4gICAgICB0aGlzLl9tYXNrLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX3ByZXBhcmVBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gJiYgIShvcHRpb25zLmFuaW1hdGlvbiBpbiBfYW5pbWF0b3JEaWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbmltYXRvciAke29wdGlvbnMuYW5pbWF0aW9ufSBpcyBub3QgcmVnaXN0ZXJlZC5gKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpLFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9XG4gICAgKTtcbiAgfVxuXG4gIF9leGVjdXRlQWN0aW9uKGFjdGlvbnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBjb25zdCB7YWN0aW9uLCBiZWZvcmUsIGFmdGVyfSA9IGFjdGlvbnM7XG5cbiAgICB0aGlzLl9wcmVwYXJlQW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBgcHJlJHthY3Rpb259YCwgeyAvLyBzeW5jaHJvbm91c1xuICAgICAgcG9wb3ZlcjogdGhpcyxcbiAgICAgIGNhbmNlbDogKCkgPT4gY2FuY2VsZWQgPSB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgQ2FuY2VsZWQgaW4gcHJlJHthY3Rpb259IGV2ZW50LmApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG5cbiAgICAgICAgYmVmb3JlICYmIGJlZm9yZSgpO1xuXG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0b3Iob3B0aW9ucylbYWN0aW9uXSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBhZnRlciAmJiBhZnRlcigpO1xuXG4gICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIGBwb3N0JHthY3Rpb259YCwge3BvcG92ZXI6IHRoaXN9KTtcblxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyh0YXJnZXQsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd8RXZlbnR8SFRNTEVsZW1lbnR9IHRhcmdldFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC4gQ2FuIGJlIGVpdGhlciBhIENTUyBzZWxlY3RvciwgYW4gZXZlbnQgb2JqZWN0IG9yIGEgRE9NIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44K/44O844Ky44OD44OI44Go44Gq44KL6KaB57Sg44KS5oyH5a6a44GX44G+44GZ44CCQ1NT44K744Os44Kv44K/44GLZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgYtET03opoHntKDjga7jgYTjgZrjgozjgYvjgpLmuKHjgZvjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuICBVc2Ugb25lIG9mIGBcImZhZGUtaW9zXCJgLCBgXCJmYWRlLW1kXCJgLCBgXCJub25lXCJgIGFuZCBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZS1pb3NcIiwgXCJmYWRlLW1kXCIsIFwibm9uZVwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wZW4gdGhlIHBvcG92ZXIgYW5kIHBvaW50IGl0IGF0IGEgdGFyZ2V0LiBUaGUgdGFyZ2V0IGNhbiBiZSBlaXRoZXIgYW4gZXZlbnQsIGEgQ1NTIHNlbGVjdG9yIG9yIGEgRE9NIGVsZW1lbnQuLlsvZW5dXG4gICAqICAgW2phXeWvvuixoeOBqOOBmeOCi+imgee0oOOBq+ODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBl+OBvuOBmeOAgnRhcmdldOW8leaVsOOBq+OBr+OAgSRldmVudOOCquODluOCuOOCp+OCr+ODiOOChERPTeOCqOODrOODoeODs+ODiOOChENTU+OCu+ODrOOCr+OCv+OCkua4oeOBmeOBk+OBqOOBjOWHuuadpeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnRhcmdldDtcbiAgICB9XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXJnZXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZUFjdGlvbih7XG4gICAgICBhY3Rpb246ICdzaG93JyxcbiAgICAgIGJlZm9yZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLl9wb3NpdGlvblBvcG92ZXIodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiAgVXNlIG9uZSBvZiBgXCJmYWRlLWlvc1wiYCwgYFwiZmFkZS1tZFwiYCwgYFwibm9uZVwiYCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb25zIGlzIGNhbGxlZCBhZnRlciB0aGUgcG9wb3ZlciBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNsb3NlIHRoZSBwb3BvdmVyLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLl9leGVjdXRlQWN0aW9uKHtcbiAgICAgIGFjdGlvbjogJ2hpZGUnLFxuICAgICAgYWZ0ZXI6ICgpID0+IHtcbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9jbGVhclN0eWxlcygpO1xuICAgICAgfVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5JykgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgQSBib29sZWFuIHZhbHVlIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgY2FuY2VsYWJsZSBvciBub3QuXG4gICAqXG4gICAqICAgICBXaGVuIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgaXQgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBjYW5jZWxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjYW5jZWxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjYW5jZWxhYmxlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9yZXNldEJhY2tCdXR0b25IYW5kbGVyKCkgeyAvLyBkbyB3ZSBuZWVkIHRoaXMgdHdpY2U/XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSBlID0+IHRoaXMuY2FuY2VsYWJsZSA/IHRoaXMuX2NhbmNlbCgpIDogZS5jYWxsUGFyZW50SGFuZGxlcigpO1xuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9yZXNldEJhY2tCdXR0b25IYW5kbGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fbWFyZ2luID0gdGhpcy5fbWFyZ2luIHx8IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmdldFByb3BlcnR5VmFsdWUoJ3RvcCcpKTtcbiAgICAgIHRoaXMuX3JhZGl1cyA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX2NvbnRlbnQpLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnKSk7XG5cbiAgICAgIHRoaXMuX21hc2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9yZXNldEJhY2tCdXR0b25IYW5kbGVyKCk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwsIGZhbHNlKTtcblxuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2RpcmVjdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZE9uQ2hhbmdlKCk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgdGhpcy5faW5pdEFuaW1hdG9yRmFjdG9yeSgpO1xuICAgIH1cbiAgfVxuXG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlKSB7XG4gICAgICB0aGlzLmhpZGUoe1xuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk9uc1BvcG92ZXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcG9wb3ZlcicsIHtcbiAgcHJvdG90eXBlOiBQb3BvdmVyRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1BvcG92ZXJBbmltYXRvcn0gQW5pbWF0b3JcbiAqL1xud2luZG93Lk9uc1BvcG92ZXJFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xuICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBhbmltYXRvcnMuUG9wb3ZlckFuaW1hdG9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBQb3BvdmVyQW5pbWF0b3InKTtcbiAgfVxuICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG59O1xuXG53aW5kb3cuT25zUG9wb3ZlckVsZW1lbnQuUG9wb3ZlckFuaW1hdG9yID0gYW5pbWF0b3JzLlBvcG92ZXJBbmltYXRvcjtcblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1iYXInOiAncHJvZ3Jlc3MtYmFyLS0qJyxcbiAgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtYmFyX19wcmltYXJ5LS0qJyxcbiAgJy5wcm9ncmVzcy1iYXJfX3NlY29uZGFyeSc6ICdwcm9ncmVzcy1iYXJfX3NlY29uZGFyeS0tKidcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhclwiPlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3NlY29uZGFyeVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3ByaW1hcnlcIj48L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtYmFyXG4gKiBAY2F0ZWdvcnkgcHJvZ3Jlc3NcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhlIGNvbXBvbmVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBsaW5lYXIgcHJvZ3Jlc3MgYmFyLiBJdCBjYW4gZWl0aGVyIGRpc3BsYXkgYSBwcm9ncmVzcyBiYXIgdGhhdCBzaG93cyB0aGUgdXNlciBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkLiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgcGVyY2VudGFnZSBpcyBub3Qga25vd24gaXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBhbiBhbmltYXRlZCBwcm9ncmVzcyBiYXIgc28gdGhlIHVzZXIgY2FuIHNlZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB6dlFiR2pcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wcm9ncmVzc1xuICogQHNlZWFsc28gb25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBjaXJjdWxhciBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wcm9ncmVzcy1iYXJcbiAqICB2YWx1ZT1cIjU1XCJcbiAqICBzZWNvbmRhcnktdmFsdWU9XCI4N1wiPlxuICogPC9vbnMtcHJvZ3Jlc3MtYmFyPlxuICpcbiAqIDxvbnMtcHJvZ3Jlc3MtYmFyXG4gKiAgaW5kZXRlcm1pbmF0ZT5cbiAqIDwvb25zLXByb2dyZXNzLWJhcj5cbiAqL1xuY2xhc3MgUHJvZ3Jlc3NCYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DaGFuZ2UgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICAgKiAgIFtqYV3jg5fjg63jgrDjg6zjgrnjgqTjg7PjgrjjgrHjg7zjgr/jga7opovjgZ/nm67jgpLlpInmm7TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlY29uZGFyeS12YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbmRldGVybWluYXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGV0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJykpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoYHByb2dyZXNzLWJhci0taW5kZXRlcm1pbmF0ZWApO1xuICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZShgcHJvZ3Jlc3MtYmFyLS1kZXRlcm1pbmF0ZWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoYHByb2dyZXNzLWJhci0tZGV0ZXJtaW5hdGVgKTtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoYHByb2dyZXNzLWJhci0taW5kZXRlcm1pbmF0ZWApO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVWYWx1ZSgpIHtcbiAgICB0aGlzLl9wcmltYXJ5LnN0eWxlLndpZHRoID0gKHRoaXMuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICsgJyUnIDogJzAlJztcbiAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGUud2lkdGggPSB0aGlzLmhhc0F0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgKyAnJScgOiAnMCUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5VmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCBzZWNvbmRhcnlWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpbmRldGVybWluYXRlJywgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLl90ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcblxuICAgIHRoaXMuX3ByaW1hcnkgPSB0aGlzLl90ZW1wbGF0ZS5jaGlsZE5vZGVzWzNdO1xuICAgIHRoaXMuX3NlY29uZGFyeSA9IHRoaXMuX3RlbXBsYXRlLmNoaWxkTm9kZXNbMV07XG5cbiAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3RlbXBsYXRlKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cbn1cblxud2luZG93Lk9uc1Byb2dyZXNzQmFyRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXByb2dyZXNzLWJhcicsIHtcbiAgcHJvdG90eXBlOiBQcm9ncmVzc0JhckVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcucHJvZ3Jlc3MtY2lyY3VsYXInOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSonLFxuICAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5LS0qJyxcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnktLSonXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxzdmcgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhclwiPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5XCIgY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI0MCVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjEwJVwiIHN0cm9rZS1taXRlcmxpbWl0PVwiMTBcIi8+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5XCIgY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI0MCVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjEwJVwiIHN0cm9rZS1taXRlcmxpbWl0PVwiMTBcIi8+XG4gIDwvc3ZnPlxuYCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiBAY2F0ZWdvcnkgcHJvZ3Jlc3NcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGlzcGxheXMgYSBjaXJjdWxhciBwcm9ncmVzcyBpbmRpY2F0b3IuIEl0IGNhbiBlaXRoZXIgYmUgdXNlZCB0byBzaG93IGhvdyBtdWNoIG9mIGEgdGFzayBoYXMgYmVlbiBjb21wbGV0ZWQgb3IgdG8gc2hvdyBhIGxvb3BpbmcgYW5pbWF0aW9uIHRvIGluZGljYXRlIHRoYXQgYW4gb3BlcmF0aW9uIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIEVWek1qUlxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3Byb2dyZXNzXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogIHZhbHVlPVwiNTVcIlxuICogIHNlY29uZGFyeS12YWx1ZT1cIjg3XCI+XG4gKiA8L29ucy1wcm9ncmVzcy1jaXJjdWxhcj5cbiAqXG4gKiA8b25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgaW5kZXRlcm1pbmF0ZT5cbiAqIDwvb25zLXByb2dyZXNzLWNpcmN1bGFyPlxuICovXG5jbGFzcyBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2hhbmdlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAgICogICBbamFd44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44Gu6KaL44Gf55uu44KS5aSJ5pu044GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzZWNvbmRhcnktdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5kZXRlcm1pbmF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2YWx1ZScgfHwgbmFtZSA9PT0gJ3NlY29uZGFyeS12YWx1ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnaW5kZXRlcm1pbmF0ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURldGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKGBwcm9ncmVzcy1jaXJjdWxhci0taW5kZXRlcm1pbmF0ZWApO1xuICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZShgcHJvZ3Jlc3MtY2lyY3VsYXItLWRldGVybWluYXRlYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZChgcHJvZ3Jlc3MtY2lyY3VsYXItLWRldGVybWluYXRlYCk7XG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QucmVtb3ZlKGBwcm9ncmVzcy1jaXJjdWxhci0taW5kZXRlcm1pbmF0ZWApO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgIGNvbnN0IHBlciA9IE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAqIDI1MS4zMiAqIDAuMDEpO1xuICAgICAgdGhpcy5fcHJpbWFyeS5zdHlsZVsnc3Ryb2tlLWRhc2hhcnJheSddID0gcGVyICsgJyUsIDI1MS4zMiUnO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpKSB7XG4gICAgICBjb25zdCBwZXIgPSAgTWF0aC5jZWlsKHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSAqIDI1MS4zMiAqIDAuMDEpO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5VmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCBzZWNvbmRhcnlWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpbmRldGVybWluYXRlJywgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLl90ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcblxuICAgIHRoaXMuX3ByaW1hcnkgPSB0aGlzLl90ZW1wbGF0ZS5jaGlsZE5vZGVzWzNdO1xuICAgIHRoaXMuX3NlY29uZGFyeSA9IHRoaXMuX3RlbXBsYXRlLmNoaWxkTm9kZXNbMV07XG5cbiAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3RlbXBsYXRlKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cbn1cblxud2luZG93Lk9uc1Byb2dyZXNzQ2lyY3VsYXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcHJvZ3Jlc3MtY2lyY3VsYXInLCB7XG4gIHByb3RvdHlwZTogUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG5jb25zdCBTVEFURV9JTklUSUFMID0gJ2luaXRpYWwnO1xuY29uc3QgU1RBVEVfUFJFQUNUSU9OID0gJ3ByZWFjdGlvbic7XG5jb25zdCBTVEFURV9BQ1RJT04gPSAnYWN0aW9uJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHVsbC1ob29rXG4gKiBAY2F0ZWdvcnkgcHVsbC1ob29rXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0aGF0IGFkZHMgKipQdWxsIHRvIHJlZnJlc2gqKiBmdW5jdGlvbmFsaXR5IHRvIGFuIGA8b25zLXBhZ2U+YCBlbGVtZW50LlxuICpcbiAqICAgICBJdCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGEgdGFzayB3aGVuIHRoZSB1c2VyIHB1bGxzIGRvd24gYXQgdGhlIHRvcCBvZiB0aGUgcGFnZS4gQSBjb21tb24gdXNhZ2UgaXMgdG8gcmVmcmVzaCB0aGUgZGF0YSBkaXNwbGF5ZWQgaW4gYSBwYWdlLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIFdiSm9nTVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3B1bGwtaG9va1xuICogQGd1aWRlIFVzaW5nUHVsbEhvb2tcbiAqICAgW2VuXUhvdyB0byB1c2UgUHVsbCBIb29rWy9lbl1cbiAqICAgW2phXeODl+ODq+ODleODg+OCr+OCkuS9v+OBhlsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXB1bGwtaG9vaz5cbiAqICAgICBSZWxlYXNlIHRvIHJlZnJlc2hcbiAqICAgPC9vbnMtcHVsbC1ob29rPlxuICogPC9vbnMtcGFnZT5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdvbnMtcHVsbC1ob29rJykub25BY3Rpb24gPSBmdW5jdGlvbihkb25lKSB7XG4gKiAgICAgc2V0VGltZW91dChkb25lLCAxMDAwKTtcbiAqICAgfTtcbiAqIDwvc2NyaXB0PlxuICovXG5jbGFzcyBQdWxsSG9va0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBjaGFuZ2VzdGF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgc3RhdGUgaXMgY2hhbmdlZC4gVGhlIHN0YXRlIGNhbiBiZSBlaXRoZXIgXCJpbml0aWFsXCIsIFwicHJlYWN0aW9uXCIgb3IgXCJhY3Rpb25cIi5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7nirbmhYvjgYzlpInjgo/jgaPjgZ/loLTlkIjjgavnmbrngavjgZfjgb7jgZnjgILnirbmhYvjga/jgIFcImluaXRpYWxcIiwgXCJwcmVhY3Rpb25cIiwgXCJhY3Rpb25cIuOBruOBhOOBmuOCjOOBi+OBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnB1bGxIb29rXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnN0YXRlXG4gICAqICAgW2VuXUN1cnJlbnQgc3RhdGUuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu54q25oWL5ZCN44KS5Y+C54Wn44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgXCJwdWxsLXRvLXJlZnJlc2hcIiBmdW5jdGlvbmFsaXR5IGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRpc2FibGVk54q25oWL44Gr44Gq44KK44Ki44Kv44K344On44Oz44GM5a6f6KGM44GV44KM44Gq44GP44Gq44KK44G+44GZWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudC4gV2hlbiBwdWxsZWQgZG93biBmdXJ0aGVyIHRoYW4gdGhpcyB2YWx1ZSBpdCB3aWxsIHN3aXRjaCB0byB0aGUgXCJwcmVhY3Rpb25cIiBzdGF0ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCI2NHB4XCIuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu6auY44GV5Lul5LiK44GrcHVsbCBkb3du44GZ44KL44GoXCJwcmVhY3Rpb25cIueKtuaFi+OBq+enu+ihjOOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBruWApOOBr1wiNjRweFwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGhyZXNob2xkLWhlaWdodFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgdGhyZXNob2xkIGhlaWdodC4gVGhlIGNvbXBvbmVudCBhdXRvbWF0aWNhbGx5IHN3aXRjaGVzIHRvIHRoZSBcImFjdGlvblwiIHN0YXRlIHdoZW4gcHVsbGVkIGZ1cnRoZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIjk2cHhcIi4gQSBuZWdhdGl2ZSB2YWx1ZSBvciBhIHZhbHVlIGxlc3MgdGhhbiB0aGUgaGVpZ2h0IHdpbGwgZGlzYWJsZSB0aGlzIHByb3BlcnR5LlsvZW5dXG4gICAqICAgW2phXemWvuWApOOBqOOBquOCi+mrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWApOOBp+aMh+WumuOBl+OBn+mrmOOBleOCiOOCiuOCgnB1bGwgZG93buOBmeOCi+OBqOOAgeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBr+iHquWLleeahOOBq1wiYWN0aW9uXCLnirbmhYvjgavnp7vooYzjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmaXhlZC1jb250ZW50XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNvbnRlbnQgb2YgdGhlIHBhZ2Ugd2lsbCBub3QgbW92ZSB3aGVuIHB1bGxpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gm44GE44KL5pmC44Gr44KC44Kz44Oz44OG44Oz44OE44Gv5YuV44GN44G+44Gb44KT44CCWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JvdW5kT25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkRyYWdTdGFydCA9IHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkRyYWdFbmQgPSB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IDA7XG5cbiAgICB0aGlzLl9lbnN1cmVTY3JvbGxFbGVtZW50KCk7XG5cbiAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMLCB0cnVlKTtcbiAgICB0aGlzLl9zZXRTdHlsZSgpO1xuICB9XG5cbiAgX2NyZWF0ZVNjcm9sbEVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3Njcm9sbCcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXYgY2xhc3M9XCJzY3JvbGxcIj48ZGl2PicpO1xuXG4gICAgY29uc3QgcGFnZUVsZW1lbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG5cbiAgICBzY3JvbGxFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIHdoaWxlIChwYWdlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzY3JvbGxFbGVtZW50LmFwcGVuZENoaWxkKHBhZ2VFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBwYWdlRWxlbWVudC5hcHBlbmRDaGlsZChzY3JvbGxFbGVtZW50KTtcblxuICAgIHJldHVybiBzY3JvbGxFbGVtZW50O1xuICB9XG5cbiAgX2Vuc3VyZVNjcm9sbEVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCAmJiAhdGhpcy5fc2Nyb2xsRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2NyZWF0ZVNjcm9sbEVsZW1lbnQoKTtcbiAgICB9XG4gIH1cblxuICBfc2V0U3R5bGUoKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICB0aGlzLnN0eWxlLnRvcCA9ICctJyArIGhlaWdodCArICdweCc7XG4gICAgdGhpcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIHRoaXMuc3R5bGUubGluZUhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cblxuICBfb25TY3JvbGwoZXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fcGFnZUVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCAwKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgfVxuICB9XG5cbiAgX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0oc2Nyb2xsKSB7XG4gICAgcmV0dXJuICd0cmFuc2xhdGUzZCgwcHgsICcgKyBzY3JvbGwgKyAncHgsIDBweCknO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHdoZW4gZHJhZ2dpbmcgbGVmdCBhbmQgcmlnaHQuXG4gICAgaWYgKGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uID09PSAnbGVmdCcgfHwgZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYWNrIHRvIG1ha2UgaXQgd29yayBvbiBBbmRyb2lkIDQuNCBXZWJWaWV3LiBTY3JvbGxzIG1hbnVhbGx5IG5lYXIgdGhlIHRvcCBvZiB0aGUgcGFnZSBzb1xuICAgIC8vIHRoZXJlIHdpbGwgYmUgbm8gaW5lcnRpYWwgc2Nyb2xsIHdoZW4gc2Nyb2xsaW5nIGRvd24uIEFsbG93aW5nIGRlZmF1bHQgc2Nyb2xsaW5nIHdpbGxcbiAgICAvLyBraWxsIGFsbCAndG91Y2htb3ZlJyBldmVudHMuXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3BhZ2VFbGVtZW50O1xuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gdGhpcy5fc3RhcnRTY3JvbGwgLSBldmVudC5nZXN0dXJlLmRlbHRhWTtcbiAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gIT09ICd1cCcpIHtcbiAgICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID09PSAwICYmIHRoaXMuX2dldEN1cnJlbnRTY3JvbGwoKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdHJhbnNpdGlvbkRyYWdMZW5ndGggPSBldmVudC5nZXN0dXJlLmRlbHRhWTtcblxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZXZlbnQuZ2VzdHVyZS5pbnRlcmltRGlyZWN0aW9uO1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25EcmFnTGVuZ3RoIC09IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRHJhZ0xlbmd0aCArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbCA9IE1hdGgubWF4KGV2ZW50Lmdlc3R1cmUuZGVsdGFZIC0gdGhpcy5fc3RhcnRTY3JvbGwsIDApO1xuXG4gICAgaWYgKHRoaXMuX3RocmVzaG9sZEhlaWdodEVuYWJsZWQoKSAmJiBzY3JvbGwgPj0gdGhpcy50aHJlc2hvbGRIZWlnaHQpIHtcbiAgICAgIGV2ZW50Lmdlc3R1cmUuc3RvcERldGVjdCgpO1xuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fZmluaXNoKCkpO1xuICAgIH0gZWxzZSBpZiAoc2Nyb2xsID49IHRoaXMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9QUkVBQ1RJT04pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMKTtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLl90cmFuc2xhdGVUbyhzY3JvbGwpO1xuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGFydFNjcm9sbCA9IHRoaXMuX2dldEN1cnJlbnRTY3JvbGwoKTtcbiAgfVxuXG4gIF9vbkRyYWdFbmQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPiAwKSB7XG4gICAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb247XG5cbiAgICAgIGlmIChzY3JvbGwgPiB0aGlzLmhlaWdodCkge1xuICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKDAsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkFjdGlvblxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBgYWN0aW9uYCBzdGF0ZSBpZiBpdCBleGlzdHMuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGdpdmVuIGEgYGRvbmVgIGNhbGxiYWNrIGFzIGl0J3MgZmlyc3QgYXJndW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgX2ZpbmlzaCgpIHtcbiAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9BQ1RJT04pO1xuICAgIHRoaXMuX3RyYW5zbGF0ZVRvKHRoaXMuaGVpZ2h0LCB7YW5pbWF0ZTogdHJ1ZX0pO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMub25BY3Rpb24gfHwgKGRvbmUgPT4gZG9uZSgpKTtcbiAgICBhY3Rpb24oKCkgPT4ge1xuICAgICAgdGhpcy5fdHJhbnNsYXRlVG8oMCwge2FuaW1hdGU6IHRydWV9KTtcbiAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBoZWlnaHRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBoZWlnaHQgb2YgdGhlIHB1bGwgaG9vayBpbiBwaXhlbHMuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA2NHB4YC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIGlmICghdXRpbC5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBoZWlnaHQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGAke3ZhbHVlfXB4YCk7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgfHwgJzY0JywgMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0aHJlc2hvbGRIZWlnaHRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSB0aHJlc2hvbGRIZWlnaHQgb2YgdGhlIHB1bGwgaG9vayBpbiBwaXhlbHMuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA5NnB4YC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IHRocmVzaG9sZEhlaWdodCh2YWx1ZSkge1xuICAgIGlmICghdXRpbC5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0aHJlc2hvbGQgaGVpZ2h0IG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcbiAgfVxuXG4gIGdldCB0aHJlc2hvbGRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JykgfHwgJzk2JywgMTApO1xuICB9XG5cbiAgX3RocmVzaG9sZEhlaWdodEVuYWJsZWQoKSB7XG4gICAgY29uc3QgdGggPSB0aGlzLnRocmVzaG9sZEhlaWdodDtcbiAgICByZXR1cm4gdGggPiAwICYmIHRoID49IHRoaXMuaGVpZ2h0O1xuICB9XG5cbiAgX3NldFN0YXRlKHN0YXRlLCBub0V2ZW50KSB7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHN0YXRlKTtcblxuICAgIGlmICghbm9FdmVudCAmJiBsYXN0U3RhdGUgIT09IHRoaXMuX2dldFN0YXRlKCkpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlc3RhdGUnLCB7XG4gICAgICAgIHB1bGxIb29rOiB0aGlzLFxuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgIGxhc3RTdGF0ZTogbGFzdFN0YXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzdGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzdGF0ZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIF9nZXRDdXJyZW50U2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHB1bGxEaXN0YW5jZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IG51bWJlciBvZiBwaXhlbHMgdGhlIHB1bGwgaG9vayBoYXMgbW92ZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gf6Led6Zui44KS44OU44Kv44K744Or5pWw44CCWy9qYV1cbiAgICovXG4gIGdldCBwdWxsRGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBfaXNDb250ZW50Rml4ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdmaXhlZC1jb250ZW50Jyk7XG4gIH1cblxuICBfZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29udGVudEZpeGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICovXG4gIF90cmFuc2xhdGVUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPT0gMCAmJiBzY3JvbGwgPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICBpZiAoc2Nyb2xsID09PSAwICYmICF0aGlzLl9pc0NvbnRlbnRGaXhlZCgpKSB7XG4gICAgICAgIHRoaXMuX2dldFNjcm9sbGFibGVFbGVtZW50KCkucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IHNjcm9sbDtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRTY3JvbGxhYmxlRWxlbWVudCgpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVUcmFuc2xhdGlvblRyYW5zZm9ybShzY3JvbGwpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMC4zLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnBsYXkoZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRTY3JvbGxhYmxlRWxlbWVudCgpKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVUcmFuc2xhdGlvblRyYW5zZm9ybShzY3JvbGwpXG4gICAgICAgIH0pXG4gICAgICAgIC5wbGF5KGRvbmUpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRNaW5pbXVtU2Nyb2xsKCkge1xuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIGNvbnN0IHBhZ2VIZWlnaHQgPSB0aGlzLl9wYWdlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG5cbiAgICByZXR1cm4gc2Nyb2xsSGVpZ2h0ID4gcGFnZUhlaWdodCA/IC0oc2Nyb2xsSGVpZ2h0IC0gcGFnZUhlaWdodCkgOiAwO1xuICB9XG5cbiAgX2NyZWF0ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5fcGFnZUVsZW1lbnQsIHtcbiAgICAgIGRyYWdNaW5EaXN0YW5jZTogMSxcbiAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IGZhbHNlXG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGxpc3RlbmVyc1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZycsIHRoaXMuX2JvdW5kT25EcmFnKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZ2VuZCcsIHRoaXMuX2JvdW5kT25EcmFnRW5kKTtcblxuICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQucGFyZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsLCBmYWxzZSk7XG4gIH1cblxuICBfZGVzdHJveUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWcnLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG5cbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zY3JvbGxFbGVtZW50ICYmIHRoaXMuX3Njcm9sbEVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Vuc3VyZVNjcm9sbEVsZW1lbnQoKTtcblxuICAgIHRoaXMuX3BhZ2VFbGVtZW50ID0gdGhpcy5fc2Nyb2xsRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXG4gICAgaWYgKCF0aGlzLl9wYWdlRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhZ2VfX2NvbnRlbnQnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCc8b25zLXB1bGwtaG9vaz4gbXVzdCBiZSBhIGRpcmVjdCBkZXNjZW5kYW50IG9mIGFuIDxvbnMtcGFnZT4gZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9kZXN0cm95RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gIH1cbn1cblxud2luZG93Lk9uc1B1bGxIb29rRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXB1bGwtaG9vaycsIHtcbiAgcHJvdG90eXBlOiBQdWxsSG9va0VsZW1lbnQucHJvdG90eXBlXG59KTtcblxud2luZG93Lk9uc1B1bGxIb29rRWxlbWVudC5TVEFURV9BQ1RJT04gPSBTVEFURV9BQ1RJT047XG53aW5kb3cuT25zUHVsbEhvb2tFbGVtZW50LlNUQVRFX0lOSVRJQUwgPSBTVEFURV9JTklUSUFMO1xud2luZG93Lk9uc1B1bGxIb29rRWxlbWVudC5TVEFURV9QUkVBQ1RJT04gPSBTVEFURV9QUkVBQ1RJT047XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNiBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcblxuLyoqXG4gKiBAY2xhc3MgQW5pbWF0b3JDU1MgLSBpbXBsZW1lbnRhdGlvbiBvZiBBbmltYXRvciBjbGFzcyB1c2luZyBjc3MgdHJhbnNpdGlvbnNcbiAqL1xuY2xhc3MgQW5pbWF0b3JDU1Mge1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFuaW1hdGVcbiAgICogQGRlc2MgbWFpbiBhbmltYXRpb24gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmaW5hbENTU1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF0gLSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7T2JqZWN0fSByZXN1bHRcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC50aGVuKGNhbGxiYWNrKSAtIHNldHMgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBzdG9wcGVkXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3RvcChvcHRpb25zKSAtIHN0b3BzIHRoZSBhbmltYXRpb247IGlmIG9wdGlvbnMuc3RvcE5leHQgaXMgdHJ1ZSB0aGVuIGl0IGRvZXNuJ3QgY2FsbCB0aGUgY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5maW5pc2gobXMpIC0gZmluaXNoZXMgdGhlIGFuaW1hdGlvbiBpbiB0aGUgc3BlY2lmaWVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3BlZWQobXMpIC0gc2V0cyB0aGUgYW5pbWF0aW9uIHNwZWVkIHNvIHRoYXQgaXQgZmluaXNoZXMgYXMgaWYgdGhlIG9yaWdpbmFsIGR1cmF0aW9uIHdhcyB0aGUgb25lIHNwZWNpZmllZCBoZXJlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGBcbiAgICogIHZhciByZXN1bHQgPSBhbmltYXRvci5hbmltYXRlKGVsLCB7b3BhY2l0eTogMC41fSwgMTAwMCk7XG4gICAqXG4gICAqICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgKiAgICByZXN1bHQuc3BlZWQoMjAwKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAqICAgICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAgICogICAgfSk7XG4gICAqICB9LCAzMDApO1xuICAgKiBgYGBgXG4gICAqL1xuICBhbmltYXRlKGVsLCBmaW5hbCwgZHVyYXRpb24gPSAyMDApIHtcbiAgICB2YXIgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICBpbml0aWFsID0ge30sXG4gICAgICAgIHN0b3BwZWQgPSBmYWxzZSxcbiAgICAgICAgbmV4dCA9IGZhbHNlLFxuICAgICAgICB0aW1lb3V0ID0gZmFsc2UsXG4gICAgICAgIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhmaW5hbCk7XG5cbiAgICB2YXIgdXBkYXRlU3R5bGVzID0gKCkgPT4ge1xuICAgICAgbGV0IHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocy5nZXRQcm9wZXJ0eVZhbHVlLmJpbmQocykpO1xuICAgICAgcyA9IGVsLm9mZnNldEhlaWdodDtcbiAgICB9O1xuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHN0b3A6IChvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHZhciBrID0gTWF0aC5taW4oMSwgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyBkdXJhdGlvbik7XG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZVtpXSA9ICgxIC0gaykgKiBpbml0aWFsW2ldICsgayAqIGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RvcE5leHQpIHtcbiAgICAgICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHRoZW46IChjYikgPT4ge1xuICAgICAgICBuZXh0ID0gY2I7XG4gICAgICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBzcGVlZDogKG5ld0R1cmF0aW9uKSA9PiB7XG4gICAgICAgIGlmIChpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbmV3RHVyYXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgICAgY29uc3QgcGFzc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xuICAgICAgICAgIGNvbnN0ICBrID0gcGFzc2VkIC8gZHVyYXRpb247XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gbmV3RHVyYXRpb24gKiAoMSAtIGspO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgZWwuc3R5bGVbaV0gPSAoMSAtIGspICogaW5pdGlhbFtpXSArIGsgKiBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB1cGRhdGVTdHlsZXMoKTtcblxuICAgICAgICAgIHN0YXJ0ID0gZWwuc3BlZWRVcFRpbWU7XG4gICAgICAgICAgZHVyYXRpb24gPSByZW1haW5pbmc7XG5cbiAgICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBlbC5zdHlsZVtpXSA9IGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc3VsdC5zdG9wLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgZmluaXNoOiAobWlsbGlzZWNvbmRzID0gNTApID0+IHtcbiAgICAgICAgdmFyIGsgPSAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xuXG4gICAgICAgIHJlc3VsdC5zcGVlZChtaWxsaXNlY29uZHMgLyAoMSAtIGspKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBzdG9wcGVkIHx8IGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgIGNvbnN0IHYgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoZSkpO1xuICAgICAgaW5pdGlhbFtlXSA9IGlzTmFOKHYpID8gMCA6IHY7XG4gICAgfSk7XG5cblxuICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gcHJvcGVydGllcy5qb2luKCcsJyk7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cbiAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgZWwuc3R5bGVbZV0gPSBmaW5hbFtlXSArIChlID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZXN1bHQuc3RvcCwgZHVyYXRpb24pO1xuICAgIHRoaXMuX29uU3RvcEFuaW1hdGlvbnMoZWwsIHJlc3VsdC5zdG9wKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgfVxuXG4gIF9vblN0b3BBbmltYXRpb25zKGVsLCBsaXN0ZW5lcikge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBpID0gdGhpcy5faW5kZXgrKztcbiAgICBxdWV1ZVtlbF0gPSBxdWV1ZVtlbF0gfHwgW107XG4gICAgcXVldWVbZWxdW2ldID0gKG9wdGlvbnMpID0+IHtcbiAgICAgIGRlbGV0ZSBxdWV1ZVtlbF1baV07XG4gICAgICBpZiAocXVldWVbZWxdICYmIHF1ZXVlW2VsXS5sZW5ndGggPT0gMCkge1xuICAgICAgICBkZWxldGUgcXVldWVbZWxdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVyKG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIHN0b3BBbmltYXRpb25zXG4gICogQGRlc2Mgc3RvcHMgYWN0aXZlIGFuaW1hdGlvbnMgb24gYSBzcGVjaWZpZWQgZWxlbWVudFxuICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWxlbWVudCAtIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHNcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdG9wTmV4dF0gLSB0aGUgY2FsbGJhY2tzIGFmdGVyIHRoZSBhbmltYXRpb25zIHdvbid0IGJlIGNhbGxlZCBpZiB0aGlzIG9wdGlvbiBpcyB0cnVlXG4gICovXG4gIHN0b3BBbmltYXRpb25zKGVsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgIHJldHVybiBlbC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9ucyhlbCwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAodGhpcy5fcXVldWVbZWxdIHx8IFtdKS5mb3JFYWNoKGUgPT4geyBlKG9wdGlvbnMgfHwge30pOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2Qgc3RvcEFsbFxuICAqIEBkZXNjIHN0b3BzIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3BOZXh0XSAtIHRoZSBjYWxsYmFja3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgd29uJ3QgYmUgY2FsbGVkIGlmIHRoaXMgb3B0aW9uIGlzIHRydWVcbiAgKi9cbiAgc3RvcEFsbChvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnN0b3BBbmltYXRpb25zKE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIGZhZGVcbiAgKiBAZGVzYyBmYWRlcyB0aGUgZWxlbWVudCAoc2hvcnQgdmVyc2lvbiBmb3IgYW5pbWF0ZShlbCwge29wYWNpdHk6IDB9KSlcbiAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF1cbiAgKi9cbiAgZmFkZShlbCwgZHVyYXRpb24gPSAyMDApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKGVsLCB7b3BhY2l0eTogMH0sIGR1cmF0aW9uKTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdG9yQ1NTO1xuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yLWNzcyc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXJpcHBsZVxuICogQGNhdGVnb3J5IHJpcHBsZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBZGRzIGEgTWF0ZXJpYWwgRGVzaWduIFwicmlwcGxlXCIgZWZmZWN0IHRvIGFuIGVsZW1lbnQuIFRoZSByaXBwbGUgZWZmZWN0IHdpbGwgc3ByZWFkIGZyb20gdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSB1c2VyIHRhcHMuXG4gKlxuICogICAgIFNvbWUgZWxlbWVudHMgc3VjaCBhcyBgPG9ucy1idXR0b24+YCBhbmQgYDxvbnMtZmFiPmAgIHN1cHBvcnQgYSBgcmlwcGxlYCBhdHRyaWJ1dGUuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg6rjg4Pjg5fjg6vlirnmnpzjgpJET03opoHntKDjgavov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gd0tRV2RaXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcmlwcGxlXG4gKiBAZXhhbXBsZVxuICogPGRpdiBjbGFzcz1cIm15LWRpdlwiPlxuICogIDxvbnMtcmlwcGxlPjwvb25zLXJpcHBsZT5cbiAqIDwvZGl2PlxuICpcbiAqIDxvbnMtYnV0dG9uIHJpcHBsZT5DbGljayBtZSE8L29ucy1idXR0b24+XG4gKi9cbmNsYXNzIFJpcHBsZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSByaXBwbGUgZWZmZWN0LlsvZW5dXG4gICAqICAgW2phXeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGJhY2tncm91bmRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kLlsvZW5dXG4gICAqICAgW2phXeiDjOaZr+OBruiJsuOCkuioreWumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIHRoZSByaXBwbGUgZWZmZWN0IHdpbGwgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Oq44OD44OX44Or44Ko44OV44Kn44Kv44OI44Gv54Sh5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncmlwcGxlJyk7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IHRoaXMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmlwcGxlX19iYWNrZ3JvdW5kJylbMF07XG4gICAgICB0aGlzLl93YXZlID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaXBwbGVfX3dhdmUnKVswXTtcbiAgICB9XG5cbiAgICB0aGlzLl9hbmltYXRvciA9IG5ldyBBbmltYXRvcigpO1xuXG4gICAgWydjb2xvcicsICdjZW50ZXInLCAnc3RhcnQtcmFkaXVzJywgJ2JhY2tncm91bmQnXS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZSwgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgWydfd2F2ZScsICdfYmFja2dyb3VuZCddLmZvckVhY2goZSA9PiB7XG4gICAgICB0aGlzW2VdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzW2VdLmNsYXNzTGlzdC5hZGQoJ3JpcHBsZV8nICsgZSk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXNbZV0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBfY2FsY3VsYXRlQ29vcmRzKGUpIHtcbiAgICB2YXIgeCwgeSwgaCwgdywgcjtcbiAgICB2YXIgYiA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKHRoaXMuX2NlbnRlcikge1xuICAgICAgeCA9IGIud2lkdGggLyAyO1xuICAgICAgeSA9IGIuaGVpZ2h0IC8gMjtcbiAgICAgIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAoZS5jbGllbnRYIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCkgLSBiLmxlZnQ7XG4gICAgICB5ID0gKGUuY2xpZW50WSB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkpIC0gYi50b3A7XG4gICAgICBoID0gTWF0aC5tYXgoeSwgYi5oZWlnaHQgLSB5KTtcbiAgICAgIHcgPSBNYXRoLm1heCh4LCBiLndpZHRoIC0geCk7XG4gICAgICByID0gTWF0aC5zcXJ0KGggKiBoICsgdyAqIHcpO1xuICAgIH1cbiAgICByZXR1cm4ge3gsIHksIHJ9O1xuICB9XG5cbiAgX3JpcHBsZUFuaW1hdGlvbihlLCBkdXJhdGlvbiA9IDMwMCkge1xuICAgIHZhclxuICAgICAge19hbmltYXRvciwgX3dhdmUsIF9iYWNrZ3JvdW5kLCBfbWluUn0gPSB0aGlzLFxuICAgICAge3gsIHksIHJ9ID0gdGhpcy5fY2FsY3VsYXRlQ29vcmRzKGUpO1xuXG4gICAgX2FuaW1hdG9yLnN0b3BBbGwoe3N0b3BOZXh0OiAxfSk7XG4gICAgX2FuaW1hdG9yLmFuaW1hdGUoX2JhY2tncm91bmQsIHtvcGFjaXR5OiAxfSwgZHVyYXRpb24pO1xuXG4gICAgdXRpbC5leHRlbmQoX3dhdmUuc3R5bGUsIHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB0b3A6IHkgLSBfbWluUiArICdweCcsXG4gICAgICBsZWZ0OiB4IC0gX21pblIgKyAncHgnLFxuICAgICAgd2lkdGg6IDIgKiBfbWluUiArICdweCcsXG4gICAgICBoZWlnaHQ6IDIgKiBfbWluUiArICdweCdcbiAgICB9KTtcblxuICAgIHJldHVybiBfYW5pbWF0b3IuYW5pbWF0ZShfd2F2ZSwge1xuICAgICAgdG9wOiB5IC0gcixcbiAgICAgIGxlZnQ6IHggLSByLFxuICAgICAgaGVpZ2h0OiAyICogcixcbiAgICAgIHdpZHRoOiAyICogclxuICAgIH0sIGR1cmF0aW9uKTtcbiAgfVxuXG4gIF91cGRhdGVQYXJlbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9wYXJlbnRVcGRhdGVkICYmIHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMucGFyZW50Tm9kZSk7XG4gICAgICBpZiAoY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGFyZW50VXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgX29uVGFwKGUpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVBhcmVudCgpO1xuICAgICAgdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fd2F2ZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfb25Ib2xkKGUpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVBhcmVudCgpO1xuICAgICAgdGhpcy5faG9sZGluZyA9IHRoaXMuX3JpcHBsZUFuaW1hdGlvbihlLmdlc3R1cmUuc3JjRXZlbnQsIDIwMDApO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcbiAgICB9XG4gIH1cblxuICBfb25SZWxlYXNlKGUpIHtcbiAgICBpZiAodGhpcy5faG9sZGluZykge1xuICAgICAgdGhpcy5faG9sZGluZy5zcGVlZCgzMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9hbmltYXRvci5zdG9wQWxsKHtzdG9wTmV4dDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX3dhdmUpO1xuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX2JhY2tncm91bmQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2hvbGRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGUpIHtcbiAgICBpZiAodGhpcy5faG9sZGluZykge1xuICAgICAgcmV0dXJuIHRoaXMuX29uUmVsZWFzZShlKTtcbiAgICB9XG4gICAgaWYgKFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZS5nZXN0dXJlLmRpcmVjdGlvbikgIT0gLTEpIHtcbiAgICAgIHRoaXMuX29uVGFwKGUpO1xuICAgIH1cbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICB0aGlzLl9ib3VuZE9uVGFwID0gdGhpcy5fb25UYXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uSG9sZCA9IHRoaXMuX29uSG9sZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9ib3VuZE9uSG9sZCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFyZW50Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLl9ib3VuZE9uVGFwKTtcbiAgICB0aGlzLl9wYXJlbnROb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9ib3VuZE9uSG9sZCk7XG4gICAgdGhpcy5fcGFyZW50Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdzdGFydC1yYWRpdXMnKSB7XG4gICAgICB0aGlzLl9taW5SID0gTWF0aC5tYXgoMCwgcGFyc2VGbG9hdChjdXJyZW50KSB8fCAwKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdjb2xvcicgJiYgY3VycmVudCkge1xuICAgICAgdGhpcy5fd2F2ZS5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ2JhY2tncm91bmQnKSkge1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2JhY2tncm91bmQnICYmIChjdXJyZW50IHx8IGxhc3QpKSB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdjZW50ZXInKSB7XG4gICAgICB0aGlzLl9jZW50ZXIgPSBjdXJyZW50ICE9IG51bGwgJiYgY3VycmVudCAhPSAnZmFsc2UnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cbn1cblxud2luZG93Lk9uc1JpcHBsZUVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1yaXBwbGUnLCB7XG4gIHByb3RvdHlwZTogUmlwcGxlRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcm93XG4gKiBAY2F0ZWdvcnkgZ3JpZFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgcm93IGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggYDxvbnMtY29sPmAgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cbiAqICAgW2phXeOCsOODquODg+ODieOCt+OCueODhuODoOOBq+OBpuihjOOCkuWumue+qeOBl+OBvuOBmeOAgm9ucy1jb2zjgajjgajjgoLjgavkvb/nlKjjgZfjgIHjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7phY3nva7jgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gR2d1akMge3dpZGV9XG4gKiBAZ3VpZGUgTGF5b3V0aW5nXG4gKiAgIFtlbl1MYXlvdXRpbmcgZ3VpZGVbL2VuXVxuICogICBbamFd44Os44Kk44Ki44Km44OI6Kq/5pW0Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1jb2xcbiAqICAgW2VuXVRoZSBgPG9ucy1jb2w+YCBjb21wb25lbnQgaXMgdXNlZCBhcyBjaGlsZHJlbiBvZiBgPG9ucy1yb3c+YC5bL2VuXVxuICogICBbamFdb25zLWNvbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgdmVydGljYWwtYWxpZ24uWy9lbl1cbiAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29s44KS57WE44G/5ZCI44KP44Gb44Gm44Gd44KM44Ge44KM44Gub25zLWNvbOimgee0oOOBrnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr5Yil44CF44Gu5YCk44KS5oyH5a6a44GZ44KL44Go44CB5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCdmVydGljYWwtYWxpZ27lsZ7mgKfjga7lgKTjgavjga/kuIDjgaTjga7lgKTjgaDjgZHjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNob3J0IGhhbmQgYXR0cmlidXRlIGZvciBhbGlnbmluZyB2ZXJ0aWNhbGx5LiBWYWxpZCB2YWx1ZXMgYXJlIHRvcCwgYm90dG9tLCBhbmQgY2VudGVyLlsvZW5dXG4gKiAgIFtqYV3nuKbjgavmlbTliJfjgZnjgovjgZ/jgoHjgavmjIflrprjgZfjgb7jgZnjgIJ0b3DjgIFib3R0b23jgIFjZW50ZXLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICovXG53aW5kb3cuT25zUm93RWxlbWVudCA9IHdpbmRvdy5PbnNSb3dFbGVtZW50ID8gd2luZG93Lk9uc1Jvd0VsZW1lbnQgOiBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1yb3cnKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzcGVlZC1kaWFsX19pdGVtLS0qJyxcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWwtaXRlbVxuICogQGNhdGVnb3J5IHNwZWVkLWRpYWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGlzcGxheXMgdGhlIGNoaWxkIGVsZW1lbnRzIG9mIHRoZSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgZGlhbCBjb21wb25lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICBNYXRlcmlhbCBEZXNpZ27jga5TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6KGo54++44GZ44KL6KaB57Sg44Gn44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAY29kZXBlbiBkWVFZTGdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGVlZC1kaWFsXG4gKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbFxuICogICBbZW5dVGhlIGA8b25zLXNwZWVkLWRpYWw+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy1zcGVlZC1kaWFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwZWVkLWRpYWwgcG9zaXRpb249XCJsZWZ0IGJvdHRvbVwiPlxuICogICA8b25zLWZhYj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPlxuICogICA8L29ucy1mYWI+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkE8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkI8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkM8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiA8L29ucy1zcGVlZC1kaWFsPlxuICovXG5jbGFzcyBTcGVlZERpYWxJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGNvbXBvbmVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpO1xuXG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cblxuICBfb25DbGljayhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWInKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tbWluaScpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc3BlZWQtZGlhbF9faXRlbScpO1xuXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cbn1cblxud2luZG93Lk9uc1NwZWVkRGlhbEl0ZW1FbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BlZWQtZGlhbC1pdGVtJywge1xuICBwcm90b3R5cGU6IFNwZWVkRGlhbEl0ZW1FbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG4vKipcbiAqIE1pbmltYWwgdXRpbGl0eSBsaWJyYXJ5IGZvciBtYW5pcHVsYXRpbmcgZWxlbWVudCdzIHN0eWxlLlxuICovXG5jb25zdCBzdHlsZXIgPSBmdW5jdGlvbihlbGVtZW50LCBzdHlsZSkge1xuICByZXR1cm4gc3R5bGVyLmNzcy5hcHBseShzdHlsZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFNldCBlbGVtZW50J3Mgc3R5bGUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5zdHlsZXIuY3NzID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGVzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3R5bGVzKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChrZXkgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVzW2tleV07XG4gICAgfSBlbHNlIGlmIChzdHlsZXIuX3ByZWZpeChrZXkpIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVyLl9wcmVmaXgoa2V5KV0gPSBzdHlsZXNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdObyBzdWNoIHN0eWxlIHByb3BlcnR5OiAnICsga2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQWRkIHZlbmRvciBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuc3R5bGVyLl9wcmVmaXggPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcbiAgdmFyIHByZWZpeCA9IChBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAuY2FsbChzdHlsZXMpXG4gICAgLmpvaW4oJycpXG4gICAgLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pIHx8IChzdHlsZXMuT0xpbmsgPT09ICcnICYmIFsnJywgJ28nXSlcbiAgKVsxXTtcblxuICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBwcmVmaXggKyBuYW1lLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICovXG5zdHlsZXIuY2xlYXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHN0eWxlci5fY2xlYXIoZWxlbWVudCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICovXG5zdHlsZXIuX2NsZWFyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgbGVuID0gZWxlbWVudC5zdHlsZS5sZW5ndGg7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXlzLnB1c2goc3R5bGVbaV0pO1xuICB9XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIHN0eWxlW2tleV0gPSAnJztcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdHlsZXI7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJ2xpYi9zdHlsZXInO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnc3BlZWQtZGlhbC0tKicsXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGVlZC1kaWFsXG4gKiBAY2F0ZWdvcnkgc3BlZWQtZGlhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBFbGVtZW50IHRoYXQgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgRGlhbG9nIGNvbXBvbmVudC4gSXQgaXMgdXNlZnVsIHdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgcHJpbWFyeSBhY3Rpb24gdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGluIGEgcGFnZS5cbiAqXG4gKiAgICAgVGhlIFNwZWVkIGRpYWwgbG9va3MgbGlrZSBhIGA8b25zLWZhYj5gIGVsZW1lbnQgYnV0IHdpbGwgZXhwYW5kIGEgbWVudSB3aGVuIHRhcHBlZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBkWVFZTGdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGVlZC1kaWFsXG4gKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbC1pdGVtXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbC1pdGVtPmAgcmVwcmVzZW50cyBhIG1lbnUgaXRlbS5bL2VuXVxuICogICBbamFdb25zLXNwZWVkLWRpYWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGVlZC1kaWFsIHBvc2l0aW9uPVwibGVmdCBib3R0b21cIj5cbiAqICAgPG9ucy1mYWI+XG4gKiAgICAgPG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj5cbiAqICAgPC9vbnMtZmFiPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5BPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5CPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5DPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogPC9vbnMtc3BlZWQtZGlhbD5cbiAqL1xuY2xhc3MgU3BlZWREaWFsRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IG9wZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIG1lbnUgaXRlbXMgYXJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgY2xvc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIG1lbnUgaXRlbXMgYXJlIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGNvbXBvbmVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTcGVjaWZ5IHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgY29tcG9uZW50LlxuICAgKiAgICAgSS5lLiB0byBkaXNwbGF5IGl0IGluIHRoZSB0b3AgcmlnaHQgY29ybmVyIHNwZWNpZnkgXCJyaWdodCB0b3BcIi5cbiAgICogICAgIENob29zZSBmcm9tIFwicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIgYW5kIFwiYm90dG9tXCIuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgZPjga7opoHntKDjgpLooajnpLrjgZnjgovlt6blj7PjgajkuIrkuIvjga7kvY3nva7jgpLmjIflrprjgZfjgb7jgZnjgIJcbiAgICogICAgIOS+i+OBiOOBsOOAgeWPs+S4iuOBq+ihqOekuuOBmeOCi+WgtOWQiOOBq+OBr1wicmlnaHQgdG9wXCLjgpLmjIflrprjgZfjgb7jgZnjgIJcbiAgICogICAgIOW3puWPs+OBqOS4iuS4i+OBruS9jee9ruOBruaMh+WumuOBq+OBr+OAgXJpZ2h044GobGVmdOOAgXRvcOOBqGJvdHRvbeOBjOOBneOCjOOBnuOCjOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgZGlyZWN0aW9uIHRoZSBpdGVtcyBhcmUgZGlzcGxheWVkLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiIGFuZCBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDopoHntKDjgYzooajnpLrjgZnjgovmlrnlkJHjgpLmjIflrprjgZfjgb7jgZnjgIJ1cCwgZG93biwgbGVmdCwgcmlnaHTjgYzmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2hvd24gPSB0cnVlO1xuICAgIHRoaXMuX2l0ZW1TaG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGlmICghdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ3NwZWVkX19kaWFsJykpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc3BlZWRfX2RpYWwnKTtcbiAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGlyZWN0aW9uJykpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oJ3VwJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlyZWN0aW9uJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURpcmVjdGlvbihjdXJyZW50KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUG9zaXRpb24oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnb25zLXNwZWVkLWRpYWwtaXRlbScpKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGUpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5fc2hvd24pIHtcbiAgICAgIHRoaXMudG9nZ2xlSXRlbXMoKTtcbiAgICB9XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuaW5saW5lKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5saW5lKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIGNvbnN0IGZhYiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtZmFiJyk7XG5cbiAgICBpZiAoZmFiKSB7XG4gICAgICB0aGlzLmhhc0F0dHJpYnV0ZSgncmlwcGxlJykgPyBmYWIuc2V0QXR0cmlidXRlKCdyaXBwbGUnLCAnJykgOiBmYWIucmVtb3ZlQXR0cmlidXRlKCdyaXBwbGUnKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdHlsZXIoY2hpbGRyZW5baV0sIHtcbiAgICAgICAgdHJhbnNpdGlvbkRlbGF5OiAyNSAqIGkgKyAnbXMnLFxuICAgICAgICBib3R0b206ICdhdXRvJyxcbiAgICAgICAgcmlnaHQ6ICdhdXRvJyxcbiAgICAgICAgdG9wOiAnYXV0bycsXG4gICAgICAgIGxlZnQ6ICdhdXRvJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlICd1cCc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5ib3R0b20gPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUucmlnaHQgPSAnOHB4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSAnOHB4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gJzhweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUucmlnaHQgPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSAnOHB4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5sZWZ0ID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB1cCwgZG93biwgbGVmdCBvciByaWdodC4nKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAnZmFiLS10b3BfX2xlZnQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19yaWdodCcsXG4gICAgICAnZmFiLS1ib3R0b21fX2xlZnQnLFxuICAgICAgJ2ZhYi0tdG9wX19yaWdodCcsXG4gICAgICAnZmFiLS10b3BfX2NlbnRlcicsXG4gICAgICAnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgIHN3aXRjaChwb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICBjYXNlICd0b3AgY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICBjYXNlICdib3R0b20gY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgc3BlZWQgZGlhbC5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNob3cob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtZmFiJykuc2hvdygpO1xuICAgIHRoaXMuX3Nob3duID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuaGlkZUl0ZW1zKCk7XG4gICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtZmFiJykuaGlkZSgpO1xuICAgIH0sIDIwMCk7XG4gICAgdGhpcy5fc2hvd24gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dJdGVtc1xuICAgKiBAc2lnbmF0dXJlIHNob3dJdGVtcygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBzcGVlZCBkaWFsIGl0ZW1zLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2hvd0l0ZW1zKCkge1xuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2l0ZW1TaG93bikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdHlsZXIoY2hpbGRyZW5baV0sIHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKScsXG4gICAgICAgICAgdHJhbnNpdGlvbkRlbGF5OiAyNSAqIGkgKyAnbXMnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pdGVtU2hvd24gPSB0cnVlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdvcGVuJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlSXRlbXNcbiAgICogQHNpZ25hdHVyZSBoaWRlSXRlbXMoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgc3BlZWQgZGlhbCBpdGVtcy5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGhpZGVJdGVtcygpIHtcbiAgICBpZiAodGhpcy5faXRlbVNob3duKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDApJyxcbiAgICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IDI1ICogKGNoaWxkcmVuLmxlbmd0aCAtIGkpICsgJ21zJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faXRlbVNob3duID0gZmFsc2U7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjbG9zZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuaGlkZUl0ZW1zKCk7XG4gICAgfVxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZSA9PiB7XG4gICAgICB1dGlsLm1hdGNoKGUsICcuZmFiJykgJiYgdXRpbC50b2dnbGVBdHRyaWJ1dGUoZSwgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGlubGluZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGlubGluZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd44Kk44Oz44Op44Kk44Oz6KaB57Sg44Gu5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCBpbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmxpbmUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hvd24gJiYgdGhpcy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc09wZW5cbiAgICogQHNpZ25hdHVyZSBpc09wZW4oKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBtZW51IGlzIG9wZW4gb3Igbm90LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1TaG93bjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu6KGo56S66Z2e6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnZpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlSXRlbXNcbiAgICogQHNpZ25hdHVyZSB0b2dnbGVJdGVtcygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgaXRlbSB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjga7ooajnpLrpnZ7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgdG9nZ2xlSXRlbXMoKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRoaXMuaGlkZUl0ZW1zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvd0l0ZW1zKCk7XG4gICAgfVxuICB9XG59XG5cbndpbmRvdy5PbnNTcGVlZERpYWxFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BlZWQtZGlhbCcsIHtcbiAgcHJvdG90eXBlOiBTcGVlZERpYWxFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRnJhZ21lbnR9IHRhcmdldFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgbGluayhlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodGFyZ2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItY29udGVudFxuICogQGNhdGVnb3J5IHNwbGl0dGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cbiAqXG4gKiAgICBJdCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlIHdoaWxlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb250YWlucyB0aGUgbGlzdC5cbiAqICBbL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGNvbXBvbmVudCBpcyB0aGUgcGFyZW50IGVsZW1lbnQuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1zaWRlXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtZW51LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyPlxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKlxuICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKi9cbmNsYXNzIFNwbGl0dGVyQ29udGVudEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgdXJsIG9mIHRoZSBjb250ZW50IHBhZ2UuIElmIHRoaXMgYXR0cmlidXRlIGlzIHVzZWQgdGhlIGNvbnRlbnQgd2lsbCBiZSBsb2FkZWQgZnJvbSBhIGA8b25zLXRlbXBsYXRlPmAgdGFnIG9yIGEgcmVtb3RlIGZpbGUuXG4gICAqXG4gICAqICAgICBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHB1dCBgPG9ucy1wYWdlPmAgZWxlbWVudCBhcyBhIGNoaWxkIG9mIHRoZSBlbGVtZW50LlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXW9ucy1zcGxpdHRlci1jb250ZW506KaB57Sg44Gr6KGo56S644GZ44KL44Oa44O844K444GuVVJM44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9wYWdlID0gbnVsbDtcbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwib25zLXNwbGl0dGVyLWNvbnRlbnRcIiBtdXN0IGhhdmUgXCJvbnMtc3BsaXR0ZXJcIiBhcyBwYXJlbnROb2RlLmApO1xuICAgIH1cbiAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygncGFnZScsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJykpO1xuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHt9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3BhZ2UnICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHRoaXMubG9hZChjdXJyZW50KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QYWdlIGVsZW1lbnQgbG9hZGVkIGluIHRoZSBzcGxpdHRlciBjb250ZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHNpZ25hdHVyZSBsb2FkKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2UsIFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIGA8b25zLXRlbXBsYXRlPmAgaWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgW9ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHBhZ2Ugc3BlY2lmaWVkIGluIGBwYWdlYCBpbiB0aGUgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9VUkzjgpLjg6HjgqTjg7Pjg5rjg7zjgrjjgpLoqq3jgb/ovrzjgb/jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgbmV3IGA8b25zLXBhZ2U+YCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGxvYWQocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXG4gICAgcmV0dXJuIGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgcmV3cml0YWJsZXMubGluayh0aGlzLCB1dGlsLmNyZWF0ZUZyYWdtZW50KGh0bWwpLCBvcHRpb25zLCBmcmFnbWVudCA9PiB7XG4gICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblxuICAgICAgICB0aGlzLl9zaG93KCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgIHJlc29sdmUodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfc2hvdycpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19oaWRlJyk7XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2Rlc3Ryb3knKTtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG59XG5cbndpbmRvdy5PbnNTcGxpdHRlckNvbnRlbnRFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BsaXR0ZXItY29udGVudCcsIHtcbiAgcHJvdG90eXBlOiBTcGxpdHRlckNvbnRlbnRFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbndpbmRvdy5PbnNTcGxpdHRlckNvbnRlbnRFbGVtZW50LnJld3JpdGFibGVzID0gcmV3cml0YWJsZXM7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5cbmNsYXNzIFNwbGl0dGVyTWFza0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5fc2lkZXMuZm9yRWFjaChzaWRlID0+IHNpZGUuY2xvc2UoJ2xlZnQnKS5jYXRjaCgoKSA9PiB7fSkpO1xuICAgIH1cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2spO1xuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrKTtcbiAgfVxufVxuXG53aW5kb3cuT25zU3BsaXR0ZXJNYXNrRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXNwbGl0dGVyLW1hc2snLCB7XG4gIHByb3RvdHlwZTogU3BsaXR0ZXJNYXNrRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLFxuICAgICAgZHVyYXRpb246ICcwLjMnLFxuICAgICAgZGVsYXk6ICcwJ1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgdXBkYXRlT3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLl90aW1pbmcgPSB0aGlzLl9vcHRpb25zLnRpbWluZztcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX29wdGlvbnMuZHVyYXRpb247XG4gICAgdGhpcy5fZGVsYXkgPSB0aGlzLl9vcHRpb25zLmRlbGF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc2lkZUVsZW1lbnRcbiAgICovXG4gIGFjdGl2YXRlKHNpZGVFbGVtZW50KSB7XG4gICAgY29uc3Qgc3BsaXR0ZXIgPSBzaWRlRWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgY29udGVudFJlYWR5KHNwbGl0dGVyLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zaWRlID0gc2lkZUVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZW50ID0gc3BsaXR0ZXIuY29udGVudDtcbiAgICAgIHRoaXMuX21hc2sgPSBzcGxpdHRlci5tYXNrO1xuICAgIH0pO1xuICB9XG5cbiAgaW5hY3RpdmF0ZSgpIHtcbiAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fc2lkZSA9IHRoaXMuX21hc2sgPSBudWxsO1xuICB9XG5cbiAgZ2V0IG1pbnVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zaWRlLl9zaWRlID09PSAncmlnaHQnID8gJy0nIDogJyc7XG4gIH1cblxuICB0cmFuc2xhdGUoZGlzdGFuY2UpIHtcbiAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51cyArIGRpc3RhbmNlfXB4LCAwcHgsIDBweClgXG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBvcGVuKGRvbmUpIHtcbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgIC53YWl0KHRoaXMuX2RlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51c30xMDAlLCAwcHgsIDBweClgXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLl90aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuX2RlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAnMSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgY2xvc2UoZG9uZSkge1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLl9kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMuX3RpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIHRoaXMuX3NpZGUuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5fZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogJzAnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlclxuICogQGNhdGVnb3J5IHNwbGl0dGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIGNvbXBvbmVudCB0aGF0IGVuYWJsZXMgcmVzcG9uc2l2ZSBsYXlvdXQgYnkgaW1wbGVtZW50aW5nIGJvdGggYSB0d28tY29sdW1uIGxheW91dCBhbmQgYSBzbGlkaW5nIG1lbnUgbGF5b3V0LlxuICpcbiAqICAgIEl0IGNhbiBiZSBjb25maWd1cmVkIHRvIGF1dG9tYXRpY2FsbHkgZXhwYW5kIGludG8gYSBjb2x1bW4gbGF5b3V0IG9uIGxhcmdlIHNjcmVlbnMgYW5kIGNvbGxhcHNlIHRoZSBtZW51IG9uIHNtYWxsZXIgc2NyZWVucy4gV2hlbiB0aGUgbWVudSBpcyBjb2xsYXBzZWQgdGhlIHVzZXIgY2FuIG9wZW4gaXQgYnkgc3dpcGluZy5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1jb250ZW50XG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLXNpZGVcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1lbnUuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGd1aWRlIENhbGxpbmdDb21wb25lbnRBUElzZnJvbUphdmFTY3JpcHRcbiAqICAgW2VuXVVzaW5nIGNvbXBvbmVudHMgZnJvbSBKYXZhU2NyaXB0Wy9lbl1cbiAqICAgW2phXUphdmFTY3JpcHTjgYvjgonjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLlkbzjgbPlh7rjgZlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BsaXR0ZXIgaWQ9XCJzcGxpdHRlclwiPlxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKlxuICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlIHN3aXBlYWJsZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIHZhciBzcGxpdHRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzcGxpdHRlcicpO1xuICogICBzcGxpdHRlci5sZWZ0Lm9wZW4oKTtcbiAqIDwvc2NyaXB0PlxuICovXG5jbGFzcyBTcGxpdHRlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgX2dldFNpZGUoc2lkZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCBlID0+IHtcbiAgICAgIHJldHVybiB1dGlsLm1hdGNoKGUsICdvbnMtc3BsaXR0ZXItc2lkZScpICYmIGUuZ2V0QXR0cmlidXRlKCdzaWRlJykgPT09IHNpZGU7XG4gICAgfSk7XG4gICAgZWxlbWVudCAmJiBDdXN0b21FbGVtZW50cy51cGdyYWRlKGVsZW1lbnQpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBsZWZ0XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1MZWZ0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgbGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZSgnbGVmdCcpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcmlnaHRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJpZ2h0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNpZGUoJ3JpZ2h0Jyk7XG4gIH1cblxuICBnZXQgX3NpZGVzKCkge1xuICAgIHJldHVybiBbdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0XS5maWx0ZXIoZSA9PiBlKTtcbiAgfVxuICAvKipcbiAgICogQHByb3BlcnR5IGNvbnRlbnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IG1hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItbWFzaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgdGhpcy5fc2lkZXMuc29tZShzID0+IHMuaXNPcGVuID8gcy5jbG9zZSgpIDogZmFsc2UpIHx8IGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gIH1cblxuICBfb25Nb2RlQ2hhbmdlKGUpIHtcbiAgICBpZiAoZS50YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fbGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfbGF5b3V0KCkge1xuICAgIHRoaXMuX3NpZGVzLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICB0aGlzLmNvbnRlbnQuc3R5bGVbc2lkZS5fc2lkZV0gPSBzaWRlLm1vZGUgPT09ICdzcGxpdCcgPyBzaWRlLl93aWR0aCA6IDA7XG4gICAgfSk7XG4gIH1cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYm91bmRPbk1vZGVDaGFuZ2UgPSB0aGlzLl9vbk1vZGVDaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLl9sYXlvdXQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGlmICghdGhpcy5tYXNrKSB7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy1zcGxpdHRlci1tYXNrJykpO1xuICAgIH1cbiAgfVxuXG4gIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vZGVjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uTW9kZUNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cblxuICBfc2hvdygpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfaGlkZScpO1xuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxufVxuXG53aW5kb3cuT25zU3BsaXR0ZXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BsaXR0ZXInLCB7XG4gIHByb3RvdHlwZTogU3BsaXR0ZXJFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbndpbmRvdy5PbnNTcGxpdHRlckVsZW1lbnQuX2FuaW1hdG9yRGljdCA9IHtcbiAgZGVmYXVsdDogU3BsaXR0ZXJBbmltYXRvcixcbiAgb3ZlcmxheTogU3BsaXR0ZXJBbmltYXRvclxufTtcblxud2luZG93Lk9uc1NwbGl0dGVyRWxlbWVudC5yZWdpc3RlckFuaW1hdG9yID0gZnVuY3Rpb24obmFtZSwgQW5pbWF0b3IpIHtcbiAgaWYgKCEoQW5pbWF0b3IgaW5zdGFuY2VvZiBTcGxpdHRlckFuaW1hdG9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQW5pbWF0b3IgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgU3BsaXR0ZXJBbmltYXRvci4nKTtcbiAgfVxuICB3aW5kb3cuT25zU3BsaXR0ZXJFbGVtZW50Ll9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbn07XG5cbndpbmRvdy5PbnNTcGxpdHRlckVsZW1lbnQuU3BsaXR0ZXJBbmltYXRvciA9IFNwbGl0dGVyQW5pbWF0b3I7XG5cbmV4cG9ydCBkZWZhdWx0IE9uc1NwbGl0dGVyRWxlbWVudDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IG9yaWVudGF0aW9uIGZyb20gJ29ucy9vcmllbnRhdGlvbic7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9vbnMtc3BsaXR0ZXIvYW5pbWF0b3InO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICdvbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnb25zL2Rvb3Jsb2NrJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IE9uc1NwbGl0dGVyRWxlbWVudCBmcm9tICcuL29ucy1zcGxpdHRlcic7XG5cbmNvbnN0IFNQTElUX01PREUgPSAnc3BsaXQnO1xuY29uc3QgQ09MTEFQU0VfTU9ERSA9ICdjb2xsYXBzZSc7XG5jb25zdCBDTE9TRURfU1RBVEUgPSAnY2xvc2VkJztcbmNvbnN0IE9QRU5fU1RBVEUgPSAnb3Blbic7XG5jb25zdCBDSEFOR0lOR19TVEFURSA9ICdjaGFuZ2luZyc7XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzcGxpdHRlclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShzcGxpdHRlclNpZGVFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc3BsaXR0ZXJTaWRlRWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxGcmFnbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBsaW5rKHNwbGl0dGVyU2lkZUVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0YXJnZXQpO1xuICB9XG59O1xuXG5jbGFzcyBDb2xsYXBzZURldGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHRhcmdldCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRhcmdldCAmJiB0aGlzLmNoYW5nZVRhcmdldCh0YXJnZXQpO1xuICB9XG5cbiAgY2hhbmdlVGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFsncG9ydHJhaXQnLCAnbGFuZHNjYXBlJ10uaW5kZXhPZih0YXJnZXQpICE9PSAtMTtcbiAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICBfbWF0Y2godmFsdWUpIHtcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl90YXJnZXQgPT09ICh2YWx1ZS5pc1BvcnRyYWl0ID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLm1hdGNoZXM7XG4gIH1cblxuICBfb25DaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLl9lbGVtZW50Ll91cGRhdGVNb2RlKHRoaXMuX21hdGNoKHZhbHVlKSA/IENPTExBUFNFX01PREUgOiBTUExJVF9NT0RFKTtcbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgb3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgdGhpcy5fb25DaGFuZ2Uoe2lzUG9ydHJhaXQ6IG9yaWVudGF0aW9uLmlzUG9ydHJhaXQoKX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdCA9IHdpbmRvdy5tYXRjaE1lZGlhKHRoaXMuX3RhcmdldCk7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdC5hZGRMaXN0ZW5lcih0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHRoaXMuX3F1ZXJ5UmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3F1ZXJ5UmVzdWx0KSB7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgd2lkdGhUb1B4ID0gKHdpZHRoLCBwYXJlbnQpID0+IHtcbiAgY29uc3QgW3ZhbHVlLCBweF0gPSBbcGFyc2VJbnQod2lkdGgsIDEwKSwgL3B4Ly50ZXN0KHdpZHRoKV07XG4gIHJldHVybiBweCA/IHZhbHVlIDogTWF0aC5yb3VuZChwYXJlbnQub2Zmc2V0V2lkdGggKiB2YWx1ZSAvIDEwMCk7XG59O1xuXG5jbGFzcyBDb2xsYXBzZU1vZGUge1xuICBnZXQgX2FuaW1hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Ll9hbmltYXRvcjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NFRF9TVEFURTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9sb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gIH1cblxuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSAmJiB0aGlzLl9zdGF0ZSAhPT0gQ0xPU0VEX1NUQVRFO1xuICB9XG5cbiAgaGFuZGxlR2VzdHVyZShlKSB7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUgfHwgdGhpcy5fbG9jay5pc0xvY2tlZCgpIHx8IHRoaXMuX2lzT3Blbk90aGVyU2lkZU1lbnUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS50eXBlID09PSAnZHJhZ3N0YXJ0Jykge1xuICAgICAgdGhpcy5fb25EcmFnU3RhcnQoZSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgZS50eXBlID09PSAnZHJhZ2VuZCcgPyB0aGlzLl9vbkRyYWdFbmQoZSkgOiB0aGlzLl9vbkRyYWcoZSk7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3Qgc2Nyb2xsaW5nID0gIS9sZWZ0fHJpZ2h0Ly50ZXN0KGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuX2VsZW1lbnQuX3NpZGUgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFggOiB3aW5kb3cuaW5uZXJXaWR0aCAtIGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFg7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2VsZW1lbnQuX3N3aXBlVGFyZ2V0V2lkdGg7XG4gICAgY29uc3QgaXNPcGVuID0gdGhpcy5pc09wZW4oKTtcbiAgICB0aGlzLl9pZ25vcmVEcmFnID0gc2Nyb2xsaW5nIHx8IChhcmVhICYmIGRpc3RhbmNlID4gYXJlYSAmJiAhaXNPcGVuKTtcblxuICAgIHRoaXMuX3dpZHRoID0gd2lkdGhUb1B4KHRoaXMuX2VsZW1lbnQuX3dpZHRoLCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUpO1xuICAgIHRoaXMuX3N0YXJ0RGlzdGFuY2UgPSB0aGlzLl9kaXN0YW5jZSA9IGlzT3BlbiA/IHRoaXMuX3dpZHRoIDogMDtcbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgZGVsdGEgPSB0aGlzLl9lbGVtZW50Ll9zaWRlID09PSAnbGVmdCcgPyBldmVudC5nZXN0dXJlLmRlbHRhWCA6IC1ldmVudC5nZXN0dXJlLmRlbHRhWDtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuX3dpZHRoLCB0aGlzLl9zdGFydERpc3RhbmNlICsgZGVsdGEpKTtcbiAgICBpZiAoZGlzdGFuY2UgIT09IHRoaXMuX2Rpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9hbmltYXRvci50cmFuc2xhdGUoZGlzdGFuY2UpO1xuICAgICAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ0VuZChldmVudCkge1xuICAgIGNvbnN0IHtfZGlzdGFuY2U6IGRpc3RhbmNlLCBfd2lkdGg6IHdpZHRoLCBfZWxlbWVudDogZWx9ID0gdGhpcztcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgY29uc3Qgc2hvdWxkT3BlbiA9IGVsLl9zaWRlICE9PSBkaXJlY3Rpb24gJiYgZGlzdGFuY2UgPiB3aWR0aCAqIGVsLl90aHJlc2hvbGQ7XG4gICAgdGhpcy5leGVjdXRlQWN0aW9uKHNob3VsZE9wZW4gPyAnb3BlbicgOiAnY2xvc2UnKTtcbiAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTtcbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlICYmIHRoaXMuX3N0YXRlID09PSBPUEVOX1NUQVRFKSB7XG4gICAgICB0aGlzLl9hbmltYXRvci5vcGVuKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW50ZXIgY29sbGFwc2UgbW9kZVxuICBlbnRlck1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICB0aGlzLmxheW91dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4aXQgY29sbGFwc2UgbW9kZVxuICBleGl0TW9kZSgpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIF9pc09wZW5PdGhlclNpZGVNZW51KCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLl9lbGVtZW50LnBhcmVudEVsZW1lbnQuY2hpbGRyZW4pLnNvbWUoZSA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlLCAnb25zLXNwbGl0dGVyLXNpZGUnKSAmJiBlICE9PSB0aGlzLl9lbGVtZW50ICYmIGUuaXNPcGVuO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gJ29wZW4nIG9yICdjbG9zZSdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0QW5pbWF0aW9uXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlXG4gICAqL1xuICBleGVjdXRlQWN0aW9uKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IEZJTkFMX1NUQVRFID0gbmFtZSA9PT0gJ29wZW4nID8gT1BFTl9TVEFURSA6IENMT1NFRF9TVEFURTtcblxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IEZJTkFMX1NUQVRFKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbG9jay5pc0xvY2tlZCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1NwbGl0dGVyIHNpZGUgaXMgbG9ja2VkLicpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ29wZW4nICYmIHRoaXMuX2lzT3Blbk90aGVyU2lkZU1lbnUoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdBbm90aGVyIG1lbnUgaXMgYWxyZWFkeSBvcGVuLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZWxlbWVudC5fZW1pdEV2ZW50KGBwcmUke25hbWV9YCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgQ2FuY2VsZWQgaW4gcHJlJHtuYW1lfSBldmVudC5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgY29uc3QgdW5sb2NrID0gdGhpcy5fbG9jay5sb2NrKCk7XG4gICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXRlID0gRklOQUxfU1RBVEU7XG4gICAgICB0aGlzLmxheW91dCgpO1xuICAgICAgdW5sb2NrKCk7XG4gICAgICB0aGlzLl9lbGVtZW50Ll9lbWl0RXZlbnQoYHBvc3Qke25hbWV9YCk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy53aXRob3V0QW5pbWF0aW9uKSB7XG4gICAgICBkb25lKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZSA9IENIQU5HSU5HX1NUQVRFO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yW25hbWVdKCgpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICByZXNvbHZlKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItc2lkZVxuICogQGNhdGVnb3J5IHNwbGl0dGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cbiAqXG4gKiAgICBJdCB3aWxsIGJlIGRpc3BsYXllZCBvbiBlaXRoZXIgdGhlIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiB0aGUgYDxvbnMtc3BsaXR0ZS1jb250ZW50PmAgZWxlbWVudC5cbiAqXG4gKiAgICBJdCBzdXBwb3J0cyB0d28gbW9kZXM6IGNvbGxhcHNlZCBhbmQgc3BsaXQuIFdoZW4gaXQncyBpbiBjb2xsYXBzZWQgbW9kZSBpdCB3aWxsIGJlIGhpZGRlbiBmcm9tIHZpZXcgYW5kIGNhbiBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgdXNlciBzd2lwZXMgdGhlIHNjcmVlbiBvciB0YXBzIGEgYnV0dG9uLiBJbiBzcGxpdCBtb2RlIHRoZSBlbGVtZW50IGlzIGFsd2F5cyBzaG93bi4gSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYXV0b21hdGljYWxseSBzd2l0Y2ggYmV0d2VlbiB0aGUgdHdvIG1vZGVzIGRlcGVuZGluZyBvbiB0aGUgc2NyZWVuIHNpemUuXG4gKiAgWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjga/jgIFvbnMtc3BsaXR0ZXLopoHntKDjga7lrZDopoHntKDjgajjgZfjgabliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBpcyB0aGUgcGFyZW50IGNvbXBvbmVudC5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlcj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICovXG5jbGFzcyBTcGxpdHRlclNpZGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgbW9kZWNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgY29tcG9uZW50J3MgbW9kZSBjaGFuZ2VzLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBruODouODvOODieOBjOWkieWMluOBl+OBn+mam+OBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQubW9kZVxuICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBjdXJyZW50IG1vZGUuIENhbiBiZSBlaXRoZXIgYFwiY29sbGFwc2VcImAgb3IgYFwic3BsaXRcImAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oi44O844OJ44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgc2xpZGluZyBtZW51IGlzIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgY/liY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRvIGNhbmNlbCBvcGVuaW5nIHNsaWRpbmcgbWVudS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgY/jga7jgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdG9wZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHNsaWRpbmcgbWVudSBpcyBvcGVuZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GE44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlY2xvc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBzbGlkaW5nIG1lbnUgaXMgY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0byBjYW5jZWwgb3BlbmluZyBzbGlkaW5nLW1lbnUuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44KL44Gu44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2xvc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHNsaWRpbmcgbWVudSBpcyBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCAgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24uIFVzZSBvbmUgb2YgYFwib3ZlcmxheVwiYCwgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJcIm92ZXJsYXlcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb3Blbi10aHJlc2hvbGRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgIDAuM1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGhvdyBtdWNoIHRoZSBtZW51IG5lZWRzIHRvIGJlIHN3aXBlZCBiZWZvcmUgb3BlbmluZy4gQSB2YWx1ZSBiZXR3ZWVuIGAwYCBhbmQgYDFgLlsvZW5dXG4gICAqICBbamFd44Gp44Gu44GP44KJ44GE44K544Ov44Kk44OX44GZ44KM44Gw44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844KS6ZaL44GP44GL44Gp44GG44GL44Gu5Ymy5ZCI44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTHjga7plpPjga7mlbDlgKTjgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg6/jgqTjg5fjga7ot53pm6LjgYzjgZPjgZPjgafmjIflrprjgZfjgZ/mlbDlgKTmjpvjgZHjgovjgZPjga7opoHntKDjga7luYXjgojjgorjgoLlpKfjgY3jgZHjgozjgbDjgIHjgrnjg6/jgqTjg5fjgYzntYLjgo/jgaPjgZ/mmYLjgavjgZPjga7opoHntKDjgpLplovjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8wLjPjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb2xsYXBzZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTcGVjaWZ5IHRoZSBjb2xsYXBzZSBiZWhhdmlvci4gVmFsaWQgdmFsdWVzIGFyZSBgXCJwb3J0cmFpdFwiYCwgYFwibGFuZHNjYXBlXCJgIG9yIGEgbWVkaWEgcXVlcnkuXG4gICAqICAgICBUaGUgc3RyaW5ncyBgXCJwb3J0cmFpdFwiYCBhbmQgYFwibGFuZHNjYXBlXCJgIG1lYW5zIHRoZSB2aWV3IHdpbGwgY29sbGFwc2Ugd2hlbiBkZXZpY2UgaXMgaW4gbGFuZHNjYXBlIG9yIHBvcnRyYWl0IG9yaWVudGF0aW9uLlxuICAgKiAgICAgSWYgdGhlIHZhbHVlIGlzIGEgbWVkaWEgcXVlcnksIHRoZSB2aWV3IHdpbGwgY29sbGFwc2Ugd2hlbiB0aGUgbWVkaWEgcXVlcnkgcmVzb2x2ZXMgdG8gYHRydWVgLlxuICAgKiAgICAgSWYgdGhlIHZhbHVlIGlzIG5vdCBkZWZpbmVkLCB0aGUgdmlldyBhbHdheXMgYmUgaW4gYFwiY29sbGFwc2VcImAgbW9kZS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOW3puWBtOOBruODmuODvOOCuOOCkumdnuihqOekuuOBq+OBmeOCi+adoeS7tuOCkuaMh+WumuOBl+OBvuOBmeOAgnBvcnRyYWl0LCBsYW5kc2NhcGXjgIF3aWR0aCAjcHjjgoLjgZfjgY/jga/jg6Hjg4fjgqPjgqLjgq/jgqjjg6rjga7mjIflrprjgYzlj6/og73jgafjgZnjgIJcbiAgICogICAgIHBvcnRyYWl044KC44GX44GP44GvbGFuZHNjYXBl44KS5oyH5a6a44GZ44KL44Go44CB44OH44OQ44Kk44K544Gu55S76Z2i44GM57im5ZCR44GN44KC44GX44GP44Gv5qiq5ZCR44GN44Gr44Gq44Gj44Gf5pmC44Gr6YGp55So44GV44KM44G+44GZ44CCXG4gICAqICAgICDjg6Hjg4fjgqPjgqLjgq/jgqjjg6rjgpLmjIflrprjgZnjgovjgajjgIHmjIflrprjgZfjgZ/jgq/jgqjjg6rjgavpganlkIjjgZfjgabjgYTjgovloLTlkIjjgavpgannlKjjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOWApOOBq+S9leOCguaMh+WumuOBl+OBquOBhOWgtOWQiOOBq+OBr+OAgeW4uOOBq2NvbGxhcHNl44Oi44O844OJ44Gr44Gq44KK44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGUtdGFyZ2V0LXdpZHRoXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgd2lkdGggb2Ygc3dpcGVhYmxlIGFyZWEgY2FsY3VsYXRlZCBmcm9tIHRoZSBlZGdlIChpbiBwaXhlbHMpLiBVc2UgdGhpcyB0byBlbmFibGUgc3dpcGUgb25seSB3aGVuIHRoZSBmaW5nZXIgdG91Y2ggb24gdGhlIHNjcmVlbiBlZGdlLlsvZW5dXG4gICAqICAgW2phXeOCueODr+OCpOODl+OBruWIpOWumumgmOWfn+OCkuODlOOCr+OCu+ODq+WNmOS9jeOBp+aMh+WumuOBl+OBvuOBmeOAgueUu+mdouOBruerr+OBi+OCieaMh+WumuOBl+OBn+i3nembouOBq+mBlOOBmeOCi+OBqOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHdpZHRoXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgc3BlY2lmaWVkIGluIGVpdGhlciBwaXhlbHMgb3IgYXMgYSBwZXJjZW50YWdlLCBlLmcuIGA5MCVgIG9yIGAyMDBweGAuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44Gu5qiq5bmF44KS5oyH5a6a44GX44G+44GZ44CCcHjjgagl44Gn44Gu5oyH5a6a44GM5Y+v6IO944Gn44GZ44CCZWcuIDkwJSwgMjAwcHhbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaWRlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGxlZnRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgd2hpY2ggc2lkZSBvZiB0aGUgc2NyZWVuIHRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCBpcyBsb2NhdGVkLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImxlZnRcImAgYW5kIGBcInJpZ2h0XCJgLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBjOW3puOBi+WPs+OBi+OCkuaMh+WumuOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+WApOOBr1wibGVmdFwi44GLXCJyaWdodFwi44Gu44G/44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImNvbGxhcHNlXCJgIG9yIGBcInNwbGl0XCJgLiBUaGlzIGF0dHJpYnV0ZSBpcyByZWFkIG9ubHkuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oi44O844OJ44GM6Kit5a6a44GV44KM44G+44GZ44CCXCJjb2xsYXBzZVwi44KC44GX44GP44GvXCJzcGxpdFwi44GM5oyH5a6a44GV44KM44G+44GZ44CC44GT44Gu5bGe5oCn44Gv6Kqt44G/6L6844G/5bCC55So44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBVUkwgb2YgdGhlIG1lbnUgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeimgee0oOOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdG8gZW5hYmxlIHN3aXBlIGludGVyYWN0aW9uIG9uIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4nmmYLjgavjgrnjg6/jgqTjg5fmk43kvZzjgpLmnInlirnjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29sbGFwc2VNb2RlID0gbmV3IENvbGxhcHNlTW9kZSh0aGlzKTtcbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbiA9IG5ldyBDb2xsYXBzZURldGVjdGlvbih0aGlzKTtcblxuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBPbnNTcGxpdHRlckVsZW1lbnQuX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogU3BsaXR0ZXJBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdTcGxpdHRlckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICAgIHRoaXMuX2JvdW5kSGFuZGxlR2VzdHVyZSA9IChlKSA9PiB0aGlzLl9jb2xsYXBzZU1vZGUuaGFuZGxlR2VzdHVyZShlKTtcbiAgICB0aGlzLl93YXRjaGVkQXR0cmlidXRlcyA9IFsnYW5pbWF0aW9uJywgJ3dpZHRoJywgJ3NpZGUnLCAnY29sbGFwc2UnLCAnc3dpcGVhYmxlJywgJ3N3aXBlLXRhcmdldC13aWR0aCcsICdhbmltYXRpb24tb3B0aW9ucycsICdvcGVuLXRocmVzaG9sZCcsICdwYWdlJ107XG4gIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgbXVzdCBiZSBhbiBvbnMtc3BsaXR0ZXIgZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMucGFyZW50RWxlbWVudCwge2RyYWdNaW5EaXN0YW5jZTogMX0pO1xuXG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnc2lkZScpKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2lkZScsICdsZWZ0Jyk7XG4gICAgfVxuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3dhdGNoZWRBdHRyaWJ1dGVzLmZvckVhY2goZSA9PiB0aGlzLl91cGRhdGUoZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5kaXNhYmxlKCk7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAodGhpcy5fd2F0Y2hlZEF0dHJpYnV0ZXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShuYW1lLCBjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9ICdfdXBkYXRlJyArIG5hbWUuc3BsaXQoJy0nKS5tYXAoZSA9PiBlWzBdLnRvVXBwZXJDYXNlKCkgKyBlLnNsaWNlKDEpKS5qb2luKCcnKTtcbiAgICByZXR1cm4gdGhpc1tuYW1lXSh2YWx1ZSk7XG4gIH1cblxuICBfZW1pdEV2ZW50KG5hbWUpIHtcbiAgICBpZiAobmFtZS5zbGljZSgwLCAzKSAhPT0gJ3ByZScpIHtcbiAgICAgIHJldHVybiB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgbmFtZSwge3NpZGU6IHRoaXN9KTtcbiAgICB9XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBuYW1lLCB7XG4gICAgICBzaWRlOiB0aGlzLFxuICAgICAgY2FuY2VsOiAoKSA9PiBpc0NhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gIH1cblxuICBfdXBkYXRlQ29sbGFwc2UodmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY29sbGFwc2UnKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJ3NwbGl0Jykge1xuICAgICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1vZGUoU1BMSVRfTU9ERSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICdjb2xsYXBzZScpIHtcbiAgICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmRpc2FibGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNb2RlKENPTExBUFNFX01PREUpO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmNoYW5nZVRhcmdldCh2YWx1ZSk7XG4gIH1cblxuICAvLyByZWFkb25seSBhdHRyaWJ1dGUgZm9yIHRoZSB1c2Vyc1xuICBfdXBkYXRlTW9kZShtb2RlKSB7XG4gICAgaWYgKG1vZGUgIT09IHRoaXMuX21vZGUpIHtcbiAgICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5fY29sbGFwc2VNb2RlW21vZGUgPT09IENPTExBUFNFX01PREUgPyAnZW50ZXJNb2RlJyA6ICdleGl0TW9kZSddKCk7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW9kZScsIG1vZGUpO1xuXG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ21vZGVjaGFuZ2UnLCB7c2lkZTogdGhpcywgbW9kZTogbW9kZX0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVQYWdlKHBhZ2UgPSB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpKSB7XG4gICAgaWYgKHBhZ2UgIT09IG51bGwpIHtcbiAgICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHRoaXMubG9hZChwYWdlKSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZU9wZW5UaHJlc2hvbGQodGhyZXNob2xkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29wZW4tdGhyZXNob2xkJykpIHtcbiAgICB0aGlzLl90aHJlc2hvbGQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHRocmVzaG9sZCkgfHwgMC4zKSk7XG4gIH1cblxuICBfdXBkYXRlU3dpcGVhYmxlKHN3aXBlYWJsZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZWFibGUnKSkge1xuICAgIGNvbnN0IGFjdGlvbiA9IHN3aXBlYWJsZSA9PT0gbnVsbCA/ICdvZmYnIDogJ29uJztcblxuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnc3RhcnQgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWdlbmQnLCB0aGlzLl9ib3VuZEhhbmRsZUdlc3R1cmUpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVTd2lwZVRhcmdldFdpZHRoKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlLXRhcmdldC13aWR0aCcpKSB7XG4gICAgdGhpcy5fc3dpcGVUYXJnZXRXaWR0aCA9IE1hdGgubWF4KDAsIHBhcnNlSW50KHZhbHVlKSB8fCAwKTtcbiAgfVxuXG4gIF91cGRhdGVXaWR0aCgpIHtcbiAgICB0aGlzLnN0eWxlLndpZHRoID0gdGhpcy5fd2lkdGg7XG4gIH1cblxuICBnZXQgX3dpZHRoKCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgcmV0dXJuIC9eXFxkKyhweHwlKSQvLnRlc3Qod2lkdGgpID8gd2lkdGggOiAnODAlJztcbiAgfVxuXG4gIHNldCBfd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB2YWx1ZSk7XG4gIH1cblxuICBfdXBkYXRlU2lkZShzaWRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSkge1xuICAgIHRoaXMuX3NpZGUgPSBzaWRlID09PSAncmlnaHQnID8gc2lkZSA6ICdsZWZ0JztcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRpb24oYW5pbWF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpKSB7XG4gICAgdGhpcy5fYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Ioe2FuaW1hdGlvbn0pO1xuICAgIHRoaXMuX2FuaW1hdG9yLmFjdGl2YXRlKHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdGlvbk9wdGlvbnModmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkge1xuICAgIHRoaXMuX2FuaW1hdG9yLnVwZGF0ZU9wdGlvbnMoQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh2YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QYWdlIGVsZW1lbnQgbG9hZGVkIGluIHRoZSBzcGxpdHRlciBzaWRlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgbW9kZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgbW9kZS4gUG9zc2libGUgdmFsdWVzIGFyZSBcInNwbGl0XCIsIFwiY29sbGFwc2VcIiwgXCJjbG9zZWRcIiwgXCJvcGVuXCIgb3IgXCJjaGFuZ2luZ1wiLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaXNPcGVuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgdmFsdWUgaXMgYHRydWVgIHdoZW4gdGhlIG1lbnUgaXMgb3Blbi4uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlTW9kZS5pc09wZW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG9wZW5cbiAgICogQHNpZ25hdHVyZSBvcGVuKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBtZW51IGhhcyBiZWVuIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jg6Hjg4vjg6Xjg7zjgYzplovjgYTjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3BlbiBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgb3BlbihvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VNb2RlLmV4ZWN1dGVBY3Rpb24oJ29wZW4nLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNsb3NlXG4gICAqIEBzaWduYXR1cmUgY2xvc2UoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgY2xvc2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlTW9kZS5leGVjdXRlQWN0aW9uKCdjbG9zZScsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3BlbnMgaWYgaXQncyBjbG9zZWQuIENsb3NlcyBpZiBpdCdzIG9wZW4uWy9lbl1cbiAgICogICBbamFd6ZaL44GR44Gm44GE44KL5aC05ZCI44Gv6KaB57Sg44KS6ZaJ44GY44G+44GZ44Gd44GX44Gm6ZaL44GR44Gm44GE44KL5aC05ZCI44Gv6KaB57Sg44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICB0b2dnbGUob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuID8gdGhpcy5jbG9zZShvcHRpb25zKSA6IHRoaXMub3BlbihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHNpZ25hdHVyZSBsb2FkKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhbiA8b25zLXRlbXBsYXRlPi5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CBb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gcGFnZVVybCBpbiB0aGUgcmlnaHQgc2VjdGlvblsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn1VSTOOCkuODoeOCpOODs+ODmuODvOOCuOOCkuiqreOBv+i+vOOBv+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGxvYWQocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXG4gICAgcmV0dXJuIGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgcmV3cml0YWJsZXMubGluayh0aGlzLCB1dGlsLmNyZWF0ZUZyYWdtZW50KGh0bWwpLCBvcHRpb25zLCBmcmFnbWVudCA9PiB7XG4gICAgICAgIHRoaXMuX2hpZGUoKTtcblxuICAgICAgICB0aGlzLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblxuICAgICAgICB0aGlzLl9zaG93KCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgIHJlc29sdmUodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfc2hvdycpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19oaWRlJyk7XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2Rlc3Ryb3knKTtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG59XG5cbndpbmRvdy5PbnNTcGxpdHRlclNpZGVFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BsaXR0ZXItc2lkZScsIHtcbiAgcHJvdG90eXBlOiBTcGxpdHRlclNpZGVFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbndpbmRvdy5PbnNTcGxpdHRlclNpZGVFbGVtZW50LnJld3JpdGFibGVzID0gcmV3cml0YWJsZXM7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJ29ucy9nZXN0dXJlLWRldGVjdG9yJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3N3aXRjaC0tKicsXG4gICcuc3dpdGNoX19pbnB1dCc6ICdzd2l0Y2gtLSpfX2lucHV0JyxcbiAgJy5zd2l0Y2hfX2hhbmRsZSc6ICdzd2l0Y2gtLSpfX2hhbmRsZScsXG4gICcuc3dpdGNoX190b2dnbGUnOiAnc3dpdGNoLS0qX190b2dnbGUnXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRnJhZ21lbnQoYFxuICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJzd2l0Y2hfX2lucHV0XCI+XG4gIDxkaXYgY2xhc3M9XCJzd2l0Y2hfX3RvZ2dsZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2hfX2hhbmRsZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaF9fdG91Y2hcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuY29uc3QgbG9jYXRpb25zID0ge1xuICBpb3M6IFsxLCAyMV0sXG4gIG1hdGVyaWFsOiBbMCwgMTZdXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zd2l0Y2hcbiAqIEBjYXRlZ29yeSBzd2l0Y2hcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgU3dpdGNoIGNvbXBvbmVudC4gVGhlIHN3aXRjaCBjYW4gYmUgdG9nZ2xlZCBib3RoIGJ5IGRyYWdnaW5nIGFuZCB0YXBwaW5nLlxuICpcbiAqICAgICBXaWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gc3dpdGNoIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeOCueOCpOODg+ODgeOCkuihqOekuuOBmeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzd2l0Y2hbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIExwWFpRUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3N3aXRjaFxuICogQGd1aWRlIFVzaW5nRm9ybUNvbXBvbmVudHNcbiAqICAgW2VuXVVzaW5nIGZvcm0gY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV3jg5Xjgqnjg7zjg6DjgpLkvb/jgYZbL2phXVxuICogQGd1aWRlIEV2ZW50SGFuZGxpbmdcbiAqICAgW2VuXUV2ZW50IGhhbmRsaW5nIGRlc2NyaXB0aW9uc1svZW5dXG4gKiAgIFtqYV3jgqTjg5njg7Pjg4jlh6bnkIbjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3dpdGNoIGNoZWNrZWQ+PC9vbnMtc3dpdGNoPlxuICogPG9ucy1zd2l0Y2ggZGlzYWJsZWQ+PC9vbnMtc3dpdGNoPlxuICogPG9ucy1zd2l0Y2ggbW9kaWZpZXI9XCJtYXRlcmlhbFwiPjwvb25zLXN3aXRjaD5cbiAqL1xuXG5jbGFzcyBTd2l0Y2hFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBzd2l0Y2ggaXMgdG9nZ2xlZC5bL2VuXVxuICAgKiAgIFtqYV1PTi9PRkbjgYzlpInjgo/jgaPjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zd2l0Y2hcbiAgICogICBbZW5dU3dpdGNoIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9Td2l0Y2jjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnZhbHVlXG4gICAqICAgW2VuXUN1cnJlbnQgdmFsdWUuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu5YCk44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc0ludGVyYWN0aXZlXG4gICAqICAgW2VuXVRydWUgaWYgdGhlIGNoYW5nZSB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB1c2VyIGNsaWNraW5nIG9uIHRoZSBzd2l0Y2guWy9lbl1cbiAgICogICBbamFd44K/44OD44OX44KE44Kv44Oq44OD44Kv44Gq44Gp44Gu44Om44O844K244Gu5pON5L2c44Gr44KI44Gj44Gm5aSJ44KP44Gj44Gf5aC05ZCI44Gr44GvdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBzd2l0Y2guWy9lbl1cbiAgICogIFtqYV3jgrnjgqTjg4Pjg4Hjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgc3dpdGNoIGlzIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOCueOCpOODg+ODgeOCkueEoeWKueOBrueKtuaFi+OBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNoZWNrZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHN3aXRjaCBpcyBjaGVja2VkLlsvZW5dXG4gICAqICAgW2phXeOCueOCpOODg+ODgeOBjE9O44Gu54q25oWL44Gr44GZ44KL44Go44GN44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYGlkYCBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2hlY2tlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgdmFsdWUgaXMgYHRydWVgIGlmIHRoZSBzd2l0Y2ggaXMgY2hlY2tlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgYxPTuOBruWgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIGdldCBjaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGVja2JveC5jaGVja2VkO1xuICB9XG5cbiAgc2V0IGNoZWNrZWQodmFsdWUpIHtcbiAgICBpZiAoISF2YWx1ZSAhPT0gdGhpcy5fY2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgdGhpcy5fY2hlY2tib3guY2xpY2soKTtcbiAgICAgIHRoaXMuX2NoZWNrYm94LmNoZWNrZWQgPSAhIXZhbHVlO1xuICAgICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjaGVja2VkJywgdGhpcy5jaGVja2VkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tib3guZGlzYWJsZWQ7XG4gIH1cblxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLl9jaGVja2JveC5kaXNhYmxlZCA9IHZhbHVlO1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB0aGlzLmRpc2FibGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2hlY2tib3hcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSB1bmRlcmx5aW5nIGNoZWNrYm94IGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI5YaF6YOo44GuY2hlY2tib3jopoHntKDjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGNoZWNrYm94KCkge1xuICAgIHJldHVybiB0aGlzLl9jaGVja2JveDtcbiAgfVxuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2NoZWNrYm94ID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuc3dpdGNoX19pbnB1dCcpO1xuICAgIHRoaXMuX2hhbmRsZSA9IHRoaXMucXVlcnlTZWxlY3RvcignLnN3aXRjaF9faGFuZGxlJyk7XG5cbiAgICBbJ2NoZWNrZWQnLCAnZGlzYWJsZWQnLCAnbW9kaWZpZXInLCAnbmFtZScsICdpbnB1dC1pZCddLmZvckVhY2goZSA9PiB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZShlKSk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc3dpdGNoJyk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jaGVja2JveC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLCB7ZHJhZ01pbkRpc3RhbmNlOiAxLCBob2xkVGltZW91dDogMjUxfSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xuICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmNoZWNrZWQpIHtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICB9XG4gIH1cblxuICBfb25DbGljayhldikge1xuICAgIGlmIChldi50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzd2l0Y2hfX3RvdWNoJykpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgY2xpY2soKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRQb3NpdGlvbihlKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuX2xvY2F0aW9ucztcbiAgICByZXR1cm4gTWF0aC5taW4obFsxXSwgTWF0aC5tYXgobFswXSwgdGhpcy5fc3RhcnRYICsgZS5nZXN0dXJlLmRlbHRhWCkpO1xuICB9XG5cbiAgX29uSG9sZChlKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3N3aXRjaC0tYWN0aXZlJyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWdTdGFydChlKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnc3dpdGNoLS1hY3RpdmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzd2l0Y2gtLWFjdGl2ZScpO1xuICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX2xvY2F0aW9uc1t0aGlzLmNoZWNrZWQgPyAxIDogMF07Ly8gLSBlLmdlc3R1cmUuZGVsdGFYO1xuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICB9XG5cbiAgX29uRHJhZyhlKSB7XG4gICAgZS5nZXN0dXJlLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5faGFuZGxlLnN0eWxlLmxlZnQgPSB0aGlzLl9nZXRQb3NpdGlvbihlKSArICdweCc7XG4gIH1cblxuICBfb25SZWxlYXNlKGUpIHtcbiAgICBjb25zdCBsID0gdGhpcy5fbG9jYXRpb25zO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb24oZSk7XG5cbiAgICB0aGlzLmNoZWNrZWQgPSBwb3NpdGlvbiA+PSAobFswXSArIGxbMV0pIC8gMjtcblxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcblxuICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdzd2l0Y2gtLWFjdGl2ZScpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2gobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICB0aGlzLl9pc01hdGVyaWFsID0gKGN1cnJlbnQgfHwgJycpLmluZGV4T2YoJ21hdGVyaWFsJykgIT09IC0xO1xuICAgICAgICB0aGlzLl9sb2NhdGlvbnMgPSBsb2NhdGlvbnNbdGhpcy5faXNNYXRlcmlhbCA/ICdtYXRlcmlhbCcgOiAnaW9zJ107XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0LWlkJzpcbiAgICAgICAgdGhpcy5fY2hlY2tib3guaWQgPSBjdXJyZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICB0aGlzLl9jaGVja2JveC5jaGVja2VkID0gY3VycmVudCAhPT0gbnVsbDtcbiAgICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcy5fY2hlY2tib3gsIG5hbWUsIGN1cnJlbnQgIT09IG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcy5fY2hlY2tib3gsIG5hbWUsIGN1cnJlbnQgIT09IG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG53aW5kb3cuT25zU3dpdGNoRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXN3aXRjaCcsIHtcbiAgcHJvdG90eXBlOiBTd2l0Y2hFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5leHBvcnQgY2xhc3MgVGFiYmFyQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAnMC40JztcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWxheSA6ICcwJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVudGVyUGFnZSBvbnMtcGFnZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbGVhdmVQYWdlIG9ucy1wYWdlIGVsZW1lbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVudGVyUGFnZUluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZWF2ZVBhZ2VJbmRleFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJQYWdlSW5kZXgsIGxlYXZlUGFnZUluZGV4LCBkb25lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGltcGxlbWVudGVkLicpO1xuICB9XG59XG5cblxuZXhwb3J0IGNsYXNzIFRhYmJhck5vbmVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcbiAgYXBwbHkoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGVudGVySW5kZXgsIGxlYXZlSW5kZXgsIGRvbmUpIHtcbiAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDAgLyA2MCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRhYmJhckZhZGVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucy50aW1pbmcgPSBvcHRpb25zLnRpbWluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1pbmcgOiAnbGluZWFyJztcbiAgICBvcHRpb25zLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6ICcwLjQnO1xuICAgIG9wdGlvbnMuZGVsYXkgPSBvcHRpb25zLmRlbGF5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlbGF5IDogJzAnO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJQYWdlSW5kZXgsIGxlYXZlUGFnZUluZGV4LCBkb25lKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGFiYmFyU2xpZGVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucy50aW1pbmcgPSBvcHRpb25zLnRpbWluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1pbmcgOiAnZWFzZS1pbic7XG4gICAgb3B0aW9ucy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAnMC4xNSc7XG4gICAgb3B0aW9ucy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVsYXkgOiAnMCc7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2pxTGl0ZX0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7anFMaXRlfSBsZWF2ZVBhZ2VcbiAgICovXG4gIGFwcGx5KGVudGVyUGFnZSwgbGVhdmVQYWdlLCBlbnRlckluZGV4LCBsZWF2ZUluZGV4LCBkb25lKSB7XG4gICAgY29uc3Qgc2duID0gZW50ZXJJbmRleCA+IGxlYXZlSW5kZXg7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoJyArIChzZ24gPyAnJyA6ICctJykgKyAnMTAwJSwgMCwgMCknLFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKCcgKyAoc2duID8gJy0nIDogJycpICsgJzEwMCUsIDAsIDApJyxcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQge1RhYmJhckFuaW1hdG9yLCBUYWJiYXJGYWRlQW5pbWF0b3IsIFRhYmJhck5vbmVBbmltYXRvciwgVGFiYmFyU2xpZGVBbmltYXRvcn0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRhYi1iYXJfX2NvbnRlbnQnOiAndGFiLWJhci0tKl9fY29udGVudCcsXG4gICcudGFiLWJhcic6ICd0YWItYmFyLS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiBUYWJiYXJOb25lQW5pbWF0b3IsXG4gICdmYWRlJzogVGFiYmFyRmFkZUFuaW1hdG9yLFxuICAnc2xpZGUnOiBUYWJiYXJTbGlkZUFuaW1hdG9yLFxuICAnbm9uZSc6IFRhYmJhck5vbmVBbmltYXRvclxufTtcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhYmJhckVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KHRhYmJhckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWJiYXJFbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBsaW5rKHRhYmJhckVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0YXJnZXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhYmJhckVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHVubGluayh0YWJiYXJFbGVtZW50LCB0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodGFyZ2V0KTtcbiAgfVxufTtcblxuY29uc3QgZ2VuZXJhdGVJZCA9ICgoKSA9PiB7XG4gIHZhciBpID0gMDtcbiAgcmV0dXJuICgpID0+ICdvbnMtdGFiYmFyLWdlbi0nICsgKGkrKyk7XG59KSgpO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10YWJiYXJcbiAqIEBjYXRlZ29yeSB0YWJiYXJcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQSBjb21wb25lbnQgdG8gZGlzcGxheSBhIHRhYiBiYXIgb24gdGhlIGJvdHRvbSBvZiBhIHBhZ2UuIFVzZWQgd2l0aCBgPG9ucy10YWI+YCB0byBtYW5hZ2UgcGFnZXMgdXNpbmcgdGFicy5bL2VuXVxuICogICBbamFd44K/44OW44OQ44O844KS44Oa44O844K45LiL6YOo44Gr6KGo56S644GZ44KL44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCb25zLXRhYuOBqOe1hOOBv+WQiOOCj+OBm+OBpuS9v+OBhuOBk+OBqOOBp+OAgeODmuODvOOCuOOCkueuoeeQhuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBwR3VETFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3RhYmJhclxuICogQGd1aWRlIFVzaW5nVGFiQmFyXG4gKiAgIFtlbl1Vc2luZyB0YWIgYmFyWy9lbl1cbiAqICAgW2phXeOCv+ODluODkOODvOOCkuS9v+OBhlsvamFdXG4gKiBAZ3VpZGUgRXZlbnRIYW5kbGluZ1xuICogICBbZW5dRXZlbnQgaGFuZGxpbmcgZGVzY3JpcHRpb25zWy9lbl1cbiAqICAgW2phXeOCpOODmeODs+ODiOWHpueQhuOBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgQ2FsbGluZ0NvbXBvbmVudEFQSXNmcm9tSmF2YVNjcmlwdFxuICogICBbZW5dVXNpbmcgbmF2aWdhdG9yIGZyb20gSmF2YVNjcmlwdFsvZW5dXG4gKiAgIFtqYV1KYXZhU2NyaXB044GL44KJ44Kz44Oz44Od44O844ON44Oz44OI44KS5ZG844Gz5Ye644GZWy9qYV1cbiAqIEBndWlkZSBEZWZpbmluZ011bHRpcGxlUGFnZXNpblNpbmdsZUhUTUxcbiAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJcbiAqICAgW2VuXVRoZSBgPG9ucy10YWI+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy10YWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBhZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1wYWdlPmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1vbnMtcGFnZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10YWJiYXI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cImhvbWUuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJIb21lXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwic2V0dGluZ3MuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJTZXR0aW5nc1wiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiA8L29ucy10YWJiYXI+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cImhvbWUuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJzZXR0aW5ncy5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKi9cbmNsYXNzIFRhYmJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGp1c3QgYmVmb3JlIHRoZSB0YWIgaXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzlpInjgo/jgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5pbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFiSXRlbVxuICAgKiAgIFtlbl1UYWIgaXRlbSBvYmplY3QuWy9lbl1cbiAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBjaGFuZ2UgZXZlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CB44Ki44Kv44OG44Kj44OW44Gq44K/44OW44Gu5aSJ5pu044GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBqdXN0IGFmdGVyIHRoZSB0YWIgaXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzlpInjgo/jgaPjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5pbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFiSXRlbVxuICAgKiAgIFtlbl1UYWIgaXRlbSBvYmplY3QuWy9lbl1cbiAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVhY3RpdmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGlmIHRoZSBhbHJlYWR5IG9wZW4gdGFiIGlzIHRhcHBlZCBhZ2Fpbi5bL2VuXVxuICAgKiAgIFtqYV3jgZnjgafjgavjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovjgr/jg5bjgYzjgoLjgYbkuIDluqbjgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgZXjgozjgZ/loLTlkIjjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5pbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFiSXRlbVxuICAgKiAgIFtlbl1UYWIgaXRlbSBvYmplY3QuWy9lbl1cbiAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBub25lXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIHZhbHVlcyBhcmUgYFwibm9uZVwiYCwgYFwic2xpZGVcImAgYW5kIGBcImZhZGVcImAuIERlZmF1bHQgaXMgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjoqq3jgb/ovrzjgb/mmYLjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOAgVwiZmFkZVwi44CBXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS6YG45oqe44Gn44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJub25lXCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcG9zaXRpb25cbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGJvdHRvbVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGFiYmFyJ3MgcG9zaXRpb24uIEF2YWlsYWJsZSB2YWx1ZXMgYXJlIGBcImJvdHRvbVwiYCBhbmQgYFwidG9wXCJgLiBVc2UgYFwiYXV0b1wiYCB0byBjaG9vc2UgcG9zaXRpb24gZGVwZW5kaW5nIG9uIHBsYXRmb3JtIChpT1MgYm90dG9tLCBBbmRyb2lkIHRvcCkuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu5L2N572u44KS5oyH5a6a44GX44G+44GZ44CCXCJib3R0b21cIuOCguOBl+OBj+OBr1widG9wXCLjgpLpgbjmip7jgafjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cImJvdHRvbVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3RhYmJhcklkID0gZ2VuZXJhdGVJZCgpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpcnN0Q2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5maXJzdENoaWxkLmNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmVJbmRleCcpO1xuXG4gICAgICBpZiAoYWN0aXZlSW5kZXggJiYgdGhpcy5jaGlsZHJlblsxXS5jaGlsZHJlbi5sZW5ndGggPiBhY3RpdmVJbmRleCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuWzFdLmNoaWxkcmVuW2FjdGl2ZUluZGV4XS5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICB9XG5cbiAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgICBiYXNlQ2xhc3M6IFRhYmJhckFuaW1hdG9yLFxuICAgICAgICBiYXNlQ2xhc3NOYW1lOiAnVGFiYmFyQW5pbWF0b3InLFxuICAgICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIH1cblxuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYi1iYXJfX2NvbnRlbnQnKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHZhciBjb250ZW50ID0gdXRpbC5jcmVhdGUoJy5vbnMtdGFiLWJhcl9fY29udGVudC50YWItYmFyX19jb250ZW50Jyk7XG4gICAgdmFyIHRhYmJhciA9IHV0aWwuY3JlYXRlKCcudGFiLWJhci5vbnMtdGFiLWJhcl9fZm9vdGVyLm9ucy10YWJiYXItaW5uZXInKTtcblxuICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRhYmJhci5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgdGhpcy5hcHBlbmRDaGlsZCh0YWJiYXIpO1xuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24ocG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKSkge1xuICAgIHZhciB0b3AgPSB0aGlzLl90b3AgPSBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgcGxhdGZvcm0uaXNBbmRyb2lkKCkpO1xuICAgIHZhciBhY3Rpb24gPSB0b3AgPyB1dGlsLmFkZE1vZGlmaWVyIDogdXRpbC5yZW1vdmVNb2RpZmllcjtcblxuICAgIGFjdGlvbih0aGlzLCAndG9wJyk7XG5cbiAgICB2YXIgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICBpZiAocGFnZSkge1xuICAgICAgdGhpcy5zdHlsZS50b3AgPSB0b3AgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLXRvcCcpIDogJyc7XG5cbiAgICAgIGlmICh1dGlsLm1hdGNoKHBhZ2UuZmlyc3RDaGlsZCwgJ29ucy10b29sYmFyJykpIHtcbiAgICAgICAgYWN0aW9uKHBhZ2UuZmlyc3RDaGlsZCwgJ25vc2hhZG93Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwoKCkgPT4ge1xuICAgICAgY29uc3QgZmlsbGVkID0gdXRpbC5maW5kUGFyZW50KHRoaXMsIGUgPT4gZS5oYXNBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcpKTtcbiAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdzdGF0dXMtYmFyLWZpbGwnLCB0b3AgJiYgIWZpbGxlZCk7XG4gICAgfSk7XG4gIH1cblxuICBfZ2V0VGFiYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkUGFnZVxuICAgKiBAc2lnbmF0dXJlIGxvYWRQYWdlKHVybCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZG9jdW1lbnQgb3IgYW4gYDxvbnMtdGVtcGxhdGU+YCBpZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44GfaWTlsZ7mgKfjga7lgKTjgpLliKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGlzcGxheXMgYSBuZXcgcGFnZSB3aXRob3V0IGNoYW5naW5nIHRoZSBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Ki44Kv44OG44Kj44OW44Gq44Kk44Oz44OH44OD44Kv44K544KS5aSJ5pu044Gb44Ga44Gr44CB5paw44GX44GE44Oa44O844K444KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBsb2FkUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBPbnNUYWJFbGVtZW50LnByb3RvdHlwZS5fY3JlYXRlUGFnZUVsZW1lbnQocGFnZSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICByZXNvbHZlKHRoaXMuX2xvYWRQYWdlRE9NQXN5bmMocGFnZUVsZW1lbnQsIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFnZUVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlxuICAgKi9cbiAgX2xvYWRQYWdlRE9NQXN5bmMocGFnZUVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgcGFnZUVsZW1lbnQsIG9wdGlvbnMsIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCkgIT09IC0xKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLl9zd2l0Y2hQYWdlKHBhZ2VFbGVtZW50LCBvcHRpb25zKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fb2xkUGFnZUVsZW1lbnQgPSBwYWdlRWxlbWVudDtcbiAgICAgICAgICByZXNvbHZlKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0VGFiYmFySWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhYmJhcklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnQvbnVsbH1cbiAgICovXG4gIF9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKSB7XG4gICAgdmFyIHBhZ2VzID0gdGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW47XG4gICAgdmFyIHBhZ2UgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYWdlc1tpXS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgcGFnZSA9IHBhZ2VzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFnZSAmJiBwYWdlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcGFnZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogcGFnZSBlbGVtZW50IG11c3QgYmUgYSBcIm9ucy1wYWdlXCIgZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFnZTtcbiAgfVxuXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNlbGVjdGVkVGFiSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucHJldmlvdXNUYWJJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudC5cbiAgICovXG4gIF9zd2l0Y2hQYWdlKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2xkUGFnZUVsZW1lbnQgPSB0aGlzLl9vbGRQYWdlRWxlbWVudCB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgICB0aGlzLl9vbGRQYWdlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdmFyIGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKG9sZFBhZ2VFbGVtZW50ICE9PSBpbnRlcm5hbC5udWxsRWxlbWVudCkge1xuICAgICAgICBvbGRQYWdlRWxlbWVudC5faGlkZSgpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRvci5hcHBseShlbGVtZW50LCBvbGRQYWdlRWxlbWVudCwgb3B0aW9ucy5zZWxlY3RlZFRhYkluZGV4LCBvcHRpb25zLnByZXZpb3VzVGFiSW5kZXgsICgpID0+IHtcbiAgICAgICAgaWYgKG9sZFBhZ2VFbGVtZW50ICE9PSBpbnRlcm5hbC5udWxsRWxlbWVudCkge1xuICAgICAgICAgIG9sZFBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBlbGVtZW50Ll9zaG93KCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZVRhYlxuICAgKiBAc2lnbmF0dXJlIHNldEFjdGl2ZVRhYihpbmRleCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dVGFiIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeOCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmtlZXBQYWdlXVxuICAgKiAgIFtlbl1JZiB0cnVlIHRoZSBwYWdlIHdpbGwgbm90IGJlIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844GM54++5Zyo6KGo56S644GX44Gm44GE44KLcGFnZeOCkuWkieOBiOOBquOBhOWgtOWQiOOBq+OBr3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImZhZGVcImAsIGBcInNsaWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAgmBcImZhZGVcImDjgIFgXCJzbGlkZVwiYOOAgWBcIm5vbmVcImDjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgc3BlY2lmaWVkIHRhYiBwYWdlLiBBbmltYXRpb25zIGFuZCBvdGhlciBvcHRpb25zIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHNlY29uZCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Kk44Oz44OH44OD44Kv44K544Gu44K/44OW44KS6KGo56S644GX44G+44GZ44CC44Ki44OL44Oh44O844K344On44Oz44Gq44Gp44Gu44Kq44OX44K344On44Oz44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldEFjdGl2ZVRhYihpbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIGlmICghb3B0aW9ucy5hbmltYXRpb24gJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpKSB7XG4gICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNUYWIgPSB0aGlzLl9nZXRBY3RpdmVUYWJFbGVtZW50KCksXG4gICAgICBzZWxlY3RlZFRhYiA9IHRoaXMuX2dldFRhYkVsZW1lbnQoaW5kZXgpLFxuICAgICAgcHJldmlvdXNUYWJJbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSxcbiAgICAgIHNlbGVjdGVkVGFiSW5kZXggPSBpbmRleCxcbiAgICAgIHByZXZpb3VzUGFnZUVsZW1lbnQgPSB0aGlzLl9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKTtcblxuICAgIGlmICghc2VsZWN0ZWRUYWIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BlY2lmaWVkIGluZGV4IGRvZXMgbm90IG1hdGNoIGFueSB0YWIuJyk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkVGFiSW5kZXggPT09IHByZXZpb3VzVGFiSW5kZXgpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncmVhY3RpdmUnLCB7XG4gICAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgICB0YWJJdGVtOiBzZWxlY3RlZFRhYlxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJldmlvdXNQYWdlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZWNoYW5nZScsIHtcbiAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWIsXG4gICAgICBjYW5jZWw6ICgpID0+IGNhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICBzZWxlY3RlZFRhYi5zZXRJbmFjdGl2ZSgpO1xuICAgICAgaWYgKHByZXZpb3VzVGFiKSB7XG4gICAgICAgIHByZXZpb3VzVGFiLnNldEFjdGl2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVjaGFuZ2UgZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRUYWIuc2V0QWN0aXZlKCk7XG5cbiAgICB2YXIgbmVlZExvYWQgPSAhc2VsZWN0ZWRUYWIuaXNMb2FkZWQoKSAmJiAhb3B0aW9ucy5rZWVwUGFnZTtcblxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuX2dldFRhYmJhckVsZW1lbnQoKS5jaGlsZHJlbikuZm9yRWFjaCgodGFiKSA9PiB7XG4gICAgICBpZiAodGFiICE9IHNlbGVjdGVkVGFiKSB7XG4gICAgICAgIHRhYi5zZXRJbmFjdGl2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFuZWVkTG9hZCkge1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIHtcbiAgICAgICAgICAgIGluZGV4OiBzZWxlY3RlZFRhYkluZGV4LFxuICAgICAgICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG5lZWRMb2FkKSB7XG4gICAgICB2YXIgcmVtb3ZlRWxlbWVudCA9IGZhbHNlO1xuXG4gICAgICBpZiAoKCFwcmV2aW91c1RhYiAmJiBwcmV2aW91c1BhZ2VFbGVtZW50KSB8fCAocHJldmlvdXNUYWIgJiYgcHJldmlvdXNUYWIuX3BhZ2VFbGVtZW50ICE9PSBwcmV2aW91c1BhZ2VFbGVtZW50KSkge1xuICAgICAgICByZW1vdmVFbGVtZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RjaGFuZ2UnLCB7XG4gICAgICAgICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcbiAgICAgICAgICAgIHRhYkl0ZW06IHNlbGVjdGVkVGFiXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmV2aW91c1RhYkluZGV4OiBwcmV2aW91c1RhYkluZGV4LFxuICAgICAgICBzZWxlY3RlZFRhYkluZGV4OiBzZWxlY3RlZFRhYkluZGV4XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgcGFyYW1zLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgfVxuXG4gICAgICBwYXJhbXMuYW5pbWF0aW9uT3B0aW9ucyA9IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fTtcblxuXG4gICAgICBjb25zdCBsaW5rID0gKGVsZW1lbnQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBzZWxlY3RlZFRhYi5fbG9hZFBhZ2VFbGVtZW50KHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMuX2xvYWRQZXJzaXN0ZW50UGFnZURPTShwYWdlRWxlbWVudCwgcGFyYW1zKSk7XG4gICAgICAgIH0sIGxpbmspO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcmV2aW91c1BhZ2VFbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqL1xuICBfbG9hZFBlcnNpc3RlbnRQYWdlRE9NKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKCF1dGlsLmlzQXR0YWNoZWQoZWxlbWVudCkpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIHJldHVybiB0aGlzLl9zd2l0Y2hQYWdlKGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0VGFiYmFyVmlzaWJpbGl0eVxuICAgKiBAc2lnbmF0dXJlIHNldFRhYmJhclZpc2liaWxpdHkodmlzaWJsZSlcbiAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIGhpZGUgb3Igc2hvdyB0aGUgdGFiIGJhci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0VGFiYmFyVmlzaWJpbGl0eSh2aXNpYmxlKSB7XG4gICAgdGhpcy5fY29udGVudEVsZW1lbnQuc3R5bGVbdGhpcy5fdG9wID8gJ3RvcCcgOiAnYm90dG9tJ10gPSB2aXNpYmxlID8gJycgOiAnMHB4JztcbiAgICB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZVRhYkluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlVGFiSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YWIuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGFiIGluZGV4IG9uIGN1cnJlbnQgYWN0aXZlIHRhYi4gSWYgYWN0aXZlIHRhYiBpcyBub3QgZm91bmQsIHJldHVybnMgLTEuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CC54++5Zyo44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM44Gq44GE5aC05ZCI44Gr44GvLTHjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlVGFiSW5kZXgoKSB7XG4gICAgdmFyIHRhYnMgPSB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YWJzW2ldIGluc3RhbmNlb2Ygd2luZG93Lk9uc1RhYkVsZW1lbnQgJiYgdGFic1tpXS5pc0FjdGl2ZSAmJiB0YWJzW2ldLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn0gV2hlbiBhY3RpdmUgdGFiIGlzIG5vdCBmb3VuZCwgcmV0dXJucyAtMS5cbiAgICovXG4gIF9nZXRBY3RpdmVUYWJFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRUYWJFbGVtZW50KHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIF9nZXRUYWJFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFRhYmJhckVsZW1lbnQoKS5jaGlsZHJlbltpbmRleF07XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkgeyB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHsgfVxuXG4gIF9zaG93KCkge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlRWxlbWVudCA9IHRoaXMuX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50UGFnZUVsZW1lbnQpIHtcbiAgICAgIGN1cnJlbnRQYWdlRWxlbWVudC5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlRWxlbWVudCA9IHRoaXMuX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50UGFnZUVsZW1lbnQpIHtcbiAgICAgIGN1cnJlbnRQYWdlRWxlbWVudC5faGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5fY29udGVudEVsZW1lbnQuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IHBhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBwYWdlc1tpXS5fZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG53aW5kb3cuT25zVGFiYmFyRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRhYmJhcicsIHtcbiAgcHJvdG90eXBlOiBUYWJiYXJFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gKi9cbndpbmRvdy5PbnNUYWJiYXJFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbihuYW1lLCBBbmltYXRvcikge1xuICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBUYWJiYXJBbmltYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zVGFiYmFyRWxlbWVudC5UYWJiYXJBbmltYXRvcicpO1xuICB9XG4gIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbn07XG5cbndpbmRvdy5PbnNUYWJiYXJFbGVtZW50LnJld3JpdGFibGVzID0gcmV3cml0YWJsZXM7XG53aW5kb3cuT25zVGFiYmFyRWxlbWVudC5UYWJiYXJBbmltYXRvciA9IFRhYmJhckFuaW1hdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBPbnNUYWJiYXJFbGVtZW50O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgT25zVGFiYmFyRWxlbWVudCBmcm9tICcuL29ucy10YWJiYXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICd0YWItYmFyLS0qX19pdGVtJyxcbiAgJy50YWItYmFyX19idXR0b24nOiAndGFiLWJhci0tKl9fYnV0dG9uJ1xufTtcbmNvbnN0IHRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdj5cbiAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lXCI+XG4gICAgPGJ1dHRvbiBjbGFzcz1cInRhYi1iYXJfX2J1dHRvbiB0YWItYmFyLWlubmVyXCI+PC9idXR0b24+XG4gIDwvZGl2PlxuYCk7XG5jb25zdCBkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cInRhYi1iYXJfX2ljb25cIj5cbiAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLWNsb3VkXCI+PC9vbnMtaWNvbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwidGFiLWJhcl9fbGFiZWxcIj5sYWJlbDwvZGl2PlxuICA8L2Rpdj5cbmApO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10YWJcbiAqIEBjYXRlZ29yeSB0YWJiYXJcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIHRhYiBpbnNpZGUgdGFiIGJhci4gRWFjaCBgPG9ucy10YWI+YCByZXByZXNlbnRzIGEgcGFnZS5bL2VuXVxuICogICBbamFdXG4gKiAgICAg44K/44OW44OQ44O844Gr6YWN572u44GV44KM44KL5ZCE44Ki44Kk44OG44Og44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44Gd44KM44Ge44KM44Gub25zLXRhYuOBr+ODmuODvOOCuOOCkuihqOOBl+OBvuOBmeOAglxuICogICAgIG9ucy10YWLopoHntKDjga7kuK3jgavjga/jgIHjgr/jg5bjgavooajnpLrjgZXjgozjgovjgrPjg7Pjg4bjg7Pjg4TjgpLnm7TmjqXoqJjov7DjgZnjgovjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIHBHdURMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdGFiYmFyXG4gKiBAZ3VpZGUgVXNpbmdUYWJCYXJcbiAqICAgW2VuXVVzaW5nIHRhYiBiYXJbL2VuXVxuICogICBbamFd44K/44OW44OQ44O844KS5L2/44GGWy9qYV1cbiAqIEBndWlkZSBEZWZpbmluZ011bHRpcGxlUGFnZXNpblNpbmdsZUhUTUxcbiAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJiYXJcbiAqICAgW2VuXW9ucy10YWJiYXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy10YWJiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBhZ2VcbiAqICAgW2VuXW9ucy1wYWdlIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtcGFnZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaWNvblxuICogICBbZW5db25zLWljb24gY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1pY29u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRhYmJhcj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwiaG9tZS5odG1sXCJcbiAqICAgICBsYWJlbD1cIkhvbWVcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJzZXR0aW5ncy5odG1sXCJcbiAqICAgICBsYWJlbD1cIlNldHRpbmdzXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqIDwvb25zLXRhYmJhcj5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiaG9tZS5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cInNldHRpbmdzLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L29ucy10ZW1wbGF0ZT5cblxuICovXG5jbGFzcyBUYWJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgcGFnZSB0aGF0IGlzIGRpc3BsYXllZCB3aGVuIHRoZSB0YWIgaXMgdGFwcGVkLlsvZW5dXG4gICAqICAgW2phXW9ucy10YWLjgYzlj4LnhafjgZnjgovjg5rjg7zjgrjjgbjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSBpY29uIG5hbWUgZm9yIHRoZSB0YWIuIENhbiBzcGVjaWZ5IHRoZSBzYW1lIGljb24gbmFtZSBhcyBgPG9ucy1pY29uPmAuXG4gICAqICAgICBJZiB5b3UgbmVlZCB0byB1c2UgeW91ciBvd24gaWNvbiwgY3JlYXRlIGEgQ1NTIGNsYXNzIHdpdGggYGJhY2tncm91bmQtaW1hZ2VgIG9yIGFueSBDU1MgcHJvcGVydGllcyBhbmQgc3BlY2lmeSB0aGUgbmFtZSBvZiB5b3VyIENTUyBjbGFzcyBoZXJlLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCb25zLWljb27jgajlkIzjgZjjgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICAgIOWAi+WIpeOBq+OCouOCpOOCs+ODs+OCkuOCq+OCueOCv+ODnuOCpOOCuuOBmeOCi+WgtOWQiOOBr+OAgWJhY2tncm91bmQtaW1hZ2Xjgarjganjga5DU1Pjgrnjgr/jgqTjg6vjgpLnlKjjgYTjgabmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhY3RpdmUtaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIG5hbWUgb2YgdGhlIGljb24gd2hlbiB0aGUgdGFiIGlzIGFjdGl2ZS5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjga7pmpvjga7jgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBsYWJlbFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGxhYmVsIG9mIHRoZSB0YWIgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PkuIvjgavooajnpLrjgZXjgozjgovjg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhY3RpdmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgYXR0cmlidXRlIHNob3VsZCBiZSBzZXQgdG8gdGhlIHRhYiB0aGF0IGlzIGFjdGl2ZSBieSBkZWZhdWx0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2xhYmVsJykgfHwgdGhpcy5oYXNBdHRyaWJ1dGUoJ2ljb24nKSkge1xuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBsZXQgaGFzQ2hpbGRyZW4gPSBmYWxzZTtcblxuICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbMF07XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGhhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlU291cmNlLmNsb25lTm9kZSh0cnVlKTtcbiAgICB3aGlsZSAodGVtcGxhdGUuY2hpbGRyZW5bMF0pIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2hpbGRyZW5bMF0pO1xuICAgIH1cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3RhYi1iYXJfX2l0ZW0nKTtcblxuICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcl9fYnV0dG9uJyk7XG5cbiAgICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICB0aGlzLl9oYXNEZWZhdWx0VGVtcGxhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFzRGVmYXVsdFRlbXBsYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZSgpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIC8vIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2J1dHRvbicpLCB0aGlzKTtcbiAgfVxuXG4gIF91cGRhdGVEZWZhdWx0VGVtcGxhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNEZWZhdWx0VGVtcGxhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidXR0b24gPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYi1iYXJfX2J1dHRvbicpO1xuXG4gICAgaWYgKGJ1dHRvbi5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSBkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB3aGlsZSAodGVtcGxhdGUuY2hpbGRyZW5bMF0pIHtcbiAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNoaWxkcmVuWzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2ljb24nKSkge1xuICAgICAgICBidXR0b24uaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19pY29uJyksIGJ1dHRvbi5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFidXR0b24ucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2xhYmVsJykpIHtcbiAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19sYWJlbCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBpY29uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdsYWJlbCcpO1xuXG4gICAgaWYgKHR5cGVvZiBpY29uID09PSAnc3RyaW5nJykge1xuICAgICAgZ2V0SWNvbkVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ2ljb24nLCBpY29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9faWNvbicpO1xuICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgd3JhcHBlci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgZ2V0TGFiZWxFbGVtZW50KCkudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFiZWwgPSBnZXRMYWJlbEVsZW1lbnQoKTtcbiAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICBsYWJlbC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMYWJlbEVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gc2VsZi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fbGFiZWwnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJY29uRWxlbWVudCgpIHtcbiAgICAgIHJldHVybiBzZWxmLnF1ZXJ5U2VsZWN0b3IoJ29ucy1pY29uJyk7XG4gICAgfVxuICB9XG5cbiAgX29uQ2xpY2soKSB7XG4gICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcbiAgICBpZiAodGFiYmFyKSB7XG4gICAgICB0YWJiYXIuc2V0QWN0aXZlVGFiKHRoaXMuX2ZpbmRUYWJJbmRleCgpKTtcbiAgICB9XG4gIH1cblxuICBzZXRBY3RpdmUoKSB7XG4gICAgY29uc3QgcmFkaW8gPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnaW5wdXQnKTtcbiAgICByYWRpby5jaGVja2VkID0gdHJ1ZTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuXG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLXRhYi1pbmFjdGl2ZV0sIG9ucy10YWItaW5hY3RpdmUnKSlcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKTtcbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWFjdGl2ZV0sIG9ucy10YWItYWN0aXZlJykpXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0Jyk7XG4gIH1cblxuICBzZXRJbmFjdGl2ZSgpIHtcbiAgICBjb25zdCByYWRpbyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdpbnB1dCcpO1xuICAgIHJhZGlvLmNoZWNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuXG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLXRhYi1pbmFjdGl2ZV0sIG9ucy10YWItaW5hY3RpdmUnKSlcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnKTtcbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWFjdGl2ZV0sIG9ucy10YWItYWN0aXZlJykpXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzTG9hZGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rXG4gICAqL1xuICBfbG9hZFBhZ2VFbGVtZW50KGNhbGxiYWNrLCBsaW5rKSB7XG4gICAgaWYgKCF0aGlzLnBhZ2VFbGVtZW50KSB7XG4gICAgICB0aGlzLl9jcmVhdGVQYWdlRWxlbWVudCh0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpLCAoZWxlbWVudCkgPT4ge1xuICAgICAgICBsaW5rKGVsZW1lbnQsIGVsZW1lbnQgPT4ge1xuICAgICAgICAgIHRoaXMucGFnZUVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0aGlzLnBhZ2VFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBzZXQgcGFnZUVsZW1lbnQoZWwpIHtcbiAgICB0aGlzLl9wYWdlRWxlbWVudCA9IGVsO1xuICB9XG5cbiAgZ2V0IHBhZ2VFbGVtZW50KCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fcGFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFnZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2ZpbmRUYWJJbmRleCgpO1xuXG4gICAgcmV0dXJuIHRhYmJhci5fY29udGVudEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfY3JlYXRlUGFnZUVsZW1lbnQocGFnZSwgY2FsbGJhY2spIHtcbiAgICBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XG4gICAgICBjYWxsYmFjayh1dGlsLmNyZWF0ZUVsZW1lbnQoaHRtbC50cmltKCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKTtcbiAgfVxuXG4gIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fZW5zdXJlRWxlbWVudFBvc2l0aW9uKCk7XG5cbiAgICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX2ZpbmRUYWJiYXJFbGVtZW50KCk7XG5cbiAgICAgIGlmICh0YWJiYXIuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgKyAnICcgOiAnJztcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgcHJlZml4ICsgdGFiYmFyLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnYWN0aXZlJykpIHtcbiAgICAgICAgY29uc3QgdGFiSW5kZXggPSB0aGlzLl9maW5kVGFiSW5kZXgoKTtcblxuICAgICAgICBPbnNUYWJiYXJFbGVtZW50LnJld3JpdGFibGVzLnJlYWR5KHRhYmJhciwgKCkgPT4ge1xuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0YWJiYXIuc2V0QWN0aXZlVGFiKHRhYkluZGV4LCB7YW5pbWF0aW9uOiAnbm9uZSd9KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT25zVGFiYmFyRWxlbWVudC5yZXdyaXRhYmxlcy5yZWFkeSh0YWJiYXIsICgpID0+IHtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdwYWdlJykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlUGFnZUVsZW1lbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIE9uc1RhYmJhckVsZW1lbnQucmV3cml0YWJsZXMubGluayh0YWJiYXIsIHBhZ2VFbGVtZW50LCB7fSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlRWxlbWVudCA9IHBhZ2VFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgdGFiYmFyLl9jb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnBhZ2VFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBfZmluZFRhYmJhckVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10YWJiYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRhYmJhcicpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9maW5kVGFiSW5kZXgoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMgPT09IGVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbnN1cmVFbGVtZW50UG9zaXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgb25zLXRhYiBlbGVtZW50IGlzIG11c3QgYmUgY2hpbGQgb2Ygb25zLXRhYmJhciBlbGVtZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVJpcHBsZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpY29uJzpcbiAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbndpbmRvdy5PbnNUYWJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtdGFiJywge1xuICBwcm90b3R5cGU6IFRhYkVsZW1lbnQucHJvdG90eXBlXG59KTtcblxuZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtdGFiYmFyLWl0ZW0nLCB7XG4gIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShUYWJFbGVtZW50LnByb3RvdHlwZSlcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICd0b29sYmFyLWJ1dHRvbi0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10b29sYmFyLWJ1dHRvblxuICogQGNhdGVnb3J5IHRvb2xiYXJcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHRvb2xiYXIgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG91dGxpbmVcbiAqICAgW2VuXUEgYnV0dG9uIHdpdGggYW4gb3V0bGluZS5bL2VuXVxuICogICBbamFd44Ki44Km44OI44Op44Kk44Oz44KS44KC44Gj44Gf44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQnV0dG9uIGNvbXBvbmVudCBmb3Igb25zLXRvb2xiYXIgYW5kIG9ucy1ib3R0b20tdG9vbGJhci5bL2VuXVxuICogICBbamFdb25zLXRvb2xiYXLjgYLjgovjgYTjga9vbnMtYm90dG9tLXRvb2xiYXLjgavoqK3nva7jgafjgY3jgovjg5zjgr/jg7PnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQGNvZGVwZW4gYUhtR0xcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9idXR0b25cbiAqIEBndWlkZSBBZGRpbmdhdG9vbGJhclxuICogICBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgbmF2aWdhdGlvbiBiYXIgYXQgdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgZGlzcGxheXMgYSBiYWNrIGJ1dHRvbiBpbiB0aGUgbmF2aWdhdGlvbiBiYXIuWy9lbl1cbiAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10b29sYmFyPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICBCdXR0b25cbiAqICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICBUaXRsZVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLW5hdmljb25cIiBzaXplPVwiMjhweFwiPjwvb25zLWljb24+XG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtdG9vbGJhcj5cbiAqL1xuY2xhc3MgVG9vbGJhckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Rvb2xiYXItYnV0dG9uJyk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG53aW5kb3cuT25zVG9vbGJhckJ1dHRvbiA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRvb2xiYXItYnV0dG9uJywge1xuICBwcm90b3R5cGU6IFRvb2xiYXJCdXR0b25FbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICduYXZpZ2F0aW9uLWJhci0tKicsXG4gICcubmF2aWdhdGlvbi1iYXJfX2xlZnQnOiAnbmF2aWdhdGlvbi1iYXItLSpfX2xlZnQnLFxuICAnLm5hdmlnYXRpb24tYmFyX19jZW50ZXInOiAnbmF2aWdhdGlvbi1iYXItLSpfX2NlbnRlcicsXG4gICcubmF2aWdhdGlvbi1iYXJfX3JpZ2h0JzogJ25hdmlnYXRpb24tYmFyLS0qX19yaWdodCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRvb2xiYXJcbiAqIEBjYXRlZ29yeSB0b29sYmFyXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gKiAgIFtlbl1UcmFuc3BhcmVudCB0b29sYmFyWy9lbl1cbiAqICAgW2phXemAj+aYjuOBquiDjOaZr+OCkuaMgeOBpOODhOODvOODq+ODkOODvOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRvb2xiYXIgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBuYXZpZ2F0aW9uLlxuICpcbiAqICAgICBMZWZ0LCBjZW50ZXIgYW5kIHJpZ2h0IGNvbnRhaW5lciBjYW4gYmUgc3BlY2lmaWVkIGJ5IGNsYXNzIG5hbWVzLlxuICpcbiAqICAgICBUaGlzIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheXMgYXMgYSBNYXRlcmlhbCBEZXNpZ24gdG9vbGJhciB3aGVuIHJ1bm5pbmcgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44OK44OT44Ky44O844K344On44Oz44Gn5L2/55So44GZ44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44Kv44Op44K55ZCN44Gr44KI44KK44CB5bem44CB5Lit5aSu44CB5Y+z44Gu44Kz44Oz44OG44OK44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvYnV0dG9uXG4gKiBAZ3VpZGUgQWRkaW5nYXRvb2xiYXIgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLWJvdHRvbS10b29sYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtYm90dG9tLXRvb2xiYXI+YCBkaXNwbGF5cyBhIHRvb2xiYXIgb24gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdb25zLWJvdHRvbS10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgYmFjayBidXR0b24gaW5zaWRlIHRoZSB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXItYnV0dG9uXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhci1idXR0b24+YCBjb21wb25lbnQgZGlzcGxheXMgYSB0b29sYmFyIGJ1dHRvbiBpbnNpZGUgdGhlIHRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFyLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICAgIDxvbnMtYmFjay1idXR0b24+XG4gKiAgICAgICAgIEJhY2tcbiAqICAgICAgIDwvb25zLWJhY2stYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICAgIFRpdGxlXG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKiA8L29ucy1wYWdlPlxuICovXG5cbmNsYXNzIFRvb2xiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlubGluZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXkgdGhlIHRvb2xiYXIgYXMgYW4gaW5saW5lIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844KS44Kk44Oz44Op44Kk44Oz44Gr572u44GN44G+44GZ44CC44K544Kv44Ot44O844Or6aCY5Z+f5YaF44Gr44Gd44Gu44G+44G+6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0b29sYmFyLlsvZW5dXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKTtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG5cbiAgYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl90cnlUb0Vuc3VyZU5vZGVQb3NpdGlvbigpO1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl90cnlUb0Vuc3VyZU5vZGVQb3NpdGlvbigpKTtcbiAgfVxuXG4gIF90cnlUb0Vuc3VyZU5vZGVQb3NpdGlvbigpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50Tm9kZSB8fCB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5saW5lJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcblxuICAgIGlmIChwYWdlICYmIHBhZ2UgIT09IHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgcGFnZS5fcmVnaXN0ZXJUb29sYmFyKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcubGVmdCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmNlbnRlcicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcucmlnaHQnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24gLmJhY2stYnV0dG9uX19sYWJlbCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCduYXZpZ2F0aW9uLWJhcicpO1xuICAgIHRoaXMuX2Vuc3VyZVRvb2xiYXJJdGVtRWxlbWVudHMoKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxuXG4gIF9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAvLyBjYXNlIG9mIG5vdCBlbGVtZW50XG4gICAgICBpZiAodGhpcy5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdjZW50ZXInKTtcbiAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgnbmF2aWdhdGlvbi1iYXJfX3RpdGxlJyk7XG5cbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgIXRoaXMuY2hpbGRyZW5bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgY29uc3QgbGVmdCA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdsZWZ0Jyk7XG4gICAgICBjb25zdCByaWdodCA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdyaWdodCcpO1xuXG4gICAgICBpZiAodGhpcy5jaGlsZHJlblswXSAhPT0gbGVmdCB8fCB0aGlzLmNoaWxkcmVuWzFdICE9PSBjZW50ZXIgfHwgdGhpcy5jaGlsZHJlblsyXSAhPT0gcmlnaHQpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChsZWZ0KTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjZW50ZXIpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHJpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZW5zdXJlVG9vbGJhckVsZW1lbnQobmFtZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLicgKyBuYW1lKSB8fCB1dGlsLmNyZWF0ZSgnLicgKyBuYW1lKTtcblxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbmF2aWdhdGlvbi1iYXJfXycgKyBuYW1lKTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbndpbmRvdy5PbnNUb29sYmFyRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRvb2xiYXInLCB7XG4gIHByb3RvdHlwZTogVG9vbGJhckVsZW1lbnQucHJvdG90eXBlXG59KTtcblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcucmFuZ2UnOiAncmFuZ2UtLSonLFxuICAnLnJhbmdlX19sZWZ0JzogJ3JhbmdlLS0qX19sZWZ0J1xufTtcblxuY29uc3QgdGVtcGxhdGVTb3VyY2UgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYDxkaXY+XG4gIDxkaXYgY2xhc3M9XCJyYW5nZV9fbGVmdFwiPjwvZGl2PlxuICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgY2xhc3M9XCJyYW5nZVwiPlxuPC9kaXY+YCk7XG5cbmNvbnN0IElOUFVUX0FUVFJJQlVURVMgPSBbXG4gICdhdXRvZm9jdXMnLFxuICAnZGlzYWJsZWQnLFxuICAnaW5wdXRtb2RlJyxcbiAgJ21heCcsXG4gICdtaW4nLFxuICAnbmFtZScsXG4gICdwbGFjZWhvbGRlcicsXG4gICdyZWFkb25seScsXG4gICdzaXplJyxcbiAgJ3N0ZXAnLFxuICAndmFsaWRhdG9yJyxcbiAgJ3ZhbHVlJ1xuXTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmFuZ2VcbiAqIEBjYXRlZ29yeSByYW5nZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc2xpZGVyWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFJhbmdlIGlucHV0IGNvbXBvbmVudC4gVXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHNsaWRlci5cbiAqXG4gKiAgICAgV29ya3MgdmVyeSBzaW1pbGFyIHRvIHRoZSBgPGlucHV0IHR5cGU9XCJyYW5nZVwiPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4WlFvbU1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9yYW5nZVxuICogQGd1aWRlIFVzaW5nRm9ybUNvbXBvbmVudHNcbiAqICAgW2VuXVVzaW5nIGZvcm0gY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV3jg5Xjgqnjg7zjg6DjgpLkvb/jgYZbL2phXVxuICogQGd1aWRlIEV2ZW50SGFuZGxpbmdcbiAqICAgW2VuXUV2ZW50IGhhbmRsaW5nIGRlc2NyaXB0aW9uc1svZW5dXG4gKiAgIFtqYV3jgqTjg5njg7Pjg4jlh6bnkIbjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IHRleHQgaW5wdXRzLCByYWRpbyBidXR0b25zIGFuZCBjaGVja2JveGVzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcmFuZ2UgdmFsdWU9XCIyMFwiPjwvb25zLXJhbmdlPlxuICogPG9ucy1yYW5nZSBtb2RpZmllcj1cIm1hdGVyaWFsXCIgdmFsdWU9XCIxMFwiPjwvcmFuZ2U+XG4gKi9cbmNsYXNzIFJhbmdlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG4gICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAoISh1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnJhbmdlX19sZWZ0JykgJiYgdXRpbC5maW5kQ2hpbGQodGhpcywgJ2lucHV0JykpKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlU291cmNlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZS5jaGlsZHJlblswXSkge1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNoaWxkcmVuWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHRoaXMuX2xlZnQuc3R5bGUud2lkdGggPSAoMTAwICogdGhpcy5fcmF0aW8pICsgJyUnO1xuICB9XG5cbiAgZ2V0IF9yYXRpbygpIHtcbiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhdGlvLlxuICAgIGNvbnN0IG1pbiA9IHRoaXMuX2lucHV0Lm1pbiA9PT0gJycgPyAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWluKTtcbiAgICBjb25zdCBtYXggPSB0aGlzLl9pbnB1dC5tYXggPT09ICcnID8gMTAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWF4KTtcblxuICAgIHJldHVybiAodGhpcy52YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChJTlBVVF9BVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdtaW4nIHx8IG5hbWUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuIH1cblxuICBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbkNoYW5nZSk7XG4gIH1cblxuICBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbkNoYW5nZSk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IF9pbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICB9XG5cbiAgZ2V0IF9sZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5yYW5nZV9fbGVmdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgdmFsdWUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQudmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdmFsO1xuICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICB9KTtcbiAgfVxufVxuXG53aW5kb3cuT25zUmFuZ2VFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcmFuZ2UnLCB7XG4gIHByb3RvdHlwZTogUmFuZ2VFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCJcbi8v5byV5YWl5qCH562+5byA5Y+R6ZyA6KaB55qE5LiA5Lqb5YWs5YWx57G7XG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc3BhY2UgPSB7XG4gICAgLy/or6Xnu4Tku7bnmoTmoLnmoLflvI/lkI1cbiAgICByb290Q2xhc3NOYW1lOiAnYmgtc3RlcHBpbmcnLFxuICAgIHZhbHVlOiAxLFxuICAgIC8v57yT5a2Y5qCH562+5a+56LGhXG4gICAgcm9vdE9iajogbnVsbFxufTtcblxuLyoqXG4gKiDmraXov5vnu4Tku7ZcbiAqIEBleGFtcGxlIDxiaC1zdGVwcGluZz48L2JoLXN0ZXBwaW5nPlxuICogQGV4YW1wbGUgPGJoLXN0ZXBwaW5nIHZhbHVlPVwi6K6+5a6a5Yid5aeL5YC8XCI+PC9iaC1zdGVwcGluZz5cbiAqL1xuY2xhc3MgQmhTdGVwcGluZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgICAvL+WumuS5ieiOt+WPlmlucHV05YWD57Sg55qE5pa55rOVXG4gICAgZ2V0IGlucHV0RG9tKCkge1xuICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ2lucHV0Jyk7XG4gICAgfVxuXG4gICAgLy/lrprkuYnorr7nva5pbnB1dOWAvOeahOaWueazlVxuICAgIHNldFN0ZXAodmFsdWUpe1xuICAgICAgICB0aGlzLmlucHV0RG9tLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy/ojrflj5ZpbnB1dOeahOW9k+WJjeWAvFxuICAgIGdldCBjdXJyZW50U3RlcCgpe1xuICAgICAgICBsZXQgbnVtID0gcGFyc2VJbnQodGhpcy5pbnB1dERvbS52YWx1ZSwgMTApO1xuICAgICAgICBpZighbnVtKXtcbiAgICAgICAgICAgIG51bSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG5cbiAgICAvL+atpei/m+WKoDFcbiAgICBfYWRkKCl7XG4gICAgICAgIGxldCBudW0gPSBzcGFjZS5yb290T2JqLmN1cnJlbnRTdGVwO1xuICAgICAgICBudW0rKztcbiAgICAgICAgc3BhY2Uucm9vdE9iai5zZXRTdGVwKG51bSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+WKoOWPt+aIluWHj+WPt+aXtuinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAZXZlbnQgQmhTdGVwcGluZ0VsZW1lbnQjQmhTdGVwcGluZ0VsZW1lbnQgY2hhbmdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2YWx1ZSDlvZPliY3nmoTlgLxcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGZsYWcgXCJhZGRcIueCueWHu+WKoOWPtywgXCJkb3duXCLngrnlh7vlh4/lj7dcbiAgICAgICAgICovXG4gICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh1dGlsLmZpbmRQYXJlbnQodGhpcywgc3BhY2Uucm9vdENsYXNzTmFtZSksICdjaGFuZ2UnLCB7XG4gICAgICAgICAgICB2YWx1ZTogbnVtLFxuICAgICAgICAgICAgZmxhZzogJ2FkZCdcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy/mraXov5vlh4/kuIBcbiAgICBfZG93bigpe1xuICAgICAgICBsZXQgbnVtID0gc3BhY2Uucm9vdE9iai5jdXJyZW50U3RlcDtcbiAgICAgICAgbnVtLS07XG4gICAgICAgIC8v5pyA5bCP5YC85pivMVxuICAgICAgICBpZihudW0gPCAxKXtcbiAgICAgICAgICAgIG51bSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgc3BhY2Uucm9vdE9iai5zZXRTdGVwKG51bSk7XG4gICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh1dGlsLmZpbmRQYXJlbnQodGhpcywgc3BhY2Uucm9vdENsYXNzTmFtZSksICdjaGFuZ2UnLCB7XG4gICAgICAgICAgICB2YWx1ZTogbnVtLFxuICAgICAgICAgICAgZmxhZzogJ2Rvd24nXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9pY29uQWN0aXZlSGFuZGxlKGV2ZW50KXtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QudG9nZ2xlKCdiaC1hY3RpdmUnKTtcbiAgICB9XG5cbiAgICAvL+e7hOS7tuWKoOi9veWujOavleeahOWbnuiwgyznm7jlvZPkuo7or6Xnu4Tku7bnmoTlhaXlj6Pmlrnms5VcbiAgICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICAgIH1cblxuICAgIC8v55uR5ZCs5bGe5oCn5Y+Y5YyW5aSE55CGXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICAgICAgLy90ZXh0IOWPmOWMluaXtueahOWkhOeQhlxuICAgICAgICBpZihuYW1lID09PSAndmFsdWUnKXtcbiAgICAgICAgICAgIHRoaXMucXVlcnlTZWxlY3RvcignaW5wdXQnKS52YWx1ZSA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL+WIneWni+WMluaWueazlVxuICAgIF9jb21waWxlKCkge1xuICAgICAgICBzcGFjZS5yb290T2JqID0gdGhpcztcbiAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgICAgIC8v5re75Yqg5qC35byPXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChzcGFjZS5yb290Q2xhc3NOYW1lKTtcblxuICAgICAgICBjb25zdCBpbml0VmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgaWYoaW5pdFZhbHVlKXtcbiAgICAgICAgICAgIHNwYWNlLnZhbHVlID0gaW5pdFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RlcEh0bWwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtzcGFjZS5yb290Q2xhc3NOYW1lfS1pY29uIGJoLWxlZnRcIj48aSBjbGFzcz1cImljb25mb250IGljb24tcmVtb3ZlXCI+PC9pPjwvZGl2PlxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiJHtzcGFjZS5yb290Q2xhc3NOYW1lfS1pbnB1dFwiIHZhbHVlPVwiJHtzcGFjZS52YWx1ZX1cIiB0eXBlPVwibnVtYmVyXCIgLz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke3NwYWNlLnJvb3RDbGFzc05hbWV9LWljb24gYmgtcmlnaHRcIj48aSBjbGFzcz1cImljb25mb250IGljb24tYWRkXCI+PC9pPjwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gc3RlcEh0bWw7XG5cbiAgICAgICAgLy/nm5HlkKzor6Xnu4Tku7bnmoTkuovku7ZcbiAgICAgICAgY29uc3QgbGVmdEljb24gPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJoLWxlZnQnKTtcbiAgICAgICAgY29uc3QgcmlnaHRJY29uID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5iaC1yaWdodCcpO1xuICAgICAgICBsZWZ0SWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2Rvd24sIGZhbHNlKTtcbiAgICAgICAgbGVmdEljb24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2ljb25BY3RpdmVIYW5kbGUsIGZhbHNlKTtcbiAgICAgICAgbGVmdEljb24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9pY29uQWN0aXZlSGFuZGxlLCBmYWxzZSk7XG5cbiAgICAgICAgcmlnaHRJY29uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYWRkLCBmYWxzZSk7XG4gICAgICAgIHJpZ2h0SWNvbi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5faWNvbkFjdGl2ZUhhbmRsZSwgZmFsc2UpO1xuICAgICAgICByaWdodEljb24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9pY29uQWN0aXZlSGFuZGxlLCBmYWxzZSk7XG4gICAgfVxuXG59XG5cbi8v5rOo5YaM6K+l5qCH562+KOeUqOS6jua1j+iniOWZqOS4jeaUr+aMgeiHquWumuS5ieagh+etvueahOWkhOeQhilcbndpbmRvdy5CaFN0ZXBwaW5nRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnYmgtc3RlcHBpbmcnLCB7XG4gICAgcHJvdG90eXBlOiBCaFN0ZXBwaW5nRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuXG4iLCJpbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc3BhY2UgPSB7XG4gICAgLy/or6Xnu4Tku7bnmoTmoLnmoLflvI/lkI1cbiAgICByb290Q2xhc3NOYW1lOiAnYmgtaW5wdXQnLFxuICAgIHZhbHVlOiAnJ1xufTtcblxuLyoqXG4gKiDovpPlhaXmoYZcbiAqXG4gKiBAZXhhbXBsZSA8YmgtaW5wdXQgbGFiZWw9XCJsYWJlbOWAvFwiIHZhbHVlPVwi6L6T5YWl5qGG55qE5YC8XCI+PC9iaC1pbnB1dD5cbiAqL1xuY2xhc3MgQmhJbnB1dEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICog6I635Y+W6L6T5YWl5qGG55qE5YC8XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB2YWx1ZSgpe1xuICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ2lucHV0JykudmFsdWU7XG4gICAgfVxuXG4gICAgLy/nu4Tku7bliqDovb3lrozmr5XnmoTlm57osIMs55u45b2T5LqO6K+l57uE5Lu255qE5YWl5Y+j5pa55rOVXG4gICAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB9XG5cbiAgICAvL+WIneWni+WMluaWueazlVxuICAgIF9jb21waWxlKCkge1xuICAgICAgICBjb25zdCBpbml0VmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgaWYoaW5pdFZhbHVlKXtcbiAgICAgICAgICAgIHNwYWNlLnZhbHVlID0gaW5pdFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbGFiZWwnKTtcblxuXG4gICAgICAgIGNvbnN0IHN0ZXBIdG1sID0gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7c3BhY2Uucm9vdENsYXNzTmFtZX0tbGFiZWxcIj4ke2xhYmVsfTwvZGl2PlxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiJHtzcGFjZS5yb290Q2xhc3NOYW1lfVwiIHZhbHVlPVwiJHtzcGFjZS52YWx1ZX1cIiB0eXBlPVwidGV4dFwiIC8+XG4gICAgICAgIGA7XG5cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBzdGVwSHRtbDtcbiAgICB9XG5cbn1cblxuLy/ms6jlhozor6XmoIfnrb4o55So5LqO5rWP6KeI5Zmo5LiN5pSv5oyB6Ieq5a6a5LmJ5qCH562+55qE5aSE55CGKVxud2luZG93LkJoSW5wdXRFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdiaC1pbnB1dCcsIHtcbiAgICBwcm90b3R5cGU6IEJoSW5wdXRFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbiIsIi8v5byV5YWl5qCH562+5byA5Y+R6ZyA6KaB55qE5LiA5Lqb5YWs5YWx57G7XG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc3BhY2UgPSB7XG4gICAgLy/or6Xnu4Tku7bnmoTmoLnmoLflvI/lkI1cbiAgICByb290Q2xhc3NOYW1lOiAnYmgtc2VhcmNoJyxcbiAgICB2YWx1ZTogJydcbn07XG5cbi8qKlxuICog5pCc57Si5qGGXG4gKlxuICogQGV4YW1wbGUgPGJoLXNlYXJjaD48L2JoLXNlYXJjaD5cbiAqL1xuY2xhc3MgQmhTZWFyY2hFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAgIC8qKlxuICAgICAqIOiOt+WPluaIluiuvue9ruaQnOe0ouahhueahOWAvFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IOS8oOWFpXRleHTliJnkuLrorr7lgLws5ZCm5YiZ5Li66I635Y+W5YC8XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB2YWx1ZSh0ZXh0KSB7XG4gICAgICAgIGlmKHR5cGVvZiB0ZXh0ID09PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcuYmgtc2VhcmNoLWlucHV0JykudmFsdWU7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCcuYmgtc2VhcmNoLWlucHV0JykudmFsdWUgPSB0ZXh0ICsgJyc7XG4gICAgICAgICAgICB0aGlzLl9zaG93Q2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jbGVhclZhbHVlKCkge1xuICAgICAgICBjb25zdCBwYXJlbnRPYmogPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ2JoLXNlYXJjaCcpO1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBhcmVudE9iai5xdWVyeVNlbGVjdG9yKCcuYmgtc2VhcmNoLWlucHV0Jyk7XG4gICAgICAgIGNvbnN0IGNsYXMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgaWYgKGlucHV0LnZhbHVlICE9ICcnKSB7XG5cbiAgICAgICAgICAgIGlmIChjbGFzID09ICdpY29uZm9udCBpY29uLWNhbmNlbCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTaWJsaW5nLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcignLmljb24tY2FuY2VsJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeCueWHu+WPlua2iOaMiemSruaXtuinpuWPkeeahOS6i+S7tlxuICAgICAgICAgKiBAZXZlbnQgQmhTZWFyY2hFbGVtZW50I0JoU2VhcmNoRWxlbWVudCBjYW5jZWxcbiAgICAgICAgICovXG4gICAgICAgIGlmKHV0aWwuaGFzQ2xhc3ModGhpcywgJ2JoLXNlYXJjaC1jYW5jZWwnKSl7XG4gICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2NhbmNlbCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Nob3dDbG9zZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSB0aGlzLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcignLmljb24tY2FuY2VsJyk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSAnJykge1xuICAgICAgICAgICAgY2FuY2VsLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbmNlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy/nu4Tku7bliqDovb3lrozmr5XnmoTlm57osIMs55u45b2T5LqO6K+l57uE5Lu255qE5YWl5Y+j5pa55rOVXG4gICAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB9XG5cbiAgICAvL+WIneWni+WMluaWueazlVxuICAgIF9jb21waWxlKCkge1xuICAgICAgICBjb25zdCBjb250ZW50SHRtbCA9IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke3NwYWNlLnJvb3RDbGFzc05hbWV9LXdyYXBcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtzcGFjZS5yb290Q2xhc3NOYW1lfS1ib3hcIj5cbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3MgPVwiaWNvbmZvbnQgaWNvbi1zZWFyY2hcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cIiR7c3BhY2Uucm9vdENsYXNzTmFtZX0taW5wdXRcIiB2YWx1ZT1cIiR7c3BhY2UudmFsdWV9XCIgdHlwZT1cInRleHRcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcyA9IFwiaWNvbmZvbnQgaWNvbi1jYW5jZWxcIj48L2k+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cImphdmFzY3JpcHQ6O1wiIGNsYXNzPVwiYmgtc2VhcmNoLWNhbmNlbFwiPuWPlua2iDwvYT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gY29udGVudEh0bWw7XG5cbiAgICAgICAgY29uc3QgY2FuY2VsID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuYmgtc2VhcmNoLWNhbmNlbCcpO1xuICAgICAgICBjb25zdCBjbG9zZSA9IHRoaXMucXVlcnlTZWxlY3RvcignLmljb24tY2FuY2VsJyk7XG4gICAgICAgIGNvbnN0IElucHV0ID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuYmgtc2VhcmNoLWlucHV0Jyk7XG4gICAgICAgIGNhbmNlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsZWFyVmFsdWUsIGZhbHNlKTtcbiAgICAgICAgY2xvc2UuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbGVhclZhbHVlLCBmYWxzZSk7XG4gICAgICAgIElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fc2hvd0Nsb3NlLCBmYWxzZSk7XG4gICAgfVxuXG59XG5cbi8v5rOo5YaM6K+l5qCH562+KOeUqOS6jua1j+iniOWZqOS4jeaUr+aMgeiHquWumuS5ieagh+etvueahOWkhOeQhilcbndpbmRvdy5CaFNlYXJjaEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ2JoLXNlYXJjaCcsIHtcbiAgICBwcm90b3R5cGU6IEJoU2VhcmNoRWxlbWVudC5wcm90b3R5cGVcbn0pO1xuIiwiXG4vL+W8leWFpeagh+etvuW8gOWPkemcgOimgeeahOS4gOS6m+WFrOWFseexu1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNwYWNlID0ge1xuICAgIC8v6K+l57uE5Lu255qE5qC55qC35byP5ZCNXG4gICAgcm9vdENsYXNzTmFtZTogJ2JoLXNlYXJjaC1iYXInXG59O1xuXG4vKipcbiAqIOaQnOe0ouadoVxuICogQGV4YW1wbGUgPGJoLXNlYXJjaC1iYXI+PC9iaC1zZWFyY2gtYmFyPlxuICogQGV4YW1wbGUgPGJoLXNlYXJjaC1iYXIgdGV4dD1cIuWGheWuuVwiPjwvYmgtc2VhcmNoLWJhcj5cbiAqL1xuY2xhc3MgQmhTZWFyY2hCYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gICAgLy/nu4Tku7bliqDovb3lrozmr5XnmoTlm57osIMs55u45b2T5LqO6K+l57uE5Lu255qE5YWl5Y+j5pa55rOVXG4gICAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB9XG5cbiAgICAvL+ebkeWQrOWxnuaAp+WPmOWMluWkhOeQhlxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgIC8vdGV4dCDlj5jljJbml7bnmoTlpITnkIZcbiAgICAgICAgaWYobmFtZSA9PT0gJ3RleHQnKXtcbiAgICAgICAgICAgIHRoaXMucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL+WIneWni+WMluaWueazlVxuICAgIF9jb21waWxlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0ZXh0JykgfHwgJyc7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRIdG1sID0gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7c3BhY2Uucm9vdENsYXNzTmFtZX1cIj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImljb25mb250IGljb24tc2VhcmNoXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxzcGFuPmAgKyB2YWx1ZSArIGA8L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcblxuICAgICAgICB0aGlzLmlubmVySFRNTCA9IGNvbnRlbnRIdG1sO1xuICAgIH1cblxufVxuXG4vL+azqOWGjOivpeagh+etvijnlKjkuo7mtY/op4jlmajkuI3mlK/mjIHoh6rlrprkuYnmoIfnrb7nmoTlpITnkIYpXG53aW5kb3cuQmhTZWFyY2hCYXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdiaC1zZWFyY2gtYmFyJywge1xuICAgIHByb3RvdHlwZTogQmhTZWFyY2hCYXJFbGVtZW50LnByb3RvdHlwZVxufSk7XG4iLCIvL+W8leWFpeagh+etvuW8gOWPkemcgOimgeeahOS4gOS6m+WFrOWFseexu1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNwYWNlID0ge1xuICAgIC8v6K+l57uE5Lu255qE5qC55qC35byP5ZCNXG4gICAgcm9vdENsYXNzTmFtZTogJ2JoLWlucHV0LXNlbGVjdCdcbn07XG5cbmNsYXNzIEJoSW5wdXRTZWxlY3RFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gICAgLy/nu4Tku7bliqDovb3lrozmr5XnmoTlm57osIMs55u45b2T5LqO6K+l57uE5Lu255qE5YWl5Y+j5pa55rOVXG4gICAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB9XG5cbiAgICAvL+WIneWni+WMluaWueazlVxuICAgIF9jb21waWxlKCkge1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2JoLWNsZWFyZml4LWNoaWxkJyk7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG4gICAgICAgIGNvbnN0IGNhcHRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnY2FwdGlvbicpO1xuICAgICAgICBjb25zdCBpY29uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKTtcbiAgICAgICAgbGV0IGljb25DbGFzcyA9IGljb24gPyBpY29uIDogJ2tleWJvYXJkYXJyb3dyaWdodCc7XG4gICAgICAgIGljb25DbGFzcyA9IGljb25DbGFzcy5yZXBsYWNlKC9eaWNvbi0vLCAnJyk7XG5cbiAgICAgICAgY29uc3QgY29udGVudEh0bWwgPSBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtzcGFjZS5yb290Q2xhc3NOYW1lfS1sYWJlbFwiPiR7bGFiZWx9PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtzcGFjZS5yb290Q2xhc3NOYW1lfS1jYXB0aW9uXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke3NwYWNlLnJvb3RDbGFzc05hbWV9LWNhcHRpb24tdGV4dFwiPiR7Y2FwdGlvbn08L3NwYW4+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJpY29uZm9udCBpY29uLSR7aWNvbkNsYXNzfVwiPjwvaT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuXG4gICAgICAgIHRoaXMuaW5uZXJIVE1MID0gY29udGVudEh0bWw7XG4gICAgfVxufVxuXG4vL+azqOWGjOivpeagh+etvijnlKjkuo7mtY/op4jlmajkuI3mlK/mjIHoh6rlrprkuYnmoIfnrb7nmoTlpITnkIYpXG53aW5kb3cuQmhJbnB1dFNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ2JoLWlucHV0LXNlbGVjdCcsIHtcbiAgICBwcm90b3R5cGU6IEJoSW5wdXRTZWxlY3RFbGVtZW50LnByb3RvdHlwZVxufSk7XG5cbiIsIlxuLy/lvJXlhaXmoIfnrb7lvIDlj5HpnIDopoHnmoTkuIDkupvlhazlhbHnsbtcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzcGFjZSA9IHtcbiAgICAvL+ivpee7hOS7tueahOagueagt+W8j+WQjVxuICAgIHJvb3RDbGFzc05hbWU6ICdiaC1jYXJvdXNlbC1idG5zJ1xufTtcblxuLyoqXG4gKiDova7mkq3pq5jkuq7mjInpkq7nu4RcbiAqXG4gKiBAZXhhbXBsZSA8YmgtY2Fyb3VzZWwtYnRucyBjb3VudD1cIuimgeaYvuekuueahOaMiemSruS4quaVsFwiIGFjdGl2ZS1pbmRleD1cIuimgemrmOS6rueahOaMiemSrmluZGV4LOi1t+Wni+aVsOaYrzBcIj48L2JoLWNhcm91c2VsLWJ0bnM+XG4gKi9cbmNsYXNzIEJoQ2Fyb3VzZWxCdG5zRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgICAvKipcbiAgICAgKiDorr7nva7pq5jkuq7kvY3nva5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg6KaB6auY5Lqu55qE5oyJ6ZKuaW5kZXgs6LW35aeL5pWw5pivMFxuICAgICAqL1xuICAgIHNldEFjdGl2ZUluZGV4KGluZGV4KXtcbiAgICAgICAgY29uc3QgYnRucyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IGJ0bnNMZW4gPSBidG5zLmxlbmd0aDtcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8YnRuc0xlbjsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBidG5zW2ldO1xuICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdiaC1hY3RpdmUnKTtcbiAgICAgICAgICAgIGlmKGluZGV4ID09PSBpKXtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2JoLWFjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy/nu4Tku7bliqDovb3lrozmr5XnmoTlm57osIMs55u45b2T5LqO6K+l57uE5Lu255qE5YWl5Y+j5pa55rOVXG4gICAgY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB9XG5cbiAgICAvL+WIneWni+WMluaWueazlVxuICAgIF9jb21waWxlKCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdjb3VudCcpLCAxMCk7XG4gICAgICAgIGlmKCFjb3VudCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYWN0aXZlSW5kZXggPSBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlLWluZGV4JyksIDEwKTtcbiAgICAgICAgYWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCA/IGFjdGl2ZUluZGV4IDogMTtcblxuICAgICAgICBjb25zdCBidG5IdG1sID0gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7c3BhY2Uucm9vdENsYXNzTmFtZX0taXRlbSBAYWN0aXZlQ2xhc3NcIj48L2Rpdj5cbiAgICAgICAgYDtcblxuICAgICAgICBsZXQgY29udGVudEh0bWwgPSAnJztcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxjb3VudDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBhY3RpdmVDbGFzcyA9ICcnO1xuICAgICAgICAgICAgaWYoaSsxID09PSBhY3RpdmVJbmRleCl7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ2xhc3MgPSAnYmgtYWN0aXZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRlbnRIdG1sICs9IGJ0bkh0bWwucmVwbGFjZSgnQGFjdGl2ZUNsYXNzJywgYWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBjb250ZW50SHRtbDtcbiAgICB9XG59XG5cbi8v5rOo5YaM6K+l5qCH562+KOeUqOS6jua1j+iniOWZqOS4jeaUr+aMgeiHquWumuS5ieagh+etvueahOWkhOeQhilcbndpbmRvdy5CaENhcm91c2VsQnRuc0VsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ2JoLWNhcm91c2VsLWJ0bnMnLCB7XG4gICAgcHJvdG90eXBlOiBCaENhcm91c2VsQnRuc0VsZW1lbnQucHJvdG90eXBlXG59KTtcblxuIiwiLy/lvJXlhaXmoIfnrb7lvIDlj5HpnIDopoHnmoTkuIDkupvlhazlhbHnsbtcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzcGFjZSA9IHtcbiAgICAvL+ivpee7hOS7tueahOagueagt+W8j+WQjVxuICAgIHJvb3RDbGFzc05hbWU6ICdiaC1tb2RhbC1ib3R0b20nLFxuICAgIGFuaW1hdGVUaW1lOiA0NTBcbn07XG5cbi8qKlxuICog5bqV6YOo5by55qGGXG4gKlxuICogQGV4YW1wbGUgPGJoLW1vZGFsLWJvdHRvbT48L2JoLW1vZGFsLWJvdHRvbT5cbiAqIEBleGFtcGxlIDxiaC1tb2RhbC1ib3R0b20gY292ZXI+PC9iaC1tb2RhbC1ib3R0b20+IOW4pumBrue9qeWxgueahOW8ueahhlxuICogQGV4YW1wbGUgPGJoLW1vZGFsLWJvdHRvbSBjbG9zZS1pY29uPjwvYmgtbW9kYWwtYm90dG9tPiDluKblhbPpl63mjInpkq7nmoTlvLnmoYZcbiAqL1xuY2xhc3MgQmhNb2RhbEJvdHRvbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICog5omT5byA5by55qGGXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmNhbGxiYWNrIOaJk+W8gOW8ueahhuWQjueahOWbnuiwg1xuICAgICAqL1xuICAgIHNob3cob3B0aW9ucyA9IHt9KXtcbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICAgICAgb3B0aW9ucyB8fCB7fVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy4nK3NwYWNlLnJvb3RDbGFzc05hbWUrJy1jb250ZW50Jyk7XG4gICAgICAgIGNvbnN0IGNvdmVyID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy4nK3NwYWNlLnJvb3RDbGFzc05hbWUrJy1jb3ZlcicpO1xuXG4gICAgICAgIGlmKGNvdmVyKXtcbiAgICAgICAgICAgIGNvdmVyLmNsYXNzTGlzdC5hZGQoJ2JoLWFuaW1hdGUtZmFkZUluLWx2MScpO1xuICAgICAgICAgICAgY292ZXIuY2xhc3NMaXN0LnJlbW92ZSgnYmgtYW5pbWF0ZS1mYWRlT3V0LWx2MScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCdiaC1hbmltYXRlLW91dC1ib3R0b20nKTtcbiAgICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdiaC1hbmltYXRlLWludG8tYm90dG9tJyk7XG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgaWYodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgIT0ndW5kZWZpbmVkJyAmJiBvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgICAgICAgLy/miafooYznmoTlm57osINcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWFs+mXreW8ueahhlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5jYWxsYmFjayDlhbPpl63lvLnmoYblkI7nmoTlm57osINcbiAgICAgKi9cbiAgICBoaWRlKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAgICAgIG9wdGlvbnMgfHwge31cbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgcm9vdCA9IHRoaXM7XG4gICAgICAgIGlmKHRoaXMubG9jYWxOYW1lICE9PSBzcGFjZS5yb290Q2xhc3NOYW1lKXtcbiAgICAgICAgICAgIHJvb3QgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgc3BhY2Uucm9vdENsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudCA9IHV0aWwuZmluZENoaWxkKHJvb3QsICcuJytzcGFjZS5yb290Q2xhc3NOYW1lKyctY29udGVudCcpO1xuICAgICAgICBjb25zdCBjb3ZlciA9IHV0aWwuZmluZENoaWxkKHJvb3QsICcuJytzcGFjZS5yb290Q2xhc3NOYW1lKyctY292ZXInKTtcblxuICAgICAgICBpZihjb3Zlcil7XG4gICAgICAgICAgICBjb3Zlci5jbGFzc0xpc3QucmVtb3ZlKCdiaC1hbmltYXRlLWZhZGVJbi1sdjEnKTtcbiAgICAgICAgICAgIGNvdmVyLmNsYXNzTGlzdC5hZGQoJ2JoLWFuaW1hdGUtZmFkZU91dC1sdjEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZSgnYmgtYW5pbWF0ZS1pbnRvLWJvdHRvbScpO1xuICAgICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ2JoLWFuaW1hdGUtb3V0LWJvdHRvbScpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9LCBzcGFjZS5hbmltYXRlVGltZSk7XG4gICAgICAgIGlmKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrICE9J3VuZGVmaW5lZCcgJiYgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgICAgICAgIC8v5omn6KGM55qE5Zue6LCDXG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL+eCueWHu+W6lemDqOW8ueahhueahOmdnuWGheWuueWMuuWfnyzlsIblvLnmoYbpmpDol49cbiAgICBfY2xpY2tBbGxIYW5kbGUoZXZlbnQpe1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gICAgLy/ngrnlh7vlvLnmoYbnmoTlhoXlrrnljLrln5/lsIbkuovku7blhpLms6HpmLvmraIs6Ziy5q2i6K+v6ZqQ6JeP5pON5L2cXG4gICAgX2NvbnRlbnRDbGlja0FsbEhhbmRsZShldmVudCl7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8v57uE5Lu25Yqg6L295a6M5q+V55qE5Zue6LCDLOebuOW9k+S6juivpee7hOS7tueahOWFpeWPo+aWueazlVxuICAgIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gICAgfVxuXG4gICAgLy/liJ3lp4vljJbmlrnms5VcbiAgICBfY29tcGlsZSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0Q29udGVudCA9IHRoaXMucXVlcnlTZWxlY3RvcignLicrc3BhY2Uucm9vdENsYXNzTmFtZSsnLWNvbnRlbnQnKTtcbiAgICAgICAgaWYoc2VsZWN0Q29udGVudCl7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RDbG9zZUljb24gPSB1dGlsLmZpbmRDaGlsZChzZWxlY3RDb250ZW50LCAnLmljb24tY2xvc2UnKTtcbiAgICAgICAgICAgIGlmKHNlbGVjdENsb3NlSWNvbil7XG4gICAgICAgICAgICAgICAgc2VsZWN0Q2xvc2VJY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oaWRlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0Q2xvc2VJY29uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oaWRlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudCA9IHV0aWwuY3JlYXRlKCcuJytzcGFjZS5yb290Q2xhc3NOYW1lKyctY29udGVudCcpO1xuXG4gICAgICAgIGxldCBpc0hhdmVDbG9zZSA9IGZhbHNlO1xuICAgICAgICBsZXQgY2xvc2VJY29uID0gbnVsbDtcbiAgICAgICAgaWYodGhpcy5oYXNBdHRyaWJ1dGUoJ2Nsb3NlLWljb24nKSl7XG4gICAgICAgICAgICBjbG9zZUljb24gPSB1dGlsLmNyZWF0ZSgnaScpO1xuICAgICAgICAgICAgY2xvc2VJY29uLmNsYXNzTGlzdC5hZGQoJ2ljb25mb250Jyk7XG4gICAgICAgICAgICBjbG9zZUljb24uY2xhc3NMaXN0LmFkZCgnaWNvbi1jbG9zZScpO1xuICAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChjbG9zZUljb24pO1xuICAgICAgICAgICAgaXNIYXZlQ2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5oYXNBdHRyaWJ1dGUoJ2NvdmVyJykpe1xuICAgICAgICAgICAgY29uc3QgY292ZXIgPSB1dGlsLmNyZWF0ZSgnLicrc3BhY2Uucm9vdENsYXNzTmFtZSsnLWNvdmVyJyk7XG4gICAgICAgICAgICAvL+e7memBrue9qeWxgua3u+WKoOWKqOeUu1xuICAgICAgICAgICAgY292ZXIuY2xhc3NMaXN0LmFkZCgnYmgtYW5pbWF0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY292ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnYmgtYW5pbWF0ZWQnKTtcblxuICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2JvdHRvbScpO1xuICAgICAgICBpZihib3R0b20pe1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5ib3R0b20gPSB1dGlsLnB4VG9SZW0oYm90dG9tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGlzSGF2ZUNsb3NlKXtcbiAgICAgICAgICAgIC8v57uZ5YWz6Zet5oyJ6ZKu5re75Yqg54K55Ye75LqL5Lu2XG4gICAgICAgICAgICBjbG9zZUljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhpZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8v57uZ5YaF5a655Y675re75Yqg5LqL5Lu255uR5ZCsXG4gICAgICAgIHRoaXMucXVlcnlTZWxlY3RvcignLicrc3BhY2Uucm9vdENsYXNzTmFtZSsnLWNvbnRlbnQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NvbnRlbnRDbGlja0FsbEhhbmRsZSwgZmFsc2UpO1xuICAgICAgICAvL+e7meaVtOS4quW6lemDqOW8ueahhua3u+WKoOeCueWHu+S6i+S7tuebkeWQrFxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tBbGxIYW5kbGUsIGZhbHNlKTtcbiAgICB9XG59XG5cbi8v5rOo5YaM6K+l5qCH562+KOeUqOS6jua1j+iniOWZqOS4jeaUr+aMgeiHquWumuS5ieagh+etvueahOWkhOeQhilcbndpbmRvdy5CaE1vZGFsQm90dG9tRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnYmgtbW9kYWwtYm90dG9tJywge1xuICAgIHByb3RvdHlwZTogQmhNb2RhbEJvdHRvbUVsZW1lbnQucHJvdG90eXBlXG59KTtcbiIsIi8qXG4g5bqV6YOo5by55qGG57uE5Lu2XG4gKi9cblxuLy/lvJXlhaXmoIfnrb7lvIDlj5HpnIDopoHnmoTkuIDkupvlhazlhbHnsbtcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuY29uc3Qgc3BhY2UgPSB7XG4gICAgLy/or6Xnu4Tku7bnmoTmoLnmoLflvI/lkI1cbiAgICByb290Q2xhc3NOYW1lOiAnYmgtbW9kYWwtYm90dG9tJyxcbiAgICBhbmltYXRlVGltZTogNDUwXG59O1xuXG4vL+e7p+aJv+e7hOS7tuW8gOWPkeaJgOmcgOeahOexu1xuY2xhc3MgQmhNb2RhbEJvdHRvbSB7XG4gICAgLy/liJ3lp4vljJblubbmmL7npLrlvLnmoYZcbiAgICBzaG93KG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgY292ZXI6IHRydWUsIC8v5piv5ZCm5pi+56S66YGu572p5bGCLOm7mOiupHRydWXmmL7npLosIGZhbHNl5LiN5pi+56S6XG4gICAgICAgICAgICBjbG9zZUljb246IHRydWUgLy/mmK/lkKbmmL7npLrlhbPpl63mjInpkq4sIOm7mOiupHRydWXmmL7npLosIGZhbHNl5LiN5pi+56S6XG4gICAgICAgIH07XG4gICAgICAgIC8v5ZCI5bm25Y+C5pWwXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAvL+WIneWni+WMluWkhOeQhlxuICAgICAgICB0aGlzLl9jb21waWxlKG9wdGlvbnMpO1xuICAgIH1cbiAgICBoaWRlKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAgICAgIG9wdGlvbnMgfHwge31cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByb290T2JqID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLicrc3BhY2Uucm9vdENsYXNzTmFtZSk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRPYmogPSB1dGlsLmZpbmRDaGlsZChyb290T2JqLCAnLicrc3BhY2Uucm9vdENsYXNzTmFtZSsnLWNvbnRlbnQnKTtcbiAgICAgICAgY29uc3QgY292ZXJPYmogPSB1dGlsLmZpbmRDaGlsZChyb290T2JqLCAnLicrc3BhY2Uucm9vdENsYXNzTmFtZSsnLWNvdmVyJyk7XG5cbiAgICAgICAgaWYoY292ZXJPYmope1xuICAgICAgICAgICAgY292ZXJPYmouY2xhc3NMaXN0LnJlbW92ZSgnYmgtYW5pbWF0ZS1mYWRlSW4nKTtcbiAgICAgICAgICAgIGNvdmVyT2JqLmNsYXNzTGlzdC5hZGQoJ2JoLWFuaW1hdGUtb3V0LWZhZGVPdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50T2JqLmNsYXNzTGlzdC5yZW1vdmUoJ2JoLWFuaW1hdGUtaW50by1ib3R0b20nKTtcbiAgICAgICAgY29udGVudE9iai5jbGFzc0xpc3QuYWRkKCdiaC1hbmltYXRlLW91dC1ib3R0b20nKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJvb3RPYmoucmVtb3ZlKCk7XG4gICAgICAgIH0sIHNwYWNlLmFuaW1hdGVUaW1lKTtcblxuICAgICAgICBpZih0eXBlb2Ygb3B0aW9ucy5jbG9zZSAhPSd1bmRlZmluZWQnICYmIG9wdGlvbnMuY2xvc2UgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgICAgICAgICAvL+aJp+ihjOeahOWbnuiwg1xuICAgICAgICAgICAgb3B0aW9ucy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy/liJ3lp4vljJbmlrnms5VcbiAgICBfY29tcGlsZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAvL+WIm+W7uuagueiKgueCuVxuICAgICAgICBjb25zdCByb290T2JqID0gdXRpbC5jcmVhdGUoJy4nK3NwYWNlLnJvb3RDbGFzc05hbWUpO1xuICAgICAgICAvL+WvueagueiKgueCueiuvue9ruS4iuS4i+W3puWPs+WAvCzpu5jorqTkvb/nlKhyZW3ljZXkvY0s5ZCm5YiZ5Lya5bCGcHjmiJbmlbDlrZfovazmjaLmiJByZW1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgIGlmKG9mZnNldCl7XG4gICAgICAgICAgICBpZihvZmZzZXQudG9wKXtcbiAgICAgICAgICAgICAgICByb290T2JqLnN0eWxlLnRvcCA9IHV0aWwucHhUb1JlbShvZmZzZXQudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG9mZnNldC5ib3R0b20pe1xuICAgICAgICAgICAgICAgIHJvb3RPYmouc3R5bGUuYm90dG9tID0gdXRpbC5weFRvUmVtKG9mZnNldC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYob2Zmc2V0LmxlZnQpe1xuICAgICAgICAgICAgICAgIHJvb3RPYmouc3R5bGUubGVmdCA9IHV0aWwucHhUb1JlbShvZmZzZXQubGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihvZmZzZXQucmlnaHQpe1xuICAgICAgICAgICAgICAgIHJvb3RPYmouc3R5bGUucmlnaHQgPSB1dGlsLnB4VG9SZW0ob2Zmc2V0LnJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8v5Yib5bu65YaF5a655Z2XXG4gICAgICAgIGNvbnN0IGNvbnRlbnRPYmogPSB1dGlsLmNyZWF0ZSgnLicrc3BhY2Uucm9vdENsYXNzTmFtZSsnLWNvbnRlbnQnKTtcbiAgICAgICAgLy/mt7vliqDliqjnlLvnsbtcbiAgICAgICAgY29udGVudE9iai5jbGFzc0xpc3QuYWRkKCdiaC1hbmltYXRlZCcpO1xuICAgICAgICBjb250ZW50T2JqLmNsYXNzTGlzdC5hZGQoJ2JoLWFuaW1hdGUtaW50by1ib3R0b20nKTtcblxuICAgICAgICAvL+aPkuWFpeWGheWuuVxuICAgICAgICBjb25zdCBjb250ZW50ID0gb3B0aW9ucy5jb250ZW50O1xuICAgICAgICBjb250ZW50T2JqLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgLy/liKTmlq3mmL7npLrlhbPpl63mjInpkq5cbiAgICAgICAgaWYob3B0aW9ucy5jbG9zZUljb24pe1xuICAgICAgICAgICAgY29uc3QgY2xvc2VJY29uID0gdXRpbC5jcmVhdGUoJ2knKTtcbiAgICAgICAgICAgIGNsb3NlSWNvbi5jbGFzc0xpc3QuYWRkKCdpY29uZm9udCcpO1xuICAgICAgICAgICAgY2xvc2VJY29uLmNsYXNzTGlzdC5hZGQoJ2ljb24tY2xvc2UnKTtcbiAgICAgICAgICAgIGNvbnRlbnRPYmouYXBwZW5kQ2hpbGQoY2xvc2VJY29uKTtcblxuICAgICAgICAgICAgLy/nm5HlkKzlhbPpl63mjInpkq7kuovku7ZcbiAgICAgICAgICAgIGNsb3NlSWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvL+aJp+ihjOWFs+mXreWbnuiwg1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZSh7J2Nsb3NlJzogb3B0aW9ucy5jbG9zZX0pO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy/liKTmlq3mmL7npLrpga7nvanlsYJcbiAgICAgICAgaWYob3B0aW9ucy5jb3Zlcil7XG4gICAgICAgICAgICBjb25zdCBjb3ZlciA9IHV0aWwuY3JlYXRlKCcuJytzcGFjZS5yb290Q2xhc3NOYW1lKyctY292ZXInKTtcbiAgICAgICAgICAgIC8v57uZ6YGu572p5bGC5re75Yqg5Yqo55S7XG4gICAgICAgICAgICBjb3Zlci5jbGFzc0xpc3QuYWRkKCdiaC1hbmltYXRlZCcpO1xuICAgICAgICAgICAgY292ZXIuY2xhc3NMaXN0LmFkZCgnYmgtYW5pbWF0ZS1mYWRlSW4nKTtcbiAgICAgICAgICAgIHJvb3RPYmouYXBwZW5kQ2hpbGQoY292ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy/lsIbliJvlu7rnmoToioLngrnliqDlhaXpobXpnaJcbiAgICAgICAgcm9vdE9iai5hcHBlbmRDaGlsZChjb250ZW50T2JqKTtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKHJvb3RPYmopO1xuXG4gICAgICAgIC8v5Yid5aeL5YyW5bm25pi+56S65a6M5oiQ5ZCOLOaJp+ihjOWbnuiwg1xuICAgICAgICBpZih0eXBlb2Ygb3B0aW9ucy5yZWFkeSAhPSd1bmRlZmluZWQnICYmIG9wdGlvbnMucmVhZHkgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgICAgICAgICAvL+aJp+ihjOeahOWbnuiwg1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZWFkeSgpO1xuICAgICAgICAgICAgfSwgc3BhY2UuYW5pbWF0ZVRpbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vL+azqOWGjOe7hOS7tlxuKGZ1bmN0aW9uIChCSCwgdW5kZWZpbmVkKSB7XG4gICAgQkguYmhNb2RhbEJvdHRvbSA9IEJoTW9kYWxCb3R0b20ucHJvdG90eXBlO1xufSkod2luZG93LkJIID0gd2luZG93LkJIIHx8IHt9KTtcbiIsIlxuLy/lvJXlhaXmoIfnrb7lvIDlj5HpnIDopoHnmoTkuIDkupvlhazlhbHnsbtcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICdvbnMvcGxhdGZvcm0nO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IFNQQUNFID0ge1xuICAgIC8v6K+l57uE5Lu255qE5qC55qC35byP5ZCNXG4gICAgcm9vdENsYXNzTmFtZTogJ2JoLXNlbGVjdC1yb2xsJyxcbiAgICB0b3VjaFN0YXJ0RGF0YToge30sXG4gICAgZGF0YUNvdW50OiAwLFxuICAgIHJvdGF0ZVhzdGVwOiAyMCxcbiAgICBhY3RpdmVJbmRleDogMCxcbiAgICAvL+W9k+inpuaRuOS6i+S7tue7k+adn+WQjuS8muWwhuagh+etvuS4iueahHNlbGVjdGVk5bGe5oCn5YC85L+u5pS5LFxuICAgIC8vIOeUseS6juWQjOaXtuebkeWQrOS6huivpeWxnuaAp+eahOWPmOWMluWBmuWKqOaAgeiuvue9ruWkhOeQhizmiYDku6XkvJrop6blj5HkuKTmrKFjaGFuZ2Xkuovku7YsXG4gICAgLy8g6K+l5bGe5oCn5piv5Li65LqG5bGP6JS956ys5LqM5qyh6Kem5Y+RY2hhbmdl5LqL5Lu2XG4gICAgc2VsZlRvU2V0U2VsZWN0ZWQ6IGZhbHNlXG59O1xuXG4vKipcbiAqIOa7mui9rumAieaLqee7hOS7tlxuICogQGV4YW1wbGUgPGJoLXNlbGVjdC1yb2xsIGRhdGU9XCLliJfooajmlbDmja7nmoRqc29u5a2X56ym5LiyIFt7a2V5OlwiXCIsIHZhbHVlOlwiXCJ9XVwiPjwvYmgtc2VsZWN0LXJvbGw+XG4gKiBAZXhhbXBsZSA8Ymgtc2VsZWN0LXJvbGwgZGF0ZT1cIuWIl+ihqOaVsOaNrueahGpzb27lrZfnrKbkuLJcIiBzZWxlY3RlZD1cIuiuvuWumumAieS4remhuXtrZXk6XCJcIix2YWx1ZTpcIlwifVwiPjwvYmgtc2VsZWN0LXJvbGw+XG4gKi9cbmNsYXNzIEJoU2VsZWN0Um9sbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICog6I635Y+W5b2T5YmN6YCJ5Lit5pWw5o2uXG4gICAgICogQHJldHVybnMge3trZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZ319XG4gICAgICovXG4gICAgZ2V0VmFsdWUoKXtcbiAgICAgICAgY29uc3QgYWN0aXZlSXRlbSA9IHRoaXMucXVlcnlTZWxlY3RvcignLmJoLWFjdGl2ZScpO1xuICAgICAgICByZXR1cm4ge1wia2V5XCI6IGFjdGl2ZUl0ZW0uZ2V0QXR0cmlidXRlKCdrZXknKSwgXCJ2YWx1ZVwiOiBhY3RpdmVJdGVtLmdldEF0dHJpYnV0ZSgndmFsdWUnKX07XG4gICAgfVxuXG4gICAgLyoqKlxuICAgICAqIOW8gOWni+inpuaRuFxuICAgICAqIOiusOW9leW9k+WJjeeahHnovbTkvY3nva4s5a2Y5YWlU1BBQ0UudG91Y2hTdGFydERhdGEucGFnZVnkuK1cbiAgICAgKiDlsIbpq5jkuq7oioLngrnnmoTpq5jkuq7ljrvmjolcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b3VjaFN0YXJ0SGFuZGxlKGV2ZW50KXtcbiAgICAgICAgU1BBQ0UudG91Y2hTdGFydERhdGEudGltZVN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgICBTUEFDRS50b3VjaFN0YXJ0RGF0YS5wYWdlWSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgIHRoaXMuX3Jlc2V0SXRlbUFjdGl2ZSgnaGlkZScpO1xuICAgIH1cblxuICAgIC8qKipcbiAgICAgKiDmu5HliqjlpITnkIZcbiAgICAgKiDojrflj5blvZPliY3nmoR56L205YC8LOiuoeeul+a7keWKqOi3neemu+S4juW6lOa7keWKqOWIsOeahOiKgueCueS9jee9rlxuICAgICAqIOiuvue9rnVs55qEdHJhbnNmb3JtXG4gICAgICog5pu05pawU1BBQ0UudG91Y2hTdGFydERhdGEucGFnZVnkuLrlvZPliY3oioLngrnkvY3nva5cbiAgICAgKiDmm7TmlrBTUEFDRS5hY3RpdmVJbmRleOS4uuW9k+WJjeiKgueCuWluZGV4XG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG91Y2hNb3ZlSGFuZGxlKGV2ZW50KXtcbiAgICAgICAgY29uc3QgcGFnZVkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICBjb25zdCBkaWZmID0gU1BBQ0UudG91Y2hTdGFydERhdGEucGFnZVkgLSBwYWdlWTtcbiAgICAgICAgY29uc3QgdWxPYmogPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3VsJyk7XG4gICAgICAgIGNvbnN0IHVsVHJhbnNmb3JtID0gdWxPYmouc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBjb25zdCByb3RhdGVYID0gdWxUcmFuc2Zvcm0ubWF0Y2goL3JvdGF0ZVhcXChcXC0/XFxkKlxcLitcXGQqZGVnXFwpfHJvdGF0ZVhcXChcXC0/XFxkKmRlZ1xcKS8pO1xuICAgICAgICBpZighcm90YXRlWCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm90YXRlWE51bSA9IE51bWJlcihyb3RhdGVYWzBdLnJlcGxhY2UoL1teXFwtXFwuMC05XSovZywgJycpKTtcbiAgICAgICAgY29uc3QgbmV3Um90YXRlWE51bSA9IHJvdGF0ZVhOdW0gKyBkaWZmO1xuICAgICAgICBjb25zdCBuZXdUcmFuc2Zvcm0gPSB1bFRyYW5zZm9ybS5yZXBsYWNlKC9yb3RhdGVYXFwoLitkZWdcXCkvLCBgcm90YXRlWCgke25ld1JvdGF0ZVhOdW19ZGVnKWApO1xuICAgICAgICBjb25zdCBpbmRleCA9IE1hdGgucm91bmQobmV3Um90YXRlWE51bSAvIFNQQUNFLnJvdGF0ZVhzdGVwKTtcblxuICAgICAgICBpZihpbmRleCA+PSAwICYmIGluZGV4IDwgU1BBQ0UuZGF0YUNvdW50KXtcbiAgICAgICAgICAgIFNQQUNFLmFjdGl2ZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgLy/lvZPmu5HliqjliLDpobbml7bmiJblupXpg6jml7Ys5pyA5aSa5Y+v5YGP56e75LiA5Liq6IqC54K555qE6Led56a7XG4gICAgICAgICAgICBpZihpbmRleCA8IDApe1xuICAgICAgICAgICAgICAgIFNQQUNFLmFjdGl2ZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpZihpbmRleCA8IC0xKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIFNQQUNFLmFjdGl2ZUluZGV4ID0gU1BBQ0UuZGF0YUNvdW50IC0gMTtcbiAgICAgICAgICAgICAgICBpZihpbmRleCA+IFNQQUNFLmRhdGFDb3VudCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1bE9iai5zdHlsZS50cmFuc2Zvcm0gPSBuZXdUcmFuc2Zvcm07XG4gICAgICAgIFNQQUNFLnRvdWNoU3RhcnREYXRhLnBhZ2VZID0gcGFnZVk7XG5cbiAgICAgICAgLy/moLnmja7lvZPliY3kvY3nva5pbmRleOiuvue9ruiKgueCueeahOaYvuekuumakOiXj1xuICAgICAgICB0aGlzLl9yZXNldEl0ZW1WaXNpYmxlKGluZGV4KTtcbiAgICB9XG5cbiAgICAvKioqXG4gICAgICog5qC55o2u5b2T5YmN5L2N572uaW5kZXjorr7nva7oioLngrnnmoTmmL7npLrpmpDol49cbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldEl0ZW1WaXNpYmxlKGluZGV4KXtcbiAgICAgICAgY29uc3QgbGlMaXN0ID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdsaScpO1xuICAgICAgICBjb25zdCBsaUxlbiA9IGxpTGlzdC5sZW5ndGg7XG4gICAgICAgIGZvcihsZXQgaT0wOyBpPGxpTGVuOyBpKyspe1xuICAgICAgICAgICAgaWYoaSA+IGluZGV4IC0gNSAmJiBpIDwgaW5kZXggKyA1KXtcbiAgICAgICAgICAgICAgICBsaUxpc3RbaV0uY2xhc3NMaXN0LmFkZCgnYmgtdmlzaWJsZScpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgbGlMaXN0W2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2JoLXZpc2libGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKipcbiAgICAgKiDop6bmkbjnu5PmnZ9cbiAgICAgKiDlr7nlvZPliY3pgInkuK3oioLngrnorr7nva7pq5jkuq5cbiAgICAgKiDlvZPoioLngrnkuI3lnKjmraPkuK3pl7Qs56e75Yqo6IqC54K55bGF5LitXG4gICAgICogdHJpZ2dlcuS4gOS4qmNoYW5nZeS6i+S7tizmioprZXnlkox2YWx1ZeWAvOi/lOWbnlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvdWNoRW5kSGFuZGxlKGV2ZW50KXtcbiAgICAgICAgU1BBQ0UudG91Y2hTdGFydERhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5fcmVzZXRJdGVtQWN0aXZlKCdzaG93Jyk7XG4gICAgICAgIGNvbnN0IHVsT2JqID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd1bCcpO1xuICAgICAgICB1bE9iai5zdHlsZS50cmFuc2Zvcm0gPSB0aGlzLl9nZXRVbFRyYW5zZm9ybShTUEFDRS5hY3RpdmVJbmRleCAqIFNQQUNFLnJvdGF0ZVhzdGVwKTtcblxuICAgICAgICBjb25zdCBzZWxlY3REYXRhID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICog5pWw5o2u5YiH5o2i5pe26Kem5Y+R55qE5LqL5Lu2XG4gICAgICAgICAqIEBldmVudCBCaFNlbGVjdFJvbGxFbGVtZW50I0JoU2VsZWN0Um9sbEVsZW1lbnQgY2hhbmdlXG4gICAgICAgICAqL1xuICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2NoYW5nZScsIHNlbGVjdERhdGEpO1xuICAgICAgICAvL+inpuaRuOe7k+adn+WQjizlkIzmraXorr7nva5zZWxlY3RlZOWAvCzorr7nva5zZWxmVG9TZXRTZWxlY3RlZOS4unRydWXpgb/lhY3lpJrmrKHop6blj5Hkuovku7ZcbiAgICAgICAgU1BBQ0Uuc2VsZlRvU2V0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCBKU09OLnN0cmluZ2lmeShzZWxlY3REYXRhKSk7XG4gICAgfVxuXG4gICAgLyoqKlxuICAgICAqIOW9k+WKqOaAgeiuvue9rnNlbGVjdGVk5bGe5oCn5pe255qE5aSE55CGXG4gICAgICog5Y+v5Lyg5YWlanNvbuWtl+espuS4suaIluWImWtleeWAvFxuICAgICAqIOagueaNruS8oOWFpeeahOWAvOiuvue9rumrmOS6ruiKgueCuSzlubbop6blj5FjaGFuZ2Xkuovku7ZcbiAgICAgKiBAcGFyYW0gbmV3VmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFNlbGVjdEl0ZW0obmV3VmFsdWUpe1xuICAgICAgICAvL3NlbGZUb1NldFNlbGVjdGVk5Li6dHJ1ZeihqOekuuaYr+e7hOS7tuiHquW3seWKqOaAgeiuvue9rueahCzkuI3lr7lzZWxlY3RlZOWBmuWQjOatpeWkhOeQhlxuICAgICAgICBpZihTUEFDRS5zZWxmVG9TZXRTZWxlY3RlZCl7XG4gICAgICAgICAgICAvL+WwhnNlbGZUb1NldFNlbGVjdGVk572u5Li6ZmFsc2VcbiAgICAgICAgICAgIFNQQUNFLnNlbGZUb1NldFNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvU2VsZWN0S2V5ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRvU2VsZWN0S2V5ID0gSlNPTi5wYXJzZSh0aGlzLl9mb3JtYXRlSnNvblN0cihuZXdWYWx1ZSkpLmtleTtcbiAgICAgICAgfWNhdGNoIChlKXtcbiAgICAgICAgICAgIHRvU2VsZWN0S2V5ID0gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZWxlY3RJdGVtID0gdGhpcy5xdWVyeVNlbGVjdG9yKGBsaVtrZXk9JyR7dG9TZWxlY3RLZXl9J11gKTtcbiAgICAgICAgaWYoc2VsZWN0SXRlbSl7XG4gICAgICAgICAgICB0aGlzLl9yZXNldEl0ZW1BY3RpdmUoJ2hpZGUnKTtcbiAgICAgICAgICAgIFNQQUNFLmFjdGl2ZUluZGV4ID0gdXRpbC5nZXRFbGVtZW50SW5kZXgoc2VsZWN0SXRlbSk7XG4gICAgICAgICAgICB0aGlzLl9yZXNldEl0ZW1WaXNpYmxlKFNQQUNFLmFjdGl2ZUluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoRW5kSGFuZGxlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKioqXG4gICAgICog6K6+572u6IqC54K56auY5LquY2xhc3NcbiAgICAgKiBAcGFyYW0gdHlwZSBzaG935a+55b2T5YmN6IqC54K56K6+572u6auY5LquLGhpZGXnp7vpmaTlvZPliY3oioLngrnnmoTpq5jkuq5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldEl0ZW1BY3RpdmUodHlwZSl7XG4gICAgICAgIGNvbnN0IHVsT2JqID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd1bCcpO1xuICAgICAgICBjb25zdCBsaUxpc3QgPSB1bE9iai5xdWVyeVNlbGVjdG9yQWxsKCdsaScpO1xuICAgICAgICBpZih0eXBlID09PSAnaGlkZScpe1xuICAgICAgICAgICAgbGlMaXN0W1NQQUNFLmFjdGl2ZUluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKCdiaC1hY3RpdmUnKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBsaUxpc3RbU1BBQ0UuYWN0aXZlSW5kZXhdLmNsYXNzTGlzdC5hZGQoJ2JoLWFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqKlxuICAgICAqIHVs55qEdHJhbnNmb3Jt5YC8XG4gICAgICogQHBhcmFtIHJvdGF0ZVhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFVsVHJhbnNmb3JtKHJvdGF0ZVgpe1xuICAgICAgICByZXR1cm4gYHBlcnNwZWN0aXZlKDUwMHJlbSkgcm90YXRlWSgwZGVnKSByb3RhdGVYKCR7cm90YXRlWH1kZWcpYDtcbiAgICB9XG5cbiAgICAvL+e7hOS7tuWKoOi9veWujOavleeahOWbnuiwgyznm7jlvZPkuo7or6Xnu4Tku7bnmoTlhaXlj6Pmlrnms5VcbiAgICBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICAgIH1cblxuICAgIC8v5bGe5oCn5Y+Y5pu055qE5Zue6LCD77yMdnVl6ZuG5oiQ5pe277yM5Lya6KKr5aSa5qyh6Kem5Y+RXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHByb3BOYW1lLG9sZFZhbHVlLG5ld1ZhbHVlKXtcbiAgICAgICAgc3dpdGNoKHByb3BOYW1lKXtcbiAgICAgICAgICAgIC8v6K+l57uE5Lu255qE5pWw5o2uLOW/hemhu+aYr2pzb27lrZfnrKbkuLJcbiAgICAgICAgICAgIC8v5L+u5pS5ZGF0YeaVsOaNrueahOWkhOeQhlxuICAgICAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgICAgICAgaWYoIW5ld1ZhbHVlKXtyZXR1cm47fVxuICAgICAgICAgICAgICAgIC8v5riy5p+T5pWw5o2uXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVySXRlbXMobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy/orr7nva7pgInkuK3oioLngrnnmoTlpITnkIZcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFNlbGVjdEl0ZW0obmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKipcbiAgICAgKiDmuLLmn5PoioLngrnliJfooahcbiAgICAgKiBAcGFyYW0gaXRlbXMg6IqC54K55pWw5o2uLOaYr2pzb27lrZfnrKbkuLJcbiAgICAgKiBAcGFyYW0gdHlwZSBpbml05piv5Yid5aeL5YyW5pe25Lul5a2X56ym5Liy6L+U5ZueLOWQpuWImeebtOaOpea3u+WKoOWIsEhUTUzkuK1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckl0ZW1zKGl0ZW1zLCB0eXBlKXtcbiAgICAgICAgbGV0IGxpc3RIdG1sID0gJyc7XG4gICAgICAgIGlmKGl0ZW1zKXtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IEpTT04ucGFyc2UoaXRlbXMpO1xuICAgICAgICAgICAgfWNhdGNoIChlKXtcbiAgICAgICAgICAgICAgICAvL+W9k+aVsOaNruaYr+mdmeaAgeeahOebtOaOpeWGmeWcqEhUTUzmoIfnrb7kuIrnmoTlpITnkIYs5bCG5YW26L2s5o2i5oiQanNvbuWPr+ino+aekOeahOagvOW8j1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gSlNPTi5wYXJzZSh0aGlzLl9mb3JtYXRlSnNvblN0cihpdGVtcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0RGF0YXMgPSBpdGVtcztcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdERhdGFMZW4gPSBzZWxlY3REYXRhcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIFNQQUNFLmRhdGFDb3VudCA9IHNlbGVjdERhdGFMZW47XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1TdHlsZSA9IGB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyIC03cmVtOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooN3JlbSkgcm90YXRlWChAcm90YXRlWE51bWRlZyk7YDtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpPHNlbGVjdERhdGFMZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1DbGFzcyA9ICcnO1xuICAgICAgICAgICAgICAgIC8v5YmNNOadoeaVsOaNruiuqeWFtuS4uuaYvuekuueKtuaAgVxuICAgICAgICAgICAgICAgIGlmKGkgPCA0KXtcbiAgICAgICAgICAgICAgICAgICAgaWYoaSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ2xhc3MgPSAnYmgtdmlzaWJsZSc7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNsYXNzID0gJ2JoLWFjdGl2ZSBiaC12aXNpYmxlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RJdGVtID0gc2VsZWN0RGF0YXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0S2V5ID0gc2VsZWN0SXRlbS5rZXkgPyBzZWxlY3RJdGVtLmtleSA6IHNlbGVjdEl0ZW0uS0VZO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdFZhbHVlID0gc2VsZWN0SXRlbS52YWx1ZSA/IHNlbGVjdEl0ZW0udmFsdWUgOiBzZWxlY3RJdGVtLlZBTFVFO1xuXG4gICAgICAgICAgICAgICAgbGlzdEh0bWwgKz0gYDxsaSBjbGFzcz1cIiR7aXRlbUNsYXNzfVwiIHZhbHVlPVwiJHtzZWxlY3RWYWx1ZX1cIiBrZXk9XCIke3NlbGVjdEtleX1cIiBzdHlsZT1cIiR7aXRlbVN0eWxlLnJlcGxhY2UoJ0Byb3RhdGVYTnVtJywgLShpICogU1BBQ0Uucm90YXRlWHN0ZXApKX1cIj4ke3NlbGVjdFZhbHVlfTwvbGk+YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHR5cGUgPT09ICdpbml0Jyl7XG4gICAgICAgICAgICByZXR1cm4gbGlzdEh0bWw7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCcuYmgtc2VsZWN0LXJvbGwtbGlzdCcpLmlubmVySFRNTCA9IGxpc3RIdG1sO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Zvcm1hdGVKc29uU3RyKGpzb25TdHIpe1xuICAgICAgICByZXR1cm4ganNvblN0ci5yZXBsYWNlKC97IConICprZXkgKicvaWcsICd7XCJrZXlcIicpXG4gICAgICAgICAgICAucmVwbGFjZSgveyAqJyAqdmFsdWUgKicvaWcsICd7XCJ2YWx1ZVwiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nICprZXkgKicgKjovaWcsICdcImtleVwiOicpXG4gICAgICAgICAgICAucmVwbGFjZSgvJyAqdmFsdWUgKicgKjovaWcsICdcInZhbHVlXCI6JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC97ICprZXkgKjovaWcsICd7XCJrZXlcIjonKVxuICAgICAgICAgICAgLnJlcGxhY2UoL3sgKnZhbHVlICo6L2lnLCAne1widmFsdWVcIjonKVxuICAgICAgICAgICAgLnJlcGxhY2UoLywgKmtleSAqOi9pZywgJyxcImtleVwiOicpXG4gICAgICAgICAgICAucmVwbGFjZSgvLCAqdmFsdWUgKjovaWcsICcsXCJ2YWx1ZVwiOicpXG4gICAgICAgICAgICAucmVwbGFjZSgvOiAqJyAqL2csICc6XCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyAqJyAqfS9nLCAnXCJ9JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nICosL2csICdcIiwnKTtcbiAgICB9XG5cbiAgICAvL+WIneWni+WMluaWueazlVxuICAgIF9jb21waWxlKCkge1xuICAgICAgICAvL+W9k+i/meS4que7hOS7tuW3sue7j+WIneWni+WMlui/hyzliJnkuI3lho3ov5vooYzliJ3lp4vljJblpITnkIZcbiAgICAgICAgaWYodGhpcy5xdWVyeVNlbGVjdG9yKCcuJytTUEFDRS5yb290Q2xhc3NOYW1lKyctYm9keScpKXtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3RvdWNoU3RhcnRIYW5kbGUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3RvdWNoU3RhcnRIYW5kbGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl90b3VjaE1vdmVIYW5kbGUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlLCBmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl90b3VjaEVuZEhhbmRsZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3RvdWNoRW5kSGFuZGxlLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL+W9k+ivpee7hOS7tuaYr+W1jOWcqOW6lemDqOW8ueahhue7hOS7tumHjCzliJnorr7nva7lupXpg6jlvLnmoYbnmoTpq5jluqZcbiAgICAgICAgY29uc3QgbW9kYWxCb3R0b21Db250ZW50T2JqID0gdXRpbC5maW5kUGFyZW50KHRoaXMsICcuYmgtbW9kYWwtYm90dG9tLWNvbnRlbnQnKTtcbiAgICAgICAgaWYobW9kYWxCb3R0b21Db250ZW50T2JqKXtcbiAgICAgICAgICAgIG1vZGFsQm90dG9tQ29udGVudE9iai5zdHlsZS5oZWlnaHQgPSAnMTdyZW0nO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9iaWxlT3MgPSBwbGF0Zm9ybS5nZXRNb2JpbGVPUygpO1xuICAgICAgICBsZXQgdWx0cmFuc2Zvcm1PcmlnaW4gPSAnJztcbiAgICAgICAgLy/lvZPor6Xnu4Tku7bmmK/lnKhpT1PkuK0s5YiZ57uZ5YW25Yqg5YWl5Yqo55S75a6a5L2N54K5LOS7peehruS/neWKqOeUu+eahOato+ehrlxuICAgICAgICBpZihtb2JpbGVPcyA9PT0gJ2lvcycpe1xuICAgICAgICAgICAgdWx0cmFuc2Zvcm1PcmlnaW4gPSAndHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlciA3cmVtOyc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEnKTtcbiAgICAgICAgY29uc3QgbGlzdEh0bWwgPSB0aGlzLl9yZW5kZXJJdGVtcyhkYXRhLCAnaW5pdCcpO1xuXG4gICAgICAgIC8v5ou85o6l5YaF5a655LiyXG4gICAgICAgIGNvbnN0IGNvbnRlbnRIdG1sID0gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7U1BBQ0Uucm9vdENsYXNzTmFtZX0tYm9keVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke1NQQUNFLnJvb3RDbGFzc05hbWV9LWJveFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cImJoLXNlbGVjdC1yb2xsLWxpc3RcIiBzdHlsZT1cIiR7dWx0cmFuc2Zvcm1PcmlnaW59IHRyYW5zZm9ybTogJHt0aGlzLl9nZXRVbFRyYW5zZm9ybSgwKX1cIj5cbiAgICAgICAgICAgICAgICAgICAgJHtsaXN0SHRtbH1cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG5cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBjb250ZW50SHRtbDtcblxuICAgICAgICAvL+WIneWni+WMluaXtuiLpeiuvue9ruS6hum7mOiupOmAieaLqemhuSzliJnkvb/lhbbpgInkuK1cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgaWYoc2VsZWN0ZWQpe1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRTZWxlY3RJdGVtKHNlbGVjdGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8v55uR5ZCs6K+l57uE5Lu255qE5LqL5Lu2XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3RvdWNoU3RhcnRIYW5kbGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl90b3VjaE1vdmVIYW5kbGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3RvdWNoRW5kSGFuZGxlLCBmYWxzZSk7XG4gICAgfVxuXG59XG5cbi8v5rOo5YaM6K+l5qCH562+KOeUqOS6jua1j+iniOWZqOS4jeaUr+aMgeiHquWumuS5ieagh+etvueahOWkhOeQhilcbndpbmRvdy5CaFNlbGVjdFJvbGxFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdiaC1zZWxlY3Qtcm9sbCcsIHtcbiAgICBwcm90b3R5cGU6IEJoU2VsZWN0Um9sbEVsZW1lbnQucHJvdG90eXBlXG59KTtcblxuIiwiaW1wb3J0IG9ucyBmcm9tICcuL29ucy9vbnMnO1xuXG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRlbXBsYXRlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtaWYnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1hbGVydC1kaWFsb2cnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1iYWNrLWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYnV0dG9uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtY2Fyb3VzZWwtaXRlbSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNhcm91c2VsJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtY29sJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtZGlhbG9nJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtZmFiJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWljb24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1sYXp5LXJlcGVhdCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWxpc3QtaGVhZGVyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGlzdC1pdGVtJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGlzdCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWlucHV0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbW9kYWwnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3InO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1wYWdlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcG9wb3Zlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWNpcmN1bGFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcHVsbC1ob29rJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcmlwcGxlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcm93JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbC1pdGVtJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLWNvbnRlbnQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1tYXNrJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItc2lkZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3dpdGNoJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGFiJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGFiYmFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdG9vbGJhci1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10b29sYmFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcmFuZ2UnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL2JoL2JoLXN0ZXAnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL2JoL2JoLWlucHV0JztcbmltcG9ydCAnLi9lbGVtZW50cy9iaC9iaC1zZWFyY2gnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL2JoL2JoLXNlYXJjaC1iYXInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL2JoL2JoLWlucHV0LXNlbGVjdCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvYmgvYmgtY2Fyb3VzZWwtYnRucyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvYmgvYmgtbW9kYWwtYm90dG9tJztcbmltcG9ydCAnLi9lbGVtZW50cy9iaC9iaC1tb2RhbC1ib3R0b20tY29tbWFuZCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvYmgvYmgtc2VsZWN0LXJvbGwnO1xuXG4vLyBmYXN0Y2xpY2tcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuXHRvbnMuZmFzdENsaWNrID0gRmFzdENsaWNrLmF0dGFjaChkb2N1bWVudC5ib2R5KTtcbn0sIGZhbHNlKTtcblxuLy8gb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuXHRvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmVuYWJsZSgpO1xuXHRvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih3aW5kb3cuZG9jdW1lbnQuYm9keSwgKCkgPT4ge1xuXHRcdG5hdmlnYXRvci5hcHAuZXhpdEFwcCgpO1xuXHR9KTtcblx0ZG9jdW1lbnQuYm9keS5fZ2VzdHVyZURldGVjdG9yID0gbmV3IG9ucy5HZXN0dXJlRGV0ZWN0b3IoZG9jdW1lbnQuYm9keSk7XG59LCBmYWxzZSk7XG5cbi8vIHNldHVwIGxvYWRpbmcgcGxhY2Vob2xkZXJcbm9ucy5yZWFkeShmdW5jdGlvbigpIHtcblx0b25zLl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMoKTtcbn0pO1xuXG4vLyB2aWV3cG9ydC5qc1xubmV3IFZpZXdwb3J0KCkuc2V0dXAoKTtcblxuZXhwb3J0IGRlZmF1bHQgb25zO1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
